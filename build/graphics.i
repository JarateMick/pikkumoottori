#line 1 "..\\src\\graphics\\graphics.cpp"

#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\graphics.h"
#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\limits"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#pragma once




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"

#pragma once






 
















































































#line 91 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"

  


















































































#line 252 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"
 #line 253 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"

#line 255 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"

#line 257 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"
#line 258 "H:\\Visual Studio\\VC\\INCLUDE\\xkeycheck.h"





#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"








#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















    
#line 24 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"






    
    

#line 34 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
        
            
        

#line 39 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
    #line 40 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 41 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"













#pragma once







































































































































#line 151 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"



#line 155 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






































#line 194 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"


#line 197 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"

#line 199 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"





#line 205 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"



#line 209 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






#line 216 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"











#line 228 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"








#line 237 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"
#line 238 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros




































































































































































































































































































































































































































































                                                




                                                

















































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1564 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






























#line 1595 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"
























#line 1620 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"












#line 1633 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






































#line 1672 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"


























































































































#line 1795 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






































































































#line 1898 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"








































































































































































#line 2067 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"





































































































#line 2169 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"



















































































































































































































#line 2381 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"
extern "C" {




#line 2387 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"



































































































































































































































#line 2615 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2654 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"









































































































































































































































#line 2888 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"









#line 2898 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"


    
    
#line 2903 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






#line 2910 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"
#line 2911 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






#line 2918 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"
#line 2919 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"











#line 2931 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"

































#line 2965 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"






















}
#line 2989 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"


















#pragma once


extern "C" {
#line 24 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"
















































































































































































































































#line 265 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"



#line 269 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"


















































































#line 352 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"


}
#line 356 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"

#line 358 "H:\\Visual Studio\\VC\\INCLUDE\\ConcurrencySal.h"
#line 2991 "H:\\Visual Studio\\VC\\INCLUDE\\sal.h"


#line 46 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"










#pragma once



#pragma pack(push, 8)


extern "C" {
#line 20 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"



#line 24 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 32 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"
#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"


    
    


        typedef char* va_list;
    #line 41 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"
#line 42 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"


    


#line 48 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"





#line 54 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"



#line 58 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"
    
    
#line 61 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"











#line 73 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"







#line 81 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"











#line 93 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"











#line 105 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 116 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"


} 
#line 120 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    } 

    





#line 156 "H:\\Visual Studio\\VC\\INCLUDE\\vadefs.h"

#pragma pack(pop)
#line 47 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"






    



    





















#line 80 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    
#line 88 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


















    

#line 109 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"

#line 111 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"

#line 113 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
        
    

#line 117 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 118 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    





#line 127 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
        
    #line 129 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 130 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"







#line 138 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
    
#line 140 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





#line 146 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
    
    
#line 149 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"




    
#line 155 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"








    


#line 167 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"



#line 171 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
    
#line 173 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"




    
#line 179 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    
        
        
    

#line 187 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 188 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 202 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"



    
#line 207 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    
#line 211 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    
#line 215 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"








    
        
    

#line 228 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 229 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    


#line 235 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
            
        
    }


#line 247 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"






#line 254 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    
        
    





#line 265 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 266 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"



#line 270 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"


    
        
    


#line 278 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 279 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"









    void __cdecl __security_init_cookie(void);

    



        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 297 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 298 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
        
extern uintptr_t __security_cookie;
 

    
    
    
#line 306 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"

} __pragma(pack(pop))

#line 310 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"
#line 10 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 11 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

__pragma(pack(push, 8)) extern "C" {









    

#line 25 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
        
    

#line 29 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 30 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"




    
#line 36 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    

#line 41 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
        
    

#line 45 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 46 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 50 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    
#line 52 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    


#line 58 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"





#line 64 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    
#line 66 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"





    
#line 73 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 77 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    
#line 79 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"













    


        
    #line 97 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 98 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 102 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    
#line 104 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 108 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    
#line 110 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 114 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    
#line 116 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 137 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 147 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"










    
#line 159 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



















    

#line 181 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
        
    #line 183 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 184 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 188 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    
#line 192 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"









    











        
    #line 215 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 216 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    
#line 220 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    
        
    

#line 227 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 228 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

























__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    



        
        
        
        
        
        
        
        
        
        
        
        

    #line 283 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 284 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
















#line 301 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    


        


    #line 310 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 311 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"









    






        
    #line 329 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 330 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    


        
    #line 337 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 338 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 342 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"













#line 356 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"















#line 372 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"





    
#line 379 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 383 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    

#line 388 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 389 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    


        


            
        #line 399 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    #line 400 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 401 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 405 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"





#line 411 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    


        



    #line 421 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 422 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    
        
    



#line 431 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 441 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

    
        
              
        

#line 448 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    



#line 453 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

    
        
    



#line 461 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

    
        
    



#line 469 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 470 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    
#line 474 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 514 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



#line 518 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 525 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 526 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



    
#line 531 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 535 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 711 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 712 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"












































































    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1787 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 1977 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
    #line 1978 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"
#line 1979 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))

#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"









    

#line 23 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"

#line 25 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
        
    #line 27 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
#line 28 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"


    

#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
        
            
        

#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
    #line 39 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
#line 40 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"


    

#line 45 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
        
            
        

#line 50 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
    #line 51 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
#line 52 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"


    

#line 57 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"

#line 59 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
        
            
        

#line 64 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
    #line 65 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
#line 66 "H:\\Visual Studio\\VC\\INCLUDE\\crtdefs.h"
#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#pragma pack(push,8)



















 
  
  
 


#line 37 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  
 #line 41 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  
  
 


#line 49 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  
 #line 53 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"




















#line 74 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 76 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

		

	







		
		


			
		#line 93 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	#line 94 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
#line 95 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

		




 
  
 #line 104 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"










































	
	






		


			
		#line 159 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	#line 160 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

	
	




		

#line 170 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
			
		#line 172 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	#line 173 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

	
	

#line 178 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 180 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
		
	#line 182 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 184 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"





	
		#pragma detect_mismatch("_MSC_VER", "1900")
	#line 192 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
	#line 196 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

	
		

#line 201 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 203 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
		

#line 207 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	#line 208 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
#line 209 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"








	
		
	

#line 222 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
#line 223 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"




#line 228 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"




#line 233 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 235 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
#line 236 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"









#line 246 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 248 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"


 
#line 252 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
 

 









 









 









 
































#line 320 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"





#line 326 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 
 
#line 329 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
 

 #line 334 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"











#line 346 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"













#pragma once








#line 24 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"














    
    
#line 41 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"


    






#line 51 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"



    
#line 56 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"

#pragma comment(lib, "msvcprt" "" "")






#line 65 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"

#line 67 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"

#line 69 "H:\\Visual Studio\\VC\\INCLUDE\\use_ansi.h"
#line 348 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"



#line 352 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"



#line 356 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"


 















 
  

#line 378 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
   
  #line 380 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 #line 381 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  

#line 386 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
   
  #line 388 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 #line 389 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  

#line 394 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
   
  #line 396 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 #line 397 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"


 
  





#line 407 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

   


#line 412 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
    
   #line 414 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

  #line 416 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 #line 417 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  
 #line 421 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 
  

#line 426 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
   


     
   #line 431 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
  #line 432 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 #line 433 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

 


























  
   
  #line 464 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
 #line 465 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

		

 
  
  
  




  
  
  

  







   
   
   
  #line 492 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

  
  
  
  

 












#line 512 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		






		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 578 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() noexcept;	
  #line 582 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

	static  void __cdecl _Lockit_ctor(int);
	static  void __cdecl _Lockit_dtor(int);

private:
	static  void __cdecl _Lockit_ctor(_Lockit *);
	static  void __cdecl _Lockit_ctor(_Lockit *, int);
	static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;

  











#line 611 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 697 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

class __declspec(dllimport) _Init_locks
	{	
public:
 
  










#line 714 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	__thiscall _Init_locks();
	__thiscall ~_Init_locks() noexcept;
  #line 717 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"

private:
	static  void __cdecl _Init_locks_ctor(_Init_locks *);
	static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 731 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
	};

#pragma warning(pop)
}
 #line 736 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;




 

 
 #pragma pack(pop)
#line 755 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"
#line 756 "H:\\Visual Studio\\VC\\INCLUDE\\yvals.h"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  

 
 
extern "C" {
 #line 18 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"
 #line 19 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"

		





		






void __cdecl _Feraise(int);

typedef union
	{	
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		
__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) double __cdecl _Sinh(double, double);

__declspec(dllimport) short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport)  _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		
__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) float __cdecl _FSinh(float, float);

__declspec(dllimport) short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport)  _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		
__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);

__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport)  _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
 
}
 #line 72 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"
 #line 73 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 79 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"
#line 80 "H:\\Visual Studio\\VC\\INCLUDE\\ymath.h"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cfloat"

#pragma once




#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 27 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"
    #line 28 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"
#line 29 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"

















    










#line 58 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"
























































































































































#line 211 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"

    

#line 215 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );












 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);


      __declspec(dllimport) float __cdecl _scalbf(  float _X,   long _Y);
#line 319 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"










    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 398 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\float.h"



} __pragma(pack(pop))
#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\cfloat"
#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\cfloat"





#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\climits"

#pragma once




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"







#pragma once


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"

__pragma(pack(push, 8)) extern "C" {









    
    



#line 29 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"









































#line 71 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"


    
        
    

#line 78 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"
#line 79 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"


    
        
    #line 84 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"
#line 85 "H:\\Visual Studio\\VC\\INCLUDE\\limits.h"



} __pragma(pack(pop))
#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\climits"
#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\climits"





#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"

#pragma once









 #line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\math.h"










#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {

#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 




    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 47 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"
    #line 48 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"
#line 49 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"










#line 60 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 63 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 83 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"
#line 84 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"


    
#line 88 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"


















































































void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 460 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    



#line 587 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl _logbf(  float _X);
          __declspec(dllimport) float __cdecl _nextafterf(  float _X,   float _Y);
          __declspec(dllimport) int   __cdecl _finitef(  float _X);
          __declspec(dllimport) int   __cdecl _isnanf(  float _X);
          __declspec(dllimport) int   __cdecl _fpclassf(  float _X);

          __declspec(dllimport) int   __cdecl _set_FMA3_enable(  int _Flag);
          __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    




#line 605 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"



    

          __declspec(dllimport) float __cdecl acosf(  float _X);
          __declspec(dllimport) float __cdecl asinf(  float _X);
          __declspec(dllimport) float __cdecl atan2f(  float _Y,   float _X);
          __declspec(dllimport) float __cdecl atanf(  float _X);
          __declspec(dllimport) float __cdecl ceilf(  float _X);
          __declspec(dllimport) float __cdecl cosf(  float _X);
          __declspec(dllimport) float __cdecl coshf(  float _X);
          __declspec(dllimport) float __cdecl expf(  float _X);

    









































#line 662 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

    



#line 668 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 675 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl floorf(  float _X);
          __declspec(dllimport) float __cdecl fmodf(  float _X,   float _Y);

    











#line 694 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

          __declspec(dllimport) float  __cdecl log10f(  float _X);
          __declspec(dllimport) float  __cdecl logf(  float _X);
          __declspec(dllimport) float  __cdecl modff(  float _X,   float *_Y);
          __declspec(dllimport) float  __cdecl powf(  float _X,   float _Y);
          __declspec(dllimport) float  __cdecl sinf(  float _X);
          __declspec(dllimport) float  __cdecl sinhf(  float _X);
          __declspec(dllimport) float  __cdecl sqrtf(  float _X);
          __declspec(dllimport) float  __cdecl tanf(  float _X);
          __declspec(dllimport) float  __cdecl tanhf(  float _X);

    

















































#line 773 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    



#line 961 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 979 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 987 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"

#line 989 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_math.h"


#pragma warning(pop)

} __pragma(pack(pop))

#line 12 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\math.h"




#line 13 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"
#line 14 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"

 

template<class _Ty>
	  inline _Ty _Pow_int(_Ty _Xx, int _Yx) noexcept
	{
	unsigned int _Nx;
	if (_Yx >= 0)
		_Nx = static_cast<unsigned int>(_Yx);
	else
		_Nx = static_cast<unsigned int>(-_Yx);

	for (_Ty _Zx = static_cast<_Ty>(1); ; _Xx *= _Xx)
		{
		if ((_Nx & 1) != 0)
			_Zx *= _Xx;
		if ((_Nx >>= 1) == 0)
			return (_Yx < 0 ? static_cast<_Ty>(1) / _Zx : _Zx);
		}
	}

  inline double abs(  double _Xx) noexcept
	{
	return (:: fabs(_Xx));
	}

  inline double pow(  double _Xx,   int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

  inline float abs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float acos(  float _Xx) noexcept
	{
	return (:: acosf(_Xx));
	}

  inline float acosh(  float _Xx) noexcept
	{
	return (:: acoshf(_Xx));
	}

  inline float asin(  float _Xx) noexcept
	{
	return (:: asinf(_Xx));
	}

  inline float asinh(  float _Xx) noexcept
	{
	return (:: asinhf(_Xx));
	}

  inline float atan(  float _Xx) noexcept
	{
	return (:: atanf(_Xx));
	}

  inline float atanh(  float _Xx) noexcept
	{
	return (:: atanhf(_Xx));
	}

  inline float atan2(  float _Yx,   float _Xx) noexcept
	{
	return (:: atan2f(_Yx, _Xx));
	}

  inline float cbrt(  float _Xx) noexcept
	{
	return (:: cbrtf(_Xx));
	}

  inline float ceil(  float _Xx) noexcept
	{
	return (:: ceilf(_Xx));
	}

  inline float copysign(  float _Number,
	  float _Sign) noexcept
	{
	return (:: copysignf(_Number, _Sign));
	}

  inline float cos(  float _Xx) noexcept
	{
	return (:: cosf(_Xx));
	}

  inline float cosh(  float _Xx) noexcept
	{
	return (:: coshf(_Xx));
	}

  inline float erf(  float _Xx) noexcept
	{
	return (:: erff(_Xx));
	}

  inline float erfc(  float _Xx) noexcept
	{
	return (:: erfcf(_Xx));
	}

  inline float exp(  float _Xx) noexcept
	{
	return (:: expf(_Xx));
	}

  inline float exp2(  float _Xx) noexcept
	{
	return (:: exp2f(_Xx));
	}

  inline float expm1(  float _Xx) noexcept
	{
	return (:: expm1f(_Xx));
	}

  inline float fabs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float fdim(  float _Xx,   float _Yx) noexcept
	{
	return (:: fdimf(_Xx, _Yx));
	}

  inline float floor(  float _Xx) noexcept
	{
	return (:: floorf(_Xx));
	}

  inline float fma(  float _Xx,   float _Yx,
	  float _Zx) noexcept
	{
	return (:: fmaf(_Xx, _Yx, _Zx));
	}

  inline float fmax(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmaxf(_Xx, _Yx));
	}

  inline float fmin(  float _Xx,   float _Yx) noexcept
	{
	return (:: fminf(_Xx, _Yx));
	}

  inline float fmod(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmodf(_Xx, _Yx));
	}

  inline float frexp(  float _Xx,   int* _Yx) noexcept
	{
	return (:: frexpf(_Xx, _Yx));
	}

  inline float hypot(  float _Xx,   float _Yx) noexcept
	{
	return (:: hypotf(_Xx, _Yx));
	}

  inline int ilogb(  float _Xx) noexcept
	{
	return (:: ilogbf(_Xx));
	}

  inline float ldexp(  float _Xx,   int _Yx) noexcept
	{
	return (:: ldexpf(_Xx, _Yx));
	}

  inline float lgamma(  float _Xx) noexcept
	{
	return (:: lgammaf(_Xx));
	}

  inline long long llrint(  float _Xx) noexcept
	{
	return (:: llrintf(_Xx));
	}

  inline long long llround(  float _Xx) noexcept
	{
	return (:: llroundf(_Xx));
	}

  inline float log(  float _Xx) noexcept
	{
	return (:: logf(_Xx));
	}

  inline float log10(  float _Xx) noexcept
	{
	return (:: log10f(_Xx));
	}

  inline float log1p(  float _Xx) noexcept
	{
	return (:: log1pf(_Xx));
	}

  inline float log2(  float _Xx) noexcept
	{
	return (:: log2f(_Xx));
	}

  inline float logb(  float _Xx) noexcept
	{
	return (:: logbf(_Xx));
	}

  inline long lrint(  float _Xx) noexcept
	{
	return (:: lrintf(_Xx));
	}

  inline long lround(  float _Xx) noexcept
	{
	return (:: lroundf(_Xx));
	}

  inline float modf(  float _Xx,   float* _Yx) noexcept
	{
	return (:: modff(_Xx, _Yx));
	}

  inline float nearbyint(  float _Xx) noexcept
	{
	return (:: nearbyintf(_Xx));
	}

  inline float nextafter(  float _Xx,   float _Yx) noexcept
	{
	return (:: nextafterf(_Xx, _Yx));
	}

  inline float nexttoward(  float _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,
	  float _Yx) noexcept
	{
	return (:: powf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,   int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

  inline float remainder(  float _Xx,   float _Yx) noexcept
	{
	return (:: remainderf(_Xx, _Yx));
	}

  inline float remquo(  float _Xx,   float _Yx,
	  int *_Zx) noexcept
	{
	return (:: remquof(_Xx, _Yx, _Zx));
	}

  inline float rint(  float _Xx) noexcept
	{
	return (:: rintf(_Xx));
	}

  inline float round(  float _Xx) noexcept
	{
	return (:: roundf(_Xx));
	}

  inline float scalbln(  float _Xx,   long _Yx) noexcept
	{
	return (:: scalblnf(_Xx, _Yx));
	}

  inline float scalbn(  float _Xx,   int _Yx) noexcept
	{
	return (:: scalbnf(_Xx, _Yx));
	}

  inline float sin(  float _Xx) noexcept
	{
	return (:: sinf(_Xx));
	}

  inline float sinh(  float _Xx) noexcept
	{
	return (:: sinhf(_Xx));
	}

  inline float sqrt(  float _Xx) noexcept
	{
	return (:: sqrtf(_Xx));
	}

  inline float tan(  float _Xx) noexcept
	{
	return (:: tanf(_Xx));
	}

  inline float tanh(  float _Xx) noexcept
	{
	return (:: tanhf(_Xx));
	}

  inline float tgamma(  float _Xx) noexcept
	{
	return (:: tgammaf(_Xx));
	}

  inline float trunc(  float _Xx) noexcept
	{
	return (:: truncf(_Xx));
	}

  inline long double abs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double acos(  long double _Xx) noexcept
	{
	return (:: acosl(_Xx));
	}

  inline long double acosh(  long double _Xx) noexcept
	{
	return (:: acoshl(_Xx));
	}

  inline long double asin(  long double _Xx) noexcept
	{
	return (:: asinl(_Xx));
	}

  inline long double asinh(  long double _Xx) noexcept
	{
	return (:: asinhl(_Xx));
	}

  inline long double atan(  long double _Xx) noexcept
	{
	return (:: atanl(_Xx));
	}

  inline long double atanh(  long double _Xx) noexcept
	{
	return (:: atanhl(_Xx));
	}

  inline long double atan2(  long double _Yx,
	  long double _Xx) noexcept
	{
	return (:: atan2l(_Yx, _Xx));
	}

  inline long double cbrt(  long double _Xx) noexcept
	{
	return (:: cbrtl(_Xx));
	}

  inline long double ceil(  long double _Xx) noexcept
	{
	return (:: ceill(_Xx));
	}

  inline long double copysign(  long double _Number,
	  long double _Sign) noexcept
	{
	return (:: copysignl(_Number, _Sign));
	}

  inline long double cos(  long double _Xx) noexcept
	{
	return (:: cosl(_Xx));
	}

  inline long double cosh(  long double _Xx) noexcept
	{
	return (:: coshl(_Xx));
	}

  inline long double erf(  long double _Xx) noexcept
	{
	return (:: erfl(_Xx));
	}

  inline long double erfc(  long double _Xx) noexcept
	{
	return (:: erfcl(_Xx));
	}

  inline long double exp(  long double _Xx) noexcept
	{
	return (:: expl(_Xx));
	}

  inline long double exp2(  long double _Xx) noexcept
	{
	return (:: exp2l(_Xx));
	}

  inline long double expm1(  long double _Xx) noexcept
	{
	return (:: expm1l(_Xx));
	}

  inline long double fabs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double fdim(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fdiml(_Xx, _Yx));
	}

  inline long double floor(  long double _Xx) noexcept
	{
	return (:: floorl(_Xx));
	}

  inline long double fma(  long double _Xx,
	  long double _Yx,   long double _Zx) noexcept
	{
	return (:: fmal(_Xx, _Yx, _Zx));
	}

  inline long double fmax(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmaxl(_Xx, _Yx));
	}

  inline long double fmin(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fminl(_Xx, _Yx));
	}

  inline long double fmod(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmodl(_Xx, _Yx));
	}

  inline long double frexp(  long double _Xx,
	  int* _Yx) noexcept
	{
	return (:: frexpl(_Xx, _Yx));
	}

  inline long double hypot(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: hypotl(_Xx, _Yx));
	}

  inline int ilogb(  long double _Xx) noexcept
	{
	return (:: ilogbl(_Xx));
	}

  inline long double ldexp(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: ldexpl(_Xx, _Yx));
	}

  inline long double lgamma(  long double _Xx) noexcept
	{
	return (:: lgammal(_Xx));
	}

  inline long long llrint(  long double _Xx) noexcept
	{
	return (:: llrintl(_Xx));
	}

  inline long long llround(  long double _Xx) noexcept
	{
	return (:: llroundl(_Xx));
	}

  inline long double log(  long double _Xx) noexcept
	{
	return (:: logl(_Xx));
	}

  inline long double log10(  long double _Xx) noexcept
	{
	return (:: log10l(_Xx));
	}

  inline long double log1p(  long double _Xx) noexcept
	{
	return (:: log1pl(_Xx));
	}

  inline long double log2(  long double _Xx) noexcept
	{
	return (:: log2l(_Xx));
	}

  inline long double logb(  long double _Xx) noexcept
	{
	return (:: logbl(_Xx));
	}

  inline long lrint(  long double _Xx) noexcept
	{
	return (:: lrintl(_Xx));
	}

  inline long lround(  long double _Xx) noexcept
	{
	return (:: lroundl(_Xx));
	}

  inline long double modf(  long double _Xx,
	  long double* _Yx) noexcept
	{
	return (:: modfl(_Xx, _Yx));
	}

  inline long double nearbyint(  long double _Xx) noexcept
	{
	return (:: nearbyintl(_Xx));
	}

  inline long double nextafter(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nextafterl(_Xx, _Yx));
	}

  inline long double nexttoward(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: powl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

  inline long double remainder(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: remainderl(_Xx, _Yx));
	}

  inline long double remquo(  long double _Xx,
	  long double _Yx,   int *_Zx) noexcept
	{
	return (:: remquol(_Xx, _Yx, _Zx));
	}

  inline long double rint(  long double _Xx) noexcept
	{
	return (:: rintl(_Xx));
	}

  inline long double round(  long double _Xx) noexcept
	{
	return (:: roundl(_Xx));
	}

  inline long double scalbln(  long double _Xx,
	  long _Yx) noexcept
	{
	return (:: scalblnl(_Xx, _Yx));
	}

  inline long double scalbn(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: scalbnl(_Xx, _Yx));
	}

  inline long double sin(  long double _Xx) noexcept
	{
	return (:: sinl(_Xx));
	}

  inline long double sinh(  long double _Xx) noexcept
	{
	return (:: sinhl(_Xx));
	}

  inline long double sqrt(  long double _Xx) noexcept
	{
	return (:: sqrtl(_Xx));
	}

  inline long double tan(  long double _Xx) noexcept
	{
	return (:: tanl(_Xx));
	}

  inline long double tanh(  long double _Xx) noexcept
	{
	return (:: tanhl(_Xx));
	}

  inline long double tgamma(  long double _Xx) noexcept
	{
	return (:: tgammal(_Xx));
	}

  inline long double trunc(  long double _Xx) noexcept
	{
	return (:: truncl(_Xx));
	}

 #line 650 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"






 #line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xtgmath.h"


 
#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xtr1common"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cstdlib"

#pragma once










 #line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"







#pragma once



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_malloc.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
       size_t _Count,
       size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
       size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
       size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    );

 
__declspec(dllimport) 
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
              size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
       size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
       size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment
    );


















#line 225 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_search.h"










#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stddef.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 25 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

#line 37 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stddef.h"




    
        
    

#line 46 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stddef.h"


#line 49 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 15 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 44 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 185 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 209 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 14 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


































     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 63 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

     __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 70 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 86 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

     __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 93 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 108 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

     __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 115 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 361 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 373 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"



    

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 442 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 467 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

         __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 474 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 480 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
#line 481 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 15 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"


__pragma(pack(push, 8)) extern "C" {




    
#line 24 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 57 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 77 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"


    
    
#line 82 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 142 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
    __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

    __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 185 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"












#line 198 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
    __declspec(dllimport)  char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport)  int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);
#line 233 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"




 __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
 __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
 __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 252 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)






__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 352 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 379 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 409 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 635 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 645 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 662 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 669 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 685 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
 __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 694 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 

__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );


__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 760 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

  
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 789 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 
  
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 814 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"


__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 835 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"
        
    #line 837 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

    


        
    #line 843 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 850 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 925 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 932 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 951 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 960 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"





__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );


__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 988 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1013 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1020 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1039 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1048 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"




















 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1096 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1108 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)


__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }










    

    
     
    __declspec(dllimport) errno_t __cdecl getenv_s(
                                     size_t*     _RequiredCount,
          char*       _Buffer,
                                      rsize_t     _BufferCount,
                                    char const* _VarName
        );

    #line 1155 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"




    __declspec(dllimport) int*       __cdecl __p___argc (void);
    __declspec(dllimport) char***    __cdecl __p___argv (void);
    __declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);

    




        
        
        
    #line 1172 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

    __declspec(dllimport) char***    __cdecl __p__environ (void);
    __declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);

    
        
    #line 1179 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

    





        
        
    #line 1189 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"



    
    


    

          
        __declspec(dllimport) char* __cdecl getenv(
              char const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1209 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

        


#line 1214 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

        
        __declspec(dllimport) errno_t __cdecl _dupenv_s(
                char**      _Buffer,
                                                                                size_t*     _BufferCount,
                                                                                   char const* _VarName
            );

        

#line 1225 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

        __declspec(dllimport) int __cdecl system(
              char const* _Command
            );

        
        
        #pragma warning (push)
        #pragma warning (disable:6540)

         
        __declspec(dllimport) int __cdecl _putenv(
              char const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _putenv_s(
              char const* _Name,
              char const* _Value
            );

        #pragma warning (pop)

        __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                    char const* _Filename,
                                    char const* _VarName,
              char*       _Buffer,
                                      size_t      _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1261 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

         __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1268 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

        
        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _seterrormode(
              int _Mode
            );

        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _beep(
              unsigned _Frequency,
              unsigned _Duration
            );

        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _sleep(
              unsigned long _Duration
            );

    #line 1287 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

#line 1289 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"










    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

        

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
        __declspec(dllimport) int __cdecl putenv(
              char const* _EnvString
            );

    #line 1372 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1378 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#line 14 "H:\\Visual Studio\\VC\\INCLUDE\\cstdlib"
#line 15 "H:\\Visual Studio\\VC\\INCLUDE\\cstdlib"

 
namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

 
using :: getenv;
using :: system;
 #line 36 "H:\\Visual Studio\\VC\\INCLUDE\\cstdlib"

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}
 #line 44 "H:\\Visual Studio\\VC\\INCLUDE\\cstdlib"

#line 46 "H:\\Visual Studio\\VC\\INCLUDE\\cstdlib"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xtr1common"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
struct _Nil
	{	
	};

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static constexpr _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	constexpr operator value_type() const noexcept
		{	
		return (value);
		}

	constexpr value_type operator()() const noexcept
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

	
template<bool _Val>
	struct _Cat_base
		: integral_constant<bool, _Val>
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, size_t _Nx>
	struct remove_const<const _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, size_t _Nx>
	struct remove_volatile<volatile _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 193 "H:\\Visual Studio\\VC\\INCLUDE\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<__int64>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned __int64>
		: true_type
	{	
	};
 #line 255 "H:\\Visual Studio\\VC\\INCLUDE\\xtr1common"

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

template<class _Ty>
	struct _Identity
	{	
	typedef _Ty type;
	};














}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 354 "H:\\Visual Studio\\VC\\INCLUDE\\xtr1common"
#line 355 "H:\\Visual Studio\\VC\\INCLUDE\\xtr1common"





#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}








































template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
		&& ::std:: is_arithmetic<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"    double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"    double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"    double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"    double __cdecl atan2(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"    double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"    double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"    double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C"    double __cdecl fabs(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C"   __declspec(dllimport) double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"    double __cdecl fmod(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"    double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"    double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"    double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"    double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"    double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"    double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"    double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

		









		

inline float _Fma(float _Left, float _Middle, float _Right)
	{	
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	
	return (:: fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	
	return (:: remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

extern "C"   __declspec(dllimport) double __cdecl acosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl asinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl atanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl cbrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl copysign(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl erf(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl erfc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl expm1(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl exp2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl fdim(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C"   __declspec(dllimport) double __cdecl fmax(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl fmin(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl hypot(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) int __cdecl ilogb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl lgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C"   __declspec(dllimport) long long __cdecl llrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C"   __declspec(dllimport) long long __cdecl llround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl log1p(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl log2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl logb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C"   __declspec(dllimport) long __cdecl lrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C"   __declspec(dllimport) long __cdecl lround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl nearbyint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl nextafter(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl nexttoward(  double,   long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left,   long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl remainder(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C"   __declspec(dllimport) double __cdecl rint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl round(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl scalbln(  double,   long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left,   long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl scalbn(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left,   int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl tgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl trunc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 218 "H:\\Visual Studio\\VC\\INCLUDE\\xtgmath.h"
#line 219 "H:\\Visual Studio\\VC\\INCLUDE\\xtgmath.h"
 #line 220 "H:\\Visual Studio\\VC\\INCLUDE\\xtgmath.h"





#line 657 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"
#line 658 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"

 
namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
 #line 740 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"

#line 742 "H:\\Visual Studio\\VC\\INCLUDE\\cmath"





#line 10 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cwchar"

#pragma once










 #line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"









#pragma once



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\errno.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 30 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 78 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 126 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 12 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_string.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_string.h"



__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

 
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 40 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


__declspec(dllimport) void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 60 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

 
__declspec(dllimport) char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

 
__declspec(dllimport) char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

   
__declspec(dllimport) char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

 

__declspec(dllimport) wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

 
__declspec(dllimport) wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

   

__declspec(dllimport) wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 109 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_string.h"
#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 85 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 15 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"








#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



__pragma(pack(push, 8)) extern "C" {



#line 17 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"




#line 22 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
    
#line 24 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"


    

#line 29 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 33 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"














    








#line 58 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"




#line 63 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 70 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
    #line 71 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
#line 72 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"






#line 79 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 99 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"



#line 103 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"



















} __pragma(pack(pop))
#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

__pragma(pack(push, 8)) extern "C" {









    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 38 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 94 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 107 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 121 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 134 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 148 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 161 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 174 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 191 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 209 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 226 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 244 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 261 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 295 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 310 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 327 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 342 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 355 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 377 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 400 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 417 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"

#line 428 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"



} __pragma(pack(pop))
#line 16 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {











    

#line 28 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"
#line 42 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"





















  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"


















































































#line 196 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 17 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 18 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"








#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_share.h"








#pragma once












    
    
    
    
#line 27 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_share.h"
#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable:4820) 











    
    
#line 33 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 94 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 152 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"

 
 __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 158 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 268 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wio.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 19 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 117 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h"
#line 118 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))
#line 20 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"









#pragma once




__pragma(pack(push, 8)) extern "C" {








    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 100 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 178 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 206 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 212 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 253 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 305 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 309 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 319 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 323 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 334 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 338 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 350 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 354 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 356 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 367 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 371 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 381 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 385 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 395 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 399 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 408 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 412 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 422 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 426 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 437 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 441 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 443 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 453 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 457 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 466 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 470 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 480 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 489 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 498 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 507 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 517 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 526 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 537 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 546 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 548 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 558 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 567 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 576 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 585 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 594 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 603 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 611 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 620 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 629 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 638 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 648 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 657 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 659 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 668 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 677 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 685 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 694 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 720 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 726 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 736 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 740 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 751 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 757 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 769 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 773 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 775 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 784 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 788 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 797 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 801 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 811 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 815 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 826 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 830 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 832 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 842 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 851 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

      
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 860 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 879 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 888 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 899 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 908 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 910 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 919 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

      
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 936 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 945 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 954 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 973 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 982 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 984 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1000 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1058 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1066 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4793)

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...);  __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
     
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1131 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1138 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1147 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1160 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1168 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1180 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1184 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1197 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1204 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1216 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1220 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1231 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1235 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1247 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1251 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1264 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1272 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1285 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1289 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 1291 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1299 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1312 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1320 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1332 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1336 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1347 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1355 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1365 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1369 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1380 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1388 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1398 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1402 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1413 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1422 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1434 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1443 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1453 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1462 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1473 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1482 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    
    
    #pragma warning(disable:4793 4996)

     __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...);  __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1496 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...);  __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1503 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1517 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1526 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1538 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1547 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 1549 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1556 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1568 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1577 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1588 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1597 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1609 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1618 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1629 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1638 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1650 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1664 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1675 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1689 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1702 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1723 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1732 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1740 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1749 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1758 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1767 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1776 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1786 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1804 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1813 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1874 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1877 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    




#line 1884 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1912 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1918 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1929 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1933 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1945 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1951 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1964 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1968 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 1970 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1978 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1991 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1997 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 2010 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 2016 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2027 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2036 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
      
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2046 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2055 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2066 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2087 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2096 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    #line 2098 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2110 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2124 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2135 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2149 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2161 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2170 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2181 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2190 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"

    


#line 2195 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"



} __pragma(pack(pop))

#line 21 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"








#pragma once






__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 65 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"











#line 77 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 86 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 94 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
     __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 107 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 119 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 128 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 146 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

#line 150 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 162 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
    
#line 166 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 175 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 182 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 190 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 204 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 212 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 237 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
        



    #line 242 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 

      
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 258 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 269 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 273 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"



 
  
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 294 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 
 
  
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 313 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 351 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 359 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 375 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 382 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 392 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 397 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 410 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 417 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 428 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 433 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 446 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 453 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 565 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"









    


#line 578 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 587 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 644 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 650 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#line 23 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 62 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 100 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"

 
 
  
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 119 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 130 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"

 __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 135 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 146 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"

 __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 151 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"









    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 202 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"

    #pragma warning(pop)
#line 205 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"



} __pragma(pack(pop))
#line 24 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"







#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"







#pragma once




    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 20 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"
#line 21 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 32 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"
#line 33 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 44 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"
#line 45 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/types.h"
#line 12 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820) 







struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 103 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"


















    
    
    
    
    
    
    
#line 129 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"
















    
    
    
    
    
    
#line 152 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 246 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"
#line 247 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\sys/stat.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 25 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





    
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 93 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

      __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 101 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 119 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

     __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 126 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 146 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

     __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 154 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 178 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 278 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"

#line 280 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\wchar.h"



} __pragma(pack(pop))
#line 14 "H:\\Visual Studio\\VC\\INCLUDE\\cwchar"
#line 15 "H:\\Visual Studio\\VC\\INCLUDE\\cwchar"

typedef mbstate_t _Mbstatet;

 
namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
 #line 47 "H:\\Visual Studio\\VC\\INCLUDE\\cwchar"

#line 49 "H:\\Visual Studio\\VC\\INCLUDE\\cwchar"





#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cstddef"

#pragma once










 
#line 15 "H:\\Visual Studio\\VC\\INCLUDE\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 21 "H:\\Visual Studio\\VC\\INCLUDE\\cstddef"

 
namespace std {
typedef double max_align_t;	
}
 #line 27 "H:\\Visual Studio\\VC\\INCLUDE\\cstddef"
#line 28 "H:\\Visual Studio\\VC\\INCLUDE\\cstddef"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\initializer_list"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Elem>
	class initializer_list
	{	
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() noexcept
		: _First(0), _Last(0)
		{	
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) noexcept
		: _First(_First_arg), _Last(_Last_arg)
		{	
		}

	constexpr const _Elem *begin() const noexcept
		{	
		return (_First);
		}

	constexpr const _Elem *end() const noexcept
		{	
		return (_Last);
		}

	constexpr size_t size() const noexcept
		{	
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		
template<class _Elem> inline
	constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Elem> inline
	constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.end());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 76 "H:\\Visual Studio\\VC\\INCLUDE\\initializer_list"
#line 77 "H:\\Visual Studio\\VC\\INCLUDE\\initializer_list"





#line 10 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
  
  
 #line 23 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

namespace std {
		
 
 
 #line 29 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

 
 
 
 
 

 
 

  

  











#line 55 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"
   
   
  #line 58 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

 




















#line 81 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

		


		
 

 



































 
 

		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static const bool value = false;
	};

		

 
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
 #line 173 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

		
template<class _Ty = void>
	struct plus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty = void>
	struct minus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty = void>
	struct multiplies
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty = void>
	struct equal_to
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty = void>
	struct less
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
typedef int _Is_trans;	

		
template<>
	struct plus<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct minus<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct multiplies<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct equal_to<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct less<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};


}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	
 
	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
	const size_t _FNV_offset_basis = 14695981039346656037ULL;
	const size_t _FNV_prime = 1099511628211ULL;

 



#line 351 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}
	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
	{	
	typedef _Kty argument_type;
	typedef size_t result_type;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static const bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};
template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

template<>
	struct hash<char16_t>
		: public _Bitwise_hash<char16_t>
	{	
	};

template<>
	struct hash<char32_t>
		: public _Bitwise_hash<char32_t>
	{	
	};

 
template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};
 #line 426 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}
#line 524 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}




 





 #line 541 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

 



#line 547 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

 #line 549 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

 








 #line 560 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"

 



 

#line 569 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"


























































namespace std {
	
template<class... _Types>
	struct _Arg_types
	{	
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	
	typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	
	typedef _Ty1 first_argument_type;
	typedef _Ty2 second_argument_type;
	};

	
template<class _Ty>
	struct _Is_function
	{	
	typedef false_type _Bool_type;
	};











template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };


template<class _Ret,
	class... _Types>
	struct _Is_function<_Ret (_Types..., ...)>
	{	
	typedef true_type _Bool_type;
	typedef _Ret result_type;
	};

template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	
	};

		
template<class _Ty> inline
	_Ty *_Addressof(_Ty& _Val, true_type) noexcept
	{	
	return (_Val);
	}

template<class _Ty> inline
	_Ty *_Addressof(_Ty& _Val, false_type) noexcept
	{	
	return (reinterpret_cast<_Ty *>(
		&const_cast<char&>(
		reinterpret_cast<const volatile char&>(_Val))));
	}

template<class _Ty> inline
	_Ty *addressof(_Ty& _Val) noexcept
	{	
	return (_Addressof(_Val, is_function<_Ty>()));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 707 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"
#line 708 "H:\\Visual Studio\\VC\\INCLUDE\\xstddef"





#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\limits"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4756)	

namespace std {















 

 
 
 
 

 
 
 
 

 
 
 
 

 
 

		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static constexpr bool has_denorm_loss = (bool)(false);
	static constexpr bool has_infinity = (bool)(false);
	static constexpr bool has_quiet_NaN = (bool)(false);
	static constexpr bool has_signaling_NaN = (bool)(false);
	static constexpr bool is_bounded = (bool)(false);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(false);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr bool is_specialized = (bool)(false);
	static constexpr bool tinyness_before = (bool)(false);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
	static constexpr int digits = (int)(0);
	static constexpr int digits10 = (int)(0);

	static constexpr int max_digits10 = (int)(0);

	static constexpr int max_exponent = (int)(0);
	static constexpr int max_exponent10 = (int)(0);
	static constexpr int min_exponent = (int)(0);
	static constexpr int min_exponent10 = (int)(0);
	static constexpr int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static constexpr _Ty (min)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(true);
	static constexpr bool is_integer = (bool)(true);
	static constexpr bool is_modulo = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static constexpr bool has_denorm_loss = (bool)(true);
	static constexpr bool has_infinity = (bool)(true);
	static constexpr bool has_quiet_NaN = (bool)(true);
	static constexpr bool has_signaling_NaN = (bool)(true);
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(true);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr bool tinyness_before = (bool)(true);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
	static constexpr int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)((-128) != 0);
	static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
#line 263 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((_Ty)0x0000);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return ((_Ty)0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(0x0000 != 0);
	static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));
#line 320 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);
#line 322 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (false);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (true);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(1);
	static constexpr int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 - 1);
	static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8);
	static constexpr int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-32768));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (32767);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (short) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
#line 552 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

 
		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned short));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);
#line 611 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};
 #line 613 "H:\\Visual Studio\\VC\\INCLUDE\\limits"

		
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	
public:
	typedef char16_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char16_t));
	static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);
#line 670 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647 - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (int) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
#line 728 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned int));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);
#line 786 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647L - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647L);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
#line 844 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffUL);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);
#line 902 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	
public:
	typedef char32_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char32_t));
	static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);
#line 960 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

 
		
template<> class numeric_limits<__int64>
	: public _Num_int_base
	{	
public:
	typedef __int64 _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0x7fffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (__int64) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (__int64) - 1) * 301L / 1000);
#line 1019 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};

		
template<> class numeric_limits<unsigned __int64>
	: public _Num_int_base
	{	
public:
	typedef unsigned __int64 _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned __int64));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned __int64) * 301L / 1000);
#line 1077 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
	};
 #line 1079 "H:\\Visual Studio\\VC\\INCLUDE\\limits"

		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (1.175494351e-38F);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (3.402823466e+38F);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (1.192092896e-07F);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5F);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (1.401298464e-45F);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)(1e+300 * 1e+300)));
		}

	static  _Ty quiet_NaN() noexcept	
		{	
		return (:: _FNan._Float);
		}

	static  _Ty signaling_NaN() noexcept	
		{	
		return (:: _FSnan._Float);
		}

	static constexpr int digits = (int)(24);
	static constexpr int digits10 = (int)(6);

	static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)128);
	static constexpr int max_exponent10 = (int)((int)38);
	static constexpr int min_exponent = (int)((int)(-125));
	static constexpr int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)(1e+300 * 1e+300)));
		}

	static  _Ty quiet_NaN() noexcept	
		{	
		return (:: _Nan._Double);
		}

	static  _Ty signaling_NaN() noexcept	
		{	
		return (:: _Snan._Double);
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5L);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)(1e+300 * 1e+300)));
		}

	static  _Ty quiet_NaN() noexcept	
		{	
		return (:: _LNan._Long_double);
		}

	static  _Ty signaling_NaN() noexcept	
		{	
		return (:: _LSnan._Long_double);
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

  









































































































































































































#line 1472 "H:\\Visual Studio\\VC\\INCLUDE\\limits"

 
 
 
 

 
 
 
 

 
 
 
 



}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1495 "H:\\Visual Studio\\VC\\INCLUDE\\limits"
#line 1496 "H:\\Visual Studio\\VC\\INCLUDE\\limits"






#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\ratio"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\stdint.h"







#pragma once




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 14 "H:\\Visual Studio\\VC\\INCLUDE\\stdint.h"



typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 96 "H:\\Visual Studio\\VC\\INCLUDE\\stdint.h"




































#line 133 "H:\\Visual Studio\\VC\\INCLUDE\\stdint.h"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\ratio"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\type_traits"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4180 4296)

	

		
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


namespace std {
	
template<class _Ty>
	struct _Ptr_traits
	{	
	};

template<class _Ty>
	struct _Ptr_traits<_Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<const _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<volatile _Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Ptr_traits<const volatile _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Is_memfunptr
	{	
	typedef false_type _Bool_type;
	};













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)  > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)  &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)  &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };


	
	
template<class _Ty>
	struct add_const
	{	
	typedef const _Ty type;
	};

	
template<class _Ty>
	struct add_volatile
	{	
	typedef volatile _Ty type;
	};

	
template<class _Ty>
	struct add_cv
	{	
	typedef const volatile _Ty type;
	};

	
template<class _Ty>
	struct add_lvalue_reference
	{	
	typedef _Ty& type;
	};








template<> struct add_lvalue_reference< void> { typedef  void type; }; template<> struct add_lvalue_reference<const void> { typedef const void type; }; template<> struct add_lvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_lvalue_reference<const volatile void> { typedef const volatile void type; };


	
template<class _Ty>
	struct add_rvalue_reference
	{	
	typedef _Ty&& type;
	};








template<> struct add_rvalue_reference< void> { typedef  void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };


	
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval() noexcept;

	
template<class _Ty>
	struct remove_extent
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_all_extents
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

	
template<class _Ty>
	struct remove_pointer
	{	
	typedef _Ty type;
	};








template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };


	
template<class _Ty>
	struct add_pointer
	{	
	typedef typename remove_reference<_Ty>::type *type;
	};

	
	
template<class _Ty>
	struct _Is_void
		: false_type
	{	
	};

template<>
	struct _Is_void<void>
		: true_type
	{	
	};

template<class _Ty>
	struct is_void
		: _Is_void<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_array
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	
	};


	
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	
	typedef _Ty2 _Class_type;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
	{	
	};

	
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
	{	
	};

	
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	

template<class _Ty>
	struct is_null_pointer
		: _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
	{	
	};

	
template<class _Ty>
	struct is_union : _Cat_base<__is_union(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_class : _Cat_base<__is_class(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	
	};

	

template<class _From,
	class _To>
	struct is_convertible
		: _Cat_base<__is_convertible_to(_From, _To)>
	{	
	};

	
template<class _Ty>
	struct is_enum
		: _Cat_base<__is_enum(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_const
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_const
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_const<_Ty[_Nx]>
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_const<const _Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_volatile
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_pod : _Cat_base<__is_pod(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_empty : _Cat_base<__is_empty(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_polymorphic : _Cat_base<__is_polymorphic(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_abstract : _Cat_base<__is_abstract(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_final : _Cat_base<__is_final(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_literal_type : _Cat_base<__is_literal_type(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivial : _Cat_base<__is_trivial(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copyable : _Cat_base<__is_trivially_copyable(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_virtual_destructor
		: _Cat_base<__has_virtual_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_constructible
		: _Cat_base<__is_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_copy_constructible
		: is_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_constructible

		: is_constructible<
			_Ty,

			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct _Is_assignable
	{	
	template<class _Dest,
		class _Src>
		static auto _Fn(int)
			-> decltype((void)(::std:: declval<_Dest>() = ::std:: declval<_Src>()),
				true_type());

	template<class _Dest,
		class _Src>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_To, _From>(0)) type;
	};

template<class _To,
	class _From>
	struct is_assignable
		: _Is_assignable<_To, _From>::type
	{	
	};

	
template<class _Ty>
	struct is_copy_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_move_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_destructible
		: _Cat_base<__is_destructible(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_constructible
		: is_trivially_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_constructible

		: is_trivially_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _To,
	class _From>
	struct is_trivially_assignable

		: _Cat_base<__is_trivially_assignable(_To, _From)>

	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_assignable

		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_trivially_move_assignable

		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_trivially_destructible
		: _Cat_base<__has_trivial_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_nothrow_assignable

		: _Cat_base<__is_nothrow_assignable(_To, _From)>

	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_assignable

		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_assignable

		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_nothrow_destructible
		: _Cat_base<__is_nothrow_destructible(_Ty)>
	{	
	};

	
template<class _Ty,
	bool = is_integral<_Ty>::value>
	struct _Sign_base
	{	
	typedef typename remove_cv<_Ty>::type _Uty;
	typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
	typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
	};

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	
		
	typedef is_floating_point<_Ty> _Signed;
	typedef false_type _Unsigned;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	
	};

	
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	
	};

	
template<class _Ty>
	struct _Change_sign
	{	
	static_assert(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	
template<class _Ty>
	struct make_signed
	{	
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	
template<class _Ty>
	struct make_unsigned
	{	
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

	

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	
	};

	




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	
	typedef _Align_type<max_align_t, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	
	typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	
	typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	
	typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
	};

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	struct aligned_storage
	{	
	typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
	};




	
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
	{	
	static const size_t value = 0;
	};

template<size_t _Val>
	struct _Maximum<_Val>
	{	
	static const size_t value = _Val;
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>
	{	
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	
	static const size_t _Max_len = _Maximum<
		_Len, sizeof(_Types)...>::value;	
	static const size_t alignment_value = _Maximum<
		alignment_of<_Types>::value...>::value;
	typedef typename aligned_storage<_Max_len, alignment_value>::type type;
	};

	
template<class _Ty>
	struct underlying_type
	{	
	typedef __underlying_type(_Ty) type;
	};

	
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

	
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	
	};

template<class _Ty, unsigned int _Nx, size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	
	};

	
template<class _Base,
	class _Der>
	struct is_base_of : _Cat_base<__is_base_of(_Base, _Der)>
	{	
	};

	
template<class _Ty>
	struct decay
	{	
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

namespace tr1 {	
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
	}	

		
template<class... _Ty>
	struct common_type;

template<class _Ty>
	struct common_type<_Ty>
	{	
	typedef typename decay<_Ty>::type type;
	};

template<class _Ty0,
	class _Ty1>
	struct common_type<_Ty0, _Ty1>
	{	
	typedef typename decay<
		decltype(_Always_false<_Ty0>::value
			? ::std:: declval<_Ty0>()
			: ::std:: declval<_Ty1>())
	>::type type;
	};

template<class _Ty0,
	class _Ty1,
	class... _Ty>
	struct common_type<_Ty0, _Ty1, _Ty...>
	{	
	typedef typename common_type<
		typename common_type<_Ty0, _Ty1>::type, _Ty...
	>::type type;
	};

	
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	
	static_assert(is_integral<_Ty>::value,
		"integer_sequence<T, I...> requires T to be an integral type.");

	typedef integer_sequence<_Ty, _Vals...> type;
	typedef _Ty value_type;

	static constexpr size_t size() noexcept
		{	
		return (sizeof...(_Vals));
		}
	};

	
template<bool _Negative,
	bool _Zero,
	class _Int_con,
	class _Int_seq>
	struct _Make_seq
	{	
	static_assert(!_Negative,
		"make_integer_sequence<T, N> requires N to be non-negative.");
	};

template<class _Ty,
	_Ty... _Vals>
	struct _Make_seq<false, true,
		integral_constant<_Ty, 0>,
		integer_sequence<_Ty, _Vals...> >
		: integer_sequence<_Ty, _Vals...>
	{	
	};

template<class _Ty,
	_Ty _Ix,
	_Ty... _Vals>
	struct _Make_seq<false, false,
		integral_constant<_Ty, _Ix>,
		integer_sequence<_Ty, _Vals...> >
		: _Make_seq<false, _Ix == 1,
			integral_constant<_Ty, _Ix - 1>,
			integer_sequence<_Ty, _Ix - 1, _Vals...> >
	{	
	};

template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = typename _Make_seq<_Size < 0, _Size == 0,
		integral_constant<_Ty, _Size>, integer_sequence<_Ty> >::type;

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

	
template<class _Ty>
	struct identity
	{	
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	
		return (_Left);
		}
	};

	
template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type& _Arg) noexcept
	{	
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type&& _Arg) noexcept
	{	
	static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename remove_reference<_Ty>::type&&
		move(_Ty&& _Arg) noexcept
	{	
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename remove_reference<_Ty>::type&&
		_Move(_Ty&& _Arg) noexcept
	{	
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
		&& is_copy_constructible<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) noexcept
	{	
	return (::std:: move(_Arg));
	}

	
template<class _Ty> inline
	typename decay<_Ty>::type _Decay_copy(_Ty&& _Arg)
	{	
	return (::std:: forward<_Ty>(_Arg));
	}

	
template<class...>
	struct _Param_tester
	{	
	typedef void type;
	};

	
template<class... _Types>	
	using void_t = typename _Param_tester<_Types...>::type;

	
struct _Invoker_pmf_object
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmf_pointer
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmd_object
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
		{	
		return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
		}
	};

struct _Invoker_pmd_pointer
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
		{	
		return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
		}
	};

struct _Invoker_functor
	{	
	template<class _Callable,
		class... _Types>
		static auto _Call(_Callable&& _Obj, _Types&&... _Args)
		-> decltype(::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...));
		}
	};

template<class _Callable,
	class _Ty1,
	class _Decayed = typename decay<_Callable>::type,
	bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
	bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
	struct _Invoker1;

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
		: _If<is_base_of<
			typename _Is_memfunptr<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmf_object,
		_Invoker_pmf_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
		: _If<is_base_of<
			typename _Is_member_object_pointer<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmd_object,
		_Invoker_pmd_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable>
	struct _Invoker<_Callable>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class _Ty1,
	class... _Types2>
	struct _Invoker<_Callable, _Ty1, _Types2...>
		: _Invoker1<_Callable, _Ty1>
	{	
	};

template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
	-> decltype(_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
	{	
	return (_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
	}

template<class _Rx,
	bool = is_void<_Rx>::value>
	struct _Forced
	{	
	};

struct _Unforced
	{	
	};

template<class _Cv_void,
	class... _Valtys> inline
	void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
	{	
	::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
	}

template<class _Rx,
	class... _Valtys> inline
	_Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

template<class... _Valtys> inline
	auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
	-> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

	
template<class _Fty>
	struct result_of
	{	
	static_assert(_Always_false<_Fty>::value,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};










template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> { typedef decltype(::std:: invoke(::std:: declval<_Fty>(), ::std:: declval<_Args>()...)) type; };    template<class _Fty, class... _Args> struct result_of<_Fty __vectorcall (_Args...)> { typedef decltype(::std:: invoke(::std:: declval<_Fty>(), ::std:: declval<_Args>()...)) type; };


	
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	
	};

template<class _Ty>
	struct _Weak_result_type<_Ty, typename _Param_tester<
		typename _Ty::result_type>::type>
	{	
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_argument_type<_Ty, typename _Param_tester<
		typename _Ty::argument_type>::type>
		: _Weak_result_type<_Ty>
	{	
	typedef typename _Ty::argument_type argument_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_binary_args<_Ty, typename _Param_tester<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type>::type>
		: _Weak_argument_type<_Ty>
	{	
	typedef typename _Ty::first_argument_type first_argument_type;
	typedef typename _Ty::second_argument_type second_argument_type;
	};

template<class _Ty>
	struct _Weak_types
	{	
	typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
	typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
	typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty> >::type>::type type;
	};

	
template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	
public:
	static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
		"reference_wrapper<T> requires T to be an object type "
		"or a function type.");

	typedef _Ty type;

	reference_wrapper(_Ty& _Val) noexcept
		: _Ptr(::std:: addressof(_Val))
		{	
		}

	operator _Ty&() const noexcept
		{	
		return (*_Ptr);
		}

	_Ty& get() const noexcept
		{	
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
		}

	reference_wrapper(_Ty&&) = delete;

private:
	_Ty *_Ptr;
	};

	
template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(_Ty& _Val) noexcept
	{	
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: ref(_Val.get()));
	}

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) noexcept
	{	
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: cref(_Val.get()));
	}

	
template<class _Ty>
	struct _Unrefwrap_helper
	{	
	typedef _Ty type;
	static const bool _Is_refwrap = false;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	
	typedef _Ty& type;
	static const bool _Is_refwrap = true;
	};

template<class _Ty>
	struct _Unrefwrap
	{	
	typedef typename decay<_Ty>::type _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	static const bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
	};

namespace tr1 {	
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
	}	

		
template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
	using result_of_t = typename result_of<_Ty>::type;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1773 "H:\\Visual Studio\\VC\\INCLUDE\\type_traits"
#line 1774 "H:\\Visual Studio\\VC\\INCLUDE\\type_traits"






#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\ratio"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
template<intmax_t _Val>
	struct _Abs
	{	
	static const intmax_t value = _Val < 0 ? -_Val : _Val;
	};

	
template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Sfinae = false,
	bool _Good = (_Abs<_Ax>::value
		<= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
	struct _Safe_mult
		: integral_constant<intmax_t, _Ax * _Bx>
	{	
	};

template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Sfinae>
	struct _Safe_mult<_Ax, _Bx, _Sfinae, false>
	{	
	static_assert(_Sfinae,
		"integer arithmetic overflow");
	};

	
template<intmax_t _Val>
	struct _Sign_of
	{	
	static const intmax_t value = _Val < 0 ? -1 : 1;
	};

	
template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Good,
	bool _Also_good>
	struct _Safe_addX
	{	
	static const intmax_t value = _Ax + _Bx;
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Safe_addX<_Ax, _Bx, false, false>
	{	
	static_assert(_Always_false<_Safe_addX>::value,
		"integer arithmetic overflow");
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Safe_add
	{	
	static const intmax_t value = _Safe_addX<_Ax, _Bx,
		_Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
		(_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::value;
	};

	
template<intmax_t _Ax,
	intmax_t _Bx>
	struct _GcdX
	{	
	static const intmax_t value = _GcdX<_Bx, _Ax % _Bx>::value;
	};

template<intmax_t _Ax>
	struct _GcdX<_Ax, 0>
	{	
	static const intmax_t value = _Ax;
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Gcd
	{	
	static const intmax_t value =
		_GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::value;
	};

template<>
	struct _Gcd<0, 0>
	{	
	static const intmax_t value = 1;	
	};

	
template<intmax_t _Nx,
	intmax_t _Dx = 1>
	struct ratio
	{	
	static_assert(_Dx != 0,
		"zero denominator");
	static_assert(-9223372036854775807i64 <= _Nx,
		"numerator too negative");
	static_assert(-9223372036854775807i64 <= _Dx,
		"denominator too negative");

	static constexpr intmax_t num = _Sign_of<_Nx>::value
		* _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

	static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>
		::value;

	typedef ratio<num, den> type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct _Are_ratios
		: false_type
	{	
	};

template<intmax_t _N1,
	intmax_t _D1,
	intmax_t _N2,
	intmax_t _D2>
	struct _Are_ratios<ratio<_N1, _D1>, ratio<_N2, _D2> >
		: true_type
	{	
	};

	
template<class _R1,
	class _R2>
	struct _Ratio_add
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

	static const intmax_t _N1 = _R1::num;
	static const intmax_t _D1 = _R1::den;
	static const intmax_t _N2 = _R2::num;
	static const intmax_t _D2 = _R2::den;

	static const intmax_t _Gx = _Gcd<_D1, _D2>::value;

	
	typedef typename ratio<
		_Safe_add<
			_Safe_mult<_N1, _D2 / _Gx>::value,
			_Safe_mult<_N2, _D1 / _Gx>::value
			>::value,
		_Safe_mult<_D1, _D2 / _Gx>::value
		>::type type;
	};

template<class _R1,
	class _R2>
	using ratio_add = typename _Ratio_add<_R1, _R2>::type;

	
template<class _R1,
	class _R2>
	struct _Ratio_subtract
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

	static const intmax_t _N2 = _R2::num;
	static const intmax_t _D2 = _R2::den;

	typedef ratio_add<_R1, ratio<-_N2, _D2> > type;
	};

template<class _R1,
	class _R2>
	using ratio_subtract = typename _Ratio_subtract<_R1, _R2>::type;

	
template<class _R1,
	class _R2>
	struct _Ratio_multiply
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

	static const intmax_t _N1 = _R1::num;
	static const intmax_t _D1 = _R1::den;
	static const intmax_t _N2 = _R2::num;
	static const intmax_t _D2 = _R2::den;

	static const intmax_t _Gx = _Gcd<_N1, _D2>::value;
	static const intmax_t _Gy = _Gcd<_N2, _D1>::value;

	typedef _Safe_mult<_N1 / _Gx, _N2 / _Gy, true> _Num;
	typedef _Safe_mult<_D1 / _Gy, _D2 / _Gx, true> _Den;
	};

template<class _R1,
	class _R2,
	bool _Sfinae = true,
	class = void>
	struct _Ratio_multiply_sfinae
	{	
	static_assert(_Sfinae,
		"integer arithmetic overflow");
	};

template<class _R1,
	class _R2,
	bool _Sfinae>
	struct _Ratio_multiply_sfinae<_R1, _R2, _Sfinae, typename _Param_tester<
		typename _Ratio_multiply<_R1, _R2>::_Num::type,
		typename _Ratio_multiply<_R1, _R2>::_Den::type>::type>
	{	
	typedef ratio<
		_Ratio_multiply<_R1, _R2>::_Num::value,
		_Ratio_multiply<_R1, _R2>::_Den::value> type;
	};

template<class _R1,
	class _R2>
	using ratio_multiply = typename _Ratio_multiply_sfinae<_R1, _R2, false>
		::type;

	
template<class _R1,
	class _R2>
	struct _Ratio_divide
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

	static const intmax_t _N2 = _R2::num;
	static const intmax_t _D2 = _R2::den;

	typedef ratio<_D2, _N2> _R2_inverse;
	};

template<class _R1,
	class _R2,
	bool _Sfinae = true>
	using _Ratio_divide_sfinae = typename _Ratio_multiply_sfinae<
		_R1, typename _Ratio_divide<_R1, _R2>::_R2_inverse, _Sfinae>::type;

template<class _R1,
	class _R2>
	using ratio_divide = _Ratio_divide_sfinae<_R1, _R2, false>;

	
template<class _R1,
	class _R2>
	struct ratio_equal
		: _Cat_base<_R1::num == _R2::num && _R1::den == _R2::den>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_not_equal
		: integral_constant<bool, !ratio_equal<_R1, _R2>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct _Ratio_less
	{	
	static const intmax_t _N1 = _R1::num;
	static const intmax_t _D1 = _R1::den;
	static const intmax_t _N2 = _R2::num;
	static const intmax_t _D2 = _R2::den;

	static const intmax_t _Gn = _Gcd<_N1, _N2>::value;
	static const intmax_t _Gd = _Gcd<_D1, _D2>::value;

	static const intmax_t _Left = _Safe_mult<_N1 / _Gn, _D2 / _Gd>::value;
	static const intmax_t _Right = _Safe_mult<_N2 / _Gn, _D1 / _Gd>::value;

	typedef integral_constant<bool, (_Left < _Right)> type;
	};

template<class _R1,
	class _R2>
	struct ratio_less
		: _Ratio_less<_R1, _R2>::type
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_less_equal
		: integral_constant<bool, !ratio_less<_R2, _R1>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_greater
		: integral_constant<bool, ratio_less<_R2, _R1>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_greater_equal
		: integral_constant<bool, !ratio_less<_R1, _R2>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	

typedef ratio<1, 1000000000000000000LL> atto;
typedef ratio<1, 1000000000000000LL> femto;
typedef ratio<1, 1000000000000LL> pico;

typedef ratio<1, 1000000000> nano;
typedef ratio<1, 1000000> micro;
typedef ratio<1, 1000> milli;
typedef ratio<1, 100> centi;
typedef ratio<1, 10> deci;
typedef ratio<10, 1> deca;
typedef ratio<100, 1> hecto;
typedef ratio<1000, 1> kilo;
typedef ratio<1000000, 1> mega;
typedef ratio<1000000000, 1> giga;

typedef ratio<1000000000000LL, 1> tera;
typedef ratio<1000000000000000LL, 1> peta;
typedef ratio<1000000000000000000LL, 1> exa;
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 363 "H:\\Visual Studio\\VC\\INCLUDE\\ratio"
#line 364 "H:\\Visual Studio\\VC\\INCLUDE\\ratio"





#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\utility"

#pragma once




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cstdio"

#pragma once










 #line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {































    
#line 48 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"















    
    
#line 66 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 139 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 313 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 338 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    #line 385 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 417 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 427 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

      
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 436 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
 __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 444 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(pop)

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    













#line 582 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 592 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"



    
    

#line 599 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 640 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 644 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 654 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 658 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 669 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 673 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 685 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 689 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 691 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 702 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 706 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 716 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 720 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 730 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 734 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 743 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 747 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 757 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 761 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 772 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 776 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 778 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 788 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 792 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 801 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 805 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 815 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 824 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 833 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 842 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 858 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 867 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 878 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 887 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 889 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 899 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 908 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 917 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 926 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 935 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 944 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 952 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 961 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 970 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 979 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 989 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 998 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1000 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1009 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1018 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1026 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1035 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1060 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1066 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1076 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1080 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1091 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1097 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1110 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1114 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1116 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1126 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1130 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1139 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1143 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1153 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1157 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1168 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1172 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1174 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1184 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1193 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

      
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1202 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1211 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1221 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1230 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1241 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1250 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1252 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1261 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1270 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

      
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1278 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1287 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1296 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1305 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1315 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1324 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1326 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"



    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1387 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1395 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1407 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1414 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    








#line 1425 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1437 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1445 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1457 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1464 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1475 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1482 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1495 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1503 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1517 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1521 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1529 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1531 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1544 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1552 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1564 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1568 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1582 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1590 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1603 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1607 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1616 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1631 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1635 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1644 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1646 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1656 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1664 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1673 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1677 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1687 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1695 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1704 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1708 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1720 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1728 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1740 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1744 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1755 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1769 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1779 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1793 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
       int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...);    int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1804 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    #pragma warning(pop)

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1817 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1826 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1839 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1848 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 1850 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1857 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1869 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1878 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1889 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1898 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1910 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1924 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    








#line 1935 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1946 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1956 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1967 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1977 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

        int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...);     int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1986 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1998 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2007 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 2018 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2027 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2040 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2049 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2061 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2070 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2078 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2087 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2096 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2104 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2113 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2122 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2131 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2139 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2148 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2173 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2179 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2189 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2193 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2204 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2210 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2225 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2229 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2236 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2240 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2250 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2259 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

      
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2268 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2277 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2287 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2296 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2307 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2321 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #line 2323 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable:6530)

     
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2337 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2350 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2360 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2373 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2385 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2398 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2408 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2421 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2427 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2443 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2453 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2465 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"
#line 2466 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#line 14 "H:\\Visual Studio\\VC\\INCLUDE\\cstdio"
#line 15 "H:\\Visual Studio\\VC\\INCLUDE\\cstdio"


 
 
 
 
 
 
 

 
 
 
 

  

typedef FILE FILE;

 
namespace std {
using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
 #line 59 "H:\\Visual Studio\\VC\\INCLUDE\\cstdio"

#line 61 "H:\\Visual Studio\\VC\\INCLUDE\\cstdio"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cstring"

#pragma once










 #line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"







#pragma once



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"










#pragma once







__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 56 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"

    












#line 71 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"

#line 73 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 94 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 111 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 117 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_memory.h"
#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"





__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 70 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 83 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
      char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 94 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"
#pragma warning(pop)

#line 97 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 128 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 137 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 149 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 158 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
 
  
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 178 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
  
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 190 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 232 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 237 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 250 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 257 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 264 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 272 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 336 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 344 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 

#line 350 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

#line 354 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 366 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"
    
#line 370 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 379 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 394 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 402 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 425 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

  char* __cdecl _strset( char *_Destination,  int _Value);
#line 431 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 454 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 459 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 472 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 479 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 527 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"





    


#line 536 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );

    

#line 545 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 594 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"



} __pragma(pack(pop))

#line 600 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\string.h"
#line 14 "H:\\Visual Studio\\VC\\INCLUDE\\cstring"
#line 15 "H:\\Visual Studio\\VC\\INCLUDE\\cstring"

 
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
 #line 28 "H:\\Visual Studio\\VC\\INCLUDE\\cstring"

#line 30 "H:\\Visual Studio\\VC\\INCLUDE\\cstring"





#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"







#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new_debug.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new.h"


extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 






    namespace std
    {
        struct nothrow_t { };

        extern nothrow_t const nothrow;
    }
#line 32 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new.h"

   
__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new(
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

   
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new[](
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block
    ) throw();

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete[](
    void* _Block
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) throw();


    
       
    inline void* __cdecl operator new(size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) throw()
    {
        return;
    }
#line 97 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new.h"


    
       
    inline void* __cdecl operator new[](size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) throw()
    {
    }
#line 111 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new.h"



#pragma warning(pop)
#pragma pack(pop)

} 
#line 119 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new.h"
#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new_debug.h"


extern "C++" {

#pragma pack(push, 8)






         
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

         
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

#line 53 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 60 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_new_debug.h"
#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"

__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;



    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
























































































#line 234 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"










    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

















































































































































































































































































































#line 585 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"











    
    
    
    
    
    
    

















































































#line 685 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"











    

    
        
    #line 701 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"

    
        
    #line 705 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"

    
        
    #line 709 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"

    
    

    
    

    
    

    
    












































#line 766 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"













    
#line 781 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

typedef _Longlong streamoff;
typedef _Longlong streamsize;

  
  

  



extern __declspec(dllimport)  const streamoff _BADOFF;
  #line 33 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return ((streamoff)(_Myoff + ((long long)(_Fpos))));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator==(streamoff _Right) const
		{	
		return ((streamoff)*this == _Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

 

 
 

typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;

		
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	
	typedef _Elem char_type;
	typedef _Int_type int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(
		  const _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(  const _Elem *_First)
		{	
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Dest_size,
		  const _Elem *_First2, size_t _Count)
		{	
		{ if (!(_Count <= _Dest_size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); return (0); } };
		return (copy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(
		  const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(
		  _Elem *_First,
		size_t _Count, _Elem _Ch)
		{	
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((int_type)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((int_type)(-1));
		}
	};

		
template<class _Elem>
	struct char_traits
		: public _Char_traits<_Elem, long>
	{	
	};

		
template<>
	struct char_traits<char16_t>
	: public _Char_traits<char16_t, unsigned short>
	{	
	};

typedef streampos u16streampos;

		
template<>
	struct char_traits<char32_t>
	: public _Char_traits<char32_t, unsigned int>
	{	
	};

typedef streampos u32streampos;

		
template<>
	struct char_traits<wchar_t>
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};

 
		
template<>
	struct char_traits<unsigned short>
	{	
	typedef unsigned short _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp((const wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen((const wchar_t *)_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
#line 431 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr((const wchar_t *)_First,
				_Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(const int_type& _Meta)
		noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(const _Elem& _Ch)
		noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(const int_type& _Meta)
		noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};
 #line 503 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"

		
template<> struct char_traits<char>
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_bytes,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: memset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return ((unsigned char)_Left < (unsigned char)_Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((unsigned char)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((-1));
		}
	};

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 #line 674 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;

 





















 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
	numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
	numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
 #line 748 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 754 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"
#line 755 "H:\\Visual Studio\\VC\\INCLUDE\\iosfwd"





#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\utility"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180 4512)

namespace std {
		
template<class _Ty> inline
	void swap(_Ty&, _Ty&)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);
#line 23 "H:\\Visual Studio\\VC\\INCLUDE\\utility"

template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	swap(*_Left, *_Right);
	}

		
template<class _Ty,
	size_t _Size> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		noexcept(noexcept(swap(*_Left, *_Right)))
	{	
	if (&_Left != &_Right)
		{	
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)
#line 51 "H:\\Visual Studio\\VC\\INCLUDE\\utility"
	{	
	_Ty _Tmp = _Move(_Left);
	_Left = _Move(_Right);
	_Right = _Move(_Tmp);
	}

		
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
		noexcept(noexcept(swap(_Left, _Right)))
	{	
	swap(_Left, _Right);
	}

		
struct piecewise_construct_t
	{	
	};

constexpr piecewise_construct_t piecewise_construct{};

		

template<class...>
	class tuple;


template<class _Ty1,
	class _Ty2>
	struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	constexpr pair()
		: first(), second()
		{	
		}

	constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	pair(const pair&) = default;
	pair(pair&&) = default;

	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
			&& is_convertible<const _Other2&, _Ty2>::value,
			void>::type>
		constexpr pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}


	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2);


	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
			&& is_convertible<_Other2, _Ty2>::value,
			void>::type>
		constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept((is_nothrow_constructible<_Ty1, _Other1&&>::value && is_nothrow_constructible<_Ty2, _Other2&&>::value))
#line 143 "H:\\Visual Studio\\VC\\INCLUDE\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
			&& is_convertible<_Other2, _Ty2>::value,
			void>::type>
		constexpr pair(pair<_Other1, _Other2>&& _Right)
			noexcept((is_nothrow_constructible<_Ty1, _Other1&&>::value && is_nothrow_constructible<_Ty2, _Other2&&>::value))
#line 156 "H:\\Visual Studio\\VC\\INCLUDE\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
		{	
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))
#line 173 "H:\\Visual Studio\\VC\\INCLUDE\\utility"
		{	
		first = ::std:: forward<_Ty1>(_Right.first);
		second = ::std:: forward<_Ty2>(_Right.second);
		return (*this);
		}

	void swap(_Myt& _Right)
		noexcept(noexcept(_Swap_adl(this->first, _Right.first)) && noexcept(_Swap_adl(this->second, _Right.second)))
#line 182 "H:\\Visual Studio\\VC\\INCLUDE\\utility"
		{	
		if (this != &_Right)
			{	
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	_Ty1 first;	
	_Ty2 second;	
	};

		

template<class _Ty1,
	class _Ty2> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	

template<class _Ty1,
	class _Ty2> inline
	constexpr pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	
	typedef pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type> _Mypair;
	return (_Mypair(::std:: forward<_Ty1>(_Val1),
		::std:: forward<_Ty2>(_Val2)));
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}

namespace std {
template<class _Ty,
	size_t _Size>
	class array;

	
template<class _Tuple>
	struct tuple_size
	{	
	static_assert(_Always_false<_Tuple>::value,
		"The C++ Standard doesn't define tuple_size for this type.");
	};

template<class _Ty,
	size_t _Size>
	struct tuple_size<array<_Ty, _Size> >
		: integral_constant<size_t, _Size>
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2> >
	: integral_constant<size_t, 2>
	{	
	};

template<class... _Types>
	struct tuple_size<tuple<_Types...> >
	: integral_constant<size_t, sizeof...(_Types)>
	{	
	};


template<class _Tuple>
	struct tuple_size<const _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

	
template<size_t _Index,
	class _Tuple>
	struct tuple_element
	{	
	static_assert(_Always_false<_Tuple>::value,
		"tuple_element index out of bounds");
	};

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	struct tuple_element<_Idx, array<_Ty, _Size> >
	{	
	static_assert(_Idx < _Size, "array index out of bounds");

	typedef _Ty type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty2 type;
	};

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...> >
	{	
	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...> >
		: public tuple_element<_Index - 1, tuple<_Rest...> >
	{	
	};


template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

	
template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 0>) noexcept
	{	
	return (_Pr.first);
	}

template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 1>) noexcept
	{	
	return (_Pr.second);
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
	return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		_Ctype;
	return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
		get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
	return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<0>(::std:: move(_Pr)));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<1>(::std:: move(_Pr)));
	}

	

template<class _Ty,
	class _Other = _Ty> inline
	_Ty exchange(_Ty& _Val, _Other&& _New_val)
	{	
	_Ty _Old_val = ::std:: move(_Val);
	_Val = ::std:: forward<_Other>(_New_val);
	return (_Old_val);
	}
}

namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 550 "H:\\Visual Studio\\VC\\INCLUDE\\utility"
#line 551 "H:\\Visual Studio\\VC\\INCLUDE\\utility"





#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 44 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"
















  
__declspec(dllimport) int* __cdecl __daylight(void);




  
__declspec(dllimport) long* __cdecl __dstbias(void);




  
__declspec(dllimport) long* __cdecl __timezone(void);




    
__declspec(dllimport) char** __cdecl __tzname(void);



  
__declspec(dllimport) errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
__declspec(dllimport) errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
__declspec(dllimport) errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
__declspec(dllimport) errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );








 
 
  
__declspec(dllimport) char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );
#line 129 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }
#line 135 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

 
__declspec(dllimport) clock_t __cdecl clock(void);

 
 
  
__declspec(dllimport) char* __cdecl _ctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
#line 158 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

 
 
  
__declspec(dllimport) char* __cdecl _ctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }
#line 178 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

 
__declspec(dllimport) double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
__declspec(dllimport) double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  
__declspec(dllimport) struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  
__declspec(dllimport) struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  
__declspec(dllimport) struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  
__declspec(dllimport) struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

__declspec(dllimport) size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
#line 288 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

 __declspec(dllimport)  char* __cdecl _strdate( char *_Buffer);
#line 293 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"


__declspec(dllimport) errno_t __cdecl _strtime_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
#line 304 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

 __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);
#line 309 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

__declspec(dllimport) __time32_t __cdecl _time32(
      __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
__declspec(dllimport) int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
__declspec(dllimport) int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );










    __declspec(dllimport) void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );

#line 356 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"










    











































































































          
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _ctime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _gmtime64(_Time);
            #pragma warning(pop)
        }

        
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _localtime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 576 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

    #line 578 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

#line 580 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    #line 595 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"

#line 597 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\time.h"



} __pragma(pack(pop))
#line 10 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xtimec.h"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 


#line 17 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"
  
 #line 19 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"

 #pragma warning(disable: 4511 4512)

extern "C" {

  #pragma warning(disable:4115 4100 4097 4245)

 

#line 31 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"
  
 #line 33 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"

typedef unsigned int _Thrd_id_t;
typedef struct
	{	
	void *_Hnd;	
	_Thrd_id_t _Id;
	} _Thrd_imp_t;





typedef unsigned int (__stdcall *_Thrd_callback_t)(void *);

 
 












 
  
  
  
  
 




#line 72 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"
 #line 73 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"

typedef struct _Mtx_internal_imp_t *_Mtx_imp_t;

typedef struct _Cnd_internal_imp_t *_Cnd_imp_t;
typedef int _Tss_imp_t;

	
__declspec(dllimport) void __cdecl _Thrd_abort(const char *);
__declspec(dllimport) int __cdecl _Thrd_start(_Thrd_imp_t *, _Thrd_callback_t, void *);
void _Tss_destroy(void);

 






#line 92 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"
  
 #line 94 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"

}


  
  
  
  

  
  

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 110 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"
#line 111 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xthrcommon.h"





















#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xtimec.h"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


extern "C" {	
#line 17 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xtimec.h"

typedef struct xtime
	{	
	__time64_t sec;
	long nsec;
	} xtime;

__declspec(dllimport) int __cdecl xtime_get(xtime*, int);

__declspec(dllimport) long __cdecl _Xtime_diff_to_millis(const xtime *);
__declspec(dllimport) long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime *);
__declspec(dllimport) long long __cdecl _Xtime_get_ticks(void);



__declspec(dllimport) long long __cdecl _Query_perf_counter(void);
__declspec(dllimport) long long __cdecl _Query_perf_frequency(void);


} 
#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xtimec.h"
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 42 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xtimec.h"
#line 43 "H:\\Visual Studio\\VC\\INCLUDE\\thr/xtimec.h"





















#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4455)
 #pragma warning(disable: 6326)

namespace std {
namespace chrono {
	
template<class _Rep>
	struct treat_as_floating_point
		: is_floating_point<_Rep>
	{	
	};

	
template<class _Rep>
	struct duration_values
	{	
	static constexpr _Rep zero()
		{	
		return (_Rep(0));
		}

	static constexpr _Rep (min)()
		{	
		return (numeric_limits<_Rep>::lowest());
		}

	static constexpr _Rep (max)()
		{	
		return ((numeric_limits<_Rep>::max)());
		}
	};

	
template<class _Ty>
	struct _Is_ratio
	{	
	static const bool value = false;
	};

template<intmax_t _R1,
	intmax_t _R2>
	struct _Is_ratio<ratio<_R1, _R2> >
	{	
	static const bool value = true;
	};

	
template<class _Rep,
	class _Period = ratio<1> >
	class duration;

template<class _Ty>
	struct _Is_duration
		: false_type
	{	
	};

template<class _Rep,
	class _Period>
	struct _Is_duration<duration<_Rep, _Period> >
		: true_type
	{	
	};

template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		_To>::type
		duration_cast(const duration<_Rep, _Period>&);

template<class _Rep,
	class _Period>
	class duration
	{	
public:
	typedef duration<_Rep, _Period> _Myt;
	typedef _Rep rep;
	typedef _Period period;

	static_assert(!_Is_duration<_Rep>::value,
		"duration can't have duration as first template argument");
	static_assert(_Is_ratio<_Period>::value,
		"period not an instance of std::ratio");
	static_assert(0 < _Period::num,
		"period negative or zero");

	constexpr duration() = default;

	template<class _Rep2,
		class = typename enable_if<is_convertible<_Rep2, _Rep>::value
			&& (treat_as_floating_point<_Rep>::value
				|| !treat_as_floating_point<_Rep2>::value),
			void>::type>
		constexpr explicit duration(const _Rep2& _Val)
			: _MyRep(static_cast<_Rep>(_Val))
		{	
		}

	template<class _Rep2,
		class _Period2,
		class = typename enable_if<treat_as_floating_point<_Rep>::value

			|| (_Ratio_divide_sfinae<_Period2, _Period>::den == 1

				&& !treat_as_floating_point<_Rep2>::value),
			void>::type>
		constexpr duration(const duration<_Rep2, _Period2>& _Dur)
			: _MyRep(duration_cast<_Myt>(_Dur).count())
		{	
		}

	constexpr _Rep count() const
		{	
		return (_MyRep);
		}

	constexpr _Myt operator+() const
		{	
		return (*this);
		}

	constexpr _Myt operator-() const
		{	
		return (_Myt(0 - _MyRep));
		}

	_Myt& operator++()
		{	
		++_MyRep;
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (_Myt(_MyRep++));
		}

	_Myt& operator--()
		{	
		--_MyRep;
		return (*this);
		}

	_Myt operator--(int)
		{	
		return (_Myt(_MyRep--));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		_MyRep += _Right._MyRep;
		return (*this);
		}

	_Myt& operator-=(const _Myt& _Right)
		{	
		_MyRep -= _Right._MyRep;
		return (*this);
		}

	_Myt& operator*=(const _Rep& _Right)
		{	
		_MyRep *= _Right;
		return (*this);
		}

	_Myt& operator/=(const _Rep& _Right)
		{	
		_MyRep /= _Right;
		return (*this);
		}

	_Myt& operator%=(const _Rep& _Right)
		{	
		_MyRep %= _Right;
		return (*this);
		}

	_Myt& operator%=(const _Myt& _Right)
		{	
		_MyRep %= _Right.count();
		return (*this);
		}

	static constexpr _Myt zero()
		{	
		return (_Myt(duration_values<_Rep>::zero()));
		}

	static constexpr _Myt (min)()
		{	
		return (_Myt((duration_values<_Rep>::min)()));
		}
	static constexpr _Myt (max)()
		{	
		return (_Myt((duration_values<_Rep>::max)()));
		}

private:
	_Rep _MyRep;	
	};

template<class _Clock,
	class _Duration = typename _Clock::duration>
	class time_point
	{	
public:
	typedef _Clock clock;
	typedef _Duration duration;
	typedef typename _Duration::rep rep;
	typedef typename _Duration::period period;

	static_assert(_Is_duration<_Duration>::value,
		"duration must be an instance of std::duration");

	constexpr time_point()
		: _MyDur(_Duration::zero())
		{	
		}

	constexpr explicit time_point(const _Duration& _Other)
		: _MyDur(_Other)
		{	
		}

	template<class _Duration2,
		class = typename enable_if<is_convertible<_Duration2,
			_Duration>::value,
			void>::type>
		constexpr time_point(const time_point<_Clock, _Duration2>& _Tp)
		: _MyDur(_Tp.time_since_epoch())
		{	
		}

	constexpr _Duration time_since_epoch() const
		{	
		return (_MyDur);
		}

	time_point& operator+=(const _Duration& _Dur)
		{	
		_MyDur += _Dur;
		return (*this);
		}

	time_point& operator-=(const _Duration& _Dur)
		{	
		_MyDur -= _Dur;
		return (*this);
		}

	static constexpr time_point (min)()
		{	
		return (time_point((_Duration::min)()));
		}
	static constexpr time_point (max)()
		{	
		return (time_point((_Duration::max)()));
		}

private:
	_Duration _MyDur;	
	};
}	

	
template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Lcm
	{	
	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
	static const intmax_t value = (_Ax / _Gx) * _Bx;
	};

	
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	struct common_type<
		chrono::duration<_Rep1, _Period1>,
		chrono::duration<_Rep2, _Period2> >
	{	
	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
		ratio<_Gcd<_Period1::num, _Period2::num>::value,
			_Lcm<_Period1::den, _Period2::den>::value> > type;
	};

template<class _Clock,
	class _Duration1,
	class _Duration2>
	struct common_type<
		chrono::time_point<_Clock, _Duration1>,
		chrono::time_point<_Clock, _Duration2> >
	{	
	typedef chrono::time_point<
		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
	};

namespace chrono {
	
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type
		operator+(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_CD(_Left).count() + _CD(_Right).count()));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type
		operator-(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_CD(_Left).count() - _CD(_Right).count()));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2> inline
	constexpr typename enable_if<is_convertible<_Rep2,
		typename common_type<_Rep1, _Rep2>::type>::value,
		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
		operator*(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	
	typedef typename common_type<_Rep1, _Rep2>::type _CR;
	typedef duration<_CR, _Period1> _CD;
	return (_CD(_CD(_Left).count() * _Right));
	}

template<class _Rep1,
	class _Rep2,
	class _Period2> inline
	constexpr typename enable_if<is_convertible<_Rep1,
		typename common_type<_Rep1, _Rep2>::type>::value,
		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
		operator*(
			const _Rep1& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	return (_Right * _Left);
	}

template<class _CR,
	class _Period1,
	class _Rep2,
	bool = is_convertible<_Rep2, _CR>::value>
	struct _Duration_div_mod1
	{	
	typedef duration<_CR, _Period1> type;
	};

template<class _CR,
	class _Period1,
	class _Rep2>
	struct _Duration_div_mod1<_CR, _Period1, _Rep2, false>
	{	
	};

template<class _Rep1,
	class _Period1,
	class _Rep2,
	bool = _Is_duration<_Rep2>::value>
	struct _Duration_div_mod
	{	
	};

template<class _Rep1,
	class _Period1,
	class _Rep2>
	struct _Duration_div_mod<_Rep1, _Period1, _Rep2, false>
		: _Duration_div_mod1<typename common_type<_Rep1, _Rep2>::type,
			_Period1, _Rep2>
	{	
	};

template<class _Rep1,
	class _Period1,
	class _Rep2> inline
	typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
		constexpr operator/(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	
	typedef typename common_type<_Rep1, _Rep2>::type _CR;
	typedef duration<_CR, _Period1> _CD;
	return (_CD(_CD(_Left).count() / _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<_Rep1, _Rep2>::type
		operator/(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_Left).count() / _CD(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2> inline
	constexpr typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
		operator%(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	
	typedef typename common_type<_Rep1, _Rep2>::type _CR;
	typedef duration<_CR, _Period1> _CD;
	return (_CD(_CD(_Left).count() % _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
		operator%(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_CD(_Left).count() % _CD(_Right).count()));
	}

	
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator==(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type _CT;
	return (_CT(_Left).count() == _CT(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator!=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator<(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type _CT;
	return (_CT(_Left).count() < _CT(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator<=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator>(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator>=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	
template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		_To>::type
		duration_cast(const duration<_Rep, _Period>& _Dur)
	{	
	typedef ratio_divide<_Period, typename _To::period> _CF;

	typedef typename _To::rep _ToRep;
	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
	return (_CF::num == 1 && _CF::den == 1
			? _To(static_cast<_ToRep>(_Dur.count()))
		: _CF::num != 1 && _CF::den == 1
			? _To(static_cast<_ToRep>(
				static_cast<_CR>(
					_Dur.count()) * static_cast<_CR>(_CF::num)))
		: _CF::num == 1 && _CF::den != 1
			? _To(static_cast<_ToRep>(
				static_cast<_CR>(_Dur.count())
					/ static_cast<_CR>(_CF::den)))
		: _To(static_cast<_ToRep>(
			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
				/ static_cast<_CR>(_CF::den))));
	}

	
typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<int, ratio<60> > minutes;
typedef duration<int, ratio<3600> > hours;

	
template<class _Clock,
	class _Duration,
	class _Rep,
	class _Period> inline
	constexpr time_point<_Clock,
		typename common_type<_Duration, duration<_Rep, _Period> >::type>
		operator+(
			const time_point<_Clock, _Duration>& _Left,
			const duration<_Rep, _Period>& _Right)
	{	
	typedef time_point<_Clock, typename common_type<
		_Duration, duration<_Rep, _Period> >::type> _RT;
	return (_RT(_Left.time_since_epoch() + _Right));
	}

template<class _Rep,
	class _Period,
	class _Clock,
	class _Duration> inline
	constexpr time_point<_Clock,
		typename common_type<duration<_Rep, _Period>, _Duration>::type>
		operator+(
			const duration<_Rep, _Period>& _Left,
			const time_point<_Clock, _Duration>& _Right)
	{	
	return (_Right + _Left);
	}

template<class _Clock,
	class _Duration,
	class _Rep,
	class _Period> inline
	constexpr time_point<_Clock,
		typename common_type<_Duration, duration<_Rep, _Period> >::type>
		operator-(
			const time_point<_Clock, _Duration>& _Left,
			const duration<_Rep, _Period>& _Right)
	{	
	return (_Left + (-_Right));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr typename common_type<_Duration1, _Duration2>::type
		operator-(
			const time_point<_Clock, _Duration1>& _Left,
			const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Left.time_since_epoch() - _Right.time_since_epoch());
	}

	
template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator==(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Left.time_since_epoch() == _Right.time_since_epoch());
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator!=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator<(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Left.time_since_epoch() < _Right.time_since_epoch());
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator<=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator>(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator>=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	
template<class _To,
	class _Clock,
	class _Duration> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		time_point<_Clock, _To> >::type
		time_point_cast(const time_point<_Clock, _Duration>& _Time)
	{	
	return (time_point<_Clock, _To>(
		duration_cast<_To>(_Time.time_since_epoch())));
	}

	
struct system_clock

	{	
	typedef long long rep;

	typedef ratio_multiply<ratio<100, 1>, nano> period;

	typedef chrono::duration<rep, period> duration;
	typedef chrono::time_point<system_clock> time_point;
	static constexpr bool is_steady = false;

	static time_point now() noexcept
		{	
		return (time_point(duration(_Xtime_get_ticks())));
		}

	static __time64_t to_time_t(const time_point& _Time) noexcept
		{	
		return ((__time64_t)(_Time.time_since_epoch().count()
			/ (long long)10000000));
		}

	static time_point from_time_t(__time64_t _Tm) noexcept
		{	
		return (time_point(duration(_Tm * (long long)10000000)));
		}
	};

struct steady_clock
	{	
	typedef long long rep;
	typedef nano period;
	typedef nanoseconds duration;
	typedef chrono::time_point<steady_clock> time_point;
	static constexpr bool is_steady = true;

	static time_point now() noexcept
		{	
		static const long long _Freq
			= _Query_perf_frequency();	
		const long long _Ctr = _Query_perf_counter();
		static_assert(period::num == 1, "This assumes period::num == 1.");
		const long long _Whole = (_Ctr / _Freq) * period::den;
		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;
		return (time_point(duration(_Whole + _Part)));
		}
	};

typedef steady_clock high_resolution_clock;
}	

	
template<class _Rep,
	class _Period> inline
	xtime _To_xtime(const chrono::duration<_Rep, _Period>& _Rel_time)
	{	
	xtime _Xt;
	if (_Rel_time <= chrono::duration<_Rep, _Period>::zero())
		{	
		_Xt.sec = 0;
		_Xt.nsec = 0;
		}
	else
		{	
		chrono::nanoseconds _T0 =
			chrono::system_clock::now().time_since_epoch();
		_T0 += _Rel_time;
		_Xt.sec = chrono::duration_cast<chrono::seconds>(_T0).count();
		_T0 -= chrono::seconds(_Xt.sec);
		_Xt.nsec = (long)_T0.count();
		}
	return (_Xt);
	}

	
inline namespace literals {
inline namespace chrono_literals {
inline constexpr chrono::hours operator "" h(unsigned long long _Val)
	{	
	return (chrono::hours(_Val));
	}

inline constexpr chrono::duration<double, ratio<3600> > operator "" h(
	long double _Val)
	{	
	return (chrono::duration<double, ratio<3600> >(_Val));
	}

inline constexpr chrono::minutes (operator "" min)(unsigned long long _Val)
	{	
	return (chrono::minutes(_Val));
	}

inline constexpr chrono::duration<double, ratio<60> > (operator "" min)(
	long double _Val)
	{	
	return (chrono::duration<double, ratio<60> >(_Val));
	}

inline constexpr chrono::seconds operator "" s(unsigned long long _Val)
	{	
	return (chrono::seconds(_Val));
	}

inline constexpr chrono::duration<double> operator "" s(long double _Val)
	{	
	return (chrono::duration<double>(_Val));
	}

inline constexpr chrono::milliseconds operator "" ms(unsigned long long _Val)
	{	
	return (chrono::milliseconds(_Val));
	}

inline constexpr chrono::duration<double, milli> operator "" ms(
	long double _Val)
	{	
	return (chrono::duration<double, milli>(_Val));
	}

inline constexpr chrono::microseconds operator "" us(unsigned long long _Val)
	{	
	return (chrono::microseconds(_Val));
	}

inline constexpr chrono::duration<double, micro> operator "" us(
	long double _Val)
	{	
	return (chrono::duration<double, micro>(_Val));
	}

inline constexpr chrono::nanoseconds operator "" ns(unsigned long long _Val)
	{	
	return (chrono::nanoseconds(_Val));
	}

inline constexpr chrono::duration<double, nano> operator "" ns(
	long double _Val)
	{	
	return (chrono::duration<double, nano>(_Val));
	}
}	
}	

namespace chrono {
	using namespace literals::chrono_literals;
}	
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 855 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"
#line 856 "H:\\Visual Studio\\VC\\INCLUDE\\chrono"





#line 4 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\graphics.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"
#pragma once

















#line 20 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"








#line 29 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"











#line 41 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"





















#line 1 "I:\\Dev\\Motors\\pikkumoottori\\inc\\vec2.h"
#pragma once



 struct Vec2
{
float x;
float y;

 Vec2& operator+=(const Vec2& rhs);
 Vec2& operator-=(const Vec2& rhs);
 friend Vec2 operator+(Vec2 lhs, const Vec2& rhs);
 friend Vec2 operator-(Vec2 lhs, const Vec2& rhs);



 Vec2& operator*=(const float s);
 Vec2& operator*=(const int s);
 Vec2& operator/=(const float s);
 Vec2& operator/=(const int s);

 Vec2 operator*(const float s);
 Vec2 operator*(const int s);

 Vec2 operator/(const float s);
 Vec2 operator/(const int s);

 float length();

 void normalizeInPlace();
 void safeNormalizeInPlace();
 Vec2 normalize();
};


static Vec2 rotateVec(Vec2* vec, float theta)
{
float cs = cos(theta);
float sn = sin(theta);

float x = vec->x * cs - vec->y * sn;
float y = vec->x * sn + vec->y * cs;

return 	{ x, y };
}

Vec2 Vec2::operator/(const float s)
{
return { x / s, y / s };
}

Vec2 Vec2::operator/(const int s)
{
return { x / s, y / s };
}

Vec2 Vec2::operator*(const float s)
{
return { x * s, y * s };
}

Vec2 Vec2::operator*(const int s)
{
return { x * s, y * s };
}


void Vec2::normalizeInPlace()
{
float x = (this->x);
float y = (this->y);
float l = sqrt(x * x + y * y);

this->x /= l;
this->y /= l;
}

void Vec2::safeNormalizeInPlace()
{
	if (this->x == 0.f && this->y == 0.f)
		return;

	float x = (this->x);
	float y = (this->y);
	float l = sqrt(x * x + y * y);

	this->x /= l;
	this->y /= l;
}

Vec2 Vec2::normalize()
{
	float x = (this->x);
	float y = (this->y);
	float l = sqrt(x * x + y * y);

	return { x / l, y / l };
}

Vec2& Vec2::operator+=(const Vec2& rhs)
{
	x += rhs.x;		y += rhs.y;
	return *this;
}

Vec2& Vec2::operator-=(const Vec2& rhs)
{
	x -= rhs.x;		y -= rhs.y;
	return *this;
}

Vec2 operator+(Vec2 lhs, const Vec2& rhs)
{
	return { lhs.x + rhs.x, lhs.y + rhs.y };
}

Vec2 operator-(Vec2 lhs, const Vec2& rhs)
{
	return { lhs.x - rhs.x, lhs.y - rhs.y };
}



Vec2& Vec2::operator*=(const float s)
{
	x *= s;
	y *= s;
	return *this;
}

Vec2& Vec2::operator*=(const int s)
{
	x *= s;
	y *= s;
	return *this;
}
Vec2& Vec2::operator/=(const float s)
{
	x /= s;
	y /= s;
	return *this;
}

Vec2& Vec2::operator/=(const int s)
{
	x /= s;
	y /= s;
	return *this;
}

float Vec2::length()
{
	float x = abs(this->x);
	float y = abs(this->y);
	return sqrt(x * x + y * y);
}

#line 63 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"
#line 1 "I:\\Dev\\Motors\\pikkumoottori\\inc\\vec3.h"
#pragma once 

 struct vec3
{
	float x;
	float y; float z;


	 vec3& operator+=(const vec3& rhs);
	 vec3& operator-=(const vec3& rhs);
	 friend vec3 operator+(const vec3& lhs, const vec3& rhs);
	 vec3 operator/(const float s);
	 vec3 operator/(const int s);

	 friend vec3 operator-(vec3 lhs, const vec3& rhs);


	 float operator*(const vec3& rhs);

	 vec3 operator*(const float s);
	 vec3 operator*(const int s);
	void normalizeInPlace();
	vec3 normalize() const;
};

float vec3::operator*(const vec3& rhs)
{
	return x * rhs.x + y * rhs.y + z * rhs.z;
}

vec3 operator-(vec3 lhs, const vec3& rhs)
{
	return { lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z };
}

vec3 vec3::operator/(const float s)
{
	return { x / s, y / s, z / s };
}

vec3 vec3::operator/(const int s)
{
	return { x / s, y / s, z / s };
}


vec3& vec3::operator+=(const vec3& rhs)
{
	x += rhs.x;
	y += rhs.y;
	z += rhs.z;
	return *this;
}

vec3& vec3::operator-=(const vec3& rhs)
{
	x -= rhs.x;
	y -= rhs.y;
	z -= rhs.z;
	return *this;
}

void vec3::normalizeInPlace()
{
	float x = (this->x);
	float y = (this->y);
	float z = (this->z);
	float l = sqrt(x * x + y * y + z * z);

	if (l != 0)
	{
		this->x /= l;
		this->y /= l;
		this->z /= l;
	}
}

vec3 vec3::normalize() const
{
	float x = (this->x);
	float y = (this->y);
	float z = (this->z);
	float l = sqrt(x * x + y * y + z * z);

	if (l != 0)
	{
		x /= l;
		y /= l;
		z /= l;
		return { x, y, z };
	}
	return { 0.f, 0.f, 0.f };
}

inline vec3 operator+(const vec3 & lhs, const vec3 & rhs)
{
	return { lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z };
}

vec3 vec3::operator*(const float s)
{
	return { x * s, y * s, z * s };
}
vec3 vec3::operator*(const int s)
{
	return { x * s, y * s, z * s };
}

#line 64 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"
#line 1 "I:\\Dev\\Motors\\pikkumoottori\\inc\\vec4.h"
#pragma once 

 struct vec4
{
    float x;
    float y;
    float w;
    float h;
};
#line 65 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"



#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics/graphicsF.h"
#pragma once

struct CameraState
{
	Vec2  position;
	float scale;
	bool needUpdate;
};

struct Sprites
{
	Vec2* positions;
	Vec2* sizes;
	vec4* uvs;
	vec4* colors;
	int* ids;
	float* rotation;

	unsigned int count;
	
};


struct GraphicsContext
{
	bool initted;
	bool updateViewPort;
	CameraState camera;
	Sprites sprites;
	void* window;
};

void zoom(CameraState* camera, float factor)
{
	camera->scale += factor;
	camera->needUpdate = true;
	if (camera->scale < 0.01f)
		camera->scale = 0.02f;

}

void translate(CameraState* camera, const Vec2& position)
{
	camera->needUpdate = true;
	camera->position += position;
}




#line 69 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../platform.h"

struct Controller
{
	enum CameraKeys
	{
		w, a, s, d, ctrl, q, e,
		size,
	};

	bool jump;
	bool cameraMovement[size];
};

struct EngineContext
{
	float dt;
	Controller controller;
	GraphicsContext context;
	void* imguiContext;

	Vec2 windowDims;
};


typedef void init_game(EngineContext* engine);


typedef void update_Game(EngineContext* engine);


typedef void draw_Game(EngineContext* engine);

#line 5 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\graphics.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\shader.cpp"
#line 1 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"
#pragma once
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\string"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\ios"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

#pragma once







#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

#pragma once





#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\exception"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {

  


  



  




  


  #line 32 "H:\\Visual Studio\\VC\\INCLUDE\\exception"
}

 

#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {





    


#line 24 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"















typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;








   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 68 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    #line 72 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 84 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"

    typedef char __static_assert_t[(sizeof(unsigned int) <= 16) != 0];


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 110 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"
















    
    







#line 136 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"




#line 141 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"
#line 142 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                ((void)0);
            }
            #line 164 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 169 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"




    
#line 175 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\malloc.h"



} __pragma(pack(pop))
#line 37 "H:\\Visual Studio\\VC\\INCLUDE\\exception"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_exception.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\eh.h"







#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_terminate.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 40 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_terminate.h"

#line 42 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 46 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_terminate.h"
#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\eh.h"



__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;


    
    __declspec(dllimport) __declspec(noreturn) void __cdecl unexpected() throw(...);

    

        __declspec(dllimport) unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) throw();

        __declspec(dllimport) unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

        __declspec(dllimport) _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 48 "H:\\Visual Studio\\VC\\INCLUDE\\eh.h"

    class type_info;

    __declspec(dllimport) int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

    __declspec(dllimport) bool __cdecl __uncaught_exception();
    __declspec(dllimport) int  __cdecl __uncaught_exceptions();

#line 60 "H:\\Visual Studio\\VC\\INCLUDE\\eh.h"

} __pragma(pack(pop))

#line 64 "H:\\Visual Studio\\VC\\INCLUDE\\eh.h"
#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_exception.h"





#pragma pack(push, 8)


__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

__declspec(dllimport) void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

__declspec(dllimport) void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

class exception
{
public:

    exception()
        : _Data()
    {
    }

    explicit exception(char const* const _Message)
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int)
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other)
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other)
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

} 

#line 142 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_exception.h"
#pragma pack(pop)





#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\exception"

namespace std {

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);

__declspec(dllimport) bool __cdecl uncaught_exception() noexcept;
__declspec(dllimport) int __cdecl uncaught_exceptions() noexcept;


inline terminate_handler __cdecl get_terminate()
	{	
	return (_get_terminate());
	}

inline unexpected_handler __cdecl get_unexpected()
	{	
	return (_get_unexpected());
	}
#line 59 "H:\\Visual Studio\\VC\\INCLUDE\\exception"

}

 






































































































































































#line 230 "H:\\Visual Studio\\VC\\INCLUDE\\exception"









#line 240 "H:\\Visual Studio\\VC\\INCLUDE\\exception"

__declspec(dllimport) void __cdecl __ExceptionPtrCreate(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(  void*,   const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(  void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(  void*,   void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr() throw ()
		{
		__ExceptionPtrCreate(this);
		}

	exception_ptr(nullptr_t) throw ()
		{
		__ExceptionPtrCreate(this);
		}

	~exception_ptr() throw ()
		{
		__ExceptionPtrDestroy(this);
		}

	exception_ptr(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}

	exception_ptr& operator=(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}

	exception_ptr& operator=(nullptr_t) throw ()
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	typedef exception_ptr _Myt;

	explicit operator bool() const throw ()
		{
		return __ExceptionPtrToBool(this);
		}

	void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception() throw ()
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}

	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}

private:
	void* _Data1;
	void* _Data2;
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) throw ()
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

inline bool operator==(nullptr_t, const exception_ptr& _Rhs) throw ()
	{
	return !_Rhs;
	}

inline bool operator==(const exception_ptr& _Lhs, nullptr_t) throw ()
	{
	return !_Lhs;
	}

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline exception_ptr current_exception() noexcept
	{
	return exception_ptr::_Current_exception();
	}

inline void rethrow_exception(  exception_ptr _Ptr)
	{
	_Ptr._RethrowException();
	}

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> exception_ptr make_exception_ptr(_Ex _Except)
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}

	
class nested_exception
	{	
public:
	nested_exception() noexcept
		: _Exc(::std:: current_exception())
		{	
		}

	nested_exception(const nested_exception&) noexcept = default;
	nested_exception& operator=(const nested_exception&) noexcept = default;
	virtual ~nested_exception() noexcept = default;

	__declspec(noreturn) void rethrow_nested() const
		{	
		if (_Exc)
			::std:: rethrow_exception(_Exc);
		else
			::std:: terminate();
		}

	::std:: exception_ptr nested_ptr() const noexcept
		{	
		return (_Exc);
		}

private:
	::std:: exception_ptr _Exc;
	};

	
template<class _Ty,
	class _Uty>
	struct _With_nested
		: _Uty, nested_exception
	{	
	explicit _With_nested(_Ty&& _Arg)
		: _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
		{	
		}
	};

template<class _Ty> inline
	__declspec(noreturn) void _Throw_with_nested(_Ty&& _Arg, true_type)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;
	typedef _With_nested<_Ty, _Uty> _Glued;

	throw _Glued(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty> inline
	__declspec(noreturn) void _Throw_with_nested(_Ty&& _Arg, false_type)
	{	
	typedef typename decay<_Ty>::type _Decayed;

	throw _Decayed(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty> inline
	__declspec(noreturn) void throw_with_nested(_Ty&& _Arg)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;

	integral_constant<bool,
		is_class<_Uty>::value
		&& !is_base_of<nested_exception, _Uty>::value
		&& !is_final<_Uty>::value> _Tag;

	_Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
	}

	
template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
	{	
	const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

	if (_Nested)
		_Nested->rethrow_nested();
	}

template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *, false_type)
	{	
	}

template<class _Ty> inline
	void rethrow_if_nested(const _Ty& _Arg)
	{	
	integral_constant<bool,
		is_polymorphic<_Ty>::value
		&& (!is_base_of<nested_exception, _Ty>::value
			|| is_convertible<_Ty *, nested_exception *>::value)> _Tag;

	_Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 482 "H:\\Visual Studio\\VC\\INCLUDE\\exception"
#line 483 "H:\\Visual Studio\\VC\\INCLUDE\\exception"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cstdint"

#pragma once










 
#line 15 "H:\\Visual Studio\\VC\\INCLUDE\\cstdint"

 
namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;

	namespace tr1 {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
	}	
}
 #line 57 "H:\\Visual Studio\\VC\\INCLUDE\\cstdint"

#line 59 "H:\\Visual Studio\\VC\\INCLUDE\\cstdint"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\new"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 

  



namespace std {

		
 

typedef void (__cdecl * new_handler) ();
 #line 24 "H:\\Visual Studio\\VC\\INCLUDE\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(  new_handler)
	noexcept;	

__declspec(dllimport) new_handler __cdecl get_new_handler()
	noexcept;	
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\new"
#line 39 "H:\\Visual Studio\\VC\\INCLUDE\\new"





#line 10 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

 












#line 32 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
  
 #line 34 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
	{	
	void _Orphan_all()
		{	
		}

	void _Swap_all(_Container_base0&)
		{	
		}
	};

struct _Iterator_base0
	{	
	void _Adopt(const void *)
		{	
		}

	const _Container_base0 *_Getcont() const
		{	
		return (0);
		}
	};

		
struct _Container_proxy
	{	
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _Container_base12
	{	
public:
	_Container_base12()
		: _Myproxy(0)
		{	
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	
		}

	_Container_base12& operator=(const _Container_base12&)
		{	
		return (*this);
		}

	~_Container_base12() noexcept
		{	
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	
	void _Swap_all(_Container_base12&);	

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	
 


#line 135 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
			}
		return (*this);
		}

	~_Iterator_base12() noexcept
		{	
 


#line 145 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	
		if (_Parent == 0)
			{	
 


#line 155 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
			}
		else
			{	
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 









#line 171 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
			_Myproxy = _Parent_proxy;
 #line 173 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
			}
		}

	void _Clrcont()
		{	
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	
 











#line 206 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		
inline void _Container_base12::_Orphan_all()
	{	
 









#line 226 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	
 

#line 233 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 
typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;

 


#line 252 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

	
struct _Zero_then_variadic_args_t
	{	
	};	

struct _One_then_variadic_args_t
	{	
	};	

template<class _Ty1,
	class _Ty2,
	bool = is_empty<_Ty1>::value && !is_final<_Ty1>::value>
	class _Compressed_pair final
		: private _Ty1

	{	
private:
	_Ty2 _Myval2;

	typedef _Ty1 _Mybase;	

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Ty1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (*this);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (*this);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (*this);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (*this);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

template<class _Ty1,
	class _Ty2>
	class _Compressed_pair<_Ty1, _Ty2, false> final

	{	
private:
	_Ty1 _Myval1;
	_Ty2 _Myval2;

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Myval1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (_Myval1);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (_Myval1);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (_Myval1);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (_Myval1);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

		

		
 


		
template<class _Ty>
	struct _Get_unchecked_type
		{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 412 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _Ty,
	class = void>
	struct _Is_checked_helper
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_checked_helper<_Ty, typename _Param_tester<
		typename _Ty::_Unchecked_type>::type>
		: true_type
	{	
	};

		
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	
	return (typename _Is_checked_helper<_Iter>::type());
	}

		
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	
	return (_Src);
	}

		
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	
	_Dest = _Src;
	return (_Dest);
	}

		
		
struct input_iterator_tag
	{	
	};

struct _Mutable_iterator_tag
	{	
	};

struct output_iterator_tag
	: _Mutable_iterator_tag
	{	
	};

struct forward_iterator_tag
	: input_iterator_tag, _Mutable_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	
	};

		
struct _Nonscalar_ptr_iterator_tag
	{	
	};
struct _Scalar_ptr_iterator_tag
	{	
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;

		
template<class,
	class = void>
	struct _Is_iterator
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_iterator<_Ty, typename _Param_tester<
		typename _Ty::iterator_category,
		typename _Ty::value_type,
		typename _Ty::difference_type,
		typename _Ty::pointer,
		typename _Ty::reference
		>::type>
		: true_type
	{	
	};

template<class _Ty>
	struct _Is_iterator<_Ty *>
		: true_type
	{	
	};

		
template<class _Iter,
	bool = _Is_iterator<_Iter>::value>
	struct _Iterator_traits_base
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;

	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Iter>
	struct _Iterator_traits_base<_Iter, false>
	{	
	};

template<class _Iter>
	struct iterator_traits
		: _Iterator_traits_base<_Iter>
	{	
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		_Iter_cat(const _Iter&)
	{	
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		
template<class _Iter1,
	class _Iter2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)
	{	
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2>
	struct _Ptr_cat_helper
	{	
	typedef _Nonscalar_ptr_iterator_tag type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	
	typedef typename _If<is_scalar<_Elem>::value,
		_Scalar_ptr_iterator_tag,
		_Nonscalar_ptr_iterator_tag>::type type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	
	typedef _Scalar_ptr_iterator_tag type;
	};

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(_Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(const _Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

		

 
  
  
  
  
  
  
  
  
  
  

 






































































































































































































#line 868 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
		

template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	
 


#line 887 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FwdIt,
	class _Diff> inline
	void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
	{	
 


#line 900 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

		

template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		*_Dist_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	
 





#line 978 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		distance(_InIt _First, _InIt _Last)
	{	
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	_FwdIt next(_FwdIt _First,
		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
	{	
	static_assert(is_base_of<forward_iterator_tag,
		typename iterator_traits<_FwdIt>::iterator_category>::value,
		"next requires forward iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		
template<class _BidIt> inline
	_BidIt prev(_BidIt _First,
		typename iterator_traits<_BidIt>::difference_type _Off = 1)
	{	
	static_assert(is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value,
		"prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}

		
template<class _Ty>
	struct pointer_traits;

template<class _RanIt>
	class reverse_iterator
		: public iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference>
	{	
	typedef reverse_iterator<_RanIt> _Myt;

public:
	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		: current()
		{	
		}

	explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

protected:
	_RanIt current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> operator+(
		typename reverse_iterator<_RanIt>::difference_type _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left.base() == _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right.base() < _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
	{	
	return (reverse_iterator<_RanIt>(_Iter));
	}

		

template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array + _Size);
	}

		
template<class _Container>
	constexpr auto inline cbegin(const _Container& _Cont)
		noexcept(noexcept(::std:: begin(_Cont)))
		-> decltype(::std:: begin(_Cont))
	{	
	return (::std:: begin(_Cont));
	}

template<class _Container>
	constexpr auto inline cend(const _Container& _Cont)
		noexcept(noexcept(::std:: end(_Cont)))
		-> decltype(::std:: end(_Cont))
	{	
	return (::std:: end(_Cont));
	}

		
template<class _Container>
	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Container>
	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rbegin(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rend(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		
template<class _Container>
	auto inline crbegin(const _Container& _Cont)
		-> decltype(::std:: rbegin(_Cont))
	{	
	return (::std:: rbegin(_Cont));
	}

template<class _Container>
	auto inline crend(const _Container& _Cont)
		-> decltype(::std:: rend(_Cont))
	{	
	return (::std:: rend(_Cont));
	}


template<class _Container>
	constexpr auto inline size(const _Container& _Cont)
		-> decltype(_Cont.size())
	{	
	return (_Cont.size());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr size_t size(const _Ty(&)[_Size]) noexcept
	{	
	return (_Size);
	}

template<class _Container>
	constexpr auto inline empty(const _Container& _Cont)
		-> decltype(_Cont.empty())
	{	
	return (_Cont.empty());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr bool empty(const _Ty(&)[_Size]) noexcept
	{	
	return (false);
	}

template<class _Elem> inline
	constexpr bool empty(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.size() == 0);
	}

template<class _Container>
	constexpr auto inline data(_Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Container>
	constexpr auto inline data(const _Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Elem> inline
	constexpr const _Elem *data(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	
 
	_Array_const_iterator()
		{	
		_Ptr = 0;
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		{	
		_Ptr = _Parg + _Off;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr);
		}

	reference operator*() const
		{	
		return (*_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

	pointer _Ptr;	

 








































































































































































































#line 1759 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	
		}
	enum {_EEN_SIZE = _Size};	
	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _RanIt>
	class move_iterator
	{	
public:
	typedef move_iterator<_RanIt> _Myt;
	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef value_type&& reference;
	typedef _RanIt iterator_type;

	move_iterator()
		: current()
		{	
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		return (::std:: move(*current));
		}

	pointer operator->() const
		{	
		return (current);
		}

	_Myt& operator++()
		{	
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (::std:: move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (current - _Right.base());
		}

protected:
	iterator_type current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	
	return (move_iterator<_RanIt>(_Iter));
	}

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Rechecked(_Dest,
		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 





























































#line 2246 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	*_Dest = *_First;	
	while (0 < --_Count)
		*++_Dest = *++_First;
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Rechecked(_Dest,
			_Copy_n(_Unchecked(_First), _Count,
				_Unchecked(_Dest))));
	}

 























































































































#line 2437 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Copy_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Rechecked(_Dest,
		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 




























#line 2510 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Move(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Rechecked(_Dest,
		_Move(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 





























































#line 2616 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Move_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Rechecked(_Dest,
		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 




























#line 2689 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _FwdIt,
	class _Ty> inline
	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void _Fill(char *_First, char *_Last, char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	;
	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
	signed char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
	unsigned char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

 
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
	}

 






























































#line 2826 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

inline bool _Equal(const char *_First1, const char *_Last1,
	const char *_First2, equal_to<>)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
	const signed char *_First2, equal_to<>)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, equal_to<>)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

 
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred));
	}

 













































#line 2916 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}

 









#line 2938 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
			input_iterator_tag, input_iterator_tag)
	{	
		
	;
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
			random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	;
	return (_Equal(_First1, _Last1, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Iter_cat(_First1), _Iter_cat(_First2)));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: equal(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (((*_First1) < (*_First2)))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool _Lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
	}

 









#line 3027 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	;
	;
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{	
		if (_Pred(*_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
		}
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	;
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
	{	
	return ((-128) <= _Val && _Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	
	return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	
	return (_Val <= 127);
	}

template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
	{	
	return (0 <= _Val && _Val <= 0xff);
	}

template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
	{	
	return (_Val <= 0xff);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	
	typedef typename remove_pointer<_InIt>::type _Elem;
	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
	{	
	if (!_Within_limits(_First, _Val))
		return (_Last);
	_First = static_cast<_InIt>(:: memchr(
		_First, static_cast<unsigned char>(_Val), _Last - _First));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	
	typedef integral_constant<bool,
		(is_same<_InIt, char *>::value
		|| is_same<_InIt, signed char *>::value
		|| is_same<_InIt, unsigned char *>::value
		|| is_same<_InIt, const char *>::value
		|| is_same<_InIt, const signed char *>::value
		|| is_same<_InIt, const unsigned char *>::value)
		&& is_integral<_Ty>::value
	> _Memchr_opt;
	return (_Find(_First, _Last, _Val, _Memchr_opt()));
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	;
	return (_Rechecked(_First,
		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	;
	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
		forward_iterator_tag, forward_iterator_tag)
	{	
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	
	
	while (_Pred(*--_Last1, *--_Last2))
		;	
	++_Last1;
	++_Last2;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Trim_matching_suffixes(_Last1, _Last2, _Pred,
		_Iter_cat(_Last1), _Iter_cat(_Last2));
	typedef typename iterator_traits<_FwdIt1>::difference_type _Diff1;
	typedef typename iterator_traits<_FwdIt2>::difference_type _Diff2;
	for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
		if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
			{	
			_Diff2 _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
			if (_Count2 == 0)
				return (false);	
			_FwdIt1 _Skip1 = ::std:: next(_Next1);
			_Diff1 _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
			if (_Count2 != _Count1)
				return (false);	
			}
	return (true);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			_FwdIt2 _Last2 = ::std:: next(_First2,
				::std:: distance(_First1, _Last1));
			return (_Check_match_counts(_First1, _Last1,
				_First2, _Last2, _Pred));
			}
	return (true);
	}

 
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred));
	}

 















































#line 3340 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}


 








#line 3362 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	
		
	;
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			if (::std:: distance(_First1, _Last1)
				!= ::std:: distance(_First2, _Last2))
				return (false);	
			else
				return (_Check_match_counts(_First1, _Last1,
					_First2, _Last2, _Pred));
			}
	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	;
	return (_Is_permutation(_First1, _Last1, _First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
		
	;
	;
	return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, _Last2, equal_to<>()));
	}

		
template<class _BidIt> inline
	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		::std:: iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	;
	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	_FwdIt _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid, _Res = _Last; ; )
		{	
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			{	
			if (++_Next == _Last)
				return (_Res == _Last ? _Mid : _Res);
			else
				_Mid = _Next;	
			}
		else if (++_Next == _Last)
			{	
			if (_Res == _Last)
				_Res = _First;
			_Next = _Mid;
			}
		}
	}

template<class _BidIt> inline
	pair<_BidIt, _BidIt> _Reverse_until_sentinel(
		_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
	{	
	while (_First != _Sentinel && _Last != _Sentinel)
		::std:: iter_swap(_First++, --_Last);
	return (::std:: make_pair(_First, _Last));
	}

template<class _BidIt> inline
	_BidIt _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	::std:: reverse(_First, _Mid);
	::std:: reverse(_Mid, _Last);
	pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel(_First, _Mid, _Last);
	::std:: reverse(_Tmp.first, _Tmp.second);
	return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
	}

template<class _RanIt> inline
	_RanIt _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	
	::std:: reverse(_First, _Mid);
	::std:: reverse(_Mid, _Last);
	::std:: reverse(_First, _Last);
	return (_First + (_Last - _Mid));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	;
	;
	if (_First == _Mid)
		return (_Last);
	if (_Mid == _Last)
		return (_First);
	_Rechecked(_First, _Rotate(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Last), _Iter_cat(_First)));
	return (_First);
	}

	
template<class _Diff,
	class _Urng>
	class _Rng_from_urng
	{	
public:
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;


	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	
		for (; ; )
			{	
			_Udiff _Ret = 0;	
			_Udiff _Mask = 0;	

			while (_Mask < _Udiff(_Index - 1))
				{	
				_Ret <<= _Bits - 1;	
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	
			_Ret <<= _Bits - 1;	
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
	_Udiff _Get_bits()
		{	
		for (; ; )
			{	
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	
	size_t _Bits;	
	_Udiff _Bmask;	
	};

		
template<class _Elem>
	class __declspec(dllimport) _Yarn
	{	
public:
	typedef _Yarn<_Elem> _Myt;

	 _Yarn()
		: _Myptr(0), _Nul(0)
		{	
		}

	 _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	 _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (*this = _Right._Myptr);
		}

	_Myt&  operator=(const _Elem *_Right)
		{	
		if (_Myptr != _Right)
			{	
			_Tidy();

			if (_Right != 0)
				{	
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 




				_Myptr = (_Elem *):: malloc(_Count);
 #line 3635 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

				if (_Myptr != 0)
					:: memcpy(_Myptr, _Right, _Count);
				}
			}
		return (*this);
		}

	 ~_Yarn() noexcept
		{	
		_Tidy();
		}

	bool  empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * _C_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	
		if (_Myptr != 0)

 



			:: free(_Myptr);
 #line 3679 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"

		_Myptr = 0;
		}

	_Elem *_Myptr;	
	_Elem _Nul;		
	};

	
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		
struct allocator_arg_t
	{	
	};

constexpr allocator_arg_t allocator_arg{};

__declspec(dllimport) __declspec(noreturn) void __cdecl _Xbad_alloc();
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xlength_error(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xout_of_range(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error(  const char *);
}

namespace std {
		
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	
	};
}	
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3731 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"
#line 3732 "H:\\Visual Studio\\VC\\INCLUDE\\xutility"






#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 

  
   

  

#line 25 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"
 #line 26 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

 #pragma warning(disable: 4100)

namespace std {



 




 #line 39 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

 









		
template<class _Ty> inline
	__declspec(allocator) _Ty *_Allocate(size_t _Count, _Ty *,
		bool _Try_aligned_allocation = true)
	{	
	void *_Ptr = 0;

	if (_Count == 0)
		return (static_cast<_Ty *>(_Ptr));

	
	if ((size_t)(-1) / sizeof (_Ty) < _Count)
		_Xbad_alloc();	
	const size_t _User_size = _Count * sizeof (_Ty);

 
	if (_Try_aligned_allocation
		&& 4096 <= _User_size)
		{	
		static_assert(sizeof (void *) < 32,
			"Big allocations should at least match vector register size");
		const size_t _Block_size = (sizeof(void *) + 32 - 1) + _User_size;
		if (_Block_size <= _User_size)
			_Xbad_alloc();	
		const uintptr_t _Ptr_container =
			reinterpret_cast<uintptr_t>(::operator new(_Block_size));
		{ if (!(_Ptr_container != 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
		_Ptr = reinterpret_cast<void *>((_Ptr_container + (sizeof(void *) + 32 - 1))
			& ~(32 - 1));
		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

 


		}
	else
 #line 87 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		{	
		_Ptr = ::operator new(_User_size);
		{ if (!(_Ptr != 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
		}
	return (static_cast<_Ty *>(_Ptr));
	}

		
template<class _Ty> inline
	void _Deallocate(_Ty * _Ptr, size_t _Count)
	{	
 
	{ if (!(_Count <= (size_t)(-1) / sizeof (_Ty))) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
	const size_t _User_size = _Count * sizeof (_Ty);
	if (4096 <= _User_size)
		{	
		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
		{ if (!((_Ptr_user & (32 - 1)) == 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 107 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"
		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
		const uintptr_t _Ptr_container =
			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

 







		
		{ if (!(_Ptr_container < _Ptr_user)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

 




		{ if (!(sizeof(void *) <= _Ptr_user - _Ptr_container)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 129 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"
 #line 130 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		{ if (!(_Ptr_user - _Ptr_container <= (sizeof(void *) + 32 - 1))) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 133 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		_Ptr = reinterpret_cast<_Ty *>(_Ptr_container);
		}
 #line 137 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

	::operator delete(_Ptr);
	}

		
template<class _Ty1,
	class _Ty2> inline
	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
	{	
	void *_Vptr = _Ptr;
	::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
	}

template<class _Ty1> inline
	void _Construct(_Ty1 *_Ptr)
	{	
	void *_Vptr = _Ptr;

	::new (_Vptr) _Ty1();
	}

		
template<class _Ty> inline
	void _Destroy(_Ty *_Ptr)
	{	
	_Ptr->~_Ty();
	}

		
template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(::std:: addressof(*_First));
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{	
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al)
	{	
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

		
template<class _Alty>
	struct _Is_simple_alloc
		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
		&& is_same<typename _Alty::pointer,
			typename _Alty::value_type *>::value
		&& is_same<typename _Alty::const_pointer,
			const typename _Alty::value_type *>::value
		&& is_same<typename _Alty::reference,
			typename _Alty::value_type&>::value
		&& is_same<typename _Alty::const_reference,
			const typename _Alty::value_type&>::value>
	{	
	};

		
template<class _Value_type>
	struct _Simple_types
	{	
	typedef _Value_type value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	};

		
template<class _Alty,
	class _Pointer>
	struct _Get_voidptr
	{	
	typedef typename _Alty::template rebind<void>::other _Alvoid;
	typedef typename _Alvoid::pointer type;
	};

template<class _Alty,
	class _Ty>
	struct _Get_voidptr<_Alty, _Ty *>
	{	
	typedef void *type;
	};

		
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...> >
	{	
	typedef _First type;
	};

		
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
	{	
	typedef _Ty<_Newfirst, _Rest...> type;
	};

		
template<class _Ty>
	struct _Get_element_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 265 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_ptr_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 271 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty,
	class _Other>
	struct _Get_rebind_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 278 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct pointer_traits
	{	
	typedef typename _Get_element_type<_Ty>::type element_type;
	typedef _Ty pointer;
	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

	template<class _Other>
		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

	typedef typename _If<is_void<element_type>::value,
		char&,
		typename add_lvalue_reference<element_type>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (_Ty::pointer_to(_Val));
		}
	};

		
template<class _Ty>
	struct pointer_traits<_Ty *>
	{	
	typedef _Ty element_type;
	typedef _Ty *pointer;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		using rebind = _Other *;

	typedef typename _If<is_void<_Ty>::value,
		char&,
		typename add_lvalue_reference<_Ty>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (::std:: addressof(_Val));
		}
	};

		
template<class _Ty>
	struct _Get_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 326 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_const_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 333 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 340 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_const_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 347 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 354 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_size_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 361 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_copy
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 367 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_move
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 373 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_swap
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 379 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
template<class _Ty>
	struct _Get_is_always_equal
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 385 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

		
struct _Alloc_allocate
	{	
		

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer _Hint)
			-> decltype(_Al.allocate(_Count, _Hint))
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(_Wrap_int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer)
			-> decltype(_Al.allocate(_Count))
		{	
		return (_Al.allocate(_Count));
		}
	};

		
struct _Alloc_construct
	{	
		

	template<class _Ty,
		class _Objty,
		class... _Types>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
			_Types&&... _Args)
			-> decltype(
				_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class _Objty,
		class... _Types>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
			_Types&&... _Args)
			-> void
		{	
		::new (static_cast<void *>(_Ptr))
			_Objty(::std:: forward<_Types>(_Args)...);
		}

	};

		
struct _Alloc_destroy
	{	
	template<class _Ty,
		class _Objty>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
			-> decltype(_Al.destroy(_Ptr))
		{	
		_Al.destroy(_Ptr);
		}

	template<class _Ty,
		class _Objty>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
			-> void
		{	
		_Ptr->~_Objty();
		}
	};

		
struct _Alloc_max_size
	{	
	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al) noexcept
			-> decltype(_Al.max_size())
		{	
		return (_Al.max_size());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty&) noexcept
			-> typename _Get_size_type<_Ty>::type
		{	
		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
		}
	};

		
struct _Alloc_select
	{	
		

	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype((_Ty)_Al.select_on_container_copy_construction())
		{	
		return (_Al.select_on_container_copy_construction());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty& _Al)
			-> _Ty
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct allocator_traits
	{	
	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef typename _Get_pointer_type<_Alloc>::type
		pointer;
	typedef typename _Get_const_pointer_type<_Alloc>::type
		const_pointer;
	typedef typename _Get_void_pointer_type<_Alloc>::type
		void_pointer;
	typedef typename _Get_const_void_pointer_type<_Alloc>::type
		const_void_pointer;

	typedef typename _Get_size_type<_Alloc>::type size_type;
	typedef typename _Get_difference_type<_Alloc>::type difference_type;

	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
		propagate_on_container_copy_assignment;
	typedef typename _Get_propagate_on_container_move<_Alloc>::type
		propagate_on_container_move_assignment;
	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
		propagate_on_container_swap;
	typedef typename _Get_is_always_equal<_Alloc>::type
		is_always_equal;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Alloc_construct::_Fn(0, _Al, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	
		_Alloc_destroy::_Fn(0, _Al, _Ptr);
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Alloc_max_size::_Fn(0, _Al));
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Alloc_select::_Fn(0, _Al));
		}
	};

		
template<class _Ty>
	class allocator
	{	
public:
	static_assert(!is_const<_Ty>::value,
		"The C++ Standard forbids containers of const elements "
		"because allocator<const T> is ill-formed.");

	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;

	typedef value_type& reference;
	typedef const value_type& const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef true_type propagate_on_container_move_assignment;
	typedef true_type is_always_equal;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	allocator() noexcept
		{	
		}

	allocator(const allocator<_Ty>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Deallocate(_Ptr, _Count);
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (_Allocate(_Count, (pointer)0));
		}

	__declspec(allocator) pointer allocate(size_type _Count, const void *)
		{	
		return (allocate(_Count));
		}

	template<class _Objty,
		class... _Types>
		void construct(_Objty *_Ptr, _Types&&... _Args)
		{	
		::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		void destroy(_Uty *_Ptr)
		{	
		_Ptr->~_Uty();
		}

	size_t max_size() const noexcept
		{	
		return ((size_t)(-1) / sizeof (_Ty));
		}
	};

		
template<>
	class allocator<void>
	{	
public:
	typedef void value_type;

	typedef void *pointer;
	typedef const void *const_pointer;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() noexcept
		{	
		}

	allocator(const allocator<void>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<void>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) noexcept
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>& _Left,
		const allocator<_Other>& _Right) noexcept
	{	
	return (false);
	}

		
template<class _Ty>
	struct allocator_traits<allocator<_Ty> >
	{	
	typedef allocator<_Ty> _Alloc;

	typedef _Alloc allocator_type;
	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef true_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;
	typedef true_type is_always_equal;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc& _Al, _Objty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		static void destroy(_Alloc& _Al, _Uty *_Ptr)
		{	
		_Al.destroy(_Ptr);
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Al.max_size());
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct _Wrap_alloc
		: public _Alloc
	{	
	typedef _Alloc _Mybase;
	typedef allocator_traits<_Alloc> _Mytraits;

	typedef typename _Mytraits::value_type value_type;

	typedef typename _Mytraits::pointer pointer;
	typedef typename _Mytraits::const_pointer const_pointer;
	typedef typename _Mytraits::void_pointer void_pointer;
	typedef typename _Mytraits::const_void_pointer const_void_pointer;

	typedef typename _If<is_void<value_type>::value,
		int, value_type>::type& reference;
	typedef typename _If<is_void<const value_type>::value,
		const int, const value_type>::type& const_reference;

	typedef typename _Mytraits::size_type size_type;
	typedef typename _Mytraits::difference_type difference_type;

	typedef typename _Mytraits::propagate_on_container_copy_assignment
		propagate_on_container_copy_assignment;
	typedef typename _Mytraits::propagate_on_container_move_assignment
		propagate_on_container_move_assignment;
	typedef typename _Mytraits::propagate_on_container_swap
		propagate_on_container_swap;
	typedef typename _Mytraits::is_always_equal
		is_always_equal;

	_Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
		{	
		return (_Mytraits::select_on_container_copy_construction(*this));
		}

	template<class _Other>
		struct rebind
		{	
		typedef typename _Mytraits::template rebind_alloc<_Other>
			_Other_alloc;
		typedef _Wrap_alloc<_Other_alloc> other;
		};

	pointer address(reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	_Wrap_alloc() noexcept
		: _Mybase()
		{	
		}

	_Wrap_alloc(const _Mybase& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc(const _Wrap_alloc& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(const _Other& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(_Other& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc& operator=(const _Mybase& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	_Wrap_alloc& operator=(const _Wrap_alloc& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	template<class _Other>
		_Wrap_alloc& operator=(const _Other& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (_Mybase::allocate(_Count));
		}

	__declspec(allocator) pointer allocate(size_type _Count,
		const_void_pointer _Hint, _Nil = _Nil())
		{	
		return (_Mytraits::allocate(*this, _Count, _Hint));
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Mybase::deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		void construct(_Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Mytraits::construct(*this, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		void destroy(_Ty *_Ptr)
		{	
		_Mytraits::destroy(*this, _Ptr);
		}

	size_type max_size(_Nil = _Nil()) const noexcept
		{	
		return (_Mytraits::max_size(*this));
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (static_cast<const _Ty&>(_Left)
		== static_cast<const _Other&>(_Right));
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
	{	
	_Left = _Right;
	}

template<class _Alty> inline
	void _Pocca(_Alty&, const _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_copy_assignment _Tag;
	_Pocca(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Left = ::std:: move(_Right);
	}

template<class _Alty> inline
	void _Pocma(_Alty&, _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_move_assignment _Tag;
	_Pocma(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Swap_adl(_Left, _Right);
	}

template<class _Alty> inline
	void _Pocs(_Alty&, _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_swap _Tag;
	_Pocs(_Left, _Right, _Tag);
	}
}

		

  
   #line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xatomic0.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	
	




  
  
  
  
  

  
   

  

#line 45 "H:\\Visual Studio\\VC\\INCLUDE\\xatomic0.h"

		

typedef long _Atomic_flag_t;

  
  
  

		
inline _Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
inline int _Atomic_compare_exchange_weak_4(
	volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
inline _Uint4_t _Atomic_fetch_add_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);
inline _Uint4_t _Atomic_fetch_sub_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);

typedef _Atomic_integral_t _Atomic_counter_t;

  
inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	
	return (_Counter);
	}

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Value)
	{	
	_Counter = _Value;
	}

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
	}

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
	}

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Load_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_load_4(&_Counter, _Order));
	}

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
	_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Expected,
	memory_order _Order)
	{	
	return (_Atomic_compare_exchange_weak_4(
		&_Counter, &_Expected, _Expected + 1,
		_Order, _Order));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter(
	_Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
	{	
	return (_Compare_increment_atomic_counter_explicit(
		_Counter, _Expected, memory_order_seq_cst));
	}

  






























#line 160 "H:\\Visual Studio\\VC\\INCLUDE\\xatomic0.h"

		
extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 171 "H:\\Visual Studio\\VC\\INCLUDE\\xatomic0.h"
#line 172 "H:\\Visual Studio\\VC\\INCLUDE\\xatomic0.h"





#line 1015 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"
   #line 1 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"












#pragma once




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 19 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"







#pragma once


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"









__pragma(pack(push, 8)) extern "C" {
























#line 47 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"

    typedef struct __declspec(align(16)) _SETJMP_FLOAT128
    {
        unsigned __int64 Part[2];
    } SETJMP_FLOAT128;

    
    typedef SETJMP_FLOAT128 _JBTYPE;

    typedef struct _JUMP_BUFFER
    {
        unsigned __int64 Frame;
        unsigned __int64 Rbx;
        unsigned __int64 Rsp;
        unsigned __int64 Rbp;
        unsigned __int64 Rsi;
        unsigned __int64 Rdi;
        unsigned __int64 R12;
        unsigned __int64 R13;
        unsigned __int64 R14;
        unsigned __int64 R15;
        unsigned __int64 Rip;
        unsigned long MxCsr;
        unsigned short FpCsr;
        unsigned short Spare;

        SETJMP_FLOAT128 Xmm6;
        SETJMP_FLOAT128 Xmm7;
        SETJMP_FLOAT128 Xmm8;
        SETJMP_FLOAT128 Xmm9;
        SETJMP_FLOAT128 Xmm10;
        SETJMP_FLOAT128 Xmm11;
        SETJMP_FLOAT128 Xmm12;
        SETJMP_FLOAT128 Xmm13;
        SETJMP_FLOAT128 Xmm14;
        SETJMP_FLOAT128 Xmm15;
    } _JUMP_BUFFER;






















































#line 139 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"





    
    typedef _JBTYPE jmp_buf[16];
#line 147 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"




    
#line 153 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"




int __cdecl _setjmp(
      jmp_buf _Buf
    );


    #pragma warning(push)
    #pragma warning(disable:4987) 
    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) throw(...);
    #pragma warning(pop)





#line 175 "H:\\Visual Studio\\VC\\INCLUDE\\setjmp.h"


} __pragma(pack(pop))
#line 20 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"



    
        #line 1 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"













#pragma once



#line 19 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"







#line 27 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"
















#pragma once



#line 22 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"







#line 30 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"

















#pragma once



#line 23 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"







#line 31 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"

















#pragma once



#line 23 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"







#line 31 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"










#pragma once



#line 16 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"







#line 24 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"
















#pragma once



#line 22 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"







#line 30 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"




















#pragma once



#line 26 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"







#line 34 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"



#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"




#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"



























#pragma once



#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"







#line 41 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"





#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"














#pragma once






#line 23 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"



#line 27 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"


extern "C" { 


#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;


void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);




























































}; 
#line 187 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"

#line 189 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"
#line 190 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"
#line 191 "H:\\Visual Studio\\VC\\INCLUDE\\mmintrin.h"
#line 47 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"
#line 48 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;




#line 81 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"
#line 82 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 












































































 
 
 


extern "C" { 
  
#line 191 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);





extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#line 285 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);





extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);






























 
 
 

 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _m_pcmpgtw(_mm_setzero_si64(), _A);

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _mm_setzero_si64();

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi16(__m128 _A)
{
  return _m_packssdw(_mm_cvt_ps2pi(_A),
                        _mm_cvt_ps2pi(_mm_movehl_ps(_A, _A)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi8_ps(__m64 _A)
{
  __m64  _Ext_val = _m_pcmpgtb(_mm_setzero_si64(), _A);

  return _mm_cvtpi16_ps(_m_punpcklbw(_A, _Ext_val));
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu8_ps(__m64 _A)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(_A, _mm_setzero_si64()));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi8(__m128 _A)
{
  return _m_packsswb(_mm_cvtps_pi16(_A), _mm_setzero_si64());
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi32x2_ps(__m64 _A, __m64 _B)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), _A),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), _B));
}



}; 
#line 497 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"

#line 499 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"
#line 500 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"
#line 501 "H:\\Visual Studio\\VC\\INCLUDE\\xmmintrin.h"
#line 43 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 72 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);

extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);





extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_set1_epi64(__m64 _Q);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);
extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);






extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);


#line 416 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"


}; 
#line 420 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"

#line 422 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"
#line 423 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"
#line 424 "H:\\Visual Studio\\VC\\INCLUDE\\emmintrin.h"
#line 35 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 61 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


}; 
#line 103 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"

#line 105 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"
#line 106 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"
#line 107 "H:\\Visual Studio\\VC\\INCLUDE\\pmmintrin.h"
#line 26 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"









extern "C" {
#line 37 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);

    extern __m64 _mm_hadd_pi16 (__m64, __m64);
    extern __m64 _mm_hadd_pi32 (__m64, __m64);
    extern __m64 _mm_hadds_pi16 (__m64, __m64);

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);

    extern __m64 _mm_hsub_pi16 (__m64, __m64);
    extern __m64 _mm_hsub_pi32 (__m64, __m64);
    extern __m64 _mm_hsubs_pi16 (__m64, __m64);

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);

    extern __m64 _mm_maddubs_pi16 (__m64, __m64);

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);

    extern __m64 _mm_mulhrs_pi16 (__m64, __m64);

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);

    extern __m64 _mm_shuffle_pi8 (__m64, __m64);

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);

    extern __m64 _mm_sign_pi8 (__m64, __m64);
    extern __m64 _mm_sign_pi16 (__m64, __m64);
    extern __m64 _mm_sign_pi32 (__m64, __m64);

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);

    extern __m64 _mm_alignr_pi8 (__m64, __m64, int);

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);

    extern __m64 _mm_abs_pi8 (__m64);
    extern __m64 _mm_abs_pi16 (__m64);
    extern __m64 _mm_abs_pi32 (__m64);


};
#line 128 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"

#line 130 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"
#line 131 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"
#line 132 "H:\\Visual Studio\\VC\\INCLUDE\\tmmintrin.h"
#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"


















































extern "C" {
#line 85 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i , __m128i );

        
        

        extern int _mm_testc_si128(__m128i , __m128i );

        
        
        

        extern int _mm_testnzc_si128(__m128i , __m128i );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );

        




        
        

        extern int _mm_extract_ps(__m128 , const int );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );


        extern __m128i _mm_insert_epi64(__m128i , __int64 , const int );
#line 194 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );


        extern __int64 _mm_extract_epi64(__m128i , const int );
#line 203 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );

        

        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );

        



        extern __m128i _mm_stream_load_si128(__m128i*);


}; 
#line 258 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"

#line 260 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"
#line 261 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"
#line 262 "H:\\Visual Studio\\VC\\INCLUDE\\smmintrin.h"
#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"



extern "C" {
#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );

    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );


    extern __int64 _mm_popcnt_u64(unsigned __int64 );
#line 121 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );


    extern unsigned __int64 _mm_crc32_u64(unsigned __int64 , unsigned __int64 );
#line 133 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"


}; 
#line 137 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"

#line 139 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"
#line 140 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"
#line 141 "H:\\Visual Studio\\VC\\INCLUDE\\nmmintrin.h"
#line 32 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"



extern "C" {
#line 37 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



}; 
#line 88 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"

#line 90 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"
#line 91 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"
#line 92 "H:\\Visual Studio\\VC\\INCLUDE\\wmmintrin.h"
#line 29 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"


extern "C" {
#line 33 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);

extern void __cdecl _xsave64(void *, unsigned __int64);
#line 1221 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);

extern void __cdecl _xsaveopt64(void *, unsigned __int64);
#line 1231 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);

extern void __cdecl _xsavec64(void *, unsigned __int64);
#line 1240 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);

extern void __cdecl _xrstor64(void const *, unsigned __int64);
#line 1250 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);

extern void __cdecl _xsaves64(void *, unsigned __int64);
#line 1260 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);

extern void __cdecl _xrstors64(void const *, unsigned __int64);
#line 1270 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"





extern void __cdecl _fxsave(void *);

extern void __cdecl _fxsave64(void *);
#line 1279 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"





extern void __cdecl _fxrstor(void const *);

extern void __cdecl _fxrstor64(void const *);
#line 1288 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);

extern int __cdecl _rdrand64_step(unsigned __int64 *);
#line 1300 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"





extern unsigned int     __cdecl _readfsbase_u32();
extern unsigned int     __cdecl _readgsbase_u32();
extern unsigned __int64 __cdecl _readfsbase_u64();
extern unsigned __int64 __cdecl _readgsbase_u64();




extern void __cdecl _writefsbase_u32(unsigned int);
extern void __cdecl _writegsbase_u32(unsigned int);
extern void __cdecl _writefsbase_u64(unsigned __int64);
extern void __cdecl _writegsbase_u64(unsigned __int64);
#line 1318 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );





extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );


extern unsigned __int64 _bextr_u64(unsigned __int64 ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned __int64 _blsi_u64(unsigned __int64);
extern unsigned __int64 _blsmsk_u64(unsigned __int64);
extern unsigned __int64 _blsr_u64(unsigned __int64);
extern unsigned __int64 _bzhi_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _mulx_u64(unsigned __int64 ,
                                  unsigned __int64 ,
                                  unsigned __int64 * );
extern unsigned __int64 _pdep_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _pext_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _rorx_u64(unsigned __int64 ,
                                  const unsigned int );
extern __int64          _sarx_i64(__int64 ,
                                  unsigned int );
extern unsigned __int64 _shlx_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _shrx_u64(unsigned __int64 ,
                                          unsigned int );
#line 1838 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);

extern unsigned __int64 _lzcnt_u64(unsigned __int64);
#line 1850 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);

extern unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 1862 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);


extern void _Store64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedAnd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedAnd64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLERelease(__int64 volatile *,__int64);

extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *,__int64);
#line 1921 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);
extern int __cdecl _rdseed64_step(unsigned __int64 *);










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );




extern __m128i _mm_sha1rnds4_epu32(__m128i, __m128i, const int);
extern __m128i _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);
extern __m128i _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i _mm_sha256msg2_epu32(__m128i, __m128i);


extern unsigned char __cdecl _addcarryx_u64(unsigned char ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 * );
#line 1979 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"




extern void * _bnd_set_ptr_bounds(const void *, size_t);
extern void * _bnd_init_ptr_bounds(const void *);
extern void * _bnd_copy_ptr_bounds(const void *, const void *);
extern void _bnd_chk_ptr_bounds(const void *, size_t);
extern void _bnd_chk_ptr_lbounds(const void *);
extern void _bnd_chk_ptr_ubounds(const void *);
extern void _bnd_store_ptr_bounds(const void **, const void *);
extern void * _bnd_load_ptr_bounds(const void **, const void *);
extern const void * _bnd_get_ptr_lbound(const void *);
extern const void * _bnd_get_ptr_ubound(const void *);
extern void * _bnd_narrow_ptr_bounds(const void *, const void *, size_t);


}; 
#line 1998 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"

#line 2000 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"
#line 2001 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"
#line 2002 "H:\\Visual Studio\\VC\\INCLUDE\\immintrin.h"

#line 25 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"
        #line 1 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"












#pragma once



#line 18 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"







#line 26 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"



#line 30 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"


extern "C" { 
#line 34 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);

void __lwpval64(unsigned __int64, unsigned int, unsigned int);
unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
#line 258 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);

unsigned __int64 _bextr_u64(unsigned __int64, unsigned int, unsigned int);
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _lzcnt_u64(unsigned __int64);
unsigned __int64 _blsr_u64(unsigned __int64);
unsigned __int64 _blsmsk_u64(unsigned __int64);
unsigned __int64 _blsi_u64(unsigned __int64);
#line 276 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);

unsigned __int64 _bextri_u64(unsigned __int64, unsigned int);
unsigned __int64 _blcfill_u64(unsigned __int64);
unsigned __int64 _blsfill_u64(unsigned __int64);
unsigned __int64 _blcs_u64(unsigned __int64);
unsigned __int64 _tzmsk_u64(unsigned __int64);
unsigned __int64 _blcic_u64(unsigned __int64);
unsigned __int64 _blsic_u64(unsigned __int64);
unsigned __int64 _t1mskc_u64(unsigned __int64);
unsigned __int64 _blcmsk_u64(unsigned __int64);
unsigned __int64 _blci_u64(unsigned __int64);
#line 300 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}; 
#line 307 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"

#line 309 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"
#line 310 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"
#line 311 "H:\\Visual Studio\\VC\\INCLUDE\\ammintrin.h"
#line 26 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"
    #line 27 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"

    

#line 31 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"

    


#line 36 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"

    


#line 41 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"
#line 42 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"


extern "C" {
#line 46 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




























#line 75 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"


#line 78 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"






#line 85 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 90 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 95 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 100 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"






#line 107 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 112 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 117 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 122 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"




#line 127 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"


void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);
























long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);


short _InterlockedAnd16_np(short volatile * _Value, short _Mask);

__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);


__int64 _InterlockedAnd64_np(__int64 volatile * _Value, __int64 _Mask);

char _InterlockedAnd8(char volatile * _Value, char _Mask);


char _InterlockedAnd8_np(char volatile * _Value, char _Mask);



long _InterlockedAnd_np(long volatile * _Value, long _Mask);

long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);


unsigned char _InterlockedCompareExchange128_np(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);


short _InterlockedCompareExchange16_np(short volatile * _Destination, short _Exchange, short _Comparand);

__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);


__int64 _InterlockedCompareExchange64_np(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);

char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);


void * _InterlockedCompareExchangePointer_np(void * volatile * _Destination, void * _Exchange, void * _Comparand);



long _InterlockedCompareExchange_np(long volatile * _Destination, long _Exchange, long _Comparand);

long  _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);



__int64 _InterlockedDecrement64(__int64 volatile * _Addend);






long  _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);






long  _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);



__int64 _InterlockedIncrement64(__int64 volatile * _Addend);






long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);


short _InterlockedOr16_np(short volatile * _Value, short _Mask);

__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);


__int64 _InterlockedOr64_np(__int64 volatile * _Value, __int64 _Mask);

char _InterlockedOr8(char volatile * _Value, char _Mask);


char _InterlockedOr8_np(char volatile * _Value, char _Mask);



long _InterlockedOr_np(long volatile * _Value, long _Mask);

long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);


short _InterlockedXor16_np(short volatile * _Value, short _Mask);

__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);


__int64 _InterlockedXor64_np(__int64 volatile * _Value, __int64 _Mask);

char _InterlockedXor8(char volatile * _Value, char _Mask);


char _InterlockedXor8_np(char volatile * _Value, char _Mask);



long _InterlockedXor_np(long volatile * _Value, long _Mask);









void _ReadBarrier(void);






void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);









void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);




void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);
void __faststorefence(void);
unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);



void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);




unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);









void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);
void __movsq(unsigned long long *, unsigned long long const *, size_t);
void __movsw(unsigned short *, unsigned short const *, size_t);
__int64 __mulh(__int64, __int64);
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);



unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);
unsigned __int64 __readcr0(void);

unsigned __int64 __readcr2(void);

unsigned __int64 __readcr3(void);

unsigned __int64 __readcr4(void);

unsigned __int64 __readcr8(void);

unsigned __int64 __readdr(unsigned int);

unsigned __int64 __readeflags(void);





unsigned char __readgsbyte(unsigned long);
unsigned long __readgsdword(unsigned long);
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);

unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);
void __vmx_off(void);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
void __vmx_vmptrst(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __wbinvd(void);


void __writecr0(unsigned __int64);

void __writecr3(unsigned __int64);

void __writecr4(unsigned __int64);

void __writecr8(unsigned __int64);

void __writedr(unsigned int, unsigned __int64);

void __writeeflags(unsigned __int64);





void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);





unsigned char _bittest(long const *, long);
unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset(long *, long);
unsigned char _bittestandset64(__int64 *, __int64);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);






unsigned char _interlockedbittestandset(long volatile *, long);
unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);
















  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);




























































void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);



































__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);

__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64);
unsigned int _mm_crc32_u8(unsigned int, unsigned char);


__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);

__m128 _mm_cvtpd_ps(__m128d);

__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);
__int64 _mm_cvtsd_si64(__m128d);
__int64 _mm_cvtsd_si64x(__m128d);
__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);
__int64 _mm_cvtsi128_si64(__m128i);
__int64 _mm_cvtsi128_si64x(__m128i);
__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);
__m128d _mm_cvtsi64_sd(__m128d, __int64);
__m128i _mm_cvtsi64_si128(__int64);
__m128 _mm_cvtsi64_ss(__m128, __int64);
__m128d _mm_cvtsi64x_sd(__m128d, __int64);
__m128i _mm_cvtsi64x_si128(__int64);
__m128 _mm_cvtsi64x_ss(__m128, __int64);
__m128d _mm_cvtss_sd(__m128d, __m128);
__int64 _mm_cvtss_si64(__m128);
__int64 _mm_cvtss_si64x(__m128);

int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);

__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);
__int64 _mm_cvttsd_si64(__m128d);
__int64 _mm_cvttsd_si64x(__m128d);
__int64 _mm_cvttss_si64(__m128);
__int64 _mm_cvttss_si64x(__m128);
__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);
__int64 _mm_extract_epi64(__m128i, int);
int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);
__m128i _mm_insert_epi64(__m128i, __int64, int);
__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);


__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);

__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
void _mm_pcommit(void);
int _mm_popcnt_u32(unsigned int);
__int64 _mm_popcnt_u64(unsigned __int64);
void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);

__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);



__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);

__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);



__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);

__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);



__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);

void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(__m128i *);
void _mm_stream_pd(double *, __m128d);

void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);
void _mm_stream_si64x(__int64 *, __int64);
void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);

__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct);
unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);
int __cdecl _setjmpex(jmp_buf);
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);
void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}
#line 1134 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"
#line 1135 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"
#line 1136 "H:\\Visual Studio\\VC\\INCLUDE\\intrin.h"

#line 1016 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

   

   


  






#line 1030 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1035 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"
#line 1036 "H:\\Visual Studio\\VC\\INCLUDE\\xmemory0"






#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

  #pragma warning(disable: 4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

		
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Mystr::value_type,
			typename _Mystr::difference_type,
			typename _Mystr::const_pointer,
			typename _Mystr::const_reference,
			_Iterator_base>
	{	
public:
	typedef _String_const_iterator<_Mystr> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::const_pointer pointer;
	typedef typename _Mystr::const_reference reference;

	_String_const_iterator()
		{	
		this->_Ptr = 0;
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		{	
		this->_Adopt(_Pstring);
		this->_Ptr = _Parg;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 










#line 80 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"





#line 86 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 









#line 110 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"




#line 115 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 








#line 139 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"



#line 143 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 










#line 169 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"





#line 175 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 










#line 253 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"






#line 260 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"
	void _Compat(const _Myiter&) const
		{	
		}
 #line 264 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

	pointer _Ptr;	
	};

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_const_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>
		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
			typename _String_const_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>
			::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	
public:
	typedef _String_iterator<_Mystr> _Myiter;
	typedef _String_const_iterator<_Mystr> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::pointer pointer;
	typedef typename _Mystr::reference reference;

	_String_iterator()
		{	
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>
		_Rechecked(_String_iterator<_Mystr>& _Iter,
			typename _String_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>
			::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _String_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _String_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_String_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	
public:
	typedef _String_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_Myt> iterator;
	typedef _String_const_iterator<_Myt> const_iterator;

	_String_val()
		{	
		_Mysize = 0;
		_Myres = 0;
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0};

	value_type *_Myptr()
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	const value_type *_Myptr() const
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	union _Bxty
		{	
		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	
		} _Bx;

	size_type _Mysize;	
	size_type _Myres;	
	};

		
template<class _Alloc_types>
	class _String_alloc
	{	
public:
	typedef _String_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_String_val<_Val_types> > iterator;
	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;

	enum
		{	
		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
		};

	enum
		{	
		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
		};

	value_type *_Myptr()
		{	
		return (_Get_data()._Myptr());
		}

	const value_type *_Myptr() const
		{	
		return (_Get_data()._Myptr());
		}

 
	_String_alloc(const _Alloc& _Al = _Alloc())
		: _Mypair(_One_then_variadic_args_t(), _Al)
		{	
		}

	_String_alloc(_Alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(), ::std:: move(_Al))
		{	
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Pocca(_Getal(), _Al);
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Pocma(_Getal(), _Al);
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Pocs(_Getal(), _Right._Getal());
		}

 






































































#line 667 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_String_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _String_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	typedef typename _String_val<_Val_types>::_Bxty _Bxty;

	_Bxty& _Bx() noexcept
		{	
		return (_Get_data()._Bx);
		}

	const _Bxty& _Bx() const noexcept
		{	
		return (_Get_data()._Bx);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

	size_type& _Myres() noexcept
		{	
		return (_Get_data()._Myres);
		}

	const size_type& _Myres() const noexcept
		{	
		return (_Get_data()._Myres);
		}

private:
	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_string
		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
	{	
public:
	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string() noexcept
		: _Mybase()
		{	
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	
		;
		_Tidy();
		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, forward_iterator_tag)
		{	
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);
		_Construct(_First, _Last, input_iterator_tag());
		}

	void _Construct(_Elem *_First,
		_Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	void _Construct(const _Elem *_First,
		const _Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	basic_string(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Tidy();
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	basic_string(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(_Right.begin(), _Right.end());
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 917 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"
		{	
		if (this != &_Right)
			{	
			_Tidy(true);

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			if (this->_Getal() != _Right._Getal())
				assign(_Right.begin(), _Right.end());
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	_Myt& assign(_Myt&& _Right) noexcept
		{	
		if (this == &_Right)
			;
		else if (get_allocator() != _Right.get_allocator()
			&& this->_BUF_SIZE <= _Right._Myres())
			*this = _Right;
		else
			{	
			_Tidy(true);
			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (_Right._Myres() < this->_BUF_SIZE)
			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
				_Right._Mysize() + 1);
		else
			{	
			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
			_Right._Bx()._Ptr = pointer();
			}
		this->_Mysize() = _Right._Mysize();
		this->_Myres() = _Right._Myres();
		_Right._Tidy();
		}

	basic_string(::std:: initializer_list<_Elem> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& assign(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& append(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
		}

	~basic_string() noexcept
		{	
		_Tidy(true);
		}

	 static const size_type npos;	

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy(true);
				this->_Copy_alloc(_Right._Getal());
				}

			assign(_Right);
			}
		return (*this);
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(),
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	
		;
		if (_Inside(_Ptr))
			return (append(*this,
				_Ptr - this->_Myptr(), _Count));	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	
		;
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Chassign(this->_Mysize(), _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		append(_Iter _First, _Iter _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;	

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	
		else if (_Grow(_Num))
			{	
			_Traits::copy(this->_Myptr(),
				_Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Count)
		{	
		;
		if (_Inside(_Ptr))
			return (assign(*this,
				_Ptr - this->_Myptr(), _Count));	

		if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(), _Ptr, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	
		;
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		assign(_Iter _First, _Iter _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
		{	
		if (this->_Mysize() < _Off || _Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			if (this == &_Right)
				_Traits::move(this->_Myptr() + _Off,
					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits::copy(this->_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
		;
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - this->_Myptr(), _Count));	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	
		;
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(const_iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator insert(const_iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_pointer _First, const_pointer _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_iterator _First, const_iterator _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	_Myt& erase(size_type _Off = 0)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		_Eos(_Off);
		return (*this);
		}

	_Myt& erase(size_type _Off, size_type _Count)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off <= _Count)
			_Eos(_Off);	
		else if (0 < _Count)
			{	
			value_type *_Ptr = this->_Myptr() + _Off;
			size_type _Newsize = this->_Mysize() - _Count;
			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(const_iterator _Where)
		{	
		size_type _Count = _Where - begin();
		erase(_Count, 1);
		return (begin() + _Count);
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		;
		size_type _Count = _First - begin();
		erase(_Count, _Last - _First);
		return (begin() + _Count);
		}

	void clear() noexcept
		{	
		_Eos(0);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff,
			size_type _Count = npos)
		{	
		if (this->_Mysize() < _Off || _Right.size() < _Roff)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	

		size_type _Nm = this->_Mysize() - _N0 - _Off;	
		size_type _Newsize = this->_Mysize() + _Count - _N0;
		if (this->_Mysize() < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count <= _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + (_Roff + _Count - _N0),
				_Count);	
			}
		else
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _N0);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off + _N0,
				this->_Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
		;
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - this->_Myptr(),
				_Count));	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		;
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Myt& _Right)
		{	
		return (replace(_First - begin(), _Last - _First, _Right));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr, size_type _Count)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		replace(const_iterator _First, const_iterator _Last,
			_Iter _First2, _Iter _Last2)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		pointer _First2, pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		iterator _First2, iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myptr(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myptr(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if ((size() | this->_ALLOC_MASK) < capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	reference at(size_type _Off)
		{	
		if (this->_Mysize() <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	
		if (this->_Mysize() <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	
 



#line 1684 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

#line 1686 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

		return (this->_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
 



#line 1697 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

#line 1699 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"

		return (this->_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	
		insert(end(), _Ch);
		}

	void pop_back()
		{	
		erase(this->_Mysize() - 1);	
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	const _Elem *c_str() const noexcept
		{	
		return (this->_Myptr());
		}

	const _Elem *data() const noexcept
		{	
		return (c_str());
		}

	size_type length() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		size_type _Num = this->_Getal().max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= this->_Mysize())
			_Eos(_Newsize);
		else
			append(_Newsize - this->_Mysize(), _Ch);
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myres());
		}

	void reserve(size_type _Newcap = 0)
		{	
		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
			{	
			size_type _Size = this->_Mysize();
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const noexcept
		{	
		return (this->_Mysize() == 0);
		}

	

	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	
		;
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _Count)
			_Count = this->_Mysize() - _Off;
		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
		;
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _Count)
			_Count = this->_Mysize() - _Off;
		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_bx(_Myt& _Right)
		{	
		if (this->_BUF_SIZE <= this->_Myres())
			if (this->_BUF_SIZE <= _Right._Myres())
				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
			else
				{	
				pointer _Ptr = this->_Bx()._Ptr;
				this->_Getal().destroy(&this->_Bx()._Ptr);
				_Traits::copy(this->_Bx()._Buf,
					_Right._Bx()._Buf, _Right._Mysize() + 1);
				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
				}
		else
			if (_Right._Myres() < this->_BUF_SIZE)
				::std:: swap(this->_Bx()._Buf, _Right._Bx()._Buf);
			else
				{	
				pointer _Ptr = _Right._Bx()._Ptr;
				this->_Getal().destroy(&_Right._Bx()._Ptr);
				_Traits::copy(_Right._Bx()._Buf,
					this->_Bx()._Buf, this->_Mysize() + 1);
				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
				}
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1847 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Mysize(), _Right._Mysize());
			::std:: swap(this->_Myres(), _Right._Myres());
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
				
			this->_Swap_alloc(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Bx(), _Right._Bx());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			::std:: swap(this->_Myres(), _Right._Myres());
			}

		else
			{	
			_Myt _Tmp = *this;

			*this = _Right;
			_Right = _Tmp;
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		;
		if (_Count == 0 && _Off <= this->_Mysize())
			return (_Off);	

		size_type _Nm;
		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		;
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		;
		if (_Count == 0)
			return (_Off < this->_Mysize() ? _Off
				: this->_Mysize());	
		if (_Count <= this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr() +
				(_Off < this->_Mysize() - _Count ? _Off
					: this->_Mysize() - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		;
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		;
		if (0 < _Count && _Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		;
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		;
		if (0 < _Count && 0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		;
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		;
		if (_Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		;
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		;
		if (0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
				else if (_Uptr == this->_Myptr())
					break;
			}
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		;
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count, get_allocator()));
		}

	int compare(const _Myt& _Right) const noexcept
		{	
		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
		}

	int compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{	
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count = npos) const
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		if (_Right._Mysize() - _Roff < _Count)
			_Count = _Right._Mysize() - _Roff;	
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int compare(const _Elem *_Ptr) const
		{	
		;
		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		;
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
		;
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	

		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
			_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type get_allocator() const noexcept
		{	
		return (this->_Getal());
		}

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
		else
			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | this->_ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (this->_Myres() / 2 <= _Newres / 3)
			;
		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
			_Newres = this->_Myres()
				+ this->_Myres() / 2;	
		else
			_Newres = max_size();	

		_Elem *_Ptr;
		try {
			_Ptr = this->_Getal().allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = this->_Getal().allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Ptr, this->_Myptr(),
				_Oldlen);	
		_Tidy(true);
		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
		this->_Myres() = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	
		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
		if (max_size() < _Newsize)
			_Xlen();	
		if (this->_Myres() < _Newsize)
			_Copy(_Newsize, this->_Mysize());	
		else if (_Trim && _Newsize < this->_BUF_SIZE)
			_Tidy(true,	
				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool _Inside(const _Elem *_Ptr)
		{	
		if (_Ptr == 0 || _Ptr < this->_Myptr()
			|| this->_Myptr() + this->_Mysize() <= _Ptr)
			return (false);	
		else
			return (true);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (this->_BUF_SIZE <= this->_Myres())
			{	
			pointer _Ptr = this->_Bx()._Ptr;
			this->_Getal().destroy(&this->_Bx()._Ptr);
			if (0 < _Newsize)
				_Traits::copy(this->_Bx()._Buf,
					::std:: addressof(*_Ptr), _Newsize);
			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
			}
		this->_Myres() = this->_BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("string too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid string position");
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Traits::length(_Left) + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Traits::length(_Right));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
		size_type;
	return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem *_Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	
	return (::std:: move(_Left.append(1, _Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
	wstring;

	
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc> >
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
			_Keyval.size() * sizeof (_Elem)));
		}
	};

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
	u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
	u32string;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2633 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"
#line 2634 "H:\\Visual Studio\\VC\\INCLUDE\\xstring"






#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {










		
class logic_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 50 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class domain_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 78 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class invalid_argument
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 106 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class length_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 134 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class out_of_range
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 162 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class runtime_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 190 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 218 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class underflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 246 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};

		
class range_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 274 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
	};
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 280 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"
#line 281 "H:\\Visual Studio\\VC\\INCLUDE\\stdexcept"





#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\typeinfo"














#pragma once







#pragma pack(push,8)
#pragma warning(push,3)


#pragma warning(disable: 4275)

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"


#pragma pack(push, 8)






#line 21 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 23 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 29 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4510 4512 4610) 
struct __std_type_info_data
{
    char const* _UndecoratedName;
    char const  _DecoratedName[1];
};
#pragma warning(pop)

__declspec(dllimport) int __cdecl __std_type_info_compare(
      __std_type_info_data const* _Lhs,
      __std_type_info_data const* _Rhs
    );

__declspec(dllimport) size_t __cdecl __std_type_info_hash(
      __std_type_info_data const* _Data
    );

__declspec(dllimport) char const* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))



class type_info
{
public: 

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(type_info const& _Other) const
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(type_info const& _Other) const
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(type_info const& _Other) const
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    char const* name() const
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 93 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"
    }

    char const* raw_name() const
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    type_info(type_info const&) = delete;
    type_info& operator=(type_info const&) = delete;

    mutable __std_type_info_data _Data;
};



namespace std {

using ::type_info;

class bad_cast
    : public exception
{
public:

    bad_cast()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(char const* const _Message)
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(char const* const _Message, int)
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(char const* const _Message)
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(char const* const _Message, int)
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(char const* const _Message)
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(char const* const _Message, int)
        : bad_typeid(_Message, 1)
    {
    }
};

} 

#line 185 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"
#line 186 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_typeinfo.h"
#pragma pack(pop)
#line 30 "H:\\Visual Studio\\VC\\INCLUDE\\typeinfo"

 























































#line 88 "H:\\Visual Studio\\VC\\INCLUDE\\typeinfo"


#pragma pack(pop)
#pragma warning(pop)
#line 93 "H:\\Visual Studio\\VC\\INCLUDE\\typeinfo"
#line 94 "H:\\Visual Studio\\VC\\INCLUDE\\typeinfo"







#line 10 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"

#pragma once



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {









  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isdigit(  int _C);

  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isspace(  int _C);

  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl toupper(  int _C);


   __declspec(dllimport) int __cdecl tolower(  int _C);

   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);










    
    
    






















    
    
    



        
    #line 115 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"



    
    
    
    
    
    
    
    



    












#line 143 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    



    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        


        if (_Locale)
        {
            return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
        }

        return (__pctype_func()[(_C)] & (_Mask));
        #line 170 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 221 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"



    
    
    
    
#line 229 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"



#line 233 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\locale.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;























    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    
    __declspec(dllimport) int __cdecl _configthreadlocale(
          int _Flag
        );

    
    __declspec(dllimport) char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );

    
    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    
    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    
    __declspec(dllimport) _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );

    __declspec(dllimport) void __cdecl _free_locale(
          _locale_t _Locale
        );

    
    
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);




    
     
     
    __declspec(dllimport) char*    __cdecl _Getdays(void);

     
     
    __declspec(dllimport) char*    __cdecl _Getmonths(void);

    __declspec(dllimport) void*    __cdecl _Gettnames(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void*    __cdecl _W_Gettnames(void);

     
    __declspec(dllimport) size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);

     
    __declspec(dllimport) size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );

#line 174 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\locale.h"


} __pragma(pack(pop))
#line 8 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 
  
extern "C" {
  #line 21 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"
 #line 22 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"

		












		










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	
	unsigned int _Page;		
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned int _Page;		
	unsigned int _Mbcurmax;
	int _Isclocale;	
	unsigned char _Isleadbyte[32];	
	} _Cvtvec;

		
__declspec(dllimport) _Collvec __cdecl _Getcoll(void);
__declspec(dllimport) _Ctypevec __cdecl _Getctype(void);
__declspec(dllimport) _Cvtvec __cdecl _Getcvt(void);
__declspec(dllimport) int __cdecl _Getdateorder(void);

 








__declspec(dllimport) int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #line 96 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"

__declspec(dllimport) float __cdecl _Stof(const char *,
	    char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,
	    char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,
	    char **, long);

__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

 
  
}
  #line 129 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"
 #line 130 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"


extern "C" {
__declspec(dllimport) char *__cdecl _Getdays(void);
__declspec(dllimport) char *__cdecl _Getmonths(void);
__declspec(dllimport) void *__cdecl _Gettnames(void);
__declspec(dllimport) size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,     const char *,
	  const struct tm *, void *);

__declspec(dllimport) wchar_t *__cdecl _W_Getdays(void);
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths(void);
__declspec(dllimport) void *__cdecl _W_Gettnames(void);
__declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,     const wchar_t *,
	  const struct tm *, void *);
}

 







__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #line 158 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 163 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"
#line 164 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo.h"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

namespace std {
		
class __declspec(dllimport) _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec() noexcept
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		
class __declspec(dllimport) _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 #line 75 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 #line 86 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() noexcept
		{	
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 



	_Lockit _Lock;	
 #line 227 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"

	_Yarn<char> _Days;	
	_Yarn<char> _Months;	
	_Yarn<wchar_t> _W_Days;	
	_Yarn<wchar_t> _W_Months;	
	_Yarn<char> _Oldlocname;	
	_Yarn<char> _Newlocname;	
	};

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));
#line 276 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 301 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"
#line 302 "H:\\Visual Studio\\VC\\INCLUDE\\xlocinfo"





#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\xfacet"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 






namespace std {
	
class __declspec(dllimport) _Facet_base
	{	
public:
	virtual  ~_Facet_base() noexcept
		{	
		}

	
	virtual void  _Incref() = 0;

	
	virtual _Facet_base *  _Decref() = 0;
	};

 


#line 38 "H:\\Visual Studio\\VC\\INCLUDE\\xfacet"
void __cdecl _Facet_Register(_Facet_base *);
 #line 40 "H:\\Visual Studio\\VC\\INCLUDE\\xfacet"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 45 "H:\\Visual Studio\\VC\\INCLUDE\\xfacet"
#line 46 "H:\\Visual Studio\\VC\\INCLUDE\\xfacet"

 



#line 13 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412 28197)

namespace std {
		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

struct __declspec(dllimport) _Crt_new_delete
	{	
  
































	};

class locale
	: public _Locbase<int>, public _Crt_new_delete
	{	
public:
	typedef int category;

			
	class __declspec(dllimport) id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	

		 static int _Id_cnt;

	public:
		 id(const id&) = delete;
		id&  operator=(const id&) = delete;
		};

	class _Locimp;

			
	class __declspec(dllimport) facet
		: public _Facet_base, public _Crt_new_delete
		{	
	public:
		static size_t __cdecl _Getcat(const facet ** = 0,
			const locale * = 0)
			{	
			return ((size_t)(-1));
			}

		virtual void  _Incref()
			{	
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Myrefs));
			}

		virtual _Facet_base * _Decref()
			{	
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Myrefs)) == 0)
				return (this);
			else
				return (0);
			}

	private:
		_Atomic_counter_t _Myrefs;	

	protected:
		explicit  facet(size_t _Initrefs = 0)
			{	
			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);
			}

		virtual  ~facet() noexcept
			{	
			}

	public:
		 facet(const facet&) = delete;
		facet&  operator=(const facet&) = delete;
		};

			
 #pragma warning(push)
 #pragma warning(disable: 4275)

	class __declspec(dllimport) _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp() noexcept
		{	
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend class locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	
 #line 237 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_Yarn<char> _Name;	

		 static _Locimp *_Clocptr;

public:
		_Locimp&  operator=(const _Locimp&) = delete;
		};

 #pragma warning(pop)

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const ::std:: collate<_Elem>& _Coll_fac =
			use_facet< ::std:: collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = none;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			_Ptr->_Catmask = none;
			_Ptr->_Name = "*";
			}
		}

	locale(_Uninitialized)
		{	
		}

 



















#line 323 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
	locale(const locale& _Right) noexcept
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	locale() noexcept
		: _Ptr(_Init(true))
		{	
		}

 
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj;
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
					_Lobj._Addcats(_Loc._Ptr->_Catmask,
						_Loc.name().c_str());
					_Lobj._Addcats(_Other._Ptr->_Catmask,
						_Other.name().c_str());
					_Ptr->_Catmask = _Loc._Ptr->_Catmask
						| _Other._Ptr->_Catmask;
					_Ptr->_Name = _Lobj._Getname();
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)
		{	
		bool _Bad = false;
		_Init();
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj(_Cat, _Str.c_str());
					if (_Badname(_Lobj))
						_Bad = true;
					else
						{	
						_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
						_Ptr->_Catmask = _Cat;
						_Ptr->_Name = _Str.c_str();
						}
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}

		if (_Bad)
			{	
			delete _Ptr->_Decref();
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		_Construct(_Str, _Cat);
		}
 #line 428 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

	~locale() noexcept
		{	
		if (_Ptr != 0)
			delete _Ptr->_Decref();
		}

	locale& operator=(const locale& _Right) noexcept
		{	
		if (_Ptr != _Right._Ptr)
			{	
			delete _Ptr->_Decref();
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}
 #line 446 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

	string name() const
		{	
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	const char *c_str() const
		{	
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr0 = _Getgloballocale();
			return (_Id < _Ptr0->_Facetcount
				? _Ptr0->_Facetvec[_Id]	
				: 0);	
			}
		}

	bool operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	bool operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static __declspec(dllimport) const locale& __cdecl
		classic();	

	static __declspec(dllimport) locale __cdecl
		global(const locale&);	

	static __declspec(dllimport) locale __cdecl
		empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

	static __declspec(dllimport) _Locimp *__cdecl
		_Init(bool _Do_incref = false);	
	static __declspec(dllimport) _Locimp *__cdecl
		_Getgloballocale();
	static __declspec(dllimport) void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	
	};

		

 
















#line 534 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	
 



#line 559 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 

			throw ::std:: bad_cast();	

 

#line 579 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 


#line 592 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
			_Facet_Register(_Pfmod);
 #line 594 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
			}

		return ((const _Facet&)(*_Pf));	
	}
 #line 599 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
	}	

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{	
		bool _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #line 678 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #line 711 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = :: strlen(_Ptr) + 1;

	_Elem *_Ptrdest = (_Elem *)calloc(_Count, sizeof (_Elem));
#line 724 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

	if (!_Ptrdest)
		_Xbad_alloc();

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 #pragma warning(pop)

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)calloc(_Wchars, sizeof (wchar_t));
#line 757 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

	if (!_Ptrdest)
		_Xbad_alloc();
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
 #pragma warning(pop)

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)calloc(_Wchars, sizeof (wchar_t));
#line 797 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

	if (!_Ptrdest)
		_Xbad_alloc();

	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #line 811 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const noexcept
		{	
		return (do_always_noconv());
		}

	int  max_length() const noexcept
		{	
		return (do_max_length());
		}

	int  encoding() const noexcept
		{	
		return (do_encoding());
		}

	 ~codecvt_base() noexcept
		{	
		}

protected:
	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (1);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (1);	
		}
	};

 #pragma warning(pop)

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (is_same<_Byte, _Elem>::value);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (ok);	
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

		
enum _Codecvt_mode {
	_Consume_header = 4,
	_Generate_header = 2
	};

		
template<>
	class __declspec(dllimport) codecvt<char16_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
	typedef char16_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra, _Nskip;

			if (*_Pstate <= 1)
				;	
			else if (_By < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				{	
				++_Mid1;
				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
				*_Pstate = 1;
				continue;
				}

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			_Nskip = _Nextra < 3 ? 0 : 1;	
			_First1 = _Mid1;	

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
				break;	
			else
				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);
			if (0 < _Nskip)
				_Ch <<= 6;	

			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
				return (_Mybase::error);	
			else if (0xffff < _Ch)
				{	
				unsigned short _Ch0 =
					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

				*_Mid2++ = (_Elem)_Ch0;
				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
				continue;
				}

			if (_Nskip == 0)
				;
			else if (_Mid1 == _Last1)
				{	
				_Mid1 = _First1;
				break;
				}
			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				_Ch |= _By & 0x3f;	

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned long _Ch;
			unsigned short _Ch1 = (unsigned short)*_Mid1;
			bool _Save = false;

			if (1 < *_Pstate)
				{	
				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
					return (_Mybase::error);	
				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
				}
			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
				{	
				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
				_Save = true;	
				}
			else
				_Ch = _Ch1;	

			_Byte _By;
			int _Nextra;

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x10000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

			if (_Last2 - _Mid2 < _Nput)
				break;	
			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
				;	
			else if (_Last2 - _Mid2 < 3 + _Nput)
				break;	
			else
				{	
				*_Mid2++ = (_Byte)(unsigned char)0xef;
				*_Mid2++ = (_Byte)(unsigned char)0xbb;
				*_Mid2++ = (_Byte)(unsigned char)0xbf;
				}

			++_Mid1;
			if (_Save || _Nextra < 3)
				{	
				*_Mid2++ = _By;
				--_Nput;
				}
			for (; 0 < _Nput; --_Nput)
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid2 = _First2;

		return (1 < *_Pstate
			? _Mybase::error : _Mybase::ok);	
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		for (; _Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & _Consume_header) != 0 ? 9	
			: (_Mode & _Generate_header) != 0 ? 7	
			: 6);	
		}

	virtual int do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class __declspec(dllimport) codecvt<char32_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
	typedef char32_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra;

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1)
				break;	
			else
				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			if (_Maxcode < _Ch)
				return (_Mybase::error);	
			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			_Byte _By;
			int _Nextra;
			unsigned long _Ch = (unsigned long)*_Mid1;

			if (_Maxcode < _Ch)
				return (_Mybase::error);

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x00010000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else if (_Ch < 0x00200000)
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
			else if (_Ch < 0x04000000)
				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
			else
				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;
				if ((_Mode & _Generate_header) == 0)
					;
				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
					return (_Mybase::partial);	
				else
					{	
					*_Mid2++ = (_Byte)(unsigned char)0xef;
					*_Mid2++ = (_Byte)(unsigned char)0xbb;
					*_Mid2++ = (_Byte)(unsigned char)0xbf;
					}
				}

			if (_Last2 - _Mid2 < 1 + _Nextra)
				break;	

			++_Mid1;
			for (*_Mid2++ = _By; 0 < _Nextra; )
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
			}
		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		_Mid2 = _First2;
		return (_Mybase::ok);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		int _Wchars = 0;
		_Statype _Mystate = _State;

		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (int)(_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? 9 : 6);
		}

	virtual int  do_encoding() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? -1 : 0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		;
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};

 
		
template<>
	class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		;
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
 #line 2060 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~codecvt_byname() noexcept
		{	
		}
	};

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x04 | 0x02 | 0x01 | 0x100, alpha = 0x02 | 0x01 | 0x100,
		cntrl = 0x20, digit = 0x04, graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
		lower = 0x02, print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
		punct = 0x10, space = 0x08 | 0x40 | 0x000, upper = 0x01,
		xdigit = 0x80, blank = 0x08 | 0x40 | 0x000 | 0x000};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base() noexcept
		{	
		}
	};

 #pragma warning(pop)

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	locale::id ctype<_Elem>::id;

		
template<>
	class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	
		if (_Table != 0)
			{	
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const noexcept
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() noexcept
		{	
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

	 static const size_t table_size =
		1 << 8;	

protected:
	virtual  ~ctype() noexcept
		{	
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			:: free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;

		:: free(_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	
		;
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<>
	class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		;
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

 
		
template<>
	class __declspec(dllimport) ctype<unsigned short>
	: public ctype_base
	{	
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		;
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};
 #line 3016 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"

		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

		
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

 

  
template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;
  #line 3066 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
 #line 3067 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3072 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"
#line 3073 "H:\\Visual Studio\\VC\\INCLUDE\\xlocale"






#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"

 #line 1 "H:\\Visual Studio\\VC\\INCLUDE\\system_error"

#pragma once



#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cerrno"

#pragma once











 
#line 16 "H:\\Visual Studio\\VC\\INCLUDE\\cerrno"




#line 21 "H:\\Visual Studio\\VC\\INCLUDE\\cerrno"
#line 22 "H:\\Visual Studio\\VC\\INCLUDE\\cerrno"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\system_error"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 




namespace std {
		

enum class errc {	
	address_family_not_supported = 102,
	address_in_use = 100,
	address_not_available = 101,
	already_connected = 113,
	argument_list_too_long = 7,
	argument_out_of_domain = 33,
	bad_address = 14,
	bad_file_descriptor = 9,
	bad_message = 104,
	broken_pipe = 32,
	connection_aborted = 106,
	connection_already_in_progress = 103,
	connection_refused = 107,
	connection_reset = 108,
	cross_device_link = 18,
	destination_address_required = 109,
	device_or_resource_busy = 16,
	directory_not_empty = 41,
	executable_format_error = 8,
	file_exists = 17,
	file_too_large = 27,
	filename_too_long = 38,
	function_not_supported = 40,
	host_unreachable = 110,
	identifier_removed = 111,
	illegal_byte_sequence = 42,
	inappropriate_io_control_operation = 25,
	interrupted = 4,
	invalid_argument = 22,
	invalid_seek = 29,
	io_error = 5,
	is_a_directory = 21,
	message_size = 115,
	network_down = 116,
	network_reset = 117,
	network_unreachable = 118,
	no_buffer_space = 119,
	no_child_process = 10,
	no_link = 121,
	no_lock_available = 39,
	no_message_available = 120,
	no_message = 122,
	no_protocol_option = 123,
	no_space_on_device = 28,
	no_stream_resources = 124,
	no_such_device_or_address = 6,
	no_such_device = 19,
	no_such_file_or_directory = 2,
	no_such_process = 3,
	not_a_directory = 20,
	not_a_socket = 128,
	not_a_stream = 125,
	not_connected = 126,
	not_enough_memory = 12,
	not_supported = 129,
	operation_canceled = 105,
	operation_in_progress = 112,
	operation_not_permitted = 1,
	operation_not_supported = 130,
	operation_would_block = 140,
	owner_dead = 133,
	permission_denied = 13,
	protocol_error = 134,
	protocol_not_supported = 135,
	read_only_file_system = 30,
	resource_deadlock_would_occur = 36,
	resource_unavailable_try_again = 11,
	result_out_of_range = 34,
	state_not_recoverable = 127,
	stream_timeout = 137,
	text_file_busy = 139,
	timed_out = 138,
	too_many_files_open_in_system = 23,
	too_many_files_open = 24,
	too_many_links = 31,
	too_many_symbolic_link_levels = 114,
	value_too_large = 132,
	wrong_protocol_type = 136
	};

typedef errc _Errc;

		

enum class io_errc {	
	stream = 1
	};

typedef io_errc _Io_errc;

		
template<class _Enum>
	struct is_error_code_enum
		: public false_type
	{	
	};

template<>
	struct is_error_code_enum<_Io_errc>
		: public true_type
	{	
	};

		
template<class _Enum>
	struct is_error_condition_enum
		: public false_type
	{	
	};

template<>
	struct is_error_condition_enum<_Errc>
		: public true_type
	{	
	};

class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;

		
class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
	{	
public:
	 error_category() noexcept	
		{	
		_Addr = reinterpret_cast<uintptr_t>(this);
		}

	virtual ~error_category() noexcept
		{	
		}

	virtual const char *name() const noexcept = 0;

	virtual string message(int _Errval) const = 0;

	virtual error_condition
		default_error_condition(int _Errval) const noexcept;

	virtual bool equivalent(int _Errval,
		const error_condition& _Cond) const noexcept;

	virtual bool equivalent(const error_code& _Code,
		int _Errval) const noexcept;

	bool operator==(const error_category& _Right) const noexcept
		{	
		return (_Addr == _Right._Addr);
		}

	bool operator!=(const error_category& _Right) const noexcept
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_category& _Right) const noexcept
		{	
		return (_Addr < _Right._Addr);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;

protected:
	uintptr_t _Addr;

	enum : uintptr_t
		{	
		_Future_addr = 1,
		_Generic_addr = 3,
		_Iostream_addr = 5,
		_System_addr = 7
		};
	};

		
class error_code
	{	
public:
	typedef error_code _Myt;

	error_code() noexcept
		: _Myval(0),
			_Mycat(&system_category())
		{	
		}

	error_code(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_code_enum<_Enum>::value,
			void>::type>
		error_code(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_code(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_code_enum<_Enum>::value,
			error_code>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_code(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &system_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	error_condition default_error_condition() const noexcept;

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
class error_condition
	{	
public:
	typedef error_condition _Myt;

	error_condition() noexcept
		: _Myval(0),
			_Mycat(&generic_category())
		{	
		}

	error_condition(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_condition_enum<_Enum>::value,
			void>::type>
		error_condition(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_condition(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_condition_enum<_Enum>::value,
			error_condition>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_condition(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &generic_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
inline bool operator==(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

inline bool operator==(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

		
inline bool operator!=(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
inline bool operator<(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

inline bool operator<(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

		
inline error_condition
	error_category::default_error_condition(int _Errval) const noexcept
	{	
	return (error_condition(_Errval, *this));
	}

inline bool
	error_category::equivalent(int _Errval,
		const error_condition& _Cond) const noexcept
	{	
	return (default_error_condition(_Errval) == _Cond);
	}

inline bool
	error_category::equivalent(const error_code& _Code,
		int _Errval) const noexcept
	{	
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		
inline error_condition error_code::default_error_condition() const noexcept
	{	
	return (category().default_error_condition(value()));
	}

		
inline error_code make_error_code(_Errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, generic_category()));
	}

inline error_code make_error_code(_Io_errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, iostream_category()));
	}

		
inline error_condition make_error_condition(_Errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, generic_category()));
	}

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, iostream_category()));
	}

		
template<>
	struct hash<error_code>
	{	
	typedef error_code argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (hash<int>()(_Keyval.value()));
		}
	};

		
class _System_error
	: public runtime_error
	{	
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	
		if (!_Message.empty())
			_Message.append(": ");
		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
		{	
		}

	error_code _Mycode;	
	};

class system_error
	: public _System_error
	{	
private:
	typedef _System_error _Mybase;

public:
	system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	const error_code& code() const noexcept
		{	
		return (_Mycode);
		}

 

 





#line 572 "H:\\Visual Studio\\VC\\INCLUDE\\system_error"
	};

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) int __cdecl _Winerror_map(int);
__declspec(dllimport) unsigned long __cdecl _Winerror_message(
	unsigned long _Message_id, char *_Narrow, unsigned long _Size);

		
class _Generic_error_category
	: public error_category
	{	
public:
	_Generic_error_category() noexcept
		{	
		_Addr = _Generic_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("generic");
		}

	virtual string message(int _Errcode) const
		{	
		return (_Syserror_map(_Errcode));
		}
	};

		
class _Iostream_error_category
	: public _Generic_error_category
	{	
public:
	_Iostream_error_category() noexcept
		{	
		_Addr = _Iostream_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("iostream");
		}

	virtual string message(int _Errcode) const
		{	
		if (_Errcode == (int)io_errc::stream)
			return ("iostream stream error");
		else
			return (_Generic_error_category::message(_Errcode));
		}
	};

		
class _System_error_category
	: public error_category
	{	
public:
	_System_error_category() noexcept
		{	
		_Addr = _System_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("system");
		}

	virtual string message(int _Errcode) const
		{	
		const unsigned long _Size = 32767;
		string _Narrow(_Size, '\0');

		const unsigned long _Val = _Winerror_message(
			static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

		if (_Val == 0)
			return ("unknown error");

		_Narrow.resize(_Val);
		_Narrow.shrink_to_fit();
		return (_Narrow);
		}

	virtual error_condition
		default_error_condition(int _Errval) const noexcept
		{	
		int _Posv = _Winerror_map(_Errval);

		if (_Posv != 0)
			return (error_condition(_Posv, generic_category()));
		else
			return (error_condition(_Errval, system_category()));
		}
	};

template<class _Ty>
	struct _Immortalizer
	{	
	_Immortalizer()
		{	
		::new (static_cast<void *>(&_Storage)) _Ty();
		}

	~_Immortalizer() noexcept
		{	
		}

	_Immortalizer(const _Immortalizer&) = delete;
	_Immortalizer& operator=(const _Immortalizer&) = delete;

	typename aligned_union<1, _Ty>::type _Storage;
	};

template<class _Ty> inline
	_Ty& _Immortalize()
	{	
	static _Immortalizer<_Ty> _Static;
	return (*reinterpret_cast<_Ty *>(&_Static._Storage));
	}

inline const error_category& generic_category() noexcept
	{	
	return (_Immortalize<_Generic_error_category>());
	}

inline const error_category& iostream_category() noexcept
	{	
	return (_Immortalize<_Iostream_error_category>());
	}

inline const error_category& system_category() noexcept
	{	
	return (_Immortalize<_System_error_category>());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 711 "H:\\Visual Studio\\VC\\INCLUDE\\system_error"
#line 712 "H:\\Visual Studio\\VC\\INCLUDE\\system_error"





#line 9 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"

 #line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\share.h"







#pragma once



#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
	static constexpr _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static constexpr _Fmtflags uppercase = (_Fmtflags)0x0004;
	static constexpr _Fmtflags showbase = (_Fmtflags)0x0008;
	static constexpr _Fmtflags showpoint = (_Fmtflags)0x0010;
	static constexpr _Fmtflags showpos = (_Fmtflags)0x0020;
	static constexpr _Fmtflags left = (_Fmtflags)0x0040;
	static constexpr _Fmtflags right = (_Fmtflags)0x0080;
	static constexpr _Fmtflags internal = (_Fmtflags)0x0100;
	static constexpr _Fmtflags dec = (_Fmtflags)0x0200;
	static constexpr _Fmtflags oct = (_Fmtflags)0x0400;
	static constexpr _Fmtflags hex = (_Fmtflags)0x0800;
	static constexpr _Fmtflags scientific = (_Fmtflags)0x1000;
	static constexpr _Fmtflags fixed = (_Fmtflags)0x2000;

	static constexpr _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	

	static constexpr _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static constexpr _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static constexpr _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static constexpr _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static constexpr _Iostate goodbit = (_Iostate)0x0;
	static constexpr _Iostate eofbit = (_Iostate)0x1;
	static constexpr _Iostate failbit = (_Iostate)0x2;
	static constexpr _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static constexpr _Openmode in = (_Openmode)0x01;
	static constexpr _Openmode out = (_Openmode)0x02;
	static constexpr _Openmode ate = (_Openmode)0x04;
	static constexpr _Openmode app = (_Openmode)0x08;
	static constexpr _Openmode trunc = (_Openmode)0x10;
	static constexpr _Openmode _Nocreate = (_Openmode)0x40;
	static constexpr _Openmode _Noreplace = (_Openmode)0x80;
	static constexpr _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekbeg,
		_Seekcur,
		_Seekend
		};

	static constexpr _Seekdir beg = _Seekbeg;
	static constexpr _Seekdir cur = _Seekcur;
	static constexpr _Seekdir end = _Seekend;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);
	typedef unsigned int io_state, open_mode, seek_dir;

			
	class failure

		: public system_error
		{	
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}


 

 





#line 246 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"
		};

			
	class __declspec(dllimport) Init
		{	
	public:
		 Init()
			{	
			_Init_ctor(this);
			}

		 ~Init() noexcept
			{	
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	

		static  int& __cdecl _Init_cnt_func();
		};

	explicit  operator bool() const
		{	
		return (!fail());
		}

	bool  operator!() const
		{	
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			throw;
		else if (_Mystate & _Except & badbit)
			throw failure("ios_base::badbit set");
		else if (_Mystate & _Except & failbit)
			throw failure("ios_base::failbit set");
		else
			throw failure("ios_base::eofbit set");
		}

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	iostate  rdstate() const
		{	
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| ((int)_Newfmtflags & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	
		if (this != &_Other)
			{	
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	
			exceptions(_Other._Except);	
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() noexcept	
		{	
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	

	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
		{	
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			
	struct _Iosarray
		: public _Crt_new_delete
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		: public _Crt_new_delete
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
		{	
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	

		if (_Ptr2 != 0)
			{	
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	
		return (*_Arr);
		}

	void  _Tidy()
		{	
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	
			_Ptr2 = _Ptr1->_Next;
			delete _Ptr1;
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	
			_Pfa2 = _Pfa1->_Next;
			delete _Pfa1;
			}
		_Calls = 0;
		}

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 647 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"
#line 648 "H:\\Visual Studio\\VC\\INCLUDE\\xiosbase"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4251)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	
	typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
	 basic_streambuf()
		: _Plocale(new locale)
		{	
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	
		}

	 basic_streambuf(const _Myt& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Elem *_Pfirst0 = pbase();
			_Elem *_Pnext0 = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst0 = eback();
			_Elem *_Gnext0 = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst0, _Pnext0, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst0, _Gnext0, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() noexcept
		{	
		delete _Plocale;
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}

	_Myt * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	
		return (sync());
		}

	int_type  sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

	void  stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}

	int_type  sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	
		}

	virtual void  _Unlock()
		{	
		}

protected:
	_Elem * eback() const
		{	
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void  _Init()
		{	
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	

	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	

protected:
	locale *_Plocale;	
	};

 

  
template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
  #line 470 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"

  



 #line 476 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, const _Elem *, _Elem>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef typename traits_type::int_type int_type;
	typedef const _Elem *pointer;

	constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()
		{	
		}

	istreambuf_iterator(istream_type& _Istr) noexcept
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	_Elem operator*() const
		{	
		if (!_Got)
			_Peek();

 


#line 513 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"

		return (_Val);
		}

	const _Elem *operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
 


#line 528 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"

		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek() const
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	
	mutable bool _Got;	
	mutable _Elem _Val;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};

		
template<class _Elem,
	class _Traits> inline
	bool  operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool  operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) noexcept
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	ostreambuf_iterator(ostream_type& _Ostr) noexcept
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt& operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

	bool failed() const noexcept
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 676 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"
#line 677 "H:\\Visual Studio\\VC\\INCLUDE\\streambuf"





#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4275)

		

 
extern "C" {
 #line 24 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

extern __declspec(dllimport) float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) __int64 __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned __int64 __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 #line 50 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

namespace std {

template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	
	size_t _Count = :: wcslen(_Ptr) + 1;

	wchar_t *_Ptrdest = (wchar_t *)calloc(_Count, sizeof (wchar_t));
#line 68 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

	if (!_Ptrdest)
		_Xbad_alloc();
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 __declspec(dllimport) static locale::id id;	

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type falsename() const
		{	
		return (do_falsename());
		}

	string_type truename() const
		{	
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() noexcept
		{	
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());
#line 178 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	

			_Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
			_Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	
		:: free((void *)_Grouping);
		:: free((void *)_Falsename);
		:: free((void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~numpunct_byname() noexcept
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get() noexcept
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

 
	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
 #line 360 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	
		;
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

 
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const __int64 _Ans = :: _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned __int64 _Ans = :: _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}
 #line 553 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		;
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		float _Ans = :: _Stofx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		;
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		double _Ans = :: _Stodx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		;
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		long double _Ans = :: _Stoldx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;

 
		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned __int64 _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned __int64):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

 



#line 647 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	
		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _Atoms[0])
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;
		bool _Sticky = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static const char _Src[] = {"0123456789-+Ee"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		char *_Leading = _Ptr;	
		*_Ptr++ = '0';	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	
		size_t _Idx;

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					{	
					++_Pten;
					if (0 < _Idx)
						_Sticky = true;
					}
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						{	
						++_Pten;
						if (0 < _Idx)
							_Sticky = true;
						}
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}
			else if (0 < _Idx)
				_Sticky = true;	

		if (_Sticky)
			{	
			char *_Px = _Ptr;
			for (; --_Px != _Leading; )
				{	
				if (*_Px == localeconv()->decimal_point[0])
					;	
				else if (*_Px != '9')
					{	
					++*_Px;
					break;
					}
				else
					*_Px = '0';	
				}

			if (_Px == _Leading)
				{	
				*_Px = '1';
				++_Pten;
				}
			}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Phex = 0;	

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				|| *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	
		else
			_Seendigit = true;	

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Phex;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Phex;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Phex;	
			if (_Phex < 0)
				*_Ptr++ = '0', ++_Phex;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	
			*_Ptr++ = 'p', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		*_Phexexp = _Phex;	
		return (0);	
		}
	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

 
	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
 #line 1196 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		;
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

 
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}
 #line 1287 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabs(_Val))
			{	
			int _Ptwo;
			(void):: frexp(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabsl(_Val))
			{	
			int _Ptwo;
			(void):: frexpl(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	
				: _Ffl == ios_base::scientific ? 'E' : 'G';	
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	
				: _Ffl == ios_base::scientific ? 'e' : 'g';	

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Count) const
		{	
		;
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		if (_Poff != _Count)
			_Groupstring[_Poff] = _Punct_fac.decimal_point();

		size_t _Off = _Poff == _Count ? _Eoff : _Poff;
		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else

			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	
		;
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 

  
template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
  #line 1575 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"

  






 #line 1584 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1589 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"
#line 1590 "H:\\Visual Studio\\VC\\INCLUDE\\xlocnum"






#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\ios"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios() noexcept
		{	
		}

	void  clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	void  setstate(iostate _State,
		bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

	void  move(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  move(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  swap(_Myt& _Right) noexcept
		{	
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		}

	 basic_ios()
		{	
		}

private:
	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	

public:
	 basic_ios(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;
	};

 

  
template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;
  #line 201 "H:\\Visual Studio\\VC\\INCLUDE\\ios"

  



 #line 207 "H:\\Visual Studio\\VC\\INCLUDE\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}

namespace tr1 {	
using ::std:: hexfloat;
}	

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 362 "H:\\Visual Studio\\VC\\INCLUDE\\ios"
#line 363 "H:\\Visual Studio\\VC\\INCLUDE\\ios"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4390)

namespace std {
		

 
 

 



 



 



#line 34 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"

 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	
		if (_Addit)
			this->_Addstd(this);	
		}

protected:
	 basic_ostream(_Myt&& _Right)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_ostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_ostream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry() noexcept
			{	
 
			if (!::std:: uncaught_exception())
				this->_Myostr._Osfx();

 

#line 138 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  opfx()
		{	
		if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  





















	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		;
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		;
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		;
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator<<(__int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned __int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 416 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 < _Count)
			{	
			;
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		if (_Myios::rdbuf() != 0)
			{	
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	
			}
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

 #pragma vtordisp(pop)	

	

  

















































 

  
template class __declspec(dllimport) basic_ostream<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >;
  #line 683 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"

  



 #line 689 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"

		

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	
	return (_Ostr << _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1032 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"
#line 1033 "H:\\Visual Studio\\VC\\INCLUDE\\ostream"





#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  







#line 41 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		this->_Addstd(this);
		}

protected:
	 basic_istream(_Myt&& _Right)
		: _Chcount(_Right._Chcount)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

public:
	 basic_istream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_istream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (this->good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	
		}

  





















	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		;
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		;
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		;
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator>>(__int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned __int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 409 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				{	
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					;
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					;
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != (numeric_limits<streamsize>::max)()
					&& --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			;
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Count && 0 < _Num)
			{	
			;
			read(_Str, _Num < _Count ? _Num : _Count);	
			}

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};

	

 #pragma vtordisp(pop)	

  






















 

  
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
  #line 928 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

  



 #line 934 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_iostream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	
		}

protected:
	 basic_iostream(_Myt&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	
		_Myios::init();
		_Myios::move(::std:: forward<_Myt>(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_iostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_iostream() noexcept
		{	
		}
	};

	

 

  
template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
  #line 997 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

  



 #line 1003 "H:\\Visual Studio\\VC\\INCLUDE\\istream"

		

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width()
			: (numeric_limits<streamsize>::max)();
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
	{	
	return (_Istr >> _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1153 "H:\\Visual Studio\\VC\\INCLUDE\\istream"
#line 1154 "H:\\Visual Studio\\VC\\INCLUDE\\istream"






#line 7 "H:\\Visual Studio\\VC\\INCLUDE\\string"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)
 #pragma warning(disable: 4172)
 #pragma warning(disable: 4455)

namespace std {
		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
		? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

		

inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: strtof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: strtold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: wcstof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: wcstold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		


template<class _Ty> inline
	string _Integral_to_string(const char *_Fmt, _Ty _Val)
	{	
	static_assert(is_integral<_Ty>::value,
		"_Ty must be integral");
	char _Buf[21];
	int _Len = :: sprintf_s(_Buf, 21, _Fmt, _Val);
	return (string(_Buf, _Len));
	}

template<class _Ty> inline
	string _Floating_to_string(const char *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scprintf(_Fmt, _Val);
	string _Str(_Len + 1, '\0');
	:: sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}

template<class _Ty> inline
	wstring _Integral_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	
	static_assert(is_integral<_Ty>::value,
		"_Ty must be integral");
	wchar_t _Buf[21];
	int _Len = :: swprintf_s(_Buf, 21, _Fmt, _Val);
	return (wstring(_Buf, _Len));
	}

template<class _Ty> inline
	wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scwprintf(_Fmt, _Val);
	wstring _Str(_Len + 1, L'\0');
	:: swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}



		
inline string to_string(int _Val)
	{	
	return (_Integral_to_string("%d", _Val));
	}

inline string to_string(unsigned int _Val)
	{	
	return (_Integral_to_string("%u", _Val));
	}

inline string to_string(long _Val)
	{	
	return (_Integral_to_string("%ld", _Val));
	}

inline string to_string(unsigned long _Val)
	{	
	return (_Integral_to_string("%lu", _Val));
	}

inline string to_string(long long _Val)
	{	
	return (_Integral_to_string("%lld", _Val));
	}

inline string to_string(unsigned long long _Val)
	{	
	return (_Integral_to_string("%llu", _Val));
	}

inline string to_string(float _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(double _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(long double _Val)
	{	
	return (_Floating_to_string("%Lf", _Val));
	}

		
inline wstring to_wstring(int _Val)
	{	
	return (_Integral_to_wstring(L"%d", _Val));
	}

inline wstring to_wstring(unsigned int _Val)
	{	
	return (_Integral_to_wstring(L"%u", _Val));
	}

inline wstring to_wstring(long _Val)
	{	
	return (_Integral_to_wstring(L"%ld", _Val));
	}

inline wstring to_wstring(unsigned long _Val)
	{	
	return (_Integral_to_wstring(L"%lu", _Val));
	}

inline wstring to_wstring(long long _Val)
	{	
	return (_Integral_to_wstring(L"%lld", _Val));
	}

inline wstring to_wstring(unsigned long long _Val)
	{	
	return (_Integral_to_wstring(L"%llu", _Val));
	}

inline wstring to_wstring(float _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(double _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(long double _Val)
	{	
	return (_Floating_to_wstring(L"%Lf", _Val));
	}

	
inline namespace literals {
inline namespace string_literals {
inline string operator "" s(const char *_Str, size_t _Len)
	{	
	return (string(_Str, _Len));
	}

inline wstring operator "" s(const wchar_t *_Str, size_t _Len)
	{	
	return (wstring(_Str, _Len));
	}

inline u16string operator "" s(const char16_t *_Str, size_t _Len)
	{	
	return (u16string(_Str, _Len));
	}

inline u32string operator "" s(const char32_t *_Str, size_t _Len)
	{	
	return (u32string(_Str, _Len));
	}
}	
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 657 "H:\\Visual Studio\\VC\\INCLUDE\\string"
#line 658 "H:\\Visual Studio\\VC\\INCLUDE\\string"





#line 3 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"




#line 8 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"
#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
































#line 34 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


#line 37 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"
#pragma once
#line 25 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"
#pragma once
#line 25 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"



#line 29 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"


























































#pragma warning(pop)
#line 89 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"
#line 90 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"

#line 92 "E:\\sdk\\include\\10.0.16299.0\\shared\\winpackagefamily.h"
#line 27 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"





























































#line 89 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"

















































#line 143 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"



#line 147 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"






#line 154 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"





#line 160 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"



#line 164 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"











#line 176 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"






































 

















#line 233 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"



#pragma warning(pop)
#line 238 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"
#line 239 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"

#line 241 "E:\\sdk\\include\\10.0.16299.0\\shared\\winapifamily.h"
#line 2 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"




















#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



















#pragma warning(push)
#pragma warning(disable:4668) 
#line 23 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"
#pragma warning(disable:4001) 
#line 25 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#pragma once

















































































































































































#line 205 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"











#line 217 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"






#line 224 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"


#line 227 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#line 231 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"
#line 232 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"







#line 240 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"
#line 241 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"






#line 248 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 250 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 252 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 254 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 256 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 258 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 260 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 262 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"


#line 265 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"
#line 266 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"








#line 275 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#line 279 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#line 283 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#line 287 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#line 291 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#line 295 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 297 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"



#pragma warning(pop)


#line 304 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"
#line 305 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 307 "E:\\sdk\\include\\10.0.16299.0\\shared\\sdkddkver.h"

#line 23 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"





#pragma once
#line 30 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#pragma region Application Family or OneCore Family



















































#line 84 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"




















#line 105 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"






#line 112 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#line 116 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#line 120 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#line 124 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#line 128 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#line 132 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"





#line 138 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"




#line 143 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 144 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"







#line 152 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 153 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 160 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#pragma warning(push)
#line 163 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 167 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\excpt.h"








#pragma once


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 13 "H:\\Visual Studio\\VC\\INCLUDE\\excpt.h"

__pragma(pack(push, 8)) extern "C" {




typedef enum _EXCEPTION_DISPOSITION
{
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;

















    

        struct _EXCEPTION_RECORD;
        struct _CONTEXT;
        struct _DISPATCHER_CONTEXT;

        __declspec(dllimport) EXCEPTION_DISPOSITION __C_specific_handler(
                 struct _EXCEPTION_RECORD*   ExceptionRecord,
                 void*                       EstablisherFrame,
              struct _CONTEXT*            ContextRecord,
              struct _DISPATCHER_CONTEXT* DispatcherContext
            );

    #line 57 "H:\\Visual Studio\\VC\\INCLUDE\\excpt.h"
#line 58 "H:\\Visual Studio\\VC\\INCLUDE\\excpt.h"











unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);










} __pragma(pack(pop))
#line 168 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\stdarg.h"







#pragma once


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\stdarg.h"

__pragma(pack(push, 8)) extern "C" {










} __pragma(pack(pop))
#line 169 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 170 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"













#pragma once


extern "C" {
#line 19 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"





#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"











#pragma once

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"
















#pragma once
#line 19 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"


#pragma warning(push)
#pragma warning(disable:4668) 
#line 24 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"



 

#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"
  
 #line 32 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

 



  
 #line 39 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

 
  
  
 #line 44 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

#line 46 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"




















#line 67 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"


extern "C" {
#line 71 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"




























#line 100 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"












#line 113 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"






































































































#line 216 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"
#line 217 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"






































































































#line 320 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"



























































#line 380 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"























































































#line 468 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"



















#line 488 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"





#line 494 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"


#line 497 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"




































































#line 566 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"










#line 577 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"






























#line 608 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"
















#line 625 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

















#line 643 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"


}
#line 647 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"



























#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"




























#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"





























































































































































#pragma once
#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_undef.h"








































































































































































































































































































































































































































































#line 189 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"











































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1065 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"
































































#line 1130 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"






















































#line 1185 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"
#line 1186 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"
#line 1187 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings_strict.h"

#line 675 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"
#line 676 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

















#line 694 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"




























































































































#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\sdv_driverspecs.h"





















#line 23 "e:\\sdk\\include\\10.0.16299.0\\shared\\sdv_driverspecs.h"
#line 126 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"



#pragma once
#line 131 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"


extern "C" {
#line 135 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"























































































































#line 255 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"

    
    
    
    
    
    
    
    
    
    
    

    
    

#line 272 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"

    
    
    



    
    
    
    
    

    
    
    
    
    
    
    

    
    
    
    



    
    


    
    
    
    
    
    
    
    
    
    
    
    


    
    


    
    


    
    



    
    









    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    


    


    
    
    
    
    

    


    
    
    
    
    

    


    
    
    
    
    

    


    
    
    
    
    


    




    
    
    
    
    

    


    
    
    
    
    


    


    
    
    
    
    
    

    


    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    


    
    

    
    
    
    

    

    
    
    

    

    
    
    
    
    
    
    
    
    
    
    
    

    
    


    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    


    
    
    
    
     
    

    
    
        
        
        
        
    
    
    
    
    
    

    
    
    

    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    

    

    
    
    
    
    
    
    
    
    
    
    
#line 699 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"
    
#line 701 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"
    


    
    
    
    
    
    


    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    
    
    
    
    

    
    

    
    

    
    
    
    
    
    


    
    
    

    
	

    
    


    
    


    
    
    


    
    
    


    
    











































































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

#line 887 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"

    
    
    

    
    
    


}
#line 899 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"

#line 901 "E:\\sdk\\include\\10.0.16299.0\\shared\\driverspecs.h"


#line 696 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"












#line 709 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"


#pragma warning(pop)
#line 713 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

#line 715 "E:\\sdk\\include\\10.0.16299.0\\shared\\specstrings.h"

#line 15 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"



#pragma region Application Family or OneCore Family





#line 25 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"
#line 26 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"













#line 40 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"


extern "C" {
#line 44 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"







typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef   char *PSZ;
#line 59 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"













#line 73 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"



#line 77 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"



#line 81 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"



#line 85 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"



#line 89 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"












#line 102 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"






#line 109 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"



#line 113 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"
#line 114 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"


























#line 141 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"




#line 146 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"
#line 147 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"







#line 155 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL            *PBOOL;
typedef BOOL             *LPBOOL;
typedef BYTE            *PBYTE;
typedef BYTE             *LPBYTE;
typedef int             *PINT;
typedef int              *LPINT;
typedef WORD            *PWORD;
typedef WORD             *LPWORD;
typedef long             *LPLONG;
typedef DWORD           *PDWORD;
typedef DWORD            *LPDWORD;
typedef void             *LPVOID;
typedef const void       *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;



#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





















#pragma warning(push)
#pragma warning(disable:4668) 
#pragma warning(disable:4820) 
#line 26 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma warning(disable:4200) 
#pragma warning(disable:4201) 
#pragma warning(disable:4214) 


extern "C" {
#line 33 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



















#line 53 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









#line 63 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 64 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









#line 74 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 81 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 82 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"






































#pragma once
#line 41 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"


extern "C" {
#line 45 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"

    
    
    

    
    
    

    

#line 57 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"
    
    
    #line 60 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"
    

#line 63 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"
    

#line 66 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    


    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
















}
#line 258 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"

#line 260 "E:\\sdk\\include\\10.0.16299.0\\shared\\kernelspecs.h"
#line 87 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 91 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





#line 97 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 99 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








#line 108 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 113 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










#line 124 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









#line 134 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 138 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

















#line 156 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





















#line 178 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"






















#pragma warning(push)
#pragma warning(disable:4668) 
#line 26 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"


 
 typedef unsigned __int64 POINTER_64_INT;
 
  
 

#line 35 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"













#line 49 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"





#line 55 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"







#line 63 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"





#pragma once
#line 70 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"


extern "C" {
#line 74 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"

typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;





typedef signed int LONG32, *PLONG32;





typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;







#line 104 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"

















#line 122 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"



    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    










#line 143 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"
#line 144 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"











typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;


__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) (ULONG_PTR) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) (LONG_PTR) h );
}

__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) (ULONG_PTR) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) (unsigned long) (ULONG_PTR) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) (LONG_PTR) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) (INT_PTR) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) (long) (LONG_PTR) p );
}

__inline
void *
IntToPtr(
    const int i
    )

{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )

{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )

{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )

{
    return( (void *)(ULONG_PTR)ul );
}






__inline
void *
Ptr32ToPtr(
    const void * __ptr32 p
    )
{
    return((void *) (ULONG_PTR) (unsigned long) p);
}

__inline
void *
Handle32ToHandle(
    const void * __ptr32 h
    )
{
    return((void *) (LONG_PTR) (long) h);
}

__inline
void * __ptr32
PtrToPtr32(
    const void *p
    )
{
    return((void * __ptr32) (unsigned long) (ULONG_PTR) p);
}



#line 328 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"




































































#line 397 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"























typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;









































#line 464 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"





typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;





typedef __int64 LONG64, *PLONG64;






typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;







typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;




}
#line 499 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"


#pragma warning(pop)
#line 503 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"

#line 505 "E:\\sdk\\include\\10.0.16299.0\\shared\\basetsd.h"
#line 180 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







#line 188 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 189 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 196 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 197 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 204 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 205 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 212 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 213 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








#line 222 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 223 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 227 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 234 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 235 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 242 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 243 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 250 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 251 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 258 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 259 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 264 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 266 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 274 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 275 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 282 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 283 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"















#line 299 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 300 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#line 307 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 308 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 313 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 315 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 316 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 321 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 323 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 324 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








#line 333 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 334 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




















#line 355 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










#line 366 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 367 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"














#line 382 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







typedef void *PVOID;
typedef void * __ptr64 PVOID64;








#line 400 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





#line 406 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
















#line 423 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;
#line 437 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 438 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






typedef wchar_t WCHAR;    



#line 449 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;

typedef   WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef   PWSTR *PZPWSTR;
typedef   const PWSTR *PCZPWSTR;
typedef   WCHAR __unaligned *LPUWSTR, *PUWSTR;
typedef   const WCHAR *LPCWSTR, *PCWSTR;
typedef   PCWSTR *PZPCWSTR;
typedef   const PCWSTR *PCZPCWSTR;
typedef   const WCHAR __unaligned *LPCUWSTR, *PCUWSTR;

typedef   WCHAR *PZZWSTR;
typedef   const WCHAR *PCZZWSTR;
typedef   WCHAR __unaligned *PUZZWSTR;
typedef   const WCHAR __unaligned *PCUZZWSTR;

typedef  WCHAR *PNZWCH;
typedef  const WCHAR *PCNZWCH;
typedef  WCHAR __unaligned *PUNZWCH;
typedef  const WCHAR __unaligned *PCUNZWCH;



typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR __unaligned *LPCUWCHAR, *PCUWCHAR;





typedef unsigned long UCSCHAR;



















typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR __unaligned *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR __unaligned *PCUUCSSTR;

typedef UCSCHAR __unaligned *PUUCSCHAR;
typedef const UCSCHAR __unaligned *PCUUCSCHAR;

#line 514 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef   CHAR *NPSTR, *LPSTR, *PSTR;
typedef   PSTR *PZPSTR;
typedef   const PSTR *PCZPSTR;
typedef   const CHAR *LPCSTR, *PCSTR;
typedef   PCSTR *PZPCSTR;
typedef   const PCSTR *PCZPCSTR;

typedef   CHAR *PZZSTR;
typedef   const CHAR *PCZZSTR;

typedef  CHAR *PNZCH;
typedef  const CHAR *PCNZCH;

































typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

#line 571 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;


#line 584 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



typedef SHORT *PSHORT;  
typedef LONG *PLONG;    








typedef struct _PROCESSOR_NUMBER {
    WORD   Group;
    BYTE  Number;
    BYTE  Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;






typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD   Group;
    WORD   Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;









#line 623 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










typedef void *HANDLE;


#line 637 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 639 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 643 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
typedef HANDLE *PHANDLE;







typedef BYTE   FCHAR;
typedef WORD   FSHORT;
typedef DWORD  FLONG;










typedef   long HRESULT;
#line 666 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 667 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




    
    
    




#line 679 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









#line 689 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"













#line 703 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




























typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      








typedef enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID
} COMPARTMENT_ID, *PCOMPARTMENT_ID;

#line 749 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
























#line 774 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;









typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;


















#line 810 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;



typedef LONGLONG USN;





#line 823 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    } ;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
    LONGLONG QuadPart;
} LARGE_INTEGER;
#line 835 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef LARGE_INTEGER *PLARGE_INTEGER;





#line 843 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } ;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
    ULONGLONG QuadPart;
} ULARGE_INTEGER;
#line 855 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef ULARGE_INTEGER *PULARGE_INTEGER;





typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;
typedef LONG RTL_REFERENCE_COUNT32, *PRTL_REFERENCE_COUNT32;









typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;


typedef ULONGLONG  DWORDLONG;
typedef DWORDLONG *PDWORDLONG;






























































































































#line 1011 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






extern "C" {
#line 1019 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








unsigned char
__cdecl
_rotl8 (
      unsigned char Value,
      unsigned char Shift
    );

unsigned short
__cdecl
_rotl16 (
      unsigned short Value,
      unsigned char Shift
    );

unsigned char
__cdecl
_rotr8 (
      unsigned char Value,
      unsigned char Shift
    );

unsigned short
__cdecl
_rotr16 (
      unsigned short Value,
      unsigned char Shift
    );

#pragma intrinsic(_rotl8)
#pragma intrinsic(_rotl16)
#pragma intrinsic(_rotr8)
#pragma intrinsic(_rotr16)

#line 1061 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








unsigned int
__cdecl
_rotl (
      unsigned int Value,
      int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
      unsigned __int64 Value,
      int Shift
    );

unsigned int
__cdecl
_rotr (
      unsigned int Value,
      int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
      unsigned __int64 Value,
      int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)

#line 1103 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


}
#line 1107 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       





typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;






typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;








typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;


#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"




















#line 22 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#line 29 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"




































#line 67 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"








typedef GUID *LPGUID;
#line 77 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"



typedef const GUID *LPCGUID;
#line 82 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"




typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;







#line 104 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"







#line 112 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 113 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"







#line 121 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 122 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"







#line 130 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 131 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"







#line 139 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 140 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"

#line 142 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"








__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}











#line 175 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"

















__inline bool operator==(const GUID & guidOne, const GUID & guidOther)
{
    return !!IsEqualGUID(guidOne,guidOther);
}

__inline bool operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
#line 202 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 203 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 204 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 205 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 206 "E:\\sdk\\include\\10.0.16299.0\\shared\\guiddef.h"
#line 1154 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




typedef struct  _OBJECTID {     
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#line 1163 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"













































































#pragma region Application Family or OneCore Family




extern "C++" 
template <typename T, size_t N>
char (*RtlpNumberOf( __unaligned T (&)[N] ))[N];



#line 1257 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion











































#line 1302 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





#line 1308 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









































#line 1350 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




























typedef
 
 
EXCEPTION_DISPOSITION
__stdcall
EXCEPTION_ROUTINE (
      struct _EXCEPTION_RECORD *ExceptionRecord,
      PVOID EstablisherFrame,
      struct _CONTEXT *ContextRecord,
      PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;















































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2303 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


























#line 2330 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


























#line 2357 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











extern "C++" {

    template <size_t S>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE;

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
    {
        typedef INT8 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
    {
        typedef INT16 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
    {
        typedef INT32 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<8>
    {
        typedef INT64 type;
    };

    
    template <class T>
    struct _ENUM_FLAG_SIZED_INTEGER
    {
        typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
    };

}





#line 2411 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"













#line 2425 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


















  




























































#line 2505 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
  
#line 2507 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 2508 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;







typedef struct __declspec(align(16)) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;





typedef struct __declspec(align(16)) _XSAVE_FORMAT {
    WORD   ControlWord;
    WORD   StatusWord;
    BYTE  TagWord;
    BYTE  Reserved1;
    WORD   ErrorOpcode;
    DWORD ErrorOffset;
    WORD   ErrorSelector;
    WORD   Reserved2;
    DWORD DataOffset;
    WORD   DataSelector;
    WORD   Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];



    M128A XmmRegisters[16];
    BYTE  Reserved4[96];






#line 2558 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

} XSAVE_FORMAT, *PXSAVE_FORMAT;



typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 CompactionMask;
    DWORD64 Reserved2[6];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct __declspec(align(16)) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
      PXSAVE_AREA Area;



#line 2583 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    PVOID Buffer;



#line 2589 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

} XSTATE_CONTEXT, *PXSTATE_CONTEXT;





typedef struct _SCOPE_TABLE_AMD64 {
    DWORD Count;
    struct {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;













extern "C" {
#line 2620 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



























 
BOOLEAN
_bittest (
      LONG const *Base,
      LONG Offset
    );

BOOLEAN
_bittestandcomplement (
      LONG *Base,
      LONG Offset
    );

BOOLEAN
_bittestandset (
      LONG *Base,
      LONG Offset
    );

BOOLEAN
_bittestandreset (
      LONG *Base,
      LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
       LONG volatile *Base,
      LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
       LONG volatile *Base,
      LONG Offset
    );

BOOLEAN
_bittest64 (
      LONG64 const *Base,
      LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
      LONG64 *Base,
      LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
      LONG64 *Base,
      LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
      LONG64 *Base,
      LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
       LONG64 volatile *Base,
      LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
       LONG64 volatile *Base,
      LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)










 
BOOLEAN
_BitScanForward (
      DWORD *Index,
      DWORD Mask
    );

 
BOOLEAN
_BitScanReverse (
      DWORD *Index,
      DWORD Mask
    );

 
BOOLEAN
_BitScanForward64 (
      DWORD *Index,
      DWORD64 Mask
    );

 
BOOLEAN
_BitScanReverse64 (
      DWORD *Index,
      DWORD64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)













































































































SHORT
_InterlockedIncrement16 (
       SHORT volatile *Addend
    );

SHORT
_InterlockedDecrement16 (
       SHORT volatile *Addend
    );

SHORT
_InterlockedCompareExchange16 (
       SHORT volatile *Destination,
      SHORT ExChange,
      SHORT Comperand
    );

LONG
_InterlockedAnd (
       LONG volatile *Destination,
      LONG Value
    );

LONG
_InterlockedOr (
       LONG volatile *Destination,
      LONG Value
    );

LONG
_InterlockedXor (
       LONG volatile *Destination,
      LONG Value
    );

LONG64
_InterlockedAnd64 (
       LONG64 volatile *Destination,
      LONG64 Value
    );

LONG64
_InterlockedOr64 (
       LONG64 volatile *Destination,
      LONG64 Value
    );

LONG64
_InterlockedXor64 (
       LONG64 volatile *Destination,
      LONG64 Value
    );

LONG
_InterlockedIncrement (
       LONG volatile *Addend
    );

LONG
_InterlockedDecrement (
       LONG volatile *Addend
    );

LONG
_InterlockedExchange (
       LONG volatile *Target,
      LONG Value
    );

LONG
_InterlockedExchangeAdd (
       LONG volatile *Addend,
      LONG Value
    );



__forceinline
LONG
_InlineInterlockedAdd (
       LONG volatile *Addend,
      LONG Value
    )

{
    return _InterlockedExchangeAdd(Addend, Value) + Value;
}

#line 2973 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

LONG
_InterlockedCompareExchange (
       LONG volatile *Destination,
      LONG ExChange,
      LONG Comperand
    );

LONG64
_InterlockedIncrement64 (
       LONG64 volatile *Addend
    );

LONG64
_InterlockedDecrement64 (
       LONG64 volatile *Addend
    );

LONG64
_InterlockedExchange64 (
       LONG64 volatile *Target,
      LONG64 Value
    );

LONG64
_InterlockedExchangeAdd64 (
       LONG64 volatile *Addend,
      LONG64 Value
    );



__forceinline
LONG64
_InlineInterlockedAdd64 (
       LONG64 volatile *Addend,
      LONG64 Value
    )

{
    return _InterlockedExchangeAdd64(Addend, Value) + Value;
}

#line 3017 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

LONG64
_InterlockedCompareExchange64 (
       LONG64 volatile *Destination,
      LONG64 ExChange,
      LONG64 Comperand
    );

BOOLEAN
_InterlockedCompareExchange128 (
       LONG64 volatile *Destination,
      LONG64 ExchangeHigh,
      LONG64 ExchangeLow,
      LONG64 *ComparandResult
    );

  PVOID
_InterlockedCompareExchangePointer (
      
#line 3038 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
     PVOID volatile *Destination,
      PVOID Exchange,
      PVOID Comperand
    );

  PVOID
_InterlockedExchangePointer(
      
#line 3048 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
     PVOID volatile *Target,
      PVOID Value
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)



#pragma intrinsic(_InterlockedCompareExchange128)

#line 3077 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)






CHAR
_InterlockedExchange8 (
       CHAR volatile *Target,
      CHAR Value
    );

SHORT
_InterlockedExchange16 (
       SHORT volatile *Destination,
      SHORT ExChange
    );

#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)

#line 3102 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











char
_InterlockedExchangeAdd8 (
       char volatile * _Addend,
      char _Value
    );

char
_InterlockedAnd8 (
       char volatile *Destination,
      char Value
    );

char
_InterlockedOr8 (
       char volatile *Destination,
      char Value
    );

char
_InterlockedXor8 (
       char volatile *Destination,
      char Value
    );

SHORT
_InterlockedAnd16(
       SHORT volatile *Destination,
      SHORT Value
    );

SHORT
_InterlockedOr16(
       SHORT volatile *Destination,
      SHORT Value
    );

SHORT
_InterlockedXor16(
       SHORT volatile *Destination,
      SHORT Value
    );

#pragma intrinsic (_InterlockedExchangeAdd8)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)

#line 3164 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









void
__cpuidex (
    int CPUInfo[4],
    int Function,
    int SubLeaf
    );

#pragma intrinsic(__cpuidex)









void
_mm_clflush (
      void const *Address
    );

#pragma intrinsic(_mm_clflush)




void
_ReadWriteBarrier (
    void
    );

#pragma intrinsic(_ReadWriteBarrier)

















void
__faststorefence (
    void
    );




void
_mm_lfence (
    void
    );

void
_mm_mfence (
    void
    );

void
_mm_sfence (
    void
    );

void
_mm_pause (
    void
    );

void
_mm_prefetch (
      CHAR const *a,
      int sel
    );

void
_m_prefetchw (
      volatile const void *Source
    );













#pragma intrinsic(__faststorefence)




#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)























unsigned int
_mm_getcsr (
    void
    );

void
_mm_setcsr (
      unsigned int MxCsr
    );

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)







unsigned __int32
__getcallerseflags (
    void
    );

#pragma intrinsic(__getcallerseflags)







DWORD
__segmentlimit (
      DWORD Selector
    );

#pragma intrinsic(__segmentlimit)







DWORD64
__readpmc (
      DWORD Counter
    );

#pragma intrinsic(__readpmc)







DWORD64
__rdtsc (
    void
    );

#pragma intrinsic(__rdtsc)





void
__movsb (
      PBYTE  Destination,
      BYTE  const *Source,
      SIZE_T Count
    );

void
__movsw (
      PWORD   Destination,
      WORD   const *Source,
      SIZE_T Count
    );

void
__movsd (
      PDWORD Destination,
      DWORD const *Source,
      SIZE_T Count
    );

void
__movsq (
      PDWORD64 Destination,
      DWORD64 const *Source,
      SIZE_T Count
    );

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)





void
__stosb (
      PBYTE  Destination,
      BYTE  Value,
      SIZE_T Count
    );

void
__stosw (
      PWORD   Destination,
      WORD   Value,
      SIZE_T Count
    );

void
__stosd (
      PDWORD Destination,
      DWORD Value,
      SIZE_T Count
    );

void
__stosq (
      PDWORD64 Destination,
      DWORD64 Value,
      SIZE_T Count
    );

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)








LONGLONG
__mulh (
      LONG64 Multiplier,
      LONG64 Multiplicand
    );

ULONGLONG
__umulh (
      DWORD64 Multiplier,
      DWORD64 Multiplicand
    );

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)







DWORD64
__popcnt64 (
      DWORD64 operand
    );



#pragma intrinsic(__popcnt64)

#line 3485 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








DWORD64
__shiftleft128 (
      DWORD64 LowPart,
      DWORD64 HighPart,
      BYTE  Shift
    );

DWORD64
__shiftright128 (
      DWORD64 LowPart,
      DWORD64 HighPart,
      BYTE  Shift
    );

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)







LONG64
_mul128 (
      LONG64 Multiplier,
      LONG64 Multiplicand,
      LONG64 *HighProduct
    );

#pragma intrinsic(_mul128)





DWORD64
_umul128 (
      DWORD64 Multiplier,
      DWORD64 Multiplicand,
      DWORD64 *HighProduct
    );

#pragma intrinsic(_umul128)

#line 3539 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

__forceinline
LONG64
MultiplyExtract128 (
      LONG64 Multiplier,
      LONG64 Multiplicand,
      BYTE  Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    DWORD64 uhighProduct;
    DWORD64 ulowProduct;

    lowProduct = _mul128(Multiplier, Multiplicand, &highProduct);
    negate = 0;
    uhighProduct = (DWORD64)highProduct;
    ulowProduct = (DWORD64)lowProduct;
    if (highProduct < 0) {
        negate = 1;
        uhighProduct = (DWORD64)(-highProduct);
        ulowProduct = (DWORD64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64)__shiftright128(ulowProduct, uhighProduct, Shift);
    if (negate != 0) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}

__forceinline
DWORD64
UnsignedMultiplyExtract128 (
      DWORD64 Multiplier,
      DWORD64 Multiplicand,
      BYTE  Shift
    )

{

    DWORD64 extractedProduct;
    DWORD64 highProduct;
    DWORD64 lowProduct;

    lowProduct = _umul128(Multiplier, Multiplicand, &highProduct);
    extractedProduct = __shiftright128(lowProduct, highProduct, Shift);
    return extractedProduct;
}





BYTE 
__readgsbyte (
      DWORD Offset
    );

WORD  
__readgsword (
      DWORD Offset
    );

DWORD
__readgsdword (
      DWORD Offset
    );

DWORD64
__readgsqword (
      DWORD Offset
    );

void
__writegsbyte (
      DWORD Offset,
      BYTE  Data
    );

void
__writegsword (
      DWORD Offset,
      WORD   Data
    );

void
__writegsdword (
      DWORD Offset,
      DWORD Data
    );

void
__writegsqword (
      DWORD Offset,
      DWORD64 Data
    );

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)



void
__incgsbyte (
      DWORD Offset
    );

void
__addgsbyte (
      DWORD Offset,
      BYTE  Value
    );

void
__incgsword (
      DWORD Offset
    );

void
__addgsword (
      DWORD Offset,
      WORD   Value
    );

void
__incgsdword (
      DWORD Offset
    );

void
__addgsdword (
      DWORD Offset,
      DWORD Value
    );

void
__incgsqword (
      DWORD Offset
    );

void
__addgsqword (
      DWORD Offset,
      DWORD64 Value
    );










#line 3710 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 3712 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



}
#line 3717 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 3719 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










































#line 3762 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








#line 3771 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"












typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;




































typedef struct __declspec(align(16)) _CONTEXT {

    
    
    
    
    
    

    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;

    
    
    

    DWORD ContextFlags;
    DWORD MxCsr;

    
    
    

    WORD   SegCs;
    WORD   SegDs;
    WORD   SegEs;
    WORD   SegFs;
    WORD   SegGs;
    WORD   SegSs;
    DWORD EFlags;

    
    
    

    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;

    
    
    

    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;

    
    
    

    DWORD64 Rip;

    
    
    

    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        } ;
    } ;

    
    
    

    M128A VectorRegister[26];
    DWORD64 VectorControl;

    
    
    

    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
} CONTEXT, *PCONTEXT;






typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
typedef SCOPE_TABLE_AMD64 SCOPE_TABLE, *PSCOPE_TABLE;




















typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE {
    DWORD Count;
    BYTE  LocalHint;
    BYTE  GlobalHint;
    BYTE  Search;
    BYTE  Once;
    DWORD64 LowAddress;
    DWORD64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[12];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;





typedef
 
PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK (
      DWORD64 ControlPc,
      PVOID Context
    );
typedef GET_RUNTIME_FUNCTION_CALLBACK *PGET_RUNTIME_FUNCTION_CALLBACK;

typedef
 
DWORD   
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
      HANDLE Process,
      PVOID TableAddress,
      PDWORD Entries,
      PRUNTIME_FUNCTION* Functions
    );
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK *POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;








typedef struct _DISPATCHER_CONTEXT {
    DWORD64 ControlPc;
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    DWORD64 EstablisherFrame;
    DWORD64 TargetIp;
    PCONTEXT ContextRecord;
    PEXCEPTION_ROUTINE LanguageHandler;
    PVOID HandlerData;
    PUNWIND_HISTORY_TABLE HistoryTable;
    DWORD ScopeIndex;
    DWORD Fill0;
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;





struct _EXCEPTION_POINTERS;
typedef
LONG
(*PEXCEPTION_FILTER) (
    struct _EXCEPTION_POINTERS *ExceptionPointers,
    PVOID EstablisherFrame
    );

typedef
void
(*PTERMINATION_HANDLER) (
    BOOLEAN _abnormal_termination,
    PVOID EstablisherFrame
    );






typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    union {
        PM128A FloatingContext[16];
        struct {
            PM128A Xmm0;
            PM128A Xmm1;
            PM128A Xmm2;
            PM128A Xmm3;
            PM128A Xmm4;
            PM128A Xmm5;
            PM128A Xmm6;
            PM128A Xmm7;
            PM128A Xmm8;
            PM128A Xmm9;
            PM128A Xmm10;
            PM128A Xmm11;
            PM128A Xmm12;
            PM128A Xmm13;
            PM128A Xmm14;
            PM128A Xmm15;
        } ;
    } ;

    union {
        PDWORD64 IntegerContext[16];
        struct {
            PDWORD64 Rax;
            PDWORD64 Rcx;
            PDWORD64 Rdx;
            PDWORD64 Rbx;
            PDWORD64 Rsp;
            PDWORD64 Rbp;
            PDWORD64 Rsi;
            PDWORD64 Rdi;
            PDWORD64 R8;
            PDWORD64 R9;
            PDWORD64 R10;
            PDWORD64 R11;
            PDWORD64 R12;
            PDWORD64 R13;
            PDWORD64 R14;
            PDWORD64 R15;
        } ;
    } ;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

#line 4099 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef struct _SCOPE_TABLE_ARM {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef struct _SCOPE_TABLE_ARM64 {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM64, *PSCOPE_TABLE_ARM64;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 6244 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







typedef struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {

    PDWORD64 X19;
    PDWORD64 X20;
    PDWORD64 X21;
    PDWORD64 X22;
    PDWORD64 X23;
    PDWORD64 X24;
    PDWORD64 X25;
    PDWORD64 X26;
    PDWORD64 X27;
    PDWORD64 X28;
    PDWORD64 Fp;
    PDWORD64 Lr;

    PDWORD64 D8;
    PDWORD64 D9;
    PDWORD64 D10;
    PDWORD64 D11;
    PDWORD64 D12;
    PDWORD64 D13;
    PDWORD64 D14;
    PDWORD64 D15;

} KNONVOLATILE_CONTEXT_POINTERS_ARM64, *PKNONVOLATILE_CONTEXT_POINTERS_ARM64;





#line 6282 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"












#line 6295 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




extern "C" {
#line 6301 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


















#line 6320 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





void
__int2c (
    void
    );

#pragma intrinsic(__int2c)





#line 6337 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 6339 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










































































































#line 6446 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 6447 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


}
#line 6451 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     
            BYTE    Flags2;     
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;

#line 7643 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








extern "C" {
#line 7653 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

__forceinline
CHAR
ReadAcquire8 (
       CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
CHAR
ReadNoFence8 (
       CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease8 (
       CHAR volatile *Destination,
      CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence8 (
       CHAR volatile *Destination,
      CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
SHORT
ReadAcquire16 (
       SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
SHORT
ReadNoFence16 (
       SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease16 (
       SHORT volatile *Destination,
      SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence16 (
       SHORT volatile *Destination,
      SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG
ReadAcquire (
       LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG
ReadNoFence (
       LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease (
       LONG volatile *Destination,
      LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence (
       LONG volatile *Destination,
      LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG64
ReadAcquire64 (
       LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG64
ReadNoFence64 (
       LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )

{

    *Destination = Value;
    return;
}


}
#line 7873 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 7875 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





__forceinline
CHAR
ReadRaw8 (
       CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *(CHAR *)Source;
    return Value;
}

__forceinline
void
WriteRaw8 (
       CHAR volatile *Destination,
      CHAR Value
    )

{

    *(CHAR *)Destination = Value;
    return;
}

__forceinline
SHORT
ReadRaw16 (
       SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *(SHORT *)Source;
    return Value;
}

__forceinline
void
WriteRaw16 (
       SHORT volatile *Destination,
      SHORT Value
    )

{

    *(SHORT *)Destination = Value;
    return;
}

__forceinline
LONG
ReadRaw (
       LONG const volatile *Source
    )

{

    LONG Value;

    Value = *(LONG *)Source;
    return Value;
}

__forceinline
void
WriteRaw (
       LONG volatile *Destination,
      LONG Value
    )

{

    *(LONG *)Destination = Value;
    return;
}

__forceinline
LONG64
ReadRaw64 (
       LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *(LONG64 *)Source;
    return Value;
}

__forceinline
void
WriteRaw64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )

{

    *(LONG64 *)Destination = Value;
    return;
}





__forceinline
BYTE 
ReadUCharAcquire (
       BYTE  const volatile *Source
    )

{

    return (BYTE )ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE 
ReadUCharNoFence (
       BYTE  const volatile *Source
    )

{

    return (BYTE )ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE 
ReadBooleanAcquire (
       BOOLEAN const volatile *Source
    )

{

    return (BOOLEAN)ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE 
ReadBooleanNoFence (
       BOOLEAN const volatile *Source
    )

{

    return (BOOLEAN)ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE 
ReadUCharRaw (
       BYTE  const volatile *Source
    )

{

    return (BYTE )ReadRaw8((PCHAR)Source);
}

__forceinline
void
WriteUCharRelease (
       BYTE  volatile *Destination,
      BYTE  Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharNoFence (
       BYTE  volatile *Destination,
      BYTE  Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteBooleanRelease (
       BOOLEAN volatile *Destination,
      BOOLEAN Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteBooleanNoFence (
       BOOLEAN volatile *Destination,
      BOOLEAN Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharRaw (
       BYTE  volatile *Destination,
      BYTE  Value
    )

{

    WriteRaw8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
WORD  
ReadUShortAcquire (
       WORD   const volatile *Source
    )

{

    return (WORD  )ReadAcquire16((PSHORT)Source);
}

__forceinline
WORD  
ReadUShortNoFence (
       WORD   const volatile *Source
    )

{

    return (WORD  )ReadNoFence16((PSHORT)Source);
}

__forceinline
WORD  
ReadUShortRaw (
       WORD   const volatile *Source
    )

{

    return (WORD  )ReadRaw16((PSHORT)Source);
}

__forceinline
void
WriteUShortRelease (
       WORD   volatile *Destination,
      WORD   Value
    )

{

    WriteRelease16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortNoFence (
       WORD   volatile *Destination,
      WORD   Value
    )

{

    WriteNoFence16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortRaw (
       WORD   volatile *Destination,
      WORD   Value
    )

{

    WriteRaw16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
DWORD
ReadULongAcquire (
       DWORD const volatile *Source
    )

{

    return (DWORD)ReadAcquire((PLONG)Source);
}

__forceinline
DWORD
ReadULongNoFence (
       DWORD const volatile *Source
    )

{

    return (DWORD)ReadNoFence((PLONG)Source);
}

__forceinline
DWORD
ReadULongRaw (
       DWORD const volatile *Source
    )

{

    return (DWORD)ReadRaw((PLONG)Source);
}

__forceinline
void
WriteULongRelease (
       DWORD volatile *Destination,
      DWORD Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongNoFence (
       DWORD volatile *Destination,
      DWORD Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongRaw (
       DWORD volatile *Destination,
      DWORD Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
DWORD64
ReadULong64Acquire (
       DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadAcquire64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64NoFence (
       DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadNoFence64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64Raw (
       DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WriteULong64Release (
       DWORD64 volatile *Destination,
      DWORD64 Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64NoFence (
       DWORD64 volatile *Destination,
      DWORD64 Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64Raw (
       DWORD64 volatile *Destination,
      DWORD64 Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}















































































































#line 8439 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

__forceinline
PVOID
ReadPointerAcquire (
       PVOID const volatile *Source
    )

{

    return (PVOID)ReadAcquire64((PLONG64)Source);
}

__forceinline
PVOID
ReadPointerNoFence (
       PVOID const volatile *Source
    )

{

    return (PVOID)ReadNoFence64((PLONG64)Source);
}

__forceinline
PVOID
ReadPointerRaw (
       PVOID const volatile *Source
    )

{

    return (PVOID)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WritePointerRelease (
       PVOID volatile *Destination,
      PVOID Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WritePointerNoFence (
       PVOID volatile *Destination,
      PVOID Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WritePointerRaw (
       PVOID volatile *Destination,
      PVOID Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}

























#line 8537 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 8539 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#line 8542 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


























#line 8569 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80];
    DWORD   Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 8593 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











typedef struct _WOW64_CONTEXT {

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    DWORD ContextFlags;

    
    
    
    
    

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    
    
    
    

    WOW64_FLOATING_SAVE_AREA FloatSave;

    
    
    
    

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    
    
    
    

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    
    
    
    

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              
    DWORD   EFlags;             
    DWORD   Esp;
    DWORD   SegSs;

    
    
    
    
    

    BYTE    ExtendedRegisters[512];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 8693 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef struct _WOW64_LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     
            BYTE    Flags2;     
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;






















typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;





typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;


















#line 8803 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     
typedef PVOID PCLAIMS_BLOB;     








































typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

























































typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;












#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 8927 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 8936 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


































typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
#line 8974 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1];
#line 8987 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
} SID, *PISID;
#line 8989 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





                                                























typedef union _SE_SID {
    SID Sid;
    BYTE  Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
} SE_SID, *PSE_SID;

#line 9024 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    SidTypeLogonSession
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {



    PSID Sid;
#line 9046 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;


typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;














































































































































































































































































































































































































typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup            = 78,
    WinMediumPlusLabelSid                       = 79,
    WinLocalLogonSid                            = 80,
    WinConsoleLogonSid                          = 81,
    WinThisOrganizationCertificateSid           = 82,
    WinApplicationPackageAuthoritySid           = 83,
    WinBuiltinAnyPackageSid                     = 84,
    WinCapabilityInternetClientSid              = 85,
    WinCapabilityInternetClientServerSid        = 86,
    WinCapabilityPrivateNetworkClientServerSid  = 87,
    WinCapabilityPicturesLibrarySid             = 88,
    WinCapabilityVideosLibrarySid               = 89,
    WinCapabilityMusicLibrarySid                = 90,
    WinCapabilityDocumentsLibrarySid            = 91,
    WinCapabilitySharedUserCertificatesSid      = 92,
    WinCapabilityEnterpriseAuthenticationSid    = 93,
    WinCapabilityRemovableStorageSid            = 94,
    WinBuiltinRDSRemoteAccessServersSid         = 95,
    WinBuiltinRDSEndpointServersSid             = 96,
    WinBuiltinRDSManagementServersSid           = 97,
    WinUserModeDriversSid                       = 98,
    WinBuiltinHyperVAdminsSid                   = 99,
    WinAccountCloneableControllersSid           = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid          = 102,
    WinAuthenticationAuthorityAssertedSid       = 103,
    WinAuthenticationServiceAssertedSid         = 104,
    WinLocalAccountSid                          = 105,
    WinLocalAccountAndAdministratorSid          = 106,
    WinAccountProtectedUsersSid                 = 107,
    WinCapabilityAppointmentsSid                = 108,
    WinCapabilityContactsSid                    = 109,
    WinAccountDefaultSystemManagedSid           = 110,
    WinBuiltinDefaultSystemManagedGroupSid      = 111,
    WinBuiltinStorageReplicaAdminsSid           = 112,
    WinAccountKeyAdminsSid                      = 113,
    WinAccountEnterpriseKeyAdminsSid            = 114,
    WinAuthenticationKeyTrustSid                = 115,
    WinAuthenticationKeyPropertyMFASid          = 116,
    WinAuthenticationKeyPropertyAttestationSid  = 117,
    WinAuthenticationFreshKeyAuthSid            = 118,
} WELL_KNOWN_SID_TYPE;
































































































typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;






















typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;



























































































































typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;

typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;

typedef struct _SYSTEM_ACCESS_FILTER_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_ACCESS_FILTER_ACE, *PSYSTEM_ACCESS_FILTER_ACE;

















typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;






typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;















typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;






typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;





typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


























typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

























































































typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE  Revision;
    BYTE  Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

   
typedef struct _SECURITY_OBJECT_AI_PARAMS {
    DWORD Size;             
    DWORD ConstraintMask;
} SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;



















































typedef struct _OBJECT_TYPE_LIST {
    WORD   Level;
    WORD   Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;















typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;


















































typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;
















typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone                    = 0x00000000,   

    
    
    
    
    
    AccessReasonAllowedAce                  = 0x00010000,   
    AccessReasonDeniedAce                   = 0x00020000,   

    AccessReasonAllowedParentAce            = 0x00030000,   
    AccessReasonDeniedParentAce             = 0x00040000,   

    AccessReasonNotGrantedByCape            = 0x00050000,   
    AccessReasonNotGrantedByParentCape      = 0x00060000,   

    AccessReasonNotGrantedToAppContainer    = 0x00070000,   

    AccessReasonMissingPrivilege            = 0x00100000,
    AccessReasonFromPrivilege               = 0x00200000,


    AccessReasonIntegrityLevel              = 0x00300000,

    AccessReasonOwnership                   = 0x00400000,

    AccessReasonNullDacl                    = 0x00500000,
    AccessReasonEmptyDacl                   = 0x00600000,

    AccessReasonNoSD                        = 0x00700000,
    AccessReasonNoGrant                     = 0x00800000,   

    AccessReasonTrustLabel                  = 0x00900000,   

    AccessReasonFilterAce                   = 0x00a00000    
}
ACCESS_REASON_TYPE;

 












typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;


























typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;      
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount;  
    PACCESS_MASK GrantedAccess;
    PDWORD    AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;












































































typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;













































#line 10589 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






















#line 10612 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;







typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;






typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    TokenPrivateNameSpace,
    TokenSingletonAttributes,
    TokenBnoIsolation,
    TokenChildProcessFlags,
    MaxTokenInfoClass  
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;





typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;



typedef struct _SE_TOKEN_USER {
    union {
        TOKEN_USER TokenUser;
        SID_AND_ATTRIBUTES User;
    } ;

    union {
        SID Sid;
        BYTE  Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
    } ;

} SE_TOKEN_USER , PSE_TOKEN_USER;



#line 10717 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;



    SID_AND_ATTRIBUTES Groups[1];
#line 10726 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
} TOKEN_GROUPS, *PTOKEN_GROUPS;

typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;



#line 10741 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_USER_CLAIMS {
    PCLAIMS_BLOB UserClaims;
} TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;

typedef struct _TOKEN_DEVICE_CLAIMS {
    PCLAIMS_BLOB DeviceClaims;
} TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;










#line 10794 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef PVOID PSECURITY_ATTRIBUTES_OPAQUE;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
    DWORD AppContainerNumber;
    PSID PackageSid;
    PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    PSID TrustLevelSid;
    PSECURITY_ATTRIBUTES_OPAQUE SecurityAttributes;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;







typedef struct _TOKEN_AUDIT_POLICY {
    BYTE  PerUserPolicy[(((59)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;



typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

typedef struct _TOKEN_APPCONTAINER_INFORMATION {
    PSID TokenAppContainer;
} TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;



#line 10879 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _TOKEN_SID_INFORMATION {
    PSID Sid;
} TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;

typedef struct _TOKEN_BNO_ISOLATION_INFORMATION {
    PWSTR       IsolationPrefix;
    BOOLEAN     IsolationEnabled;
} TOKEN_BNO_ISOLATION_INFORMATION, *PTOKEN_BNO_ISOLATION_INFORMATION;






























typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    DWORD64             Version;
    PWSTR               Name;
} CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;








typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    PVOID   pValue;         
    DWORD   ValueLength;    
} CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;



































































typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {

    
    
    
    

    PWSTR   Name; 

    
    
    

    WORD    ValueType;

    
    
    
    

    WORD    Reserved;

    
    
    

    DWORD   Flags;

    
    
    

    DWORD   ValueCount;

    
    
    

    union {
        PLONG64                                         pInt64;
        PDWORD64                                        pUint64;
        PWSTR                                           *ppString;
        PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE            pFqbn;
        PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE    pOctetString;
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;






typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {

    
    
    
    

    DWORD   Name;

    
    
    

    WORD    ValueType;

    
    
    
    

    WORD    Reserved;

    
    
    

    DWORD   Flags;

    
    
    

    DWORD   ValueCount;

    
    
    

    union {
        DWORD pInt64[1];
        DWORD pUint64[1];
        DWORD ppString[1];
        DWORD pFqbn[1];
        DWORD pOctetString[1];
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;





















typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {

    
    
    

    WORD    Version;

    
    
    

    WORD    Reserved;

    DWORD   AttributeCount;
    union {
        PCLAIM_SECURITY_ATTRIBUTE_V1    pAttributeV1;
    } Attribute;
} CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;








typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;







typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;






typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;






typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;






















typedef BYTE  SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;























typedef enum _SE_IMAGE_SIGNATURE_TYPE
{
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded,
    SeImageSignatureCache,
    SeImageSignatureCatalogCached,
    SeImageSignatureCatalogNotCached,
    SeImageSignatureCatalogHint,
    SeImageSignaturePackageCatalog,
} SE_IMAGE_SIGNATURE_TYPE, *PSE_IMAGE_SIGNATURE_TYPE;






typedef enum _SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
} SE_LEARNING_MODE_DATA_TYPE;



typedef struct _SECURITY_CAPABILITIES {




    PSID AppContainerSid;
    PSID_AND_ATTRIBUTES Capabilities;
#line 11260 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
    DWORD CapabilityCount;
    DWORD Reserved;
} SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;






















#line 11286 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




















#line 11307 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   
    DWORD MemberLevel;  
    DWORD Flags;        
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;




typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;

    union {
        PVOID FiberData;
        DWORD Version;
    };


#line 11347 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;




typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;


    union {
        DWORD FiberData;
        DWORD Version;
    };


#line 11369 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;


    union {
        DWORD64 FiberData;
        DWORD Version;
    };



#line 11389 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;










typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {  
    DWORD UmsVersion;   
        PVOID UmsContext;   
        PVOID UmsCompletionList;   
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES; 

typedef struct _WOW64_ARCHITECTURE_INFORMATION {
    DWORD Machine : 16;
    DWORD KernelMode : 1;
    DWORD UserMode : 1;
    DWORD Native : 1;
    DWORD Process : 1;
    DWORD ReservedZero0 : 12;
} WOW64_ARCHITECTURE_INFORMATION;














typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;







typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0   : 25;
    } ;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;               
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;             
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD  Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;




typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;






typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        } ;
    } ;
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;

typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;

typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD RaiseExceptionOnInvalidHandleReference : 1;
            DWORD HandleExceptionsPermanentlyEnabled : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableExtensionPoints : 1;
            DWORD ReservedFlags : 31;
        } ;
    } ;
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } ;
    } ;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;

typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD ReservedFlags : 29;
        } ;
    } ;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;

typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } ;
    } ;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;

typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts     : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags             : 30;
        } ;
    } ;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } ;
    } ;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD FilterId: 4;
            DWORD ReservedFlags : 28;
        } ;
    } ;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;

typedef struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableExportAddressFilter     : 1;
            DWORD AuditExportAddressFilter      : 1;

            DWORD EnableExportAddressFilterPlus : 1;
            DWORD AuditExportAddressFilterPlus  : 1;

            DWORD EnableImportAddressFilter     : 1;
            DWORD AuditImportAddressFilter      : 1;

            DWORD EnableRopStackPivot           : 1;
            DWORD AuditRopStackPivot            : 1;

            DWORD EnableRopCallerCheck          : 1;
            DWORD AuditRopCallerCheck           : 1;

            DWORD EnableRopSimExec              : 1;
            DWORD AuditRopSimExec               : 1;

            DWORD ReservedFlags                 : 20;
        } ;
    } ;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;

typedef struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoChildProcessCreation : 1;
            DWORD AuditNoChildProcessCreation : 1;
            DWORD AllowSecureProcessCreation : 1;
            DWORD ReservedFlags : 29;
        } ;
    } ;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY;


typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;


typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;





typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
} JOBOBJECT_RATE_CONTROL_TOLERANCE, *PJOBOBJECT_RATE_CONTROL_TOLERANCE;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
} JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;

typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    DWORD LimitFlags;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;

typedef struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
            CpuRateControlToleranceInterval;
    } ;

    DWORD LimitFlags;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL IoRateControlToleranceInterval;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL NetRateControlToleranceInterval;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2;


typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;

typedef struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlToleranceLimit;
    } ;

    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlToleranceLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2;


typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    DWORD ControlFlags;
    union {
        DWORD CpuRate;
        DWORD Weight;
        struct {
            WORD   MinRate;
            WORD   MaxRate;
        } ;
    } ;
} JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;





typedef enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
} JOB_OBJECT_NET_RATE_CONTROL_FLAGS;



extern "C++" { inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator | (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator |= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator & (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator &= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator ~ (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator ^ (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator ^= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } }
typedef char __C_ASSERT__[(JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS == (JOB_OBJECT_NET_RATE_CONTROL_ENABLE + JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH + JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG))?1:-1];
#line 11883 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 11885 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



typedef struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    DWORD64 MaxBandwidth;
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    BYTE  DscpTag;
} JOBOBJECT_NET_RATE_CONTROL_INFORMATION;








typedef enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE |
                                             JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME
} JOB_OBJECT_IO_RATE_CONTROL_FLAGS;



extern "C++" { inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator | (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator |= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator & (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator &= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator ~ (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator ^ (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator ^= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } }

#line 11913 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD   VolumeNameLength;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;

typedef JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1;

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD   VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD   VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
    LONG64 SoftMaxIops;
    LONG64 SoftMaxBandwidth;
    LONG64 SoftMaxTimePercent;
    LONG64 LimitExcessNotifyIops;
    LONG64 LimitExcessNotifyBandwidth;
    LONG64 LimitExcessNotifyTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;



typedef enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
} JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS;

typedef struct _JOBOBJECT_IO_ATTRIBUTION_STATS {

    ULONG_PTR IoCount;
    ULONGLONG TotalNonOverlappedQueueTime;
    ULONGLONG TotalNonOverlappedServiceTime;
    ULONGLONG TotalSize;

} JOBOBJECT_IO_ATTRIBUTION_STATS, *PJOBOBJECT_IO_ATTRIBUTION_STATS;

typedef struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    DWORD ControlFlags;

    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;

} JOBOBJECT_IO_ATTRIBUTION_INFORMATION, *PJOBOBJECT_IO_ATTRIBUTION_INFORMATION;
































































































































typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,  
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    JobObjectReserved10Information,
    JobObjectReserved11Information,
    JobObjectReserved12Information,
    JobObjectReserved13Information,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation,
    JobObjectNotificationLimitInformation2,
    JobObjectLimitViolationInformation2,
    JobObjectCreateSilo,
    JobObjectSiloBasicInformation,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;



typedef struct _SILOOBJECT_BASIC_INFORMATION {
    DWORD SiloId;
    DWORD SiloParentId;
    DWORD NumberOfProcesses;
    BOOLEAN IsInServerSilo;
    BYTE  Reserved[3];
} SILOOBJECT_BASIC_INFORMATION, *PSILOOBJECT_BASIC_INFORMATION;

typedef enum _SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED,
    SERVERSILO_SHUTTING_DOWN,
    SERVERSILO_TERMINATING,
    SERVERSILO_TERMINATED,
} SERVERSILO_STATE, *PSERVERSILO_STATE;

typedef struct _SERVERSILO_BASIC_INFORMATION {
    DWORD ServiceSessionId;
    SERVERSILO_STATE State;
    DWORD    ExitStatus;
} SERVERSILO_BASIC_INFORMATION, *PSERVERSILO_BASIC_INFORMATION;


typedef enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
} FIRMWARE_TYPE, *PFIRMWARE_TYPE;

































typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;



typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;



typedef struct _CACHE_DESCRIPTOR {
    BYTE   Level;
    BYTE   Associativity;
    WORD   LineSize;
    DWORD  Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR   ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE  Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG  Reserved[2];
    } ;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE  Flags;
    BYTE  EfficiencyClass;
    BYTE  Reserved[20];
    WORD   GroupCount;
      GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE  Level;
    BYTE  Associativity;
    WORD   LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE  MaximumProcessorCount;
    BYTE  ActiveProcessorCount;
    BYTE  Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD   MaximumGroupCount;
    WORD   ActiveGroupCount;
    BYTE  Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } ;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

typedef enum _CPU_SET_INFORMATION_TYPE {
    CpuSetInformation
} CPU_SET_INFORMATION_TYPE, *PCPU_SET_INFORMATION_TYPE;

  struct _SYSTEM_CPU_SET_INFORMATION {
    DWORD Size;
    CPU_SET_INFORMATION_TYPE Type;
    union {
        struct {
            DWORD Id;
            WORD   Group;
            BYTE  LogicalProcessorIndex;
            BYTE  CoreIndex;
            BYTE  LastLevelCacheIndex;
            BYTE  NumaNodeIndex;
            BYTE  EfficiencyClass;
            union {






                BYTE  AllFlags;
                struct {
                    BYTE  Parked : 1;
                    BYTE  Allocated : 1;
                    BYTE  AllocatedToTargetProcess : 1;
                    BYTE  RealTime : 1;
                    BYTE  ReservedFlags : 4;
                } ;
            } ;
            DWORD Reserved;
            DWORD64 AllocationTag;
        } CpuSet;
    } ;
};

typedef struct _SYSTEM_CPU_SET_INFORMATION SYSTEM_CPU_SET_INFORMATION, *PSYSTEM_CPU_SET_INFORMATION;



typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;






























































































































































typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    
    DWORD64 EnabledFeatures;

    
    DWORD64 EnabledVolatileFeatures;

    
    DWORD Size;

    
    union {
        DWORD ControlFlags;
        struct
        {
            DWORD OptimizedSave : 1;
            DWORD CompactionEnabled : 1;
        };
    };

    
    XSTATE_FEATURE Features[(64)];

    
    DWORD64 EnabledSupervisorFeatures;

    
    DWORD64 AlignedFeatures;

    
    DWORD AllFeatureSize;

    
    DWORD AllFeatures[(64)];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;



typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;



typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD     AllocationProtect;
    DWORD     __alignment1;
    ULONGLONG RegionSize;
    DWORD     State;
    DWORD     Protect;
    DWORD     Type;
    DWORD     __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;





























typedef struct _CFG_CALL_TARGET_INFO {
    ULONG_PTR Offset;
    ULONG_PTR Flags;
} CFG_CALL_TARGET_INFO, *PCFG_CALL_TARGET_INFO;











































































typedef struct _ENCLAVE_CREATE_INFO_SGX {
    BYTE  Secs[4096];
} ENCLAVE_CREATE_INFO_SGX, *PENCLAVE_CREATE_INFO_SGX;

typedef struct _ENCLAVE_INIT_INFO_SGX {
    BYTE  SigStruct[1808];
    BYTE  Reserved1[240];
    BYTE  EInitToken[304];
    BYTE  Reserved2[1744];
} ENCLAVE_INIT_INFO_SGX, *PENCLAVE_INIT_INFO_SGX;



typedef struct _ENCLAVE_CREATE_INFO_VBS {
    DWORD Flags;
    BYTE  OwnerID[32];
} ENCLAVE_CREATE_INFO_VBS, *PENCLAVE_CREATE_INFO_VBS;




typedef struct _ENCLAVE_INIT_INFO_VBS {
    DWORD Length;
    DWORD ThreadCount;
} ENCLAVE_INIT_INFO_VBS, *PENCLAVE_INIT_INFO_VBS;



typedef PVOID (ENCLAVE_TARGET_FUNCTION)(PVOID);
typedef ENCLAVE_TARGET_FUNCTION (*PENCLAVE_TARGET_FUNCTION);
typedef PENCLAVE_TARGET_FUNCTION LPENCLAVE_TARGET_FUNCTION;

#line 12747 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











































































































































typedef struct _FILE_ID_128 {                               
    BYTE  Identifier[16];                                   
} FILE_ID_128, *PFILE_ID_128;                               





typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;


typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastModificationTime;
    LARGE_INTEGER LastChangeTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER AllocatedLength;
    LARGE_INTEGER FileSize;
    DWORD FileAttributes;
    DWORD ReparsePointTag;
    LARGE_INTEGER FileId;
    LARGE_INTEGER ParentFileId;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;
#line 12919 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;













































#line 12975 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"













#line 12989 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    GUID   ReparseGuid;
    struct {
        BYTE   DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;









































































































































#line 13146 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _SCRUB_DATA_INPUT {

    
    
    

    DWORD Size;

    
    
    
    
    
    

    DWORD Flags;

    
    
    
    
    

    DWORD MaximumIos;
    
    
    
    
    
    
    
    DWORD ObjectId[4];

    
    
    

    DWORD Reserved[13];

    
    
    
    
    

    BYTE  ResumeContext[816];

} SCRUB_DATA_INPUT, *PSCRUB_DATA_INPUT;



typedef struct _SCRUB_PARITY_EXTENT {

    LONGLONG Offset;

    ULONGLONG Length;

} SCRUB_PARITY_EXTENT, *PSCRUB_PARITY_EXTENT;

typedef struct _SCRUB_PARITY_EXTENT_DATA {

    
    
    

    WORD   Size;

    
    
    

    WORD   Flags;

    
    
    

    WORD   NumberOfParityExtents;

    
    
    

    WORD   MaximumNumberOfParityExtents;

    
    
    

    SCRUB_PARITY_EXTENT ParityExtents[1];

} SCRUB_PARITY_EXTENT_DATA, *PSCRUB_PARITY_EXTENT_DATA;

#line 13241 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _SCRUB_DATA_OUTPUT {

    
    
    

    DWORD Size;

    
    
    
    
    
    
    

    DWORD Flags;

    
    
    

    DWORD Status;

    
    
    
    

    ULONGLONG ErrorFileOffset;

    
    
    
    

    ULONGLONG ErrorLength;

    
    
    

    ULONGLONG NumberOfBytesRepaired;

    
    
    

    ULONGLONG NumberOfBytesFailed;

    
    
    

    ULONGLONG InternalFileReference;



    
    
    
    
    
    

    WORD   ResumeContextLength;

    
    
    
    
    

    WORD   ParityExtentDataOffset;

    
    
    

    DWORD Reserved[5];









#line 13332 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    
    
    
    
    
    
    
    
    
    
    
    

    BYTE  ResumeContext[816];

} SCRUB_DATA_OUTPUT, *PSCRUB_DATA_OUTPUT;

#line 13351 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









typedef enum _SharedVirtualDiskSupportType
{
    
    
    
    SharedVirtualDisksUnsupported = 0,

    
    
    
    SharedVirtualDisksSupported = 1,

    
    
    
    
    SharedVirtualDiskSnapshotsSupported = 3,

    
    
    
    
    SharedVirtualDiskCDPSnapshotsSupported = 7
} SharedVirtualDiskSupportType;

typedef enum _SharedVirtualDiskHandleState
{
    
    
    
    SharedVirtualDiskHandleStateNone = 0,

    
    
    
    
    SharedVirtualDiskHandleStateFileShared = 1,

    
    
    
    
    SharedVirtualDiskHandleStateHandleShared = 3
} SharedVirtualDiskHandleState;





typedef struct _SHARED_VIRTUAL_DISK_SUPPORT {
    
    
    
    
    SharedVirtualDiskSupportType SharedVirtualDiskSupport;

    
    
    
    
    SharedVirtualDiskHandleState HandleState;
} SHARED_VIRTUAL_DISK_SUPPORT, *PSHARED_VIRTUAL_DISK_SUPPORT;







#line 13430 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



















#line 13450 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





















#line 13472 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _NETWORK_APP_INSTANCE_EA {

    
    
    
    

    GUID AppInstanceID;

    
    
    

    DWORD CsvFlags;

} NETWORK_APP_INSTANCE_EA, *PNETWORK_APP_INSTANCE_EA;

#line 13491 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 13493 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






















extern "C" const GUID  GUID_MAX_POWER_SAVINGS;






extern "C" const GUID  GUID_MIN_POWER_SAVINGS;






extern "C" const GUID  GUID_TYPICAL_POWER_SAVINGS;







extern "C" const GUID  NO_SUBGROUP_GUID;







extern "C" const GUID  ALL_POWERSCHEMES_GUID;




































extern "C" const GUID  GUID_POWERSCHEME_PERSONALITY;








extern "C" const GUID  GUID_ACTIVE_POWERSCHEME;














extern "C" const GUID  GUID_IDLE_RESILIENCY_SUBGROUP;







extern "C" const GUID  GUID_IDLE_RESILIENCY_PERIOD;





extern "C" const GUID  GUID_DEEP_SLEEP_ENABLED;








extern "C" const GUID  GUID_DEEP_SLEEP_PLATFORM_STATE;






extern "C" const GUID  GUID_DISK_COALESCING_POWERDOWN_TIMEOUT;












extern "C" const GUID  GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT;










extern "C" const GUID  GUID_VIDEO_SUBGROUP;







extern "C" const GUID  GUID_VIDEO_POWERDOWN_TIMEOUT;








extern "C" const GUID  GUID_VIDEO_ANNOYANCE_TIMEOUT;








extern "C" const GUID  GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;







extern "C" const GUID  GUID_VIDEO_DIM_TIMEOUT;







extern "C" const GUID  GUID_VIDEO_ADAPTIVE_POWERDOWN;






extern "C" const GUID  GUID_MONITOR_POWER_ON;






extern "C" const GUID  GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;






extern "C" const GUID  GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;






extern "C" const GUID  GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;







extern "C" const GUID  GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;






extern "C" const GUID  GUID_CONSOLE_DISPLAY_STATE;







extern "C" const GUID  GUID_ALLOW_DISPLAY_REQUIRED;








extern "C" const GUID  GUID_VIDEO_CONSOLE_LOCK_TIMEOUT;






extern "C" const GUID  GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP;






extern "C" const GUID  GUID_NON_ADAPTIVE_INPUT_TIMEOUT;






extern "C" const GUID  GUID_ADAPTIVE_INPUT_CONTROLLER_STATE;







extern "C" const GUID  GUID_DISK_SUBGROUP;




extern "C" const GUID  GUID_DISK_MAX_POWER;





extern "C" const GUID  GUID_DISK_POWERDOWN_TIMEOUT;






extern "C" const GUID  GUID_DISK_IDLE_TIMEOUT;








extern "C" const GUID  GUID_DISK_BURST_IGNORE_THRESHOLD;





extern "C" const GUID  GUID_DISK_ADAPTIVE_POWERDOWN;








extern "C" const GUID  GUID_SLEEP_SUBGROUP;







extern "C" const GUID  GUID_SLEEP_IDLE_THRESHOLD;





extern "C" const GUID  GUID_STANDBY_TIMEOUT;








extern "C" const GUID  GUID_UNATTEND_SLEEP_TIMEOUT;





extern "C" const GUID  GUID_HIBERNATE_TIMEOUT;





extern "C" const GUID  GUID_HIBERNATE_FASTS4_POLICY;








extern "C" const GUID  GUID_CRITICAL_POWER_TRANSITION;





extern "C" const GUID  GUID_SYSTEM_AWAYMODE;






extern "C" const GUID  GUID_ALLOW_AWAYMODE;






extern "C" const GUID  GUID_USER_PRESENCE_PREDICTION;






extern "C" const GUID  GUID_STANDBY_BUDGET_GRACE_PERIOD;






extern "C" const GUID  GUID_STANDBY_BUDGET_PERCENT;






extern "C" const GUID  GUID_STANDBY_RESERVE_GRACE_PERIOD;






extern "C" const GUID  GUID_STANDBY_RESERVE_TIME;






extern "C" const GUID  GUID_STANDBY_RESET_PERCENT;







extern "C" const GUID  GUID_ALLOW_STANDBY_STATES;






extern "C" const GUID  GUID_ALLOW_RTC_WAKE;






extern "C" const GUID  GUID_LEGACY_RTC_MITIGATION;







extern "C" const GUID  GUID_ALLOW_SYSTEM_REQUIRED;








extern "C" const GUID  GUID_POWER_SAVING_STATUS;







extern "C" const GUID  GUID_ENERGY_SAVER_SUBGROUP;






extern "C" const GUID  GUID_ENERGY_SAVER_BATTERY_THRESHOLD;






extern "C" const GUID  GUID_ENERGY_SAVER_BRIGHTNESS;






extern "C" const GUID  GUID_ENERGY_SAVER_POLICY;








extern "C" const GUID  GUID_SYSTEM_BUTTON_SUBGROUP;




















extern "C" const GUID  GUID_POWERBUTTON_ACTION;





extern "C" const GUID  GUID_SLEEPBUTTON_ACTION;






extern "C" const GUID  GUID_USERINTERFACEBUTTON_ACTION;





extern "C" const GUID  GUID_LIDCLOSE_ACTION;
extern "C" const GUID  GUID_LIDOPEN_POWERSTATE;








extern "C" const GUID  GUID_BATTERY_SUBGROUP;











extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_0;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_0;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_0;

extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_1;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_1;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_1;

extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_2;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_2;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_2;

extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_3;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_3;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_3;










extern "C" const GUID  GUID_PROCESSOR_SETTINGS_SUBGROUP;





extern "C" const GUID  GUID_PROCESSOR_THROTTLE_POLICY;

















extern "C" const GUID  GUID_PROCESSOR_THROTTLE_MAXIMUM;









extern "C" const GUID  GUID_PROCESSOR_THROTTLE_MAXIMUM_1;









extern "C" const GUID  GUID_PROCESSOR_THROTTLE_MINIMUM;









extern "C" const GUID  GUID_PROCESSOR_THROTTLE_MINIMUM_1;






extern "C" const GUID  GUID_PROCESSOR_FREQUENCY_LIMIT;
#line 14159 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  GUID_PROCESSOR_FREQUENCY_LIMIT_1;
#line 14163 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







extern "C" const GUID  GUID_PROCESSOR_ALLOW_THROTTLING;









extern "C" const GUID  GUID_PROCESSOR_IDLESTATE_POLICY;





extern "C" const GUID  GUID_PROCESSOR_PERFSTATE_POLICY;







extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1;







extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1;







extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_POLICY;








extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_POLICY_1;







extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_POLICY;








extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_POLICY_1;








extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_TIME;








extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_TIME_1;








extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_TIME;








extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_TIME_1;







extern "C" const GUID  GUID_PROCESSOR_PERF_TIME_CHECK;







extern "C" const GUID  GUID_PROCESSOR_PERF_BOOST_POLICY;
#line 14308 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










extern "C" const GUID  GUID_PROCESSOR_PERF_BOOST_MODE;
#line 14320 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
















extern "C" const GUID  GUID_PROCESSOR_PERF_AUTONOMOUS_MODE;
#line 14338 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









extern "C" const GUID  GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE;
#line 14349 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









extern "C" const GUID  GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW;
#line 14360 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








extern "C" const GUID  GUID_PROCESSOR_DUTY_CYCLING;
#line 14370 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










extern "C" const GUID  GUID_PROCESSOR_IDLE_ALLOW_SCALING;






extern "C" const GUID  GUID_PROCESSOR_IDLE_DISABLE;








extern "C" const GUID  GUID_PROCESSOR_IDLE_STATE_MAXIMUM;








extern "C" const GUID  GUID_PROCESSOR_IDLE_TIME_CHECK;








extern "C" const GUID  GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;












extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_MAX_CORES;







extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_MIN_CORES;







extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PARKING_CORE_OVERRIDE;







extern "C" const GUID  GUID_PROCESSOR_PARKING_PERF_STATE;







extern "C" const GUID  GUID_PROCESSOR_PARKING_PERF_STATE_1;







extern "C" const GUID  GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_PERF_HISTORY;







extern "C" const GUID  GUID_PROCESSOR_PERF_HISTORY_1;









extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_HISTORY;









extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_HISTORY;









extern "C" const GUID  GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY;









extern "C" const GUID  GUID_PROCESSOR_PERF_LATENCY_HINT;






extern "C" const GUID  GUID_PROCESSOR_PERF_LATENCY_HINT_PERF;







extern "C" const GUID  GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1;







extern "C" const GUID  GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK;







extern "C" const GUID  GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1;







extern "C" const GUID  GUID_PROCESSOR_DISTRIBUTE_UTILITY;










extern "C" const GUID  GUID_PROCESSOR_HETEROGENEOUS_POLICY;







extern "C" const GUID  GUID_PROCESSOR_HETERO_DECREASE_TIME;







extern "C" const GUID  GUID_PROCESSOR_HETERO_INCREASE_TIME;








extern "C" const GUID  GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_CLASS0_FLOOR_PERF;








extern "C" const GUID  GUID_PROCESSOR_CLASS1_INITIAL_PERF;






extern "C" const GUID  GUID_PROCESSOR_THREAD_SCHEDULING_POLICY;
#line 14767 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







extern "C" const GUID  GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY;
#line 14776 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







extern "C" const GUID  GUID_SYSTEM_COOLING_POLICY;









extern "C" const GUID  GUID_LOCK_CONSOLE_ON_WAKE;









extern "C" const GUID  GUID_DEVICE_IDLE_POLICY;








extern "C" const GUID  GUID_CONNECTIVITY_IN_STANDBY;









extern "C" const GUID  GUID_DISCONNECTED_STANDBY_MODE;




















extern "C" const GUID  GUID_ACDC_POWER_SOURCE;















extern "C" const GUID  GUID_LIDSWITCH_STATE_CHANGE;
















extern "C" const GUID  GUID_BATTERY_PERCENTAGE_REMAINING;












extern "C" const GUID  GUID_BATTERY_COUNT;






extern "C" const GUID  GUID_GLOBAL_USER_PRESENCE;










extern "C" const GUID  GUID_SESSION_DISPLAY_STATUS;









extern "C" const GUID  GUID_SESSION_USER_PRESENCE;






extern "C" const GUID  GUID_IDLE_BACKGROUND_TASK;






extern "C" const GUID  GUID_BACKGROUND_TASK_NOTIFICATION;







extern "C" const GUID  GUID_APPLAUNCH_BUTTON;










extern "C" const GUID  GUID_PCIEXPRESS_SETTINGS_SUBGROUP;





extern "C" const GUID  GUID_PCIEXPRESS_ASPM_POLICY;











extern "C" const GUID  GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;






extern "C" const GUID  GUID_INTSTEER_SUBGROUP;
#line 14977 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  GUID_INTSTEER_MODE;
#line 14981 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  GUID_INTSTEER_LOAD_PER_PROC_TRIGGER;
#line 14985 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  GUID_INTSTEER_TIME_UNPARK_TRIGGER;
#line 14989 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










extern "C" const GUID  GUID_MIXED_REALITY_MODE;
#line 15001 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;



typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
    PowerActionDisplayOff
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;

typedef enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
} USER_ACTIVITY_PRESENCE, *PUSER_ACTIVITY_PRESENCE;









typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;


















typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;




















typedef struct CM_Power_Data_s {
    DWORD               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    DWORD               PD_Capabilities;
    DWORD               PD_D1Latency;
    DWORD               PD_D2Latency;
    DWORD               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#line 15121 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   
    LastSleepTime,                                  
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    SystemMonitorHiberBootPowerOff,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    ProcessorIdleStatesHv,
    ProcessorPerfStatesHv,
    ProcessorPerfCapHv,
    ProcessorSetIdle,
    LogicalProcessorIdling,
    UserPresence,
    PowerSettingNotificationName,
    GetPowerSettingValue,
    IdleResiliency,
    SessionRITState,
    SessionConnectNotification,
    SessionPowerCleanup,
    SessionLockState,
    SystemHiberbootState,
    PlatformInformation,
    PdcInvocation,
    MonitorInvocation,
    FirmwareTableInformationRegistered,
    SetShutdownSelectedTime,
    SuspendResumeInvocation,
    PlmPowerRequestCreate,
    ScreenOff,
    CsDeviceNotification,
    PlatformRole,
    LastResumePerformance,
    DisplayBurst,
    ExitLatencySamplingPercentage,
    RegisterSpmPowerSettings,
    PlatformIdleStates,
    ProcessorIdleVeto,
    PlatformIdleVeto,
    SystemBatteryStatePrecise,
    ThermalEvent,
    PowerRequestActionInternal,
    BatteryDeviceState,
    PowerInformationInternal,
    ThermalStandby,
    SystemHiberFileType,
    PhysicalPowerButtonPress,
    QueryPotentialDripsConstraint,
    EnergyTrackerCreate,
    EnergyTrackerQuery,
    UpdateBlackBoxRecorder,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;





typedef enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
} POWER_USER_PRESENCE_TYPE, *PPOWER_USER_PRESENCE_TYPE;

typedef struct _POWER_USER_PRESENCE {
    POWER_USER_PRESENCE_TYPE UserPresence;
} POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;




typedef struct _POWER_SESSION_CONNECT {
    BOOLEAN Connected;  
    BOOLEAN Console;    
} POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;

typedef struct _POWER_SESSION_TIMEOUTS {
    DWORD InputTimeout;
    DWORD DisplayTimeout;
} POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;




typedef struct _POWER_SESSION_RIT_STATE {
    BOOLEAN Active;  
    DWORD LastInputTime; 
} POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;




typedef struct _POWER_SESSION_WINLOGON {
    DWORD SessionId; 
    BOOLEAN Console; 
    BOOLEAN Locked; 
} POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;




typedef struct _POWER_IDLE_RESILIENCY {
    DWORD CoalescingTimeout;
    DWORD IdleResiliencyPeriod;
} POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;




typedef enum {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonGracePeriod,
    MonitorRequestReasonPnP,
    MonitorRequestReasonDP,
    MonitorRequestReasonSxTransition,
    MonitorRequestReasonSystemIdle,
    MonitorRequestReasonNearProximity,
    MonitorRequestReasonThermalStandby,
    MonitorRequestReasonResumePdc,
    MonitorRequestReasonResumeS4,
    MonitorRequestReasonTerminal,
    MonitorRequestReasonPdcSignal,
    MonitorRequestReasonAcDcDisplayBurstSuppressed,
    MonitorRequestReasonSystemStateEntered, 
                                            
                                            
    MonitorRequestReasonWinrt,
    MonitorRequestReasonUserInputKeyboard,
    MonitorRequestReasonUserInputMouse,
    MonitorRequestReasonUserInputTouch,
    MonitorRequestReasonUserInputPen,
    MonitorRequestReasonUserInputAccelerometer,
    MonitorRequestReasonUserInputHid,
    MonitorRequestReasonUserInputPoUserPresent,
    MonitorRequestReasonUserInputSessionSwitch,
    MonitorRequestReasonUserInputInitialization,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,         
    MonitorRequestReasonPdcSignalWindowsMobileShell,            
    MonitorRequestReasonPdcSignalHeyCortana,                    
    MonitorRequestReasonPdcSignalHolographicShell,              
    MonitorRequestReasonMax
} POWER_MONITOR_REQUEST_REASON;

typedef enum _POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn
} POWER_MONITOR_REQUEST_TYPE;




typedef struct _POWER_MONITOR_INVOCATION {
    BOOLEAN Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;





typedef struct _RESUME_PERFORMANCE {
    DWORD PostTimeMs;
    ULONGLONG TotalResumeTimeMs;
    ULONGLONG ResumeCompleteTimestamp;
} RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;





typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    
    
    
    
    DWORD       Version;


    
    
    
    GUID        Guid;


    
    
    
    
    SYSTEM_POWER_CONDITION PowerCondition;

    
    
    
    DWORD       DataLength;

    
    
    
    BYTE    Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;



typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;






typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    
    
    
    
    LARGE_INTEGER       ActivationTime;

    
    
    
    DWORD               Flags;

    
    
    
    DWORD               ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;





typedef enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer, 
    PlatformRoleSlate,             
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE, *PPOWER_PLATFORM_ROLE;

















#line 15461 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _POWER_PLATFORM_INFORMATION {
    BOOLEAN AoAc;
} POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;






typedef struct {
    DWORD       Granularity;
    DWORD       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#line 15476 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



typedef struct {
    DWORD   Frequency;
    DWORD   Flags;
    DWORD   PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE  PromotePercent;
    BYTE  DemotePercent;
    BYTE  StateType;
    BYTE  Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;            
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          
    DWORD OldState;             
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          
    DWORD OldState;             
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency;            
    DWORD Power;                
    BYTE  PercentFrequency;
    BYTE  IncreaseLevel;        
    BYTE  DecreaseLevel;        
    BYTE  Type;                 
    DWORD IncreaseTime;         
    DWORD DecreaseTime;         
    DWORD64 Control;            
    DWORD64 Status;             
    DWORD HitCount;
    DWORD Reserved1;            
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         
    DWORD MaxPerfState;         
    DWORD MinPerfState;         
    DWORD LowestPerfState;      
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;   
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         
    DWORD MaxPerfState;         
    DWORD MinPerfState;         
    DWORD LowestPerfState;      
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;     
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;







typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;







typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD AbortCount;
    DWORD64 StartTime;
      PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;






























































extern "C" const GUID  PPM_PERFSTATE_CHANGE_GUID;
#line 15700 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_PERFSTATE_DOMAIN_CHANGE_GUID;
#line 15704 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_IDLESTATE_CHANGE_GUID;
#line 15708 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_PERFSTATES_DATA_GUID;
#line 15712 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_IDLESTATES_DATA_GUID;
#line 15716 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_IDLE_ACCOUNTING_GUID;
#line 15720 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_IDLE_ACCOUNTING_EX_GUID;
#line 15724 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_THERMALCONSTRAINT_GUID;
#line 15728 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_PERFMON_PERFSTATE_GUID;
#line 15732 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


extern "C" const GUID  PPM_THERMAL_POLICY_CHANGE_GUID;
#line 15736 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable:4121)

typedef struct {
    BYTE  Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)




typedef struct {
    POWER_ACTION    Action;
    DWORD           Flags;
    DWORD           EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;


































typedef struct {
    BOOLEAN                 Enable;
    BYTE                    Spare[3];
    DWORD                   BatteryLevel;
    POWER_ACTION_POLICY     PowerPolicy;
    SYSTEM_POWER_STATE      MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;








typedef struct _SYSTEM_POWER_POLICY {
    DWORD                   Revision;       

    
    POWER_ACTION_POLICY     PowerButton;
    POWER_ACTION_POLICY     SleepButton;
    POWER_ACTION_POLICY     LidClose;
    SYSTEM_POWER_STATE      LidOpenWake;
    DWORD                   Reserved;

    
    POWER_ACTION_POLICY     Idle;
    DWORD                   IdleTimeout;
    BYTE                    IdleSensitivity;

    BYTE                    DynamicThrottle;
    BYTE                    Spare2[2];

    
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;
    SYSTEM_POWER_STATE      ReducedLatencySleep;
    DWORD                   WinLogonFlags;

    DWORD                   Spare3;

    
    
    DWORD                   DozeS4Timeout;

    
    DWORD                   BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL      DischargePolicy[4];

    
    DWORD                   VideoTimeout;
    BOOLEAN                 VideoDimDisplay;
    DWORD                   VideoReserved[3];

    
    DWORD                   SpindownTimeout;

    
    BOOLEAN                 OptimizeForPower;
    BYTE                    FanThrottleTolerance;
    BYTE                    ForcedThrottle;
    BYTE                    MinThrottle;
    POWER_ACTION_POLICY     OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;










typedef struct {
    DWORD TimeCheck;
    BYTE  DemotePercent;
    BYTE  PromotePercent;
    BYTE  Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD   Revision;
    union {
        WORD   AsWORD  ;
        struct {
            WORD   AllowScaling : 1;
            WORD   Disabled : 1;
            WORD   Reserved : 14;
        } ;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;














typedef struct _PROCESSOR_POWER_POLICY_INFO {

    
    DWORD                   TimeCheck;                      
    DWORD                   DemoteLimit;                    
    DWORD                   PromoteLimit;                   

    
    BYTE                    DemotePercent;
    BYTE                    PromotePercent;
    BYTE                    Spare[2];

    
    DWORD                   AllowDemotion:1;
    DWORD                   AllowPromotion:1;
    DWORD                   Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;


typedef struct _PROCESSOR_POWER_POLICY {
    DWORD                       Revision;       

    
    BYTE                        DynamicThrottle;
    BYTE                        Spare[3];

    
    DWORD                       DisableCStates:1;
    DWORD                       Reserved:31;

    
    
    
    DWORD                       PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;





typedef struct {
    DWORD Revision;
    BYTE  MaxThrottle;
    BYTE  MinThrottle;
    BYTE  BusyAdjThreshold;
    union {
        BYTE  Spare;
        union {
            BYTE  AsBYTE ;
            struct {
                BYTE  NoDomainAccounting : 1;
                BYTE  IncreasePolicy: 2;
                BYTE  DecreasePolicy: 2;
                BYTE  Reserved : 3;
            } ;
        } Flags;
    } ;

    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;


typedef struct _ADMINISTRATOR_POWER_POLICY {

    
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;

    
    DWORD                   MinVideoTimeout;
    DWORD                   MaxVideoTimeout;

    
    DWORD                   MinSpindownTimeout;
    DWORD                   MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef enum _HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB,
    HiberFileBucket4GB,
    HiberFileBucket8GB,
    HiberFileBucket16GB,
    HiberFileBucket32GB,
    HiberFileBucketUnlimited,
    HiberFileBucketMax
} HIBERFILE_BUCKET_SIZE, *PHIBERFILE_BUCKET_SIZE;






typedef struct _HIBERFILE_BUCKET {
    DWORD64 MaxPhysicalMemory;
    DWORD PhysicalMemoryPercent[0x03];
} HIBERFILE_BUCKET, *PHIBERFILE_BUCKET;

typedef struct {
    
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;           
    BOOLEAN             SystemS5;           
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;

    
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    BYTE                ProcessorMinThrottle;




#line 16057 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
    BYTE                ProcessorMaxThrottle;
    BOOLEAN             FastSystemS4;
    BOOLEAN             Hiberboot;
    BOOLEAN             WakeAlarmPresent;
    BOOLEAN             AoAc;
#line 16063 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    
    BOOLEAN             DiskSpinDown;



#line 16070 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
    
    BYTE                HiberFileType;
    BOOLEAN             AoAcConnectivitySupported;
    BYTE                spare3[6];
#line 16075 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState; 
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[3];

    BYTE                Tag;

    DWORD               MaxCapacity;
    DWORD               RemainingCapacity;
    DWORD               Rate;
    DWORD               EstimatedTime;

    DWORD               DefaultAlert1;
    DWORD               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;










#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 16117 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 16125 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









#line 16135 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_DOS_HEADER {      
    WORD   e_magic;                     
    WORD   e_cblp;                      
    WORD   e_cp;                        
    WORD   e_crlc;                      
    WORD   e_cparhdr;                   
    WORD   e_minalloc;                  
    WORD   e_maxalloc;                  
    WORD   e_ss;                        
    WORD   e_sp;                        
    WORD   e_csum;                      
    WORD   e_ip;                        
    WORD   e_cs;                        
    WORD   e_lfarlc;                    
    WORD   e_ovno;                      
    WORD   e_res[4];                    
    WORD   e_oemid;                     
    WORD   e_oeminfo;                   
    WORD   e_res2[10];                  
    LONG   e_lfanew;                    
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      
    WORD   ne_magic;                    
    CHAR   ne_ver;                      
    CHAR   ne_rev;                      
    WORD   ne_enttab;                   
    WORD   ne_cbenttab;                 
    LONG   ne_crc;                      
    WORD   ne_flags;                    
    WORD   ne_autodata;                 
    WORD   ne_heap;                     
    WORD   ne_stack;                    
    LONG   ne_csip;                     
    LONG   ne_sssp;                     
    WORD   ne_cseg;                     
    WORD   ne_cmod;                     
    WORD   ne_cbnrestab;                
    WORD   ne_segtab;                   
    WORD   ne_rsrctab;                  
    WORD   ne_restab;                   
    WORD   ne_modtab;                   
    WORD   ne_imptab;                   
    LONG   ne_nrestab;                  
    WORD   ne_cmovent;                  
    WORD   ne_align;                    
    WORD   ne_cres;                     
    BYTE   ne_exetyp;                   
    BYTE   ne_flagsothers;              
    WORD   ne_pretthunks;               
    WORD   ne_psegrefbytes;             
    WORD   ne_swaparea;                 
    WORD   ne_expver;                   
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      
    WORD   e32_magic;                   
    BYTE   e32_border;                  
    BYTE   e32_worder;                  
    DWORD  e32_level;                   
    WORD   e32_cpu;                     
    WORD   e32_os;                      
    DWORD  e32_ver;                     
    DWORD  e32_mflags;                  
    DWORD  e32_mpages;                  
    DWORD  e32_startobj;                
    DWORD  e32_eip;                     
    DWORD  e32_stackobj;                
    DWORD  e32_esp;                     
    DWORD  e32_pagesize;                
    DWORD  e32_lastpagesize;            
    DWORD  e32_fixupsize;               
    DWORD  e32_fixupsum;                
    DWORD  e32_ldrsize;                 
    DWORD  e32_ldrsum;                  
    DWORD  e32_objtab;                  
    DWORD  e32_objcnt;                  
    DWORD  e32_objmap;                  
    DWORD  e32_itermap;                 
    DWORD  e32_rsrctab;                 
    DWORD  e32_rsrccnt;                 
    DWORD  e32_restab;                  
    DWORD  e32_enttab;                  
    DWORD  e32_dirtab;                  
    DWORD  e32_dircnt;                  
    DWORD  e32_fpagetab;                
    DWORD  e32_frectab;                 
    DWORD  e32_impmod;                  
    DWORD  e32_impmodcnt;               
    DWORD  e32_impproc;                 
    DWORD  e32_pagesum;                 
    DWORD  e32_datapage;                
    DWORD  e32_preload;                 
    DWORD  e32_nrestab;                 
    DWORD  e32_cbnrestab;               
    DWORD  e32_nressum;                 
    DWORD  e32_autodata;                
    DWORD  e32_debuginfo;               
    DWORD  e32_debuglen;                
    DWORD  e32_instpreload;             
    DWORD  e32_instdemand;              
    DWORD  e32_heapsize;                
    BYTE   e32_res3[12];                
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   
    WORD   e32_ddkver;                  
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;


#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 16247 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 16248 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;




















































 




typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;







typedef struct _IMAGE_OPTIONAL_HEADER {
    
    
    

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    
    
    

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;






typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;





#line 16435 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;


typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64                 PIMAGE_NT_HEADERS;



#line 16460 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




































































typedef struct ANON_OBJECT_HEADER {
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
    DWORD   Flags;           
    DWORD   MetaDataSize;    
    DWORD   MetaDataOffset;  
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {
   
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;         
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
    DWORD   Flags;           
    DWORD   MetaDataSize;    
    DWORD   MetaDataOffset;  

    
    DWORD   NumberOfSections; 
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;







typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[8];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

































































#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 16657 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 16658 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     
            DWORD   Long;      
        } Name;
        DWORD   LongName[2];    
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL __unaligned *PIMAGE_SYMBOL;



typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE     ShortName[8];
        struct {
            DWORD   Short;     
            DWORD   Long;      
        } Name;
        DWORD   LongName[2];    
    } N;
    DWORD   Value;
    LONG    SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX __unaligned *PIMAGE_SYMBOL_EX;
































































































#line 16795 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 16800 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





#line 16806 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 16811 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 16815 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#line 16818 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 16820 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE  bAuxType;                  
    BYTE  bReserved;                 
    DWORD SymbolTableIndex;
    BYTE  rgbReserved[12];           
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF __unaligned *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 16831 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      
        union {
            struct {
                WORD    Linenumber;             
                WORD    Size;                   
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        
    } Sym;
    struct {
        BYTE    Name[18];
    } File;
    struct {
        DWORD   Length;                         
        WORD    NumberOfRelocations;            
        WORD    NumberOfLinenumbers;            
        DWORD   CheckSum;                       
        SHORT   Number;                         
        BYTE    Selection;                      
	BYTE    bReserved;
	SHORT   HighNumber;                     
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE  rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL __unaligned *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD   WeakDefaultSymIndex;                       
        DWORD   WeakSearchType;
        BYTE    rgbReserved[12];
    } Sym;
    struct {
        BYTE    Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD   Length;                         
        WORD    NumberOfRelocations;            
        WORD    NumberOfLinenumbers;            
        DWORD   CheckSum;                       
        SHORT   Number;                         
        BYTE    Selection;                      
        BYTE    bReserved;
        SHORT   HighNumber;                     
        BYTE    rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE  rgbReserved[2];
    } ;
    struct {
        DWORD crc;
        BYTE  rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX __unaligned *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;























typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             
    } ;
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION __unaligned *PIMAGE_RELOCATION;




























































































































                                                
                                                
                                                
                                                









































































































































































































































































typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               
        DWORD   VirtualAddress;                 
    } Type;
    WORD    Linenumber;                         
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER __unaligned *PIMAGE_LINENUMBER;


#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 17348 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 17349 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;

} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION __unaligned * PIMAGE_BASE_RELOCATION;











































typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          
    BYTE     Date[12];                          
    BYTE     UserID[6];                         
    BYTE     GroupID[6];                        
    BYTE     Mode[8];                           
    BYTE     Size[10];                          
    BYTE     EndHeader[2];                      
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;











typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     
    DWORD   AddressOfNames;         
    DWORD   AddressOfNameOrdinals;  
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;





typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack8.h"























#pragma warning(disable:4103)

#pragma pack(push,8)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack8.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack8.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack8.h"
#line 17447 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  
        ULONGLONG Function;         
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 17459 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      
        DWORD Function;             
        DWORD Ordinal;
        DWORD AddressOfData;        
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;












typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;         
    ULONGLONG AddressOfCallBacks;     
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    DWORD   AddressOfIndex;             
    DWORD   AddressOfCallBacks;         
    DWORD   SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;




typedef IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;








#line 17542 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            
        DWORD   OriginalFirstThunk;         
    } ;
    DWORD   TimeDateStamp;                  
                                            
                                            
                                            

    DWORD   ForwarderChain;                 
    DWORD   Name;
    DWORD   FirstThunk;                     
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR __unaligned *PIMAGE_IMPORT_DESCRIPTOR;





typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;

} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;             
            DWORD ReservedAttributes : 31;
        } ;
    } Attributes;

    DWORD DllNameRVA;                       
    DWORD ModuleHandleRVA;                  
    DWORD ImportAddressTableRVA;            
    DWORD ImportNameTableRVA;               
    DWORD BoundImportAddressTableRVA;       
    DWORD UnloadInformationTableRVA;        
    DWORD TimeDateStamp;                    
                                            

} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR;



















typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;

} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;


















typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } ;
        DWORD   Name;
        WORD    Id;
    } ;
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        } ;
    } ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;










typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;











typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;







typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    WORD    Flags;          
    WORD    Catalog;        
    DWORD   CatalogOffset;
    DWORD   Reserved;       
} IMAGE_LOAD_CONFIG_CODE_INTEGRITY, *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY;





typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
    DWORD Version;
    DWORD Size;

} IMAGE_DYNAMIC_RELOCATION_TABLE, *PIMAGE_DYNAMIC_RELOCATION_TABLE;





#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"























#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"
#line 17726 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_DYNAMIC_RELOCATION32 {
    DWORD      Symbol;
    DWORD      BaseRelocSize;

} IMAGE_DYNAMIC_RELOCATION32, *PIMAGE_DYNAMIC_RELOCATION32;

typedef struct _IMAGE_DYNAMIC_RELOCATION64 {
    ULONGLONG  Symbol;
    DWORD      BaseRelocSize;

} IMAGE_DYNAMIC_RELOCATION64, *PIMAGE_DYNAMIC_RELOCATION64;

typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
    DWORD      HeaderSize;
    DWORD      FixupInfoSize;
    DWORD      Symbol;
    DWORD      SymbolGroup;
    DWORD      Flags;
    
    
} IMAGE_DYNAMIC_RELOCATION32_V2, *PIMAGE_DYNAMIC_RELOCATION32_V2;

typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
    DWORD      HeaderSize;
    DWORD      FixupInfoSize;
    ULONGLONG  Symbol;
    DWORD      SymbolGroup;
    DWORD      Flags;
    
    
} IMAGE_DYNAMIC_RELOCATION64_V2, *PIMAGE_DYNAMIC_RELOCATION64_V2;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 17760 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef IMAGE_DYNAMIC_RELOCATION64          IMAGE_DYNAMIC_RELOCATION;
typedef PIMAGE_DYNAMIC_RELOCATION64         PIMAGE_DYNAMIC_RELOCATION;
typedef IMAGE_DYNAMIC_RELOCATION64_V2       IMAGE_DYNAMIC_RELOCATION_V2;
typedef PIMAGE_DYNAMIC_RELOCATION64_V2      PIMAGE_DYNAMIC_RELOCATION_V2;





#line 17772 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"























#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"
#line 34 "e:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"
#line 17781 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    BYTE       PrologueByteCount;
    
} IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER __unaligned * PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;

typedef struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    DWORD      EpilogueCount;
    BYTE       EpilogueByteCount;
    BYTE       BranchDescriptorElementSize;
    WORD       BranchDescriptorCount;
    
    
} IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER __unaligned * PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 17799 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD   Size;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    DWORD   LockPrefixTable;                
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    WORD    CSDVersion;
    WORD    DependentLoadFlags;
    DWORD   EditList;                       
    DWORD   SecurityCookie;                 
    DWORD   SEHandlerTable;                 
    DWORD   SEHandlerCount;
    DWORD   GuardCFCheckFunctionPointer;    
    DWORD   GuardCFDispatchFunctionPointer; 
    DWORD   GuardCFFunctionTable;           
    DWORD   GuardCFFunctionCount;
    DWORD   GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    DWORD   GuardAddressTakenIatEntryTable; 
    DWORD   GuardAddressTakenIatEntryCount;
    DWORD   GuardLongJumpTargetTable;       
    DWORD   GuardLongJumpTargetCount;
    DWORD   DynamicValueRelocTable;         
    DWORD   CHPEMetadataPointer;
    DWORD   GuardRFFailureRoutine;          
    DWORD   GuardRFFailureRoutineFunctionPointer; 
    DWORD   DynamicValueRelocTableOffset;
    WORD    DynamicValueRelocTableSection;
    WORD    Reserved2;
    DWORD   GuardRFVerifyStackPointerFunctionPointer; 
    DWORD   HotPatchTableOffset;
    DWORD   Reserved3;
    DWORD   EnclaveConfigurationPointer;    
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD      Size;
    DWORD      TimeDateStamp;
    WORD       MajorVersion;
    WORD       MinorVersion;
    DWORD      GlobalFlagsClear;
    DWORD      GlobalFlagsSet;
    DWORD      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;                
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    DWORD      ProcessHeapFlags;
    WORD       CSDVersion;
    WORD       DependentLoadFlags;
    ULONGLONG  EditList;                       
    ULONGLONG  SecurityCookie;                 
    ULONGLONG  SEHandlerTable;                 
    ULONGLONG  SEHandlerCount;
    ULONGLONG  GuardCFCheckFunctionPointer;    
    ULONGLONG  GuardCFDispatchFunctionPointer; 
    ULONGLONG  GuardCFFunctionTable;           
    ULONGLONG  GuardCFFunctionCount;
    DWORD      GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    ULONGLONG  GuardAddressTakenIatEntryTable; 
    ULONGLONG  GuardAddressTakenIatEntryCount;
    ULONGLONG  GuardLongJumpTargetTable;       
    ULONGLONG  GuardLongJumpTargetCount;
    ULONGLONG  DynamicValueRelocTable;         
    ULONGLONG  CHPEMetadataPointer;            
    ULONGLONG  GuardRFFailureRoutine;          
    ULONGLONG  GuardRFFailureRoutineFunctionPointer; 
    DWORD      DynamicValueRelocTableOffset;
    WORD       DynamicValueRelocTableSection;
    WORD       Reserved2;
    ULONGLONG  GuardRFVerifyStackPointerFunctionPointer; 
    DWORD      HotPatchTableOffset;
    DWORD      Reserved3;
    ULONGLONG  EnclaveConfigurationPointer;     
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;





typedef IMAGE_LOAD_CONFIG_DIRECTORY64     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64    PIMAGE_LOAD_CONFIG_DIRECTORY;



#line 17902 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



typedef struct _IMAGE_HOT_PATCH_INFO {
    DWORD Version;
    DWORD Size;
    DWORD SequenceNumber;
    DWORD BaseImageList;
    DWORD BaseImageCount;
    DWORD BufferOffset; 
} IMAGE_HOT_PATCH_INFO, *PIMAGE_HOT_PATCH_INFO;

typedef struct _IMAGE_HOT_PATCH_BASE {
    DWORD SequenceNumber;
    DWORD Flags;
    DWORD OriginalTimeDateStamp;
    DWORD OriginalCheckSum;
    DWORD CodeIntegrityInfo;
    DWORD CodeIntegritySize;
    DWORD PatchTable;
    DWORD BufferOffset; 
} IMAGE_HOT_PATCH_BASE, *PIMAGE_HOT_PATCH_BASE;

typedef struct _IMAGE_HOT_PATCH_HASHES {
    BYTE  SHA256[32];
    BYTE  SHA1[20];
} IMAGE_HOT_PATCH_HASHES, *PIMAGE_HOT_PATCH_HASHES;



























                                                                  
























typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD Ret : 2;
            DWORD H : 1;
            DWORD Reg : 3;
            DWORD R : 1;
            DWORD L : 1;
            DWORD C : 1;
            DWORD StackAdjust : 10;
        } ;
    } ;
} IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD RegF : 3;
            DWORD RegI : 4;
            DWORD H : 1;
            DWORD CR : 2;
            DWORD FrameSize : 9;
        } ;
    } ;
} IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    } ;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;








#line 18059 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 18064 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 18069 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




#line 18074 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#line 18079 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








typedef struct _IMAGE_ENCLAVE_CONFIG32 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE  FamilyID[16];
    BYTE  ImageID[16];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    DWORD EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG32, *PIMAGE_ENCLAVE_CONFIG32;

typedef struct _IMAGE_ENCLAVE_CONFIG64 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE  FamilyID[16];
    BYTE  ImageID[16];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    ULONGLONG EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG64, *PIMAGE_ENCLAVE_CONFIG64;


typedef IMAGE_ENCLAVE_CONFIG64          IMAGE_ENCLAVE_CONFIG;
typedef PIMAGE_ENCLAVE_CONFIG64         PIMAGE_ENCLAVE_CONFIG;



#line 18126 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







typedef struct _IMAGE_ENCLAVE_IMPORT {
    DWORD MatchType;
    DWORD MinimumSecurityVersion;
    BYTE  UniqueOrAuthorID[32];
    BYTE  FamilyID[16];
    BYTE  ImageID[16];
    DWORD ImportName;
    DWORD Reserved;
} IMAGE_ENCLAVE_IMPORT, *PIMAGE_ENCLAVE_IMPORT;











typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;




















typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD       ulOffStart;             
    DWORD       cbProcSize;             
    DWORD       cdwLocals;              
    WORD        cdwParams;              
    WORD        cbProlog : 8;           
    WORD        cbRegs   : 3;           
    WORD        fHasSEH  : 1;           
    WORD        fUseBP   : 1;           
    WORD        reserved : 1;           
    WORD        cbFrame  : 2;           
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               
    DWORD       Length;                 
                                        
    BOOLEAN     Unicode;                
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;








typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    union {
        ULONGLONG   EndOfPrologue;
        ULONGLONG   UnwindInfoAddress;
    } ;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;





















typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;



typedef struct _NON_PAGED_DEBUG_INFO {
    WORD        Signature;
    WORD        Flags;
    DWORD       Size;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       SizeOfImage;
    ULONGLONG   ImageBase;
    
    
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;









#line 18308 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



                                                









typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;                 
                                                
    int :7;                                     
    unsigned int AmaskShift: 8;                 
    int :16;                                    
    DWORD FirstEntryRVA;                        
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;                         
    DWORD NewInst;                              
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#line 1 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "e:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 18336 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"








typedef struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;                       
    WORD    Sig2;                       
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;              
    DWORD   SizeOfData;                 

    union {
        WORD    Ordinal;                
        WORD    Hint;
    } ;

    WORD    Type : 2;                   
    WORD    NameType : 3;               
    WORD    Reserved : 11;              
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          
    IMPORT_OBJECT_NAME = 1,             
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  
                                        
    IMPORT_OBJECT_NAME_EXPORTAS = 4,    
} IMPORT_OBJECT_NAME_TYPE;





typedef enum ReplacesCorHdrNumericDefines
{

    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED       =0x00020000,


    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =5,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,


    NATIVE_TYPE_MAX_CB                  =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,


    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,
    IMAGE_COR_MIH_BASICBLOCK            =0x08,


    COR_VTABLE_32BIT                    =0x01,          
    COR_VTABLE_64BIT                    =0x02,          
    COR_VTABLE_FROM_UNMANAGED           =0x04,          
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  =0x08,  
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          


    IMAGE_COR_EATJ_THUNK_SIZE           =32,            


    
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;


typedef struct IMAGE_COR20_HEADER
{
    
    DWORD                   cb;
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;

    
    IMAGE_DATA_DIRECTORY    MetaData;
    DWORD                   Flags;

    
    
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    } ;

    
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#line 18460 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\apiset.h"





































#line 39 "E:\\sdk\\include\\10.0.16299.0\\shared\\apiset.h"





















































































#line 125 "E:\\sdk\\include\\10.0.16299.0\\shared\\apiset.h"



#line 129 "E:\\sdk\\include\\10.0.16299.0\\shared\\apiset.h"

#line 131 "E:\\sdk\\include\\10.0.16299.0\\shared\\apiset.h"
#line 18466 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







#pragma region Application or OneCore Family






__declspec(dllimport)
 
WORD  
__stdcall
RtlCaptureStackBackTrace(
      DWORD FramesToSkip,
      DWORD FramesToCapture,
      PVOID * BackTrace,
      PDWORD BackTraceHash
    );


#line 18493 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 18495 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
void
__stdcall
RtlCaptureContext(
      PCONTEXT ContextRecord
    );


#line 18513 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 18515 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion



#pragma region Application or OneCore Family



__declspec(dllimport)
void
__stdcall
RtlUnwind(
      PVOID TargetFrame,
      PVOID TargetIp,
      PEXCEPTION_RECORD ExceptionRecord,
      PVOID ReturnValue
    );


#line 18535 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion




#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOLEAN
__cdecl
RtlAddFunctionTable(
      PRUNTIME_FUNCTION FunctionTable,
      DWORD EntryCount,
      DWORD64 BaseAddress
    );


__declspec(dllimport)
BOOLEAN
__cdecl
RtlDeleteFunctionTable(
      PRUNTIME_FUNCTION FunctionTable
    );


__declspec(dllimport)
BOOLEAN
__cdecl
RtlInstallFunctionTableCallback(
      DWORD64 TableIdentifier,
      DWORD64 BaseAddress,
      DWORD Length,
      PGET_RUNTIME_FUNCTION_CALLBACK Callback,
      PVOID Context,
      PCWSTR OutOfProcessCallbackDll
    );







__declspec(dllimport)
DWORD   
__stdcall
RtlAddGrowableFunctionTable(
      PVOID * DynamicTable,
      PRUNTIME_FUNCTION FunctionTable,
      DWORD EntryCount,
      DWORD MaximumEntryCount,
      ULONG_PTR RangeBase,
      ULONG_PTR RangeEnd
    );


__declspec(dllimport)
void
__stdcall
RtlGrowFunctionTable(
      PVOID DynamicTable,
      DWORD NewEntryCount
    );


__declspec(dllimport)
void
__stdcall
RtlDeleteGrowableFunctionTable(
      PVOID DynamicTable
    );


#line 18611 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 18615 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion

#pragma region Application or OneCore Family



__declspec(dllimport)
PRUNTIME_FUNCTION
__stdcall
RtlLookupFunctionEntry(
      DWORD64 ControlPc,
      PDWORD64 ImageBase,
      PUNWIND_HISTORY_TABLE HistoryTable
    );


#line 18632 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
void
__cdecl
RtlRestoreContext(
      PCONTEXT ContextRecord,
      struct _EXCEPTION_RECORD * ExceptionRecord
    );


#line 18648 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion

#pragma region Application or OneCore Family



__declspec(dllimport)
void
__stdcall
RtlUnwindEx(
      PVOID TargetFrame,
      PVOID TargetIp,
      PEXCEPTION_RECORD ExceptionRecord,
      PVOID ReturnValue,
      PCONTEXT ContextRecord,
      PUNWIND_HISTORY_TABLE HistoryTable
    );


#line 18668 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
PEXCEPTION_ROUTINE
__stdcall
RtlVirtualUnwind(
      DWORD HandlerType,
      DWORD64 ImageBase,
      DWORD64 ControlPc,
      PRUNTIME_FUNCTION FunctionEntry,
      PCONTEXT ContextRecord,
      PVOID * HandlerData,
      PDWORD64 EstablisherFrame,
      PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
    );


#line 18690 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion

#line 18693 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





























































































































































#line 18851 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





























































































































































#line 19009 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"









































#line 19051 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#pragma region Application or OneCore Family






__declspec(dllimport)
PVOID
__stdcall
RtlPcToFileHeader(
      PVOID PcValue,
      PVOID * BaseOfImage
    );


#line 19070 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19072 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion


#pragma region Desktop Family or OneCore Family









 
__declspec(dllimport)
SIZE_T
__stdcall
RtlCompareMemory(
      const void * Source1,
      const void * Source2,
      SIZE_T Length
    );


#line 19097 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19099 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19101 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion










#line 19113 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
















#pragma warning(push)
#pragma warning(disable:4324)   

typedef struct __declspec(align(16)) _SLIST_ENTRY {
    struct _SLIST_ENTRY *Next;
} SLIST_ENTRY, *PSLIST_ENTRY;

#pragma warning(pop)





#line 19143 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



typedef union __declspec(align(16)) _SLIST_HEADER {
    struct {  
        ULONGLONG Alignment;
        ULONGLONG Region;
    } ;
    struct {  
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG Reserved:4;
        ULONGLONG NextEntry:60; 
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;







































#line 19198 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19200 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
void
__stdcall
RtlInitializeSListHead (
      PSLIST_HEADER ListHead
    );

 
__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlFirstEntrySList (
      const SLIST_HEADER *ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPopEntrySList (
      PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushEntrySList (
      PSLIST_HEADER ListHead,
        PSLIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushListSListEx (
      PSLIST_HEADER ListHead,
        PSLIST_ENTRY List,
      PSLIST_ENTRY ListEnd,
      DWORD Count
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedFlushSList (
      PSLIST_HEADER ListHead
    );

__declspec(dllimport)
WORD  
__stdcall
RtlQueryDepthSList (
      PSLIST_HEADER ListHead
    );

#line 19260 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion


























typedef union _RTL_RUN_ONCE {       
    PVOID Ptr;                      
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;     

#line 19292 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _RTL_BARRIER {                       
            DWORD Reserved1;                        
            DWORD Reserved2;                        
            ULONG_PTR Reserved3[2];                 
            DWORD Reserved4;                        
            DWORD Reserved5;                        
} RTL_BARRIER, *PRTL_BARRIER;                       




































































__declspec(noreturn)
void
__fastfail(
      unsigned int Code
    );

#pragma intrinsic(__fastfail)

#line 19377 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

















#pragma region Desktop Family


__forceinline
DWORD
HEAP_MAKE_TAG_FLAGS (
      DWORD TagBase,
      DWORD Tag
    )

{
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}
#line 19408 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#line 19409 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion






















































#line 19465 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











__forceinline
PVOID
RtlSecureZeroMemory(
      PVOID ptr,
      SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;



    __stosb((PBYTE )((DWORD64)vptr), 0, cnt);



















#line 19508 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    return ptr;
}

#line 19513 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






















typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;





typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#line 19580 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;





typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#line 19616 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"















































#pragma region Desktop Family or OneCore Family


















__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
      ULONGLONG ConditionMask,
      DWORD TypeMask,
      BYTE  Condition
    );

#line 19692 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19694 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19696 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOLEAN
__stdcall
RtlGetProductInfo(
       DWORD  OSMajorVersion,
       DWORD  OSMinorVersion,
       DWORD  SpMajorVersion,
       DWORD  SpMinorVersion,
      PDWORD ReturnedProductType
    );

#line 19719 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



#line 19723 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion



typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,              
    UmsThreadAffinity,              
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef
 
void
__stdcall
RTL_UMS_SCHEDULER_ENTRY_POINT(
      RTL_UMS_SCHEDULER_REASON Reason,
      ULONG_PTR ActivationPayload,
      PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
































#line 19788 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 19790 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











#line 19802 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"






#pragma region Desktop Family or OneCore Family








__declspec(dllimport)
DWORD
__stdcall
RtlCrc32(
      const void *Buffer,
      size_t Size,
      DWORD InitialCrc
    );

__declspec(dllimport)
ULONGLONG
__stdcall
RtlCrc64(
      const void *Buffer,
      size_t Size,
      ULONGLONG InitialCrc
    );



#line 19838 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion



#line 19843 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"












typedef enum _OS_DEPLOYEMENT_STATE_VALUES {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT
} OS_DEPLOYEMENT_STATE_VALUES;

__declspec(dllimport)
OS_DEPLOYEMENT_STATE_VALUES
__stdcall
RtlOsDeploymentState(
      DWORD Flags    
    );


#line 19869 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"







typedef struct _NV_MEMORY_RANGE {
    void *BaseAddress;
    SIZE_T Length;
} NV_MEMORY_RANGE, *PNV_MEMORY_RANGE;















 
__declspec(dllimport)
DWORD   
__stdcall
RtlGetNonVolatileToken (
      PVOID NvBuffer,
      SIZE_T Size,
     PVOID *NvToken
    );

 
__declspec(dllimport)
DWORD   
__stdcall
RtlFreeNonVolatileToken (
      PVOID NvToken
    );

 
__declspec(dllimport)
DWORD   
__stdcall
RtlFlushNonVolatileMemory (
      PVOID NvToken,
      PVOID NvBuffer,
      SIZE_T Size,
      DWORD Flags
    );

 
__declspec(dllimport)
DWORD   
__stdcall
RtlDrainNonVolatileFlush (
      PVOID NvToken
    );

 
__declspec(dllimport)
DWORD   
__stdcall
RtlWriteNonVolatileMemory (
      PVOID NvToken,
      void __unaligned *NvDestination,
      void __unaligned *Source,
      SIZE_T Size,
      DWORD Flags
    );

 
__declspec(dllimport)
DWORD   
__stdcall
RtlFlushNonVolatileMemoryRanges (
      PVOID NvToken,
      PNV_MEMORY_RANGE NvRanges,
      SIZE_T NumRanges,
      DWORD Flags
    );
#line 19955 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"




















typedef struct CORRELATION_VECTOR {
    CHAR Version;
    CHAR Vector[129];
} CORRELATION_VECTOR;

typedef CORRELATION_VECTOR *PCORRELATION_VECTOR;



__declspec(dllimport)
DWORD   
__stdcall
RtlInitializeCorrelationVector(
      PCORRELATION_VECTOR CorrelationVector,
       int Version,
       const GUID * Guid
    );


__declspec(dllimport)
DWORD   
__stdcall
RtlIncrementCorrelationVector(
      PCORRELATION_VECTOR CorrelationVector
    );

__declspec(dllimport)
DWORD   
__stdcall
RtlExtendCorrelationVector(
      PCORRELATION_VECTOR CorrelationVector
    );

__declspec(dllimport)
DWORD   
__stdcall
RtlValidateCorrelationVector(
      PCORRELATION_VECTOR Vector
    );

#line 20016 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"










typedef enum _IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool,
    ImagePolicyEntryTypeInt8,
    ImagePolicyEntryTypeUInt8,
    ImagePolicyEntryTypeInt16,
    ImagePolicyEntryTypeUInt16,
    ImagePolicyEntryTypeInt32,
    ImagePolicyEntryTypeUInt32,
    ImagePolicyEntryTypeInt64,
    ImagePolicyEntryTypeUInt64,
    ImagePolicyEntryTypeAnsiString,
    ImagePolicyEntryTypeUnicodeString,
    ImagePolicyEntryTypeMaximum
} IMAGE_POLICY_ENTRY_TYPE;

typedef enum _IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw,
    ImagePolicyIdDebug,
    ImagePolicyIdCrashDump,
    ImagePolicyIdCrashDumpKey,
    ImagePolicyIdCrashDumpKeyGuid,
    ImagePolicyIdParentSd,
    ImagePolicyIdParentSdRev,
    ImagePolicyIdSvn,
    ImagePolicyIdDeviceId,
    ImagePolicyIdCapability,
    ImagePolicyIdScenarioId,
    ImagePolicyIdMaximum
} IMAGE_POLICY_ID;

typedef struct _IMAGE_POLICY_ENTRY {
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
    union {
        const void* None;
        BOOLEAN BoolValue;
        INT8 Int8Value;
        UINT8 UInt8Value;
        INT16 Int16Value;
        UINT16 UInt16Value;
        INT32 Int32Value;
        UINT32 UInt32Value;
        INT64 Int64Value;
        UINT64 UInt64Value;
        PCSTR AnsiStringValue;
        PCWSTR UnicodeStringValue;
    } u;
} IMAGE_POLICY_ENTRY;
typedef const IMAGE_POLICY_ENTRY* PCIMAGE_POLICY_ENTRY;

#pragma warning(push)
#pragma warning(disable:4200) 
typedef struct _IMAGE_POLICY_METADATA {
    BYTE  Version;
    BYTE  Reserved0[7];
    ULONGLONG ApplicationId;
    IMAGE_POLICY_ENTRY Policies[];
} IMAGE_POLICY_METADATA;
typedef const IMAGE_POLICY_METADATA* PCIMAGE_POLICY_METADATA;
#pragma warning(pop)


















































typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD   CreatorBackTraceIndexHigh;
    WORD   SpareWORD  ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;

















#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    
    
    
    

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {                            
        PVOID Ptr;                                       
} RTL_SRWLOCK, *PRTL_SRWLOCK;                            

typedef struct _RTL_CONDITION_VARIABLE {                    
        PVOID Ptr;                                       
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;      


typedef
void
(__stdcall *PAPCFUNC)(
      ULONG_PTR Parameter
    );
typedef LONG (__stdcall *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1



    ,

    HeapOptimizeResources = 3

#line 20216 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


} HEAP_INFORMATION_CLASS;





typedef struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    DWORD Version;
    DWORD Flags;
} HEAP_OPTIMIZE_RESOURCES_INFORMATION, *PHEAP_OPTIMIZE_RESOURCES_INFORMATION;

#line 20231 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"













typedef void (__stdcall * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );   
typedef void (__stdcall * WORKERCALLBACKFUNC) (PVOID );                 
typedef void (__stdcall * APC_CALLBACK_FUNCTION) (DWORD   , PVOID, PVOID); 
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK; 
typedef
void
(__stdcall *PFLS_CALLBACK_FUNCTION) (
     PVOID lpFlsData
    );

typedef
BOOLEAN
(__stdcall *PSECURE_MEMORY_CACHE_CALLBACK) (
      PVOID Addr,
      SIZE_T Range
    );




typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    RunlevelInformationInActivationContext                  = 5,
    CompatibilityInformationInActivationContext             = 6,
    ActivationContextManifestResourceName                   = 7,
    MaxActivationContextInfoClass,

    
    
    
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4
} ACTIVATION_CONTEXT_INFO_CLASS;




typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;







typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;










typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;      
    DWORD ulManifestPathType;                   
    DWORD ulManifestPathLength;                 
    LARGE_INTEGER liManifestLastWriteTime;      
    DWORD ulPolicyPathType;                     
    DWORD ulPolicyPathLength;                   
    LARGE_INTEGER liPolicyLastWriteTime;        
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor;               
    DWORD ulManifestVersionMinor;               
    DWORD ulPolicyVersionMajor;                 
    DWORD ulPolicyVersionMinor;                 
    DWORD ulAssemblyDirectoryNameLength;        

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD  ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL  RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;




#pragma warning(push)
#pragma warning(disable:4200) 
#line 20380 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;


#pragma warning(pop)
#line 20389 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#line 20393 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

typedef struct _SUPPORTED_OS_INFO {
    WORD   MajorVersion;
    WORD   MinorVersion;
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;




typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;



typedef struct _PERFORMANCE_DATA {
    WORD   Size;
    BYTE  Version;
    BYTE  HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;




#pragma region Desktop Family


































































void
__stdcall
RtlGetDeviceFamilyInfoEnum(
      ULONGLONG *pullUAPInfo,
      DWORD *pulDeviceFamily,
      DWORD *pulDeviceForm
);

DWORD   
__stdcall
RtlConvertDeviceFamilyInfoToString(
      PDWORD pulDeviceFamilyBufferSize,
      PDWORD pulDeviceFormBufferSize,
      PWSTR DeviceFamily,
      PWSTR DeviceForm

);

DWORD   
__stdcall
RtlSwitchedVVI(
      PRTL_OSVERSIONINFOEXW VersionInfo,
      DWORD TypeMask,
      ULONGLONG  ConditionMask
    );


#line 20537 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 20539 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma endregion












































typedef struct _EVENTLOGRECORD {
    DWORD  Length;        
    DWORD  Reserved;      
    DWORD  RecordNumber;  
    DWORD  TimeGenerated; 
    DWORD  TimeWritten;   
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; 
    DWORD  ClosingRecordNumber; 
    DWORD  StringOffset;  
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    
    
    
    
    
    
    
    
    
    
    
    
} EVENTLOGRECORD, *PEVENTLOGRECORD;






#pragma warning(push)
#line 20621 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
#pragma warning(disable : 4200) 

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;



struct _EVENTSFORLOGFILE
{
    DWORD           ulSize;
    WCHAR           szLogicalLogFile[256];        
    DWORD           ulNumRecords;
    EVENTLOGRECORD  pEventLogRecords[];
};

struct _PACKEDEVENTINFO
{
    DWORD               ulSize;  
    DWORD               ulNumEventsForLogFile; 
    DWORD               ulOffsets[];           
};

#line 20647 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#pragma warning(pop)


#line 20653 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

























































                                                    


                                                    


                                                    


                                                    
                                                    




                                                    
                                                    
                                                    


































































                                                      


















                                            










































































typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = 0x00000001,
    FileSystemType           = 0x00000002,
    Win32ServiceOwnProcess   = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType              = 0x00000004,
    RecognizerType           = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = 0x00000000,
    SystemLoad  = 0x00000001,
    AutoLoad    = 0x00000002,
    DemandLoad  = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = 0x00000000,
    NormalError   = 0x00000001,
    SevereError   = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;

































































typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;












typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;










typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;









typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
















typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;























































































typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;





typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;





typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;





typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;









typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;











typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;




typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;

#line 21224 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"





extern "C" {
#line 21231 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\ktmtypes.h"






















extern "C" {
#line 25 "E:\\sdk\\include\\10.0.16299.0\\shared\\ktmtypes.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\ktmtypes.h"

typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

















































typedef ULONG NOTIFICATION_MASK;






















































typedef struct _TRANSACTION_NOTIFICATION {
    PVOID         TransactionKey;
    ULONG         TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG         ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID   EnlistmentId;
    UOW    UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;



typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID  UOW;
    GUID  TmIdentity;
    ULONG BufferLength;
    
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID  UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;







typedef struct _KCRM_MARSHAL_HEADER {
    ULONG              VersionMajor;
    ULONG              VersionMinor;
    ULONG              NumProtocols;
    ULONG              Unused;        
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW                UOW;
    GUID               TmIdentity;
    ULONG              IsolationLevel;
    ULONG              IsolationFlags;
    ULONG              Timeout;
    WCHAR              Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID    ProtocolId;
      ULONG StaticInfoLength;
    ULONG              TransactionIdInfoLength; 
    ULONG              Unused1;        
    ULONG              Unused2;        
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;


#pragma warning(pop)
#line 210 "E:\\sdk\\include\\10.0.16299.0\\shared\\ktmtypes.h"


}
#line 214 "E:\\sdk\\include\\10.0.16299.0\\shared\\ktmtypes.h"

#line 216 "E:\\sdk\\include\\10.0.16299.0\\shared\\ktmtypes.h"
#line 21234 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 21239 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"











































































































































































typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID    TransactionId;
    DWORD   State;
    DWORD   Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID    TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID  LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
      WCHAR LogPath[1]; 

} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG  LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;



typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;



typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD              IsolationLevel;
    DWORD              IsolationFlags;
    LARGE_INTEGER      Timeout;
    DWORD              Outcome;
    DWORD              DescriptionLength;
    WCHAR              Description[1];            

} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;



typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID   EnlistmentId;
    GUID   ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD                       NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; 
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID    ResourceManagerId;
    DWORD   DescriptionLength;
    WCHAR   Description[1];            
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE    IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;




typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation

    ,


    TransactionBindInformation, 
    TransactionDTCPrivateInformation 
    ,

} TRANSACTION_INFORMATION_CLASS;


typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4

    ,



    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5



} TRANSACTIONMANAGER_INFORMATION_CLASS;



typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID    EnlistmentId;
    GUID    TransactionId;
    GUID    ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID   CrmTransactionManagerId;
    GUID   CrmResourceManagerId;
    GUID   CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;



typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW    UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD   NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; 
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;






typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;









typedef struct _KTMOBJECT_CURSOR {

    
    
    

    GUID    LastQuery;

    
    
    

    DWORD   ObjectIdCount;

    
    
    

    GUID    ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;




#pragma warning(pop)
#line 21622 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


}
#line 21626 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 21628 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
typedef DWORD TP_VERSION, *PTP_VERSION; 

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef void (__stdcall *PTP_SIMPLE_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL; 

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP; 

typedef void (__stdcall *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
      PVOID ObjectContext,
      PVOID CleanupContext
    );








typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY               CallbackPriority;
    DWORD                              Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;























#line 21711 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"



__forceinline
void
TpInitializeCallbackEnviron(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{



    CallbackEnviron->Version = 3;





#line 21730 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

    CallbackEnviron->Pool = 0;
    CallbackEnviron->CleanupGroup = 0;
    CallbackEnviron->CleanupGroupCancelCallback = 0;
    CallbackEnviron->RaceDll = 0;
    CallbackEnviron->ActivationContext = 0;
    CallbackEnviron->FinalizationCallback = 0;
    CallbackEnviron->u.Flags = 0;



    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);

#line 21745 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

}

__forceinline
void
TpSetCallbackThreadpool(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         PTP_POOL             Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

__forceinline
void
TpSetCallbackCleanupGroup(
       PTP_CALLBACK_ENVIRON              CallbackEnviron,
          PTP_CLEANUP_GROUP                 CleanupGroup,
      PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

__forceinline
void
TpSetCallbackActivationContext(
       PTP_CALLBACK_ENVIRON CallbackEnviron,
      struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

__forceinline
void
TpSetCallbackNoActivationContext(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1; 
}

__forceinline
void
TpSetCallbackLongFunction(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

__forceinline
void
TpSetCallbackRaceWithDll(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         PVOID                DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

__forceinline
void
TpSetCallbackFinalizationCallback(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         PTP_SIMPLE_CALLBACK  FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}



__forceinline
void
TpSetCallbackPriority(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}

#line 21831 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

__forceinline
void
TpSetCallbackPersistent(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


__forceinline
void
TpDestroyCallbackEnviron(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    
    
    
    
    

    (CallbackEnviron);
}

#line 21858 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef void (__stdcall *PTP_WORK_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
          PTP_WORK              Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef void (__stdcall *PTP_TIMER_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
          PTP_TIMER             Timer
    );

typedef DWORD    TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef void (__stdcall *PTP_WAIT_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
          PTP_WAIT              Wait,
             TP_WAIT_RESULT        WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;



__forceinline
struct _TEB *
NtCurrentTeb (
    void
    )

{
    return (struct _TEB *)__readgsqword(((LONG)(LONG_PTR)&(((NT_TIB *)0)->Self)));
}

__forceinline
PVOID
GetCurrentFiber (
    void
    )

{

    return (PVOID)__readgsqword(((LONG)(LONG_PTR)&(((NT_TIB *)0)->FiberData)));
}

__forceinline
PVOID
GetFiberData (
    void
    )

{

    return *(PVOID *)GetCurrentFiber();
}

#line 21924 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
































#line 21957 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"
































#line 21990 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"












#line 22003 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"













#line 22017 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


}
#line 22021 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#pragma warning(pop)




#line 22029 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"

#line 22031 "E:\\sdk\\include\\10.0.16299.0\\um\\winnt.h"


#line 183 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"
#line 184 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"


typedef UINT_PTR            WPARAM;
typedef LONG_PTR            LPARAM;
typedef LONG_PTR            LRESULT;




















typedef HANDLE          *SPHANDLE;
typedef HANDLE           *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;



#pragma warning(push)
#pragma warning(disable:4255) 
#line 221 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"


typedef INT_PTR ( __stdcall *FARPROC)();
typedef INT_PTR ( __stdcall *NEARPROC)();
typedef INT_PTR (__stdcall *PROC)();




#line 231 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"




#line 236 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"

#pragma warning(pop)
#line 239 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"




#line 244 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"

typedef WORD                ATOM;   

struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;
struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE;      
struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA;
struct HKL__{int unused;}; typedef struct HKL__ *HKL;


typedef int HFILE;


#line 266 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"





typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;



}
#line 280 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"

#line 282 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"
#pragma endregion

#line 285 "E:\\sdk\\include\\10.0.16299.0\\shared\\minwindef.h"

#line 25 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"







#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"



#pragma region Application Family or OneCore Family


struct HWND__{int unused;}; typedef struct HWND__ *HWND;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK;

#line 43 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion












#line 57 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#pragma region Application Family




typedef void * HGDIOBJ;


#line 67 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#line 68 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"


struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL;
#line 72 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH;
#line 76 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE;
#line 79 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

struct HDC__{int unused;}; typedef struct HDC__ *HDC;
#line 82 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC;          
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE;

struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT;
#line 88 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
struct HICON__{int unused;}; typedef struct HICON__ *HICON;

struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU;
#line 92 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN;
#line 96 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"


struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;
#line 100 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#line 102 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion




#pragma region Application Family


struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR;

#line 113 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion

#line 116 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#pragma region Desktop Family


struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD;

#line 123 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion

#line 126 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#pragma region Application Family



typedef HICON HCURSOR;      


#line 135 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

typedef DWORD   COLORREF;

#line 139 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion

#pragma region Desktop Family


typedef DWORD   *LPCOLORREF;



#line 149 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion

#pragma region Application Family


typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT,  *NPRECT,  *LPRECT;

typedef const RECT * LPCRECT;

typedef struct _RECTL       
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL * LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT,  *NPPOINT,  *LPPOINT;

typedef struct _POINTL      
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT   x;
    SHORT   y;



#line 204 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
} POINTS, *PPOINTS, *LPPOINTS;

#line 207 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"
#pragma endregion

































}
#line 243 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#pragma region Desktop Family





struct DPI_AWARENESS_CONTEXT__{int unused;}; typedef struct DPI_AWARENESS_CONTEXT__ *DPI_AWARENESS_CONTEXT;

typedef enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID           = -1,
    DPI_AWARENESS_UNAWARE           = 0,
    DPI_AWARENESS_SYSTEM_AWARE      = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
} DPI_AWARENESS;






#line 265 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#line 267 "E:\\sdk\\include\\10.0.16299.0\\shared\\windef.h"

#line 172 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"















#pragma once
#line 18 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma warning(push)
#pragma warning(disable:4820) 
#pragma warning(disable:4668) 
#line 23 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma warning(disable:4001) 
#pragma warning(disable:4201) 
#pragma warning(disable:4214) 
#line 27 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
















#line 18 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 19 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 26 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 27 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 35 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"








#line 44 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 45 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"







#line 53 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 60 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 61 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 68 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 69 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 76 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 77 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 84 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 85 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"






#line 92 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 93 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"

#line 95 "E:\\sdk\\include\\10.0.16299.0\\shared\\apisetcconv.h"
#line 33 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"







#pragma once




#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 17 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"

#pragma warning(push)
#pragma warning(disable:4820) 
#line 21 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 25 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"





extern "C" {
#line 32 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"














typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } ;
        PVOID Pointer;
    } ;

    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;


















typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
      CHAR   cFileName[ 260 ];
      CHAR   cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
      WCHAR  cFileName[ 260 ];
      WCHAR  cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;





typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#line 145 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"



typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;




typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
#line 164 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"



typedef enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
    ReadDirectoryNotifyInformation         = 1,
    ReadDirectoryNotifyExtendedInformation 
} READ_DIRECTORY_NOTIFY_INFORMATION_CLASS, *PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS;
#line 172 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"
#line 173 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;


typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,

    FileStorageInfo,
    FileAlignmentInfo,
    FileIdInfo,
    FileIdExtdDirectoryInfo,
    FileIdExtdDirectoryRestartInfo,
#line 204 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"

    FileDispositionInfoEx,
    FileRenameInfoEx,
#line 208 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;
#line 211 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

typedef
void
(__stdcall *LPOVERLAPPED_COMPLETION_ROUTINE)(
         DWORD dwErrorCode,
         DWORD dwNumberOfBytesTransfered,
      LPOVERLAPPED lpOverlapped
    );




typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } ;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;








typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;














typedef DWORD (__stdcall *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef LPVOID (__stdcall *PENCLAVE_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;







typedef PCONTEXT LPCONTEXT;
#line 379 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"






























































}
#line 443 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"





#pragma warning(pop)





#line 455 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"
#line 456 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"

#line 458 "E:\\sdk\\include\\10.0.16299.0\\um\\minwinbase.h"

#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"
 











#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"























#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"



extern "C" {
#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"




#pragma region Desktop Family or OneCore Family





__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsW(
         LPWCH NewEnvironment
    );







#line 70 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"
#pragma endregion

#pragma region PC Family or OneCore Family





__declspec(dllimport)
HANDLE
__stdcall
GetStdHandle(
      DWORD nStdHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetStdHandle(
      DWORD nStdHandle,
      HANDLE hHandle
    );





__declspec(dllimport)
BOOL
__stdcall
SetStdHandleEx(
      DWORD nStdHandle,
      HANDLE hHandle,
      PHANDLE phPrevValue
    );


#line 109 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"



#line 113 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"
#pragma endregion

#pragma region Application Family or OneCore Family





__declspec(dllimport)
LPSTR
__stdcall
GetCommandLineA(
    void
    );

__declspec(dllimport)
LPWSTR
__stdcall
GetCommandLineW(
    void
    );





#line 140 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

__declspec(dllimport)
 
LPCH
__stdcall
GetEnvironmentStrings(
    void
    );


__declspec(dllimport)
 
LPWCH
__stdcall
GetEnvironmentStringsW(
    void
    );






#line 164 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsA(
         LPCH penv
    );

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsW(
         LPWCH penv
    );





#line 184 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetEnvironmentVariableA(
      LPCSTR lpName,
      LPSTR lpBuffer,
      DWORD nSize
    );

__declspec(dllimport)
 
DWORD
__stdcall
GetEnvironmentVariableW(
      LPCWSTR lpName,
      LPWSTR lpBuffer,
      DWORD nSize
    );





#line 210 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableA(
      LPCSTR lpName,
      LPCSTR lpValue
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableW(
      LPCWSTR lpName,
      LPCWSTR lpValue
    );





#line 232 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

__declspec(dllimport)
 
DWORD
__stdcall
ExpandEnvironmentStringsA(
      LPCSTR lpSrc,
      LPSTR lpDst,
      DWORD nSize
    );

__declspec(dllimport)
 
DWORD
__stdcall
ExpandEnvironmentStringsW(
      LPCWSTR lpSrc,
      LPWSTR lpDst,
      DWORD nSize
    );





#line 258 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryA(
      LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryW(
      LPCWSTR lpPathName
    );





#line 278 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"


__declspec(dllimport)
 
DWORD
__stdcall
GetCurrentDirectoryA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );

__declspec(dllimport)
 
DWORD
__stdcall
GetCurrentDirectoryW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );





#line 303 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"



#line 307 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family





__declspec(dllimport)
DWORD
__stdcall
SearchPathW(
      LPCWSTR lpPath,
      LPCWSTR lpFileName,
      LPCWSTR lpExtension,
      DWORD nBufferLength,
      LPWSTR lpBuffer,
      LPWSTR * lpFilePart
    );






#line 333 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"








__declspec(dllimport)
DWORD
__stdcall
SearchPathA(
      LPCSTR lpPath,
      LPCSTR lpFileName,
      LPCSTR lpExtension,
      DWORD nBufferLength,
      LPSTR lpBuffer,
      LPSTR * lpFilePart
    );





__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathA(
      LPCSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathW(
      LPCWSTR ExeName
    );





#line 376 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

#line 378 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

#line 380 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"



#line 384 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"
#pragma endregion





}
#line 392 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"

#line 394 "E:\\sdk\\include\\10.0.16299.0\\um\\processenv.h"


#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
 
 












#pragma once
#line 17 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"


























#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"



extern "C" {
#line 51 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#pragma region Application Family or OneCore Family
















#line 70 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion







#pragma region Application Family or OneCore Family



__declspec(dllimport)
LONG
__stdcall
CompareFileTime(
      const FILETIME * lpFileTime1,
      const FILETIME * lpFileTime2
    );


__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryA(
      LPCSTR lpPathName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryW(
      LPCWSTR lpPathName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );





#line 112 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 114 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
HANDLE
__stdcall
CreateFileA(
      LPCSTR lpFileName,
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD dwCreationDisposition,
      DWORD dwFlagsAndAttributes,
      HANDLE hTemplateFile
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateFileW(
      LPCWSTR lpFileName,
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD dwCreationDisposition,
      DWORD dwFlagsAndAttributes,
      HANDLE hTemplateFile
    );





#line 151 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceW(
      DWORD dwFlags,
      LPCWSTR lpDeviceName,
      LPCWSTR lpTargetPath
    );






#line 167 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
DeleteFileA(
      LPCSTR lpFileName
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteFileW(
      LPCWSTR lpFileName
    );





#line 192 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointW(
      LPCWSTR lpszVolumeMountPoint
    );






__declspec(dllimport)
BOOL
__stdcall
FileTimeToLocalFileTime(
      const FILETIME * lpFileTime,
      LPFILETIME lpLocalFileTime
    );





__declspec(dllimport)
BOOL
__stdcall
FindClose(
      HANDLE hFindFile
    );


#line 226 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FindCloseChangeNotification(
      HANDLE hChangeHandle
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationA(
      LPCSTR lpPathName,
      BOOL bWatchSubtree,
      DWORD dwNotifyFilter
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationW(
      LPCWSTR lpPathName,
      BOOL bWatchSubtree,
      DWORD dwNotifyFilter
    );





#line 263 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 265 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileA(
      LPCSTR lpFileName,
      LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileW(
      LPCWSTR lpFileName,
      LPWIN32_FIND_DATAW lpFindFileData
    );





#line 292 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"




__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExA(
      LPCSTR lpFileName,
      FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
      FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
      DWORD dwAdditionalFlags
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExW(
      LPCWSTR lpFileName,
      FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
      FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
      DWORD dwAdditionalFlags
    );





#line 325 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 327 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 329 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeW(
      LPWSTR lpszVolumeName,
      DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindNextChangeNotification(
      HANDLE hChangeHandle
    );


#line 357 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FindNextFileA(
      HANDLE hFindFile,
      LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileW(
      HANDLE hFindFile,
      LPWIN32_FIND_DATAW lpFindFileData
    );





#line 384 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 386 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeW(
      HANDLE hFindVolume,
      LPWSTR lpszVolumeName,
      DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindVolumeClose(
      HANDLE hFindVolume
    );


#line 415 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FlushFileBuffers(
      HANDLE hFile
    );


#line 430 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceA(
      LPCSTR lpRootPathName,
      LPDWORD lpSectorsPerCluster,
      LPDWORD lpBytesPerSector,
      LPDWORD lpNumberOfFreeClusters,
      LPDWORD lpTotalNumberOfClusters
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceW(
      LPCWSTR lpRootPathName,
      LPDWORD lpSectorsPerCluster,
      LPDWORD lpBytesPerSector,
      LPDWORD lpNumberOfFreeClusters,
      LPDWORD lpTotalNumberOfClusters
    );





#line 463 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
    
__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExA(
      LPCSTR lpDirectoryName,
      PULARGE_INTEGER lpFreeBytesAvailableToCaller,
      PULARGE_INTEGER lpTotalNumberOfBytes,
      PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExW(
      LPCWSTR lpDirectoryName,
      PULARGE_INTEGER lpFreeBytesAvailableToCaller,
      PULARGE_INTEGER lpTotalNumberOfBytes,
      PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );





#line 489 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeA(
      LPCSTR lpRootPathName
    );

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeW(
      LPCWSTR lpRootPathName
    );





#line 509 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 511 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesA(
      LPCSTR lpFileName
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesW(
      LPCWSTR lpFileName
    );





#line 545 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExA(
      LPCSTR lpFileName,
      GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExW(
      LPCWSTR lpFileName,
      GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation
    );





#line 569 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 571 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandle(
      HANDLE hFile,
      LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileSize(
      HANDLE hFile,
      LPDWORD lpFileSizeHigh
    );


#line 609 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
GetFileSizeEx(
      HANDLE hFile,
      PLARGE_INTEGER lpFileSize
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileType(
      HANDLE hFile
    );





__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleA(
      HANDLE hFile,
      LPSTR lpszFilePath,
      DWORD cchFilePath,
      DWORD dwFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleW(
      HANDLE hFile,
      LPWSTR lpszFilePath,
      DWORD cchFilePath,
      DWORD dwFlags
    );





#line 660 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 662 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileTime(
      HANDLE hFile,
      LPFILETIME lpCreationTime,
      LPFILETIME lpLastAccessTime,
      LPFILETIME lpLastWriteTime
    );


__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameW(
      LPCWSTR lpFileName,
      DWORD nBufferLength,
      LPWSTR lpBuffer,
     LPWSTR * lpFilePart
    );






__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameA(
      LPCSTR lpFileName,
      DWORD nBufferLength,
      LPSTR lpBuffer,
     LPSTR * lpFilePart
    );




#line 705 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
DWORD
__stdcall
GetLogicalDrives(
    void
    );


#line 715 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );






__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameA(
      LPCSTR lpszShortPath,
      LPSTR lpszLongPath,
      DWORD cchBuffer
    );




#line 748 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 750 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameW(
      LPCWSTR lpszShortPath,
      LPWSTR lpszLongPath,
      DWORD cchBuffer
    );






#line 772 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
DWORD
__stdcall
GetShortPathNameW(
      LPCWSTR lpszLongPath,
      LPWSTR lpszShortPath,
      DWORD cchBuffer
    );






#line 794 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
UINT
__stdcall
GetTempFileNameW(
      LPCWSTR lpPathName,
      LPCWSTR lpPrefixString,
      UINT uUnique,
      LPWSTR lpTempFileName
    );






#line 816 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationByHandleW(
      HANDLE hFile,
      LPWSTR lpVolumeNameBuffer,
      DWORD nVolumeNameSize,
      LPDWORD lpVolumeSerialNumber,
      LPDWORD lpMaximumComponentLength,
      LPDWORD lpFileSystemFlags,
      LPWSTR lpFileSystemNameBuffer,
      DWORD nFileSystemNameSize
    );


#line 841 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#line 842 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationW(
      LPCWSTR lpRootPathName,
      LPWSTR lpVolumeNameBuffer,
      DWORD nVolumeNameSize,
      LPDWORD lpVolumeSerialNumber,
      LPDWORD lpMaximumComponentLength,
      LPDWORD lpFileSystemFlags,
      LPWSTR lpFileSystemNameBuffer,
      DWORD nFileSystemNameSize
    );






#line 868 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameW(
      LPCWSTR lpszFileName,
      LPWSTR lpszVolumePathName,
      DWORD cchBufferLength
    );






#line 889 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
LocalFileTimeToFileTime(
      const FILETIME * lpLocalFileTime,
      LPFILETIME lpFileTime
    );


__declspec(dllimport)
BOOL
__stdcall
LockFile(
      HANDLE hFile,
      DWORD dwFileOffsetLow,
      DWORD dwFileOffsetHigh,
      DWORD nNumberOfBytesToLockLow,
      DWORD nNumberOfBytesToLockHigh
    );


__declspec(dllimport)
BOOL
__stdcall
LockFileEx(
      HANDLE hFile,
      DWORD dwFlags,
      DWORD dwReserved,
      DWORD nNumberOfBytesToLockLow,
      DWORD nNumberOfBytesToLockHigh,
      LPOVERLAPPED lpOverlapped
    );


#line 930 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceW(
      LPCWSTR lpDeviceName,
      LPWSTR lpTargetPath,
      DWORD ucchMax
    );






#line 951 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
ReadFile(
      HANDLE hFile,
       LPVOID lpBuffer,
      DWORD nNumberOfBytesToRead,
      LPDWORD lpNumberOfBytesRead,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
 
BOOL
__stdcall
ReadFileEx(
      HANDLE hFile,
       LPVOID lpBuffer,
      DWORD nNumberOfBytesToRead,
      LPOVERLAPPED lpOverlapped,
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

    
#line 984 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
ReadFileScatter(
      HANDLE hFile,
      FILE_SEGMENT_ELEMENT aSegmentArray[],
      DWORD nNumberOfBytesToRead,
      LPDWORD lpReserved,
      LPOVERLAPPED lpOverlapped
    );


#line 1004 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryA(
      LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryW(
      LPCWSTR lpPathName
    );





#line 1029 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetEndOfFile(
      HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesA(
      LPCSTR lpFileName,
      DWORD dwFileAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesW(
      LPCWSTR lpFileName,
      DWORD dwFileAttributes
    );





#line 1059 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"




__declspec(dllimport)
BOOL
__stdcall
SetFileInformationByHandle(
      HANDLE hFile,
      FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
      LPVOID lpFileInformation,
      DWORD dwBufferSize
    );


#line 1075 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
DWORD
__stdcall
SetFilePointer(
      HANDLE hFile,
      LONG lDistanceToMove,
      PLONG lpDistanceToMoveHigh,
      DWORD dwMoveMethod
    );


__declspec(dllimport)
BOOL
__stdcall
SetFilePointerEx(
      HANDLE hFile,
      LARGE_INTEGER liDistanceToMove,
      PLARGE_INTEGER lpNewFilePointer,
      DWORD dwMoveMethod
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileTime(
      HANDLE hFile,
      const FILETIME * lpCreationTime,
      const FILETIME * lpLastAccessTime,
      const FILETIME * lpLastWriteTime
    );


#line 1110 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
SetFileValidData(
      HANDLE hFile,
      LONGLONG ValidDataLength
    );


#line 1129 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1131 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
UnlockFile(
      HANDLE hFile,
      DWORD dwFileOffsetLow,
      DWORD dwFileOffsetHigh,
      DWORD nNumberOfBytesToUnlockLow,
      DWORD nNumberOfBytesToUnlockHigh
    );



__declspec(dllimport)
BOOL
__stdcall
UnlockFileEx(
      HANDLE hFile,
      DWORD dwReserved,
      DWORD nNumberOfBytesToUnlockLow,
      DWORD nNumberOfBytesToUnlockHigh,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFile(
      HANDLE hFile,
      LPCVOID lpBuffer,
      DWORD nNumberOfBytesToWrite,
      LPDWORD lpNumberOfBytesWritten,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFileEx(
      HANDLE hFile,
      LPCVOID lpBuffer,
      DWORD nNumberOfBytesToWrite,
      LPOVERLAPPED lpOverlapped,
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

    
#line 1187 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
WriteFileGather(
      HANDLE hFile,
      FILE_SEGMENT_ELEMENT aSegmentArray[],
      DWORD nNumberOfBytesToWrite,
      LPDWORD lpReserved,
      LPOVERLAPPED lpOverlapped
    );


#line 1206 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion








#pragma region Application Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
GetTempPathW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );






#line 1233 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointW(
      LPCWSTR lpszVolumeMountPoint,
      LPWSTR lpszVolumeName,
      DWORD cchBufferLength
    );









__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameW(
      LPCWSTR lpszVolumeName,
         LPWCH lpszVolumePathNames,
      DWORD cchBufferLength,
      PDWORD lpcchReturnLength
    );






#line 1272 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1274 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
    DWORD dwSize;   
    DWORD dwFileAttributes;
    DWORD dwFileFlags;   
    DWORD dwSecurityQosFlags;	
    LPSECURITY_ATTRIBUTES lpSecurityAttributes; 
    HANDLE hTemplateFile;      
} CREATEFILE2_EXTENDED_PARAMETERS, *PCREATEFILE2_EXTENDED_PARAMETERS, *LPCREATEFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HANDLE
__stdcall
CreateFile2(
      LPCWSTR lpFileName,
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      DWORD dwCreationDisposition,
      LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams
    );


#line 1305 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1307 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#line 1310 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"







#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
SetFileIoOverlappedRange(
      HANDLE FileHandle,
      PUCHAR OverlappedRangeStart,
      ULONG Length
    );


#line 1335 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1337 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeA(
      LPCSTR lpFileName,
      LPDWORD lpFileSizeHigh
    );

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeW(
      LPCWSTR lpFileName,
      LPDWORD lpFileSizeHigh
    );





#line 1367 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1369 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1371 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#line 1374 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"



#pragma region Desktop Family or OneCore Family






typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;




__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamW(
      LPCWSTR lpFileName,
      STREAM_INFO_LEVELS InfoLevel,
      LPVOID lpFindStreamData,
      DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextStreamW(
      HANDLE hFindStream,
      LPVOID lpFindStreamData
    );


#line 1422 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1424 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"




__declspec(dllimport)
BOOL
__stdcall
AreFileApisANSI(
    void
    );


#line 1437 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1439 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
DWORD
__stdcall
GetTempPathA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );




#line 1460 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1462 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1464 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family









__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameW(
      LPCWSTR lpFileName,
      DWORD dwFlags,
      LPDWORD StringLength,
      PWSTR LinkName
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextFileNameW(
      HANDLE hFindStream,
      LPDWORD StringLength,
      PWSTR LinkName
    );


#line 1498 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1500 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1502 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationA(
      LPCSTR lpRootPathName,
      LPSTR lpVolumeNameBuffer,
      DWORD nVolumeNameSize,
      LPDWORD lpVolumeSerialNumber,
      LPDWORD lpMaximumComponentLength,
      LPDWORD lpFileSystemFlags,
      LPSTR lpFileSystemNameBuffer,
      DWORD nFileSystemNameSize
    );




#line 1529 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

__declspec(dllimport)
UINT
__stdcall
GetTempFileNameA(
      LPCSTR lpPathName,
      LPCSTR lpPrefixString,
      UINT uUnique,
      LPSTR lpTempFileName
    );




#line 1544 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#line 1545 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1547 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
void
__stdcall
SetFileApisToOEM(
    void
    );


__declspec(dllimport)
void
__stdcall
SetFileApisToANSI(
    void
    );


#line 1573 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1575 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"
#pragma endregion






}
#line 1584 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 1586 "E:\\sdk\\include\\10.0.16299.0\\um\\fileapi.h"

#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
 











#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
























#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"

#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"



extern "C" {
#line 47 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"






#pragma region Application Family or OneCore Family





__declspec(dllimport)
BOOL
__stdcall
IsDebuggerPresent(
    void
    );

#line 67 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"

#line 69 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
void
__stdcall
DebugBreak(
    void
    );


#line 84 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
void
__stdcall
OutputDebugStringA(
      LPCSTR lpOutputString
    );

__declspec(dllimport)
void
__stdcall
OutputDebugStringW(
      LPCWSTR lpOutputString
    );





#line 109 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"

#line 111 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
ContinueDebugEvent(
      DWORD dwProcessId,
      DWORD dwThreadId,
      DWORD dwContinueStatus
    );


__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEvent(
      LPDEBUG_EVENT lpDebugEvent,
      DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcess(
      DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcessStop(
      DWORD dwProcessId
    );





__declspec(dllimport)
BOOL
__stdcall
CheckRemoteDebuggerPresent(
      HANDLE hProcess,
      PBOOL pbDebuggerPresent
    );


#line 170 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"

#line 172 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"

#line 174 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
#pragma endregion


#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEventEx(
      LPDEBUG_EVENT lpDebugEvent,
      DWORD dwMilliseconds
    );


#line 194 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"

#line 196 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"
#pragma endregion





}
#line 204 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"


#line 207 "E:\\sdk\\include\\10.0.16299.0\\um\\debugapi.h"


#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"





















#line 35 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"

#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"



extern "C" {
#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
PVOID
__stdcall
EncodePointer(
      PVOID Ptr
    );


__declspec(dllimport)
 
PVOID
__stdcall
DecodePointer(
      PVOID Ptr
    );


#line 66 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
PVOID
__stdcall
EncodeSystemPointer(
      PVOID Ptr
    );


__declspec(dllimport)
 
PVOID
__stdcall
DecodeSystemPointer(
      PVOID Ptr
    );





__declspec(dllimport)
HRESULT
__stdcall
EncodeRemotePointer(
      HANDLE ProcessHandle,
      PVOID Ptr,
      PVOID * EncodedPtr
    );


__declspec(dllimport)
HRESULT
__stdcall
DecodeRemotePointer(
      HANDLE ProcessHandle,
      PVOID Ptr,
      PVOID * DecodedPtr
    );


#line 114 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"

#line 116 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"
#pragma endregion

#pragma region PC Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
Beep(
      DWORD dwFreq,
      DWORD dwDuration
    );


#line 132 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"
#pragma endregion


}
#line 137 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"

#line 139 "E:\\sdk\\include\\10.0.16299.0\\um\\utilapiset.h"
#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"



















#line 33 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"

#line 35 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"



extern "C" {
#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"






#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
CloseHandle(
        HANDLE hObject
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateHandle(
      HANDLE hSourceProcessHandle,
      HANDLE hSourceHandle,
      HANDLE hTargetProcessHandle,
     LPHANDLE lpTargetHandle,
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      DWORD dwOptions
    );


__declspec(dllimport)
BOOL
__stdcall
CompareObjectHandles(
      HANDLE hFirstObjectHandle,
      HANDLE hSecondObjectHandle
    );


#line 85 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetHandleInformation(
      HANDLE hObject,
      LPDWORD lpdwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetHandleInformation(
      HANDLE hObject,
      DWORD dwMask,
      DWORD dwFlags
    );


#line 111 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"
#pragma endregion


}
#line 116 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"

#line 118 "E:\\sdk\\include\\10.0.16299.0\\um\\handleapi.h"
#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
 













#pragma once
#line 17 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

























#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 45 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"



extern "C" {
#line 50 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"








#pragma region Application Family or OneCore Family







typedef LONG (__stdcall *PTOP_LEVEL_EXCEPTION_FILTER)(
      struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;





__declspec(dllimport)

void
__stdcall
RaiseException(
      DWORD dwExceptionCode,
      DWORD dwExceptionFlags,
      DWORD nNumberOfArguments,
      const ULONG_PTR * lpArguments
    );


#line 89 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
LONG
__stdcall
UnhandledExceptionFilter(
      struct _EXCEPTION_POINTERS * ExceptionInfo
    );


#line 105 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
LPTOP_LEVEL_EXCEPTION_FILTER
__stdcall
SetUnhandledExceptionFilter(
      LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );




__declspec(dllimport)
   
DWORD
__stdcall
GetLastError(
    void
    );


#line 131 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

__declspec(dllimport)
void
__stdcall
SetLastError(
      DWORD dwErrCode
    );


#line 141 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
UINT
__stdcall
GetErrorMode(
    void
    );


#line 159 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
UINT
__stdcall
SetErrorMode(
      UINT uMode
    );


#line 176 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion





#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
 
PVOID
__stdcall
AddVectoredExceptionHandler(
      ULONG First,
      PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredExceptionHandler(
      PVOID Handle
    );


__declspec(dllimport)
 
PVOID
__stdcall
AddVectoredContinueHandler(
      ULONG First,
      PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredContinueHandler(
      PVOID Handle
    );


#line 226 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"























#line 250 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#line 251 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 253 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 255 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion





#pragma region Application Family or OneCore Family






__declspec(dllimport)
void
__stdcall
RaiseFailFastException(
      PEXCEPTION_RECORD pExceptionRecord,
      PCONTEXT pContextRecord,
      DWORD dwFlags
    );


#line 279 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 281 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion





#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
void
__stdcall
FatalAppExitA(
      UINT uAction,
      LPCSTR lpMessageText
    );

__declspec(dllimport)
void
__stdcall
FatalAppExitW(
      UINT uAction,
      LPCWSTR lpMessageText
    );





#line 315 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 317 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 319 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
DWORD
__stdcall
GetThreadErrorMode(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadErrorMode(
      DWORD dwNewMode,
      LPDWORD lpOldMode
    );


#line 346 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 348 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
void
__stdcall
TerminateProcessOnMemoryExhaustion(
      SIZE_T FailedAllocationSize
    );


#line 366 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 368 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"
#pragma endregion









}
#line 380 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"

#line 382 "E:\\sdk\\include\\10.0.16299.0\\um\\errhandlingapi.h"




#line 45 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"
 











#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"





















#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"

#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"



extern "C" {
#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"






#pragma region Application Family or OneCore Family








#line 60 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"

__declspec(dllimport)
DWORD
__stdcall
FlsAlloc(
      PFLS_CALLBACK_FUNCTION lpCallback
    );


__declspec(dllimport)
PVOID
__stdcall
FlsGetValue(
      DWORD dwFlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
FlsSetValue(
      DWORD dwFlsIndex,
      PVOID lpFlsData
    );


__declspec(dllimport)
BOOL
__stdcall
FlsFree(
      DWORD dwFlsIndex
    );


#line 95 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"

#line 97 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"
#pragma endregion





#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
IsThreadAFiber(
    void
    );


#line 119 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"

#line 121 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"
#pragma endregion







}
#line 131 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"

#line 133 "E:\\sdk\\include\\10.0.16299.0\\um\\fibersapi.h"


#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"
 
 












#pragma once
#line 17 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"


























#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"

#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"



extern "C" {
#line 51 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"










__declspec(dllimport)
BOOL
__stdcall
CreatePipe(
      PHANDLE hReadPipe,
      PHANDLE hWritePipe,
      LPSECURITY_ATTRIBUTES lpPipeAttributes,
      DWORD nSize
    );


__declspec(dllimport)
BOOL
__stdcall
ConnectNamedPipe(
      HANDLE hNamedPipe,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DisconnectNamedPipe(
      HANDLE hNamedPipe
    );


__declspec(dllimport)
BOOL
__stdcall
SetNamedPipeHandleState(
      HANDLE hNamedPipe,
      LPDWORD lpMode,
      LPDWORD lpMaxCollectionCount,
      LPDWORD lpCollectDataTimeout
    );


__declspec(dllimport)
BOOL
__stdcall
PeekNamedPipe(
      HANDLE hNamedPipe,
      LPVOID lpBuffer,
      DWORD nBufferSize,
      LPDWORD lpBytesRead,
      LPDWORD lpTotalBytesAvail,
      LPDWORD lpBytesLeftThisMessage
    );


__declspec(dllimport)
BOOL
__stdcall
TransactNamedPipe(
      HANDLE hNamedPipe,
      LPVOID lpInBuffer,
      DWORD nInBufferSize,
      LPVOID lpOutBuffer,
      DWORD nOutBufferSize,
      LPDWORD lpBytesRead,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeW(
      LPCWSTR lpName,
      DWORD dwOpenMode,
      DWORD dwPipeMode,
      DWORD nMaxInstances,
      DWORD nOutBufferSize,
      DWORD nInBufferSize,
      DWORD nDefaultTimeOut,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeW(
      LPCWSTR lpNamedPipeName,
      DWORD nTimeOut
    );









__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameW(
      HANDLE Pipe,
      LPWSTR ClientComputerName,
      ULONG ClientComputerNameLength
    );


#line 173 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"





__declspec(dllimport)
 
BOOL
__stdcall
ImpersonateNamedPipeClient(
      HANDLE hNamedPipe
    );
                               


#line 189 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"







#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeInfo(
      HANDLE hNamedPipe,
      LPDWORD lpFlags,
      LPDWORD lpOutBufferSize,
      LPDWORD lpInBufferSize,
      LPDWORD lpMaxInstances
    );


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateW(
      HANDLE hNamedPipe,
      LPDWORD lpState,
      LPDWORD lpCurInstances,
      LPDWORD lpMaxCollectionCount,
      LPDWORD lpCollectDataTimeout,
      LPWSTR lpUserName,
      DWORD nMaxUserNameSize
    );





#line 230 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"
#pragma endregion

#line 233 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"








#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeW(
      LPCWSTR lpNamedPipeName,
      LPVOID lpInBuffer,
      DWORD nInBufferSize,
      LPVOID lpOutBuffer,
      DWORD nOutBufferSize,
      LPDWORD lpBytesRead,
      DWORD nTimeOut
    );






#line 264 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"
#pragma endregion

#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"








}
#line 277 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"

#line 279 "E:\\sdk\\include\\10.0.16299.0\\um\\namedpipeapi.h"




#line 47 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"



















#line 33 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"

#line 35 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"



extern "C" {
#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"

#pragma region Application Family or OneCore Family







__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceCounter(
      LARGE_INTEGER * lpPerformanceCount
    );


__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceFrequency(
      LARGE_INTEGER * lpFrequency
    );


#line 66 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"
#pragma endregion


}
#line 71 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"

#line 73 "E:\\sdk\\include\\10.0.16299.0\\um\\profileapi.h"
#line 48 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"






















#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"

#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"





#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"

#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"



extern "C" {
#line 51 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"



#pragma warning(push)
#pragma warning(disable:4820) 
#line 57 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"

#pragma region Desktop Family or OneCore Family







typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

#line 76 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family







__declspec(dllimport)
 
HANDLE
__stdcall
HeapCreate(
      DWORD flOptions,
      SIZE_T dwInitialSize,
      SIZE_T dwMaximumSize
    );


__declspec(dllimport)
BOOL
__stdcall
HeapDestroy(
      HANDLE hHeap
    );

    
__declspec(dllimport)
 
 
__declspec(allocator)
LPVOID
__stdcall
HeapAlloc(
      HANDLE hHeap,
      DWORD dwFlags,
      SIZE_T dwBytes
    );


__declspec(dllimport)
 
 
 
__declspec(allocator)
LPVOID
__stdcall
HeapReAlloc(
      HANDLE hHeap,
      DWORD dwFlags,
      LPVOID lpMem,
      SIZE_T dwBytes
    );


__declspec(dllimport)
 
BOOL
__stdcall
HeapFree(
      HANDLE hHeap,
      DWORD dwFlags,
        LPVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapSize(
      HANDLE hHeap,
      DWORD dwFlags,
      LPCVOID lpMem
    );


__declspec(dllimport)
HANDLE
__stdcall
GetProcessHeap(
    void
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapCompact(
      HANDLE hHeap,
      DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
HeapSetInformation(
      HANDLE HeapHandle,
      HEAP_INFORMATION_CLASS HeapInformationClass,
      PVOID HeapInformation,
      SIZE_T HeapInformationLength
    );


#line 183 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
HeapValidate(
      HANDLE hHeap,
      DWORD dwFlags,
      LPCVOID lpMem
    );


#line 200 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family






BOOL
__stdcall
HeapSummary(
      HANDLE hHeap,
      DWORD dwFlags,
      LPHEAP_SUMMARY lpSummary
    );


#line 219 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"

#line 221 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
GetProcessHeaps(
      DWORD NumberOfHeaps,
      PHANDLE ProcessHeaps
    );


__declspec(dllimport)
BOOL
__stdcall
HeapLock(
      HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapUnlock(
      HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapWalk(
      HANDLE hHeap,
      LPPROCESS_HEAP_ENTRY lpEntry
    );


__declspec(dllimport)
BOOL
__stdcall
HeapQueryInformation(
      HANDLE HeapHandle,
      HEAP_INFORMATION_CLASS HeapInformationClass,
      PVOID HeapInformation,
      SIZE_T HeapInformationLength,
      PSIZE_T ReturnLength
    );

    
#line 274 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
#pragma endregion







#pragma warning(pop)
#line 284 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"


}
#line 288 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"

#line 290 "E:\\sdk\\include\\10.0.16299.0\\um\\heapapi.h"
#line 49 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"
 











#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"






















#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"

#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"



extern "C" {
#line 45 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"






#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
HANDLE
__stdcall
CreateIoCompletionPort(
      HANDLE FileHandle,
      HANDLE ExistingCompletionPort,
      ULONG_PTR CompletionKey,
      DWORD NumberOfConcurrentThreads
    );


__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatus(
      HANDLE CompletionPort,
      LPDWORD lpNumberOfBytesTransferred,
      PULONG_PTR lpCompletionKey,
      LPOVERLAPPED * lpOverlapped,
      DWORD dwMilliseconds
    );





__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatusEx(
      HANDLE CompletionPort,
      LPOVERLAPPED_ENTRY lpCompletionPortEntries,
      ULONG ulCount,
      PULONG ulNumEntriesRemoved,
      DWORD dwMilliseconds,
      BOOL fAlertable
    );


#line 96 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"

__declspec(dllimport)
BOOL
__stdcall
PostQueuedCompletionStatus(
      HANDLE CompletionPort,
      DWORD dwNumberOfBytesTransferred,
      ULONG_PTR dwCompletionKey,
      LPOVERLAPPED lpOverlapped
    );


#line 109 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
DeviceIoControl(
      HANDLE hDevice,
      DWORD dwIoControlCode,
      LPVOID lpInBuffer,
      DWORD nInBufferSize,
      LPVOID lpOutBuffer,
      DWORD nOutBufferSize,
      LPDWORD lpBytesReturned,
      LPOVERLAPPED lpOverlapped
    );


#line 131 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResult(
      HANDLE hFile,
      LPOVERLAPPED lpOverlapped,
      LPDWORD lpNumberOfBytesTransferred,
      BOOL bWait
    );





__declspec(dllimport)
BOOL
__stdcall
CancelIoEx(
      HANDLE hFile,
      LPOVERLAPPED lpOverlapped
    );


#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"

#line 163 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"
#pragma endregion








#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CancelIo(
      HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResultEx(
      HANDLE hFile,
      LPOVERLAPPED lpOverlapped,
      LPDWORD lpNumberOfBytesTransferred,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


#line 197 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
CancelSynchronousIo(
      HANDLE hThread
    );


#line 215 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"

#line 217 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"
#pragma endregion

#line 220 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"







}
#line 229 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"

#line 231 "E:\\sdk\\include\\10.0.16299.0\\um\\ioapiset.h"


#line 50 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
 
 











#pragma once
#line 16 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
























#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"



extern "C" {
#line 48 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"







#pragma region Application or OneCore Family









typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#line 68 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
#pragma endregion





#pragma region Application or OneCore Family






__declspec(dllimport)
void
__stdcall
InitializeSRWLock(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockExclusive(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockShared(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockExclusive(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockShared(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockExclusive(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockShared(
      PSRWLOCK SRWLock
    );


#line 144 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"












#line 157 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
InitializeCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


#line 167 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
EnterCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
 
BOOL
__stdcall
InitializeCriticalSectionAndSpinCount(
      LPCRITICAL_SECTION lpCriticalSection,
      DWORD dwSpinCount
    );





__declspec(dllimport)
BOOL
__stdcall
InitializeCriticalSectionEx(
      LPCRITICAL_SECTION lpCriticalSection,
      DWORD dwSpinCount,
      DWORD Flags
    );


#line 208 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
DWORD
__stdcall
SetCriticalSectionSpinCount(
      LPCRITICAL_SECTION lpCriticalSection,
      DWORD dwSpinCount
    );





__declspec(dllimport)
BOOL
__stdcall
TryEnterCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


#line 230 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
DeleteCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );










typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;


















typedef
BOOL
(__stdcall *PINIT_ONCE_FN) (
      PINIT_ONCE InitOnce,
      PVOID Parameter,
     PVOID *Context
    );







__declspec(dllimport)
void
__stdcall
InitOnceInitialize(
      PINIT_ONCE InitOnce
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceExecuteOnce(
      PINIT_ONCE InitOnce,
       PINIT_ONCE_FN InitFn,
      PVOID Parameter,
     LPVOID * Context
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceBeginInitialize(
      LPINIT_ONCE lpInitOnce,
      DWORD dwFlags,
      PBOOL fPending,
     LPVOID * lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceComplete(
      LPINIT_ONCE lpInitOnce,
      DWORD dwFlags,
      LPVOID lpContext
    );


#line 323 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 325 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"





typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;



















__declspec(dllimport)
void
__stdcall
InitializeConditionVariable(
      PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeConditionVariable(
      PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeAllConditionVariable(
      PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableCS(
      PCONDITION_VARIABLE ConditionVariable,
      PCRITICAL_SECTION CriticalSection,
      DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableSRW(
      PCONDITION_VARIABLE ConditionVariable,
      PSRWLOCK SRWLock,
      DWORD dwMilliseconds,
      ULONG Flags
    );


#line 396 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 398 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"





__declspec(dllimport)
BOOL
__stdcall
SetEvent(
      HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ResetEvent(
      HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseSemaphore(
      HANDLE hSemaphore,
      LONG lReleaseCount,
      LPLONG lpPreviousCount
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseMutex(
      HANDLE hMutex
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObject(
      HANDLE hHandle,
      DWORD dwMilliseconds
    );


__declspec(dllimport)
DWORD
__stdcall
SleepEx(
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObjectEx(
      HANDLE hHandle,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjectsEx(
      DWORD nCount,
      const HANDLE * lpHandles,
      BOOL bWaitAll,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );









__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexA(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      BOOL bInitialOwner,
      LPCSTR lpName
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexW(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      BOOL bInitialOwner,
      LPCWSTR lpName
    );





#line 509 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenMutexW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );






__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventA(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      BOOL bManualReset,
      BOOL bInitialState,
      LPCSTR lpName
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventW(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      BOOL bManualReset,
      BOOL bInitialState,
      LPCWSTR lpName
    );





#line 552 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenEventA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );

__declspec(dllimport)
 
HANDLE
__stdcall
OpenEventW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );





#line 578 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenSemaphoreW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );









typedef
void
(__stdcall *PTIMERAPCROUTINE)(
      LPVOID lpArgToCompletionRoutine,
          DWORD dwTimerLowValue,
          DWORD dwTimerHighValue
    );

__declspec(dllimport)
 
HANDLE
__stdcall
OpenWaitableTimerW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpTimerName
    );









BOOL
__stdcall
SetWaitableTimerEx(
      HANDLE hTimer,
      const LARGE_INTEGER * lpDueTime,
      LONG lPeriod,
      PTIMERAPCROUTINE pfnCompletionRoutine,
      LPVOID lpArgToCompletionRoutine,
      PREASON_CONTEXT WakeContext,
      ULONG TolerableDelay
    );


#line 637 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetWaitableTimer(
      HANDLE hTimer,
      const LARGE_INTEGER * lpDueTime,
      LONG lPeriod,
      PTIMERAPCROUTINE pfnCompletionRoutine,
      LPVOID lpArgToCompletionRoutine,
      BOOL fResume
    );


__declspec(dllimport)
BOOL
__stdcall
CancelWaitableTimer(
      HANDLE hTimer
    );







__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexExA(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      LPCSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexExW(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      LPCWSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );





#line 691 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"




__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventExA(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      LPCSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventExW(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      LPCWSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );





#line 722 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreExW(
      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
      LONG lInitialCount,
      LONG lMaximumCount,
      LPCWSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );








__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerExW(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
      LPCWSTR lpTimerName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );






#line 760 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 762 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 764 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
#pragma endregion








#pragma region Desktop or OneCore Family



typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;





BOOL
__stdcall
EnterSynchronizationBarrier(
      LPSYNCHRONIZATION_BARRIER lpBarrier,
      DWORD dwFlags
    );


BOOL
__stdcall
InitializeSynchronizationBarrier(
      LPSYNCHRONIZATION_BARRIER lpBarrier,
      LONG lTotalThreads,
      LONG lSpinCount
    );


BOOL
__stdcall
DeleteSynchronizationBarrier(
      LPSYNCHRONIZATION_BARRIER lpBarrier
    );


#line 810 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
#pragma endregion

#pragma region Application or OneCore Family



__declspec(dllimport)
void
__stdcall
Sleep(
      DWORD dwMilliseconds
    );


BOOL
__stdcall
WaitOnAddress(
      volatile void * Address,
      PVOID CompareAddress,
      SIZE_T AddressSize,
      DWORD dwMilliseconds
    );


void
__stdcall
WakeByAddressSingle(
      PVOID Address
    );


void
__stdcall
WakeByAddressAll(
      PVOID Address
    );

    
#line 849 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop or OneCore Family





__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
      HANDLE hObjectToSignal,
      HANDLE hObjectToWaitOn,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


#line 869 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 871 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
#pragma endregion

#line 874 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"






#pragma region Application or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjects(
      DWORD nCount,
      const HANDLE * lpHandles,
      BOOL bWaitAll,
      DWORD dwMilliseconds
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateSemaphoreW(
      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
      LONG lInitialCount,
      LONG lMaximumCount,
      LPCWSTR lpName
    );






__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerW(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
      BOOL bManualReset,
      LPCWSTR lpTimerName
    );






#line 926 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"
#pragma endregion

#line 929 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"






}
#line 937 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"

#line 939 "E:\\sdk\\include\\10.0.16299.0\\um\\synchapi.h"


#line 51 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"
 
 










#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"





















#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"



extern "C" {
#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

#pragma region Application Family or OneCore Family












__declspec(dllimport)
void
__stdcall
InitializeSListHead(
      PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPopEntrySList(
      PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushEntrySList(
      PSLIST_HEADER ListHead,
        PSLIST_ENTRY ListEntry
    );







__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushListSListEx(
      PSLIST_HEADER ListHead,
      PSLIST_ENTRY List,
      PSLIST_ENTRY ListEnd,
      ULONG Count
    );


#line 100 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedFlushSList(
      PSLIST_HEADER ListHead
    );


__declspec(dllimport)
USHORT
__stdcall
QueryDepthSList(
      PSLIST_HEADER ListHead
    );


#line 118 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

#line 120 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

#line 122 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"




#line 127 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"
#pragma endregion


}
#line 132 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

#line 134 "E:\\sdk\\include\\10.0.16299.0\\um\\interlockedapi.h"

#line 52 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
 













#pragma once
#line 17 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"


























#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"



extern "C" {
#line 51 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"









#pragma region Application Family or OneCore Family



typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;




typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#line 118 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 120 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion





#pragma region Application Family or OneCore Family






__declspec(dllimport)
DWORD
__stdcall
QueueUserAPC(
      PAPCFUNC pfnAPC,
      HANDLE hThread,
      ULONG_PTR dwData
    );


#line 144 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessTimes(
      HANDLE hProcess,
      LPFILETIME lpCreationTime,
      LPFILETIME lpExitTime,
      LPFILETIME lpKernelTime,
      LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
GetCurrentProcess(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessId(
    void
    );


#line 174 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitProcess(
      UINT uExitCode
    );


#line 190 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
TerminateProcess(
      HANDLE hProcess,
      UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
GetExitCodeProcess(
      HANDLE hProcess,
      LPDWORD lpExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
SwitchToThread(
    void
    );


__declspec(dllimport)
 
HANDLE
__stdcall
CreateThread(
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPDWORD lpThreadId
    );

#line 236 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
 
HANDLE
__stdcall
CreateRemoteThread(
      HANDLE hProcess,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPDWORD lpThreadId
    );


#line 257 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
HANDLE
__stdcall
GetCurrentThread(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentThreadId(
    void
    );


__declspec(dllimport)
 
HANDLE
__stdcall
OpenThread(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      DWORD dwThreadId
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriority(
      HANDLE hThread,
      int nPriority
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriorityBoost(
      HANDLE hThread,
      BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadPriorityBoost(
      HANDLE hThread,
      PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
int
__stdcall
GetThreadPriority(
      HANDLE hThread
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitThread(
      DWORD dwExitCode
    );

#line 334 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
TerminateThread(
      HANDLE hThread,
      DWORD dwExitCode
    );

#line 348 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
GetExitCodeThread(
      HANDLE hThread,
      LPDWORD lpExitCode
    );


__declspec(dllimport)
DWORD
__stdcall
SuspendThread(
      HANDLE hThread
    );


__declspec(dllimport)
DWORD
__stdcall
ResumeThread(
      HANDLE hThread
    );




#line 383 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

 
__declspec(dllimport)
DWORD
__stdcall
TlsAlloc(
    void
    );


__declspec(dllimport)
LPVOID
__stdcall
TlsGetValue(
      DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
TlsSetValue(
      DWORD dwTlsIndex,
      LPVOID lpTlsValue
    );


__declspec(dllimport)
BOOL
__stdcall
TlsFree(
      DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
CreateProcessA(
      LPCSTR lpApplicationName,
      LPSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCSTR lpCurrentDirectory,
      LPSTARTUPINFOA lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessW(
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );





#line 455 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 457 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetProcessShutdownParameters(
      DWORD dwLevel,
      DWORD dwFlags
    );


__declspec(dllimport)
DWORD
__stdcall
GetProcessVersion(
      DWORD ProcessId
    );


__declspec(dllimport)
void
__stdcall
GetStartupInfoW(
      LPSTARTUPINFOW lpStartupInfo
    );





__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserW(
      HANDLE hToken,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );






















__forceinline
HANDLE
GetCurrentProcessToken (
    void
    )
{
    return (HANDLE)(LONG_PTR) -4;
}

__forceinline
HANDLE
GetCurrentThreadToken (
    void
    )
{
    return (HANDLE)(LONG_PTR) -5;
}

__forceinline
HANDLE
GetCurrentThreadEffectiveToken (
    void
    )
{
    return (HANDLE)(LONG_PTR) -6;
}

#line 557 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#line 558 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 560 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
SetThreadToken(
      PHANDLE Thread,
      HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
OpenProcessToken(
      HANDLE ProcessHandle,
      DWORD DesiredAccess,
     PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
OpenThreadToken(
      HANDLE ThreadHandle,
      DWORD DesiredAccess,
      BOOL OpenAsSelf,
     PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetPriorityClass(
      HANDLE hProcess,
      DWORD dwPriorityClass
    );


__declspec(dllimport)
DWORD
__stdcall
GetPriorityClass(
      HANDLE hProcess
    );


#line 615 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetThreadStackGuarantee(
      PULONG StackSizeInBytes
    );


__declspec(dllimport)
BOOL
__stdcall
ProcessIdToSessionId(
      DWORD dwProcessId,
      DWORD * pSessionId
    );


typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

#line 641 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
DWORD
__stdcall
GetProcessId(
      HANDLE Process
    );


#line 659 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




__declspec(dllimport)
DWORD
__stdcall
GetThreadId(
      HANDLE Thread
    );


#line 672 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




__declspec(dllimport)
void
__stdcall
FlushProcessWriteBuffers(
    void
    );


#line 685 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 687 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion




#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
GetProcessIdOfThread(
      HANDLE Thread
    );


__declspec(dllimport)
 
BOOL
__stdcall
InitializeProcThreadAttributeList(
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
      DWORD dwAttributeCount,
      DWORD dwFlags,
      PSIZE_T lpSize
    );


__declspec(dllimport)
void
__stdcall
DeleteProcThreadAttributeList(
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );




__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityUpdateMode(
      HANDLE hProcess,
      DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessAffinityUpdateMode(
      HANDLE hProcess,
      LPDWORD lpdwFlags
    );




__declspec(dllimport)
BOOL
__stdcall
UpdateProcThreadAttribute(
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
      DWORD dwFlags,
      DWORD_PTR Attribute,
      PVOID lpValue,
      SIZE_T cbSize,
      PVOID lpPreviousValue,
      PSIZE_T lpReturnSize
    );


#line 761 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 764 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
HANDLE
__stdcall
CreateRemoteThreadEx(
      HANDLE hProcess,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
      LPDWORD lpThreadId
    );


#line 786 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion









#pragma region Application Family or OneCore Family






__declspec(dllimport)
void
__stdcall
GetCurrentThreadStackLimits(
      PULONG_PTR LowLimit,
      PULONG_PTR HighLimit
    );


#line 813 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetThreadContext(
      HANDLE hThread,
      LPCONTEXT lpContext
    );





__declspec(dllimport)
BOOL
__stdcall
GetProcessMitigationPolicy(
      HANDLE hProcess,
      PROCESS_MITIGATION_POLICY MitigationPolicy,
      PVOID lpBuffer,
      SIZE_T dwLength
    );


#line 838 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 840 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetThreadContext(
      HANDLE hThread,
      const CONTEXT * lpContext
    );





__declspec(dllimport)
BOOL
__stdcall
SetProcessMitigationPolicy(
      PROCESS_MITIGATION_POLICY MitigationPolicy,
      PVOID lpBuffer,
      SIZE_T dwLength
    );


#line 869 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 871 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 874 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#line 875 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FlushInstructionCache(
      HANDLE hProcess,
      LPCVOID lpBaseAddress,
      SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadTimes(
      HANDLE hThread,
      LPFILETIME lpCreationTime,
      LPFILETIME lpExitTime,
      LPFILETIME lpKernelTime,
      LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenProcess(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
IsProcessorFeaturePresent(
      DWORD ProcessorFeature
    );


#line 924 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 927 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetProcessHandleCount(
      HANDLE hProcess,
      PDWORD pdwHandleCount
    );


#line 945 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 948 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




#pragma region Application Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessorNumber(
    void
    );


#line 965 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 968 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetThreadIdealProcessorEx(
      HANDLE hThread,
      PPROCESSOR_NUMBER lpIdealProcessor,
      PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadIdealProcessorEx(
      HANDLE hThread,
      PPROCESSOR_NUMBER lpIdealProcessor
    );


__declspec(dllimport)
void
__stdcall
GetCurrentProcessorNumberEx(
      PPROCESSOR_NUMBER ProcNumber
    );


#line 1004 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 1007 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"







#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetProcessPriorityBoost(
      HANDLE hProcess,
      PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessPriorityBoost(
      HANDLE hProcess,
      BOOL bDisablePriorityBoost
    );


#line 1040 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 1042 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetThreadIOPendingFlag(
      HANDLE hThread,
      PBOOL lpIOIsPending
    );


__declspec(dllimport)
BOOL
__stdcall
GetSystemTimes(
      PFILETIME lpIdleTime,
      PFILETIME lpKernelTime,
      PFILETIME lpUserTime
    );


#line 1071 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"





typedef enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax
} THREAD_INFORMATION_CLASS;




typedef struct _MEMORY_PRIORITY_INFORMATION {
    ULONG MemoryPriority;
} MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetThreadInformation(
      HANDLE hThread,
      THREAD_INFORMATION_CLASS ThreadInformationClass,
      LPVOID ThreadInformation,
      DWORD ThreadInformationSize
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadInformation(
      HANDLE hThread,
      THREAD_INFORMATION_CLASS ThreadInformationClass,
      LPVOID ThreadInformation,
      DWORD ThreadInformationSize
    );


#line 1114 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"










typedef struct _THREAD_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} THREAD_POWER_THROTTLING_STATE;

#line 1131 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




__declspec(dllimport)
BOOL
__stdcall
IsProcessCritical(
      HANDLE hProcess,
      PBOOL Critical
    );


#line 1145 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




__declspec(dllimport)
BOOL
__stdcall
SetProtectedPolicy(
      LPCGUID PolicyGuid,
      ULONG_PTR PolicyValue,
      PULONG_PTR OldPolicyValue
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProtectedPolicy(
      LPCGUID PolicyGuid,
      PULONG_PTR PolicyValue
    );


#line 1169 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 1171 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#line 1174 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"







#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
SetThreadIdealProcessor(
      HANDLE hThread,
      DWORD dwIdealProcessor
    );


#line 1195 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,           
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessInformationClassMax
} PROCESS_INFORMATION_CLASS;

typedef struct _APP_MEMORY_INFORMATION {
    ULONG64 AvailableCommit;
    ULONG64 PrivateCommitUsage;
    ULONG64 PeakPrivateCommitUsage;
    ULONG64 TotalCommitUsage;
} APP_MEMORY_INFORMATION, *PAPP_MEMORY_INFORMATION;








typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax
} PROCESS_MEMORY_EXHAUSTION_TYPE, *PPROCESS_MEMORY_EXHAUSTION_TYPE;




typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
    USHORT Version;
    USHORT Reserved;
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ULONG_PTR Value;
} PROCESS_MEMORY_EXHAUSTION_INFO, *PPROCESS_MEMORY_EXHAUSTION_INFO;







typedef struct _PROCESS_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} PROCESS_POWER_THROTTLING_STATE, *PPROCESS_POWER_THROTTLING_STATE;

typedef struct PROCESS_PROTECTION_LEVEL_INFORMATION {
    DWORD ProtectionLevel;
} PROCESS_PROTECTION_LEVEL_INFORMATION;




__declspec(dllimport)
BOOL
__stdcall
SetProcessInformation(
      HANDLE hProcess,
      PROCESS_INFORMATION_CLASS ProcessInformationClass,
      LPVOID ProcessInformation,
      DWORD ProcessInformationSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetProcessInformation(
      HANDLE hProcess,
      PROCESS_INFORMATION_CLASS ProcessInformationClass,
      LPVOID ProcessInformation,
      DWORD ProcessInformationSize
    );


#line 1284 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"




 
BOOL
__stdcall
GetSystemCpuSetInformation(
      PSYSTEM_CPU_SET_INFORMATION Information,
      ULONG BufferLength,
     PULONG ReturnedLength,
      HANDLE Process,
      ULONG Flags
    );


 
BOOL
__stdcall
GetProcessDefaultCpuSets(
      HANDLE Process,
      PULONG CpuSetIds,
      ULONG CpuSetIdCount,
     PULONG RequiredIdCount
    );


 
BOOL
__stdcall
SetProcessDefaultCpuSets(
      HANDLE Process,
      const ULONG * CpuSetIds,
      ULONG CpuSetIdCount
    );


 
BOOL
__stdcall
GetThreadSelectedCpuSets(
      HANDLE Thread,
      PULONG CpuSetIds,
      ULONG CpuSetIdCount,
     PULONG RequiredIdCount
    );


 
BOOL
__stdcall
SetThreadSelectedCpuSets(
      HANDLE Thread,
      const ULONG * CpuSetIds,
      ULONG CpuSetIdCount
    );


#line 1343 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 1345 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserA(
      HANDLE hToken,
      LPCSTR lpApplicationName,
      LPSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCSTR lpCurrentDirectory,
      LPSTARTUPINFOA lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );




#line 1372 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessShutdownParameters(
      LPDWORD lpdwLevel,
      LPDWORD lpdwFlags
    );


#line 1383 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"
#pragma endregion

__declspec(dllimport)
HRESULT
__stdcall
SetThreadDescription(
      HANDLE hThread,
      PCWSTR lpThreadDescription
    );

 
__declspec(dllimport)
HRESULT
__stdcall
GetThreadDescription(
      HANDLE hThread,
     PWSTR * ppszThreadDescription
    );


#line 1404 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"









}
#line 1415 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"

#line 1417 "E:\\sdk\\include\\10.0.16299.0\\um\\processthreadsapi.h"





#line 53 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
 
 














#pragma once
#line 19 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"











#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"


#pragma warning(push)
#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"




















#line 63 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 65 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"





#line 71 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 73 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"


extern "C" {
#line 77 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"









#pragma region Application Family or OneCore Family



typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } ;
    } ;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

#line 110 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion





#pragma region Application Family or OneCore Family



typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

__declspec(dllimport)
BOOL
__stdcall
GlobalMemoryStatusEx(
      LPMEMORYSTATUSEX lpBuffer
    );


__declspec(dllimport)
void
__stdcall
GetSystemInfo(
      LPSYSTEM_INFO lpSystemInfo
    );


__declspec(dllimport)
void
__stdcall
GetSystemTime(
      LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemTimeAsFileTime(
      LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
void
__stdcall
GetLocalTime(
      LPSYSTEMTIME lpSystemTime
    );


#line 173 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(deprecated)
__declspec(dllimport)
 
DWORD
__stdcall
GetVersion(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetLocalTime(
      const SYSTEMTIME * lpSystemTime
    );


#line 198 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion




#pragma region Application Family or OneCore Family



 
__declspec(dllimport)
DWORD
__stdcall
GetTickCount(
    void
    );





__declspec(dllimport)
ULONGLONG
__stdcall
GetTickCount64(
    void
    );


#line 228 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 230 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
GetSystemTimeAdjustment(
      PDWORD lpTimeAdjustment,
      PDWORD lpTimeIncrement,
      PBOOL lpTimeAdjustmentDisabled
    );


__declspec(dllimport)
 
UINT
__stdcall
GetSystemDirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
UINT
__stdcall
GetSystemDirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 270 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

__declspec(dllimport)
 
 
UINT
__stdcall
GetWindowsDirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
 
UINT
__stdcall
GetWindowsDirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 296 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

__declspec(dllimport)
 
UINT
__stdcall
GetSystemWindowsDirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
UINT
__stdcall
GetSystemWindowsDirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 320 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 322 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion







#pragma region Desktop Family or OneCore Family



typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

#line 347 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion







#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameExA(
      COMPUTER_NAME_FORMAT NameType,
      LPSTR lpBuffer,
      LPDWORD nSize
    );

__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameExW(
      COMPUTER_NAME_FORMAT NameType,
      LPWSTR lpBuffer,
      LPDWORD nSize
    );





#line 384 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 386 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion







#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExW(
      COMPUTER_NAME_FORMAT NameType,
      LPCWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
SetSystemTime(
      const SYSTEMTIME * lpSystemTime
    );


#line 420 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#line 423 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"




#pragma region Application Family or OneCore Family



__declspec(deprecated)
__declspec(dllimport)
 
BOOL
__stdcall
GetVersionExA(
      LPOSVERSIONINFOA lpVersionInformation
    );

__declspec(deprecated)
__declspec(dllimport)
 
BOOL
__stdcall
GetVersionExW(
      LPOSVERSIONINFOW lpVersionInformation
    );





#line 454 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformation(
      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
      PDWORD ReturnedLength
    );





__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformationEx(
      LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
      PDWORD ReturnedLength
    );


#line 478 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 480 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion







#pragma region Application Family or OneCore Family






__declspec(dllimport)
void
__stdcall
GetNativeSystemInfo(
      LPSYSTEM_INFO lpSystemInfo
    );


#line 504 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"




__declspec(dllimport)
void
__stdcall
GetSystemTimePreciseAsFileTime(
      LPFILETIME lpSystemTimeAsFileTime
    );


#line 517 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 519 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetProductInfo(
      DWORD dwOSMajorVersion,
      DWORD dwOSMinorVersion,
      DWORD dwSpMajorVersion,
      DWORD dwSpMinorVersion,
      PDWORD pdwReturnedProductType
    );


#line 541 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"




__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
      ULONGLONG ConditionMask,
      ULONG TypeMask,
      UCHAR Condition
    );


#line 556 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"




__declspec(dllimport)
BOOL
__stdcall
GetOsSafeBootMode(
      PDWORD Flags
    );


#line 569 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

__declspec(dllimport)
UINT
__stdcall
EnumSystemFirmwareTables(
      DWORD FirmwareTableProviderSignature,
      PVOID pFirmwareTableEnumBuffer,
      DWORD BufferSize
    );


__declspec(dllimport)
UINT
__stdcall
GetSystemFirmwareTable(
      DWORD FirmwareTableProviderSignature,
      DWORD FirmwareTableID,
      PVOID pFirmwareTableBuffer,
      DWORD BufferSize
    );


#line 592 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#line 595 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"







#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
DnsHostnameToComputerNameExW(
      LPCWSTR Hostname,
      LPWSTR ComputerName,
      LPDWORD nSize
    );


__declspec(dllimport)
 
BOOL
__stdcall
GetPhysicallyInstalledSystemMemory(
      PULONGLONG TotalMemoryInKilobytes
    );




__declspec(dllimport)
BOOL
__stdcall
SetComputerNameEx2W(
      COMPUTER_NAME_FORMAT NameType,
      DWORD Flags,
      LPCWSTR lpBuffer
    );






__declspec(dllimport)
 
BOOL
__stdcall
SetSystemTimeAdjustment(
      DWORD dwTimeAdjustment,
      BOOL bTimeAdjustmentDisabled
    );


__declspec(dllimport)
BOOL
__stdcall
InstallELAMCertificateInfo(
      HANDLE ELAMFile
    );


#line 661 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#line 664 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"










__declspec(dllimport)
BOOL
__stdcall
GetProcessorSystemCycleTime(
      USHORT Group,
      PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
      PDWORD ReturnedLength
    );


#line 685 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 687 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"







#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetOsManufacturingMode(
      PBOOL pbEnabled
    );

#line 709 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 711 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion


#pragma region App Family or OneCore Family






__declspec(dllimport)
HRESULT
__stdcall
GetIntegratedDisplaySize(
      double * sizeInInches
    );


#line 730 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 732 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetComputerNameA(
      LPCSTR lpComputerName
    );

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameW(
      LPCWSTR lpComputerName
    );





#line 757 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExA(
      COMPUTER_NAME_FORMAT NameType,
      LPCSTR lpBuffer
    );




#line 770 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 772 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#pragma endregion

#line 775 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"









}
#line 786 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"





#pragma warning(pop)





#line 798 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"
#line 799 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"

#line 801 "E:\\sdk\\include\\10.0.16299.0\\um\\sysinfoapi.h"






#line 54 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
 















#pragma once
#line 19 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"






























#line 50 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 52 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"




extern "C" {
#line 58 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"



#pragma warning(push)
#pragma warning(disable:4668) 
#line 64 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#pragma region Application Family or OneCore Family















#line 82 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion









#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
   
LPVOID
__stdcall
VirtualAlloc(
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flAllocationType,
      DWORD flProtect
    );


__declspec(dllimport)
 
BOOL
__stdcall
VirtualProtect(
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flNewProtect,
      PDWORD lpflOldProtect
    );


#line 121 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




#line 129 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"


#line 132 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"


#line 135 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
 
__declspec(dllimport)
BOOL
__stdcall
VirtualFree(
        LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD dwFreeType
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQuery(
      LPCVOID lpAddress,
      PMEMORY_BASIC_INFORMATION lpBuffer,
      SIZE_T dwLength
    );


#line 157 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
   
LPVOID
__stdcall
VirtualAllocEx(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flAllocationType,
      DWORD flProtect
    );



#line 178 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"


#line 181 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"


#line 184 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"


#line 187 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
 
__declspec(dllimport)
BOOL
__stdcall
VirtualFreeEx(
      HANDLE hProcess,
        LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD dwFreeType
    );


__declspec(dllimport)
 
BOOL
__stdcall
VirtualProtectEx(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flNewProtect,
      PDWORD lpflOldProtect
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQueryEx(
      HANDLE hProcess,
      LPCVOID lpAddress,
      PMEMORY_BASIC_INFORMATION lpBuffer,
      SIZE_T dwLength
    );


__declspec(dllimport)
 
BOOL
__stdcall
ReadProcessMemory(
      HANDLE hProcess,
      LPCVOID lpBaseAddress,
      LPVOID lpBuffer,
      SIZE_T nSize,
      SIZE_T * lpNumberOfBytesRead
    );


__declspec(dllimport)
 
BOOL
__stdcall
WriteProcessMemory(
      HANDLE hProcess,
      LPVOID lpBaseAddress,
      LPCVOID lpBuffer,
      SIZE_T nSize,
      SIZE_T * lpNumberOfBytesWritten
    );


__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingW(
      HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
      DWORD flProtect,
      DWORD dwMaximumSizeHigh,
      DWORD dwMaximumSizeLow,
      LPCWSTR lpName
    );






__declspec(dllimport)
 
HANDLE
__stdcall
OpenFileMappingW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );






__declspec(dllimport)
   
LPVOID
__stdcall
MapViewOfFile(
      HANDLE hFileMappingObject,
      DWORD dwDesiredAccess,
      DWORD dwFileOffsetHigh,
      DWORD dwFileOffsetLow,
      SIZE_T dwNumberOfBytesToMap
    );


__declspec(dllimport)
   
LPVOID
__stdcall
MapViewOfFileEx(
      HANDLE hFileMappingObject,
      DWORD dwDesiredAccess,
      DWORD dwFileOffsetHigh,
      DWORD dwFileOffsetLow,
      SIZE_T dwNumberOfBytesToMap,
      LPVOID lpBaseAddress
    );


#line 310 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FlushViewOfFile(
      LPCVOID lpBaseAddress,
      SIZE_T dwNumberOfBytesToFlush
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile(
      LPCVOID lpBaseAddress
    );


#line 334 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion







#pragma region Application Family or OneCore Family



__declspec(dllimport)
SIZE_T
__stdcall
GetLargePageMinimum(
    void
    );


__declspec(dllimport)
 
BOOL
__stdcall
GetProcessWorkingSetSizeEx(
      HANDLE hProcess,
      PSIZE_T lpMinimumWorkingSetSize,
      PSIZE_T lpMaximumWorkingSetSize,
      PDWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSizeEx(
      HANDLE hProcess,
      SIZE_T dwMinimumWorkingSetSize,
      SIZE_T dwMaximumWorkingSetSize,
      DWORD Flags
    );


#line 378 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
VirtualLock(
      LPVOID lpAddress,
      SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualUnlock(
      LPVOID lpAddress,
      SIZE_T dwSize
    );


#line 403 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
UINT
__stdcall
GetWriteWatch(
      DWORD dwFlags,
      PVOID lpBaseAddress,
      SIZE_T dwRegionSize,
      PVOID * lpAddresses,
      ULONG_PTR * lpdwCount,
      LPDWORD lpdwGranularity
    );


__declspec(dllimport)
UINT
__stdcall
ResetWriteWatch(
      LPVOID lpBaseAddress,
      SIZE_T dwRegionSize
    );


#line 433 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;

__declspec(dllimport)
 
HANDLE
__stdcall
CreateMemoryResourceNotification(
      MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );


__declspec(dllimport)
 
BOOL
__stdcall
QueryMemoryResourceNotification(
      HANDLE ResourceNotificationHandle,
      PBOOL ResourceState
    );


#line 467 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"










__declspec(dllimport)
 
BOOL
__stdcall
GetSystemFileCacheSize(
      PSIZE_T lpMinimumFileCacheSize,
      PSIZE_T lpMaximumFileCacheSize,
      PDWORD lpFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetSystemFileCacheSize(
      SIZE_T MinimumFileCacheSize,
      SIZE_T MaximumFileCacheSize,
      DWORD Flags
    );


#line 499 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"




__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingNumaW(
      HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
      DWORD flProtect,
      DWORD dwMaximumSizeHigh,
      DWORD dwMaximumSizeLow,
      LPCWSTR lpName,
      DWORD nndPreferred
    );






#line 523 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"




typedef struct _WIN32_MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} WIN32_MEMORY_RANGE_ENTRY, *PWIN32_MEMORY_RANGE_ENTRY;

__declspec(dllimport)
BOOL
__stdcall
PrefetchVirtualMemory(
      HANDLE hProcess,
      ULONG_PTR NumberOfEntries,
      PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses,
      ULONG Flags
    );


#line 544 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 546 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingFromApp(
      HANDLE hFile,
      PSECURITY_ATTRIBUTES SecurityAttributes,
      ULONG PageProtection,
      ULONG64 MaximumSize,
      PCWSTR Name
    );


__declspec(dllimport)
   
PVOID
__stdcall
MapViewOfFileFromApp(
      HANDLE hFileMappingObject,
      ULONG DesiredAccess,
      ULONG64 FileOffset,
      SIZE_T NumberOfBytesToMap
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFileEx(
      PVOID BaseAddress,
      ULONG UnmapFlags
    );


#line 590 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 592 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#line 595 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"







#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
 
BOOL
__stdcall
AllocateUserPhysicalPages(
      HANDLE hProcess,
      PULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );


__declspec(dllimport)
 
BOOL
__stdcall
FreeUserPhysicalPages(
      HANDLE hProcess,
      PULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );


__declspec(dllimport)
 
BOOL
__stdcall
MapUserPhysicalPages(
      PVOID VirtualAddress,
      ULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );


#line 643 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"




__declspec(dllimport)
 
BOOL
__stdcall
AllocateUserPhysicalPagesNuma(
      HANDLE hProcess,
      PULONG_PTR NumberOfPages,
      PULONG_PTR PageArray,
      DWORD nndPreferred
    );


__declspec(dllimport)
 
LPVOID
__stdcall
VirtualAllocExNuma(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flAllocationType,
      DWORD flProtect,
      DWORD nndPreferred
    );


#line 674 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"






__declspec(dllimport)
 
BOOL
__stdcall
GetMemoryErrorHandlingCapabilities(
      PULONG Capabilities
    );


 
typedef
void
__stdcall
BAD_MEMORY_CALLBACK_ROUTINE(
    void
    );

typedef BAD_MEMORY_CALLBACK_ROUTINE *PBAD_MEMORY_CALLBACK_ROUTINE;

__declspec(dllimport)
 
PVOID
__stdcall
RegisterBadMemoryNotification(
      PBAD_MEMORY_CALLBACK_ROUTINE Callback
    );


__declspec(dllimport)
 
BOOL
__stdcall
UnregisterBadMemoryNotification(
      PVOID RegistrationHandle
    );


#line 718 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 720 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#line 723 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"





#pragma region Application Family or OneCore Family















typedef enum OFFER_PRIORITY {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow,
    VmOfferPriorityBelowNormal,
    VmOfferPriorityNormal
} OFFER_PRIORITY;

DWORD
__stdcall
OfferVirtualMemory(
      PVOID VirtualAddress,
      SIZE_T Size,
      OFFER_PRIORITY Priority
    );


DWORD
__stdcall
ReclaimVirtualMemory(
      void const * VirtualAddress,
      SIZE_T Size
    );


DWORD
__stdcall
DiscardVirtualMemory(
      PVOID VirtualAddress,
      SIZE_T Size
    );


#line 777 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 779 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 781 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#line 784 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"





#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
SetProcessValidCallTargets(
      HANDLE hProcess,
      PVOID VirtualAddress,
      SIZE_T RegionSize,
      ULONG NumberOfOffsets,
      PCFG_CALL_TARGET_INFO OffsetInformation
    );


__declspec(dllimport)
   
PVOID
__stdcall
VirtualAllocFromApp(
      PVOID BaseAddress,
      SIZE_T Size,
      ULONG AllocationType,
      ULONG Protection
    );


__declspec(dllimport)
 
BOOL
__stdcall
VirtualProtectFromApp(
      PVOID Address,
      SIZE_T Size,
      ULONG NewProtection,
      PULONG OldProtection
    );


__declspec(dllimport)
 
HANDLE
__stdcall
OpenFileMappingFromApp(
      ULONG DesiredAccess,
      BOOL InheritHandle,
      PCWSTR Name
    );


#line 844 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 846 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family
































































































#line 946 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#line 949 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"






#pragma region Desktop Family or OneCore Family






typedef enum WIN32_MEMORY_INFORMATION_CLASS {
    MemoryRegionInfo
} WIN32_MEMORY_INFORMATION_CLASS;



#pragma warning(push)
#pragma warning(disable:4201)   
#pragma warning(disable:4214)   
#line 972 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

typedef struct WIN32_MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;

    union {
        ULONG Flags;

        struct {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG Reserved : 26;
        } ;
    } ;

    SIZE_T RegionSize;
    SIZE_T CommitSize;
} WIN32_MEMORY_REGION_INFORMATION;



#pragma warning(pop)
#line 999 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
QueryVirtualMemoryInformation(
      HANDLE Process,
      const void * VirtualAddress,
      WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass,
      PVOID MemoryInformation,
      SIZE_T MemoryInformationSize,
      PSIZE_T ReturnSize
    );


#line 1015 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 1017 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#line 1020 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"






#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
   
PVOID
__stdcall
MapViewOfFileNuma2(
      HANDLE FileMappingHandle,
      HANDLE ProcessHandle,
      ULONG64 Offset,
      PVOID BaseAddress,
      SIZE_T ViewSize,
      ULONG AllocationType,
      ULONG PageProtection,
      ULONG PreferredNode
    );





__forceinline
   
PVOID
MapViewOfFile2(
      HANDLE FileMappingHandle,
      HANDLE ProcessHandle,
      ULONG64 Offset,
      PVOID BaseAddress,
      SIZE_T ViewSize,
      ULONG AllocationType,
      ULONG PageProtection
    )
{
    return MapViewOfFileNuma2(FileMappingHandle,
                              ProcessHandle,
                              Offset,
                              BaseAddress,
                              ViewSize,
                              AllocationType,
                              PageProtection,
                              ((DWORD) -1));
}

#line 1076 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile2(
      HANDLE ProcessHandle,
      PVOID BaseAddress,
      ULONG UnmapFlags
    );


#line 1088 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 1090 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"
#pragma endregion

#line 1093 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"











#pragma warning(pop)
#line 1106 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"


}
#line 1110 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"

#line 1112 "E:\\sdk\\include\\10.0.16299.0\\um\\memoryapi.h"






#line 55 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"
 











#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"






















#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"

#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"



extern "C" {
#line 45 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"





#pragma region Desktop Family or OneCore Or App Family



__declspec(dllimport)
 
BOOL
__stdcall
IsEnclaveTypeSupported(
      DWORD flEnclaveType
    );


__declspec(dllimport)
   
LPVOID
__stdcall
CreateEnclave(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      SIZE_T dwInitialCommitment,
      DWORD flEnclaveType,
      LPCVOID lpEnclaveInformation,
      DWORD dwInfoLength,
      LPDWORD lpEnclaveError
    );


__declspec(dllimport)
 
BOOL
__stdcall
LoadEnclaveData(
      HANDLE hProcess,
      LPVOID lpAddress,
      LPCVOID lpBuffer,
      SIZE_T nSize,
      DWORD flProtect,
      LPCVOID lpPageInformation,
      DWORD dwInfoLength,
      PSIZE_T lpNumberOfBytesWritten,
      LPDWORD lpEnclaveError
    );


__declspec(dllimport)
 
BOOL
__stdcall
InitializeEnclave(
      HANDLE hProcess,
      LPVOID lpAddress,
      LPCVOID lpEnclaveInformation,
      DWORD dwInfoLength,
      LPDWORD lpEnclaveError
    );


#line 110 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"
#pragma endregion




#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
 
BOOL
__stdcall
LoadEnclaveImageA(
      LPVOID lpEnclaveAddress,
      LPCSTR lpImageName
    );

__declspec(dllimport)
 
BOOL
__stdcall
LoadEnclaveImageW(
      LPVOID lpEnclaveAddress,
      LPCWSTR lpImageName
    );





#line 145 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
CallEnclave(
      LPENCLAVE_ROUTINE lpRoutine,
      LPVOID lpParameter,
      BOOL fWaitForThread,
      LPVOID * lpReturnValue
    );


__declspec(dllimport)
 
BOOL
__stdcall
TerminateEnclave(
      LPVOID lpAddress,
      BOOL fWait
    );


__declspec(dllimport)
 
BOOL
__stdcall
DeleteEnclave(
      LPVOID lpAddress
    );


#line 178 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"

#line 180 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"
#pragma endregion






}
#line 189 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"

#line 191 "E:\\sdk\\include\\10.0.16299.0\\um\\enclaveapi.h"


#line 56 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"




















#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"

#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"



extern "C" {
#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"





#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
QueueUserWorkItem(
      LPTHREAD_START_ROUTINE Function,
      PVOID Context,
      ULONG Flags
    );


__declspec(dllimport)
 
BOOL
__stdcall
UnregisterWaitEx(
      HANDLE WaitHandle,
      HANDLE CompletionEvent
    );


__declspec(dllimport)
 
HANDLE
__stdcall
CreateTimerQueue(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
CreateTimerQueueTimer(
     PHANDLE phNewTimer,
      HANDLE TimerQueue,
      WAITORTIMERCALLBACK Callback,
      PVOID Parameter,
      DWORD DueTime,
      DWORD Period,
      ULONG Flags
    );


__declspec(dllimport)
 
BOOL
__stdcall
ChangeTimerQueueTimer(
      HANDLE TimerQueue,
      HANDLE Timer,
      ULONG DueTime,
      ULONG Period
    );


__declspec(dllimport)
 
BOOL
__stdcall
DeleteTimerQueueTimer(
      HANDLE TimerQueue,
      HANDLE Timer,
      HANDLE CompletionEvent
    );


__declspec(dllimport)
 
BOOL
__stdcall
DeleteTimerQueueEx(
      HANDLE TimerQueue,
      HANDLE CompletionEvent
    );


#line 127 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"
#pragma endregion


}
#line 132 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"

#line 134 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoollegacyapiset.h"
#line 57 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"
 
 









#pragma once
#line 14 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"
























#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"

#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"



extern "C" {
#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"





#pragma region Application Family or OneCore Family



typedef
void
(__stdcall *PTP_WIN32_IO_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
      PVOID                 Overlapped,
             ULONG                 IoResult,
             ULONG_PTR             NumberOfBytesTransferred,
          PTP_IO                Io
    );




__declspec(dllimport)
 
PTP_POOL
__stdcall
CreateThreadpool(
      PVOID reserved
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolThreadMaximum(
      PTP_POOL ptpp,
      DWORD cthrdMost
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolThreadMinimum(
      PTP_POOL ptpp,
      DWORD cthrdMic
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolStackInformation(
      PTP_POOL ptpp,
      PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
BOOL
__stdcall
QueryThreadpoolStackInformation(
      PTP_POOL ptpp,
      PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpool(
      PTP_POOL ptpp
    );


__declspec(dllimport)
 
PTP_CLEANUP_GROUP
__stdcall
CreateThreadpoolCleanupGroup(
    void
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroupMembers(
      PTP_CLEANUP_GROUP ptpcg,
      BOOL fCancelPendingCallbacks,
      PVOID pvCleanupContext
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroup(
      PTP_CLEANUP_GROUP ptpcg
    );


__declspec(dllimport)
void
__stdcall
SetEventWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HANDLE evt
    );


__declspec(dllimport)
void
__stdcall
ReleaseSemaphoreWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HANDLE sem,
      DWORD crel
    );


__declspec(dllimport)
void
__stdcall
ReleaseMutexWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HANDLE mut
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSectionWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      PCRITICAL_SECTION pcs
    );


__declspec(dllimport)
void
__stdcall
FreeLibraryWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HMODULE mod
    );


__declspec(dllimport)
BOOL
__stdcall
CallbackMayRunLong(
      PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
void
__stdcall
DisassociateCurrentThreadFromCallback(
      PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
 
BOOL
__stdcall
TrySubmitThreadpoolCallback(
      PTP_SIMPLE_CALLBACK pfns,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
 
PTP_WORK
__stdcall
CreateThreadpoolWork(
      PTP_WORK_CALLBACK pfnwk,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SubmitThreadpoolWork(
      PTP_WORK pwk
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWorkCallbacks(
      PTP_WORK pwk,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWork(
      PTP_WORK pwk
    );


__declspec(dllimport)
 
PTP_TIMER
__stdcall
CreateThreadpoolTimer(
      PTP_TIMER_CALLBACK pfnti,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolTimer(
      PTP_TIMER pti,
      PFILETIME pftDueTime,
      DWORD msPeriod,
      DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
IsThreadpoolTimerSet(
      PTP_TIMER pti
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolTimerCallbacks(
      PTP_TIMER pti,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolTimer(
      PTP_TIMER pti
    );


__declspec(dllimport)
 
PTP_WAIT
__stdcall
CreateThreadpoolWait(
      PTP_WAIT_CALLBACK pfnwa,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolWait(
      PTP_WAIT pwa,
      HANDLE h,
      PFILETIME pftTimeout
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWaitCallbacks(
      PTP_WAIT pwa,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWait(
      PTP_WAIT pwa
    );


__declspec(dllimport)
 
PTP_IO
__stdcall
CreateThreadpoolIo(
      HANDLE fl,
      PTP_WIN32_IO_CALLBACK pfnio,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
StartThreadpoolIo(
      PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
CancelThreadpoolIo(
      PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolIoCallbacks(
      PTP_IO pio,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolIo(
      PTP_IO pio
    );





__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolTimerEx(
      PTP_TIMER pti,
      PFILETIME pftDueTime,
      DWORD msPeriod,
      DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolWaitEx(
      PTP_WAIT pwa,
      HANDLE h,
      PFILETIME pftTimeout,
      PVOID Reserved
    );


#line 414 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"

#line 416 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"

#line 418 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family







#line 429 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"

#line 431 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"
#pragma endregion


}
#line 436 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"

#line 438 "E:\\sdk\\include\\10.0.16299.0\\um\\threadpoolapiset.h"
#line 58 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"




















#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"

#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"



extern "C" {
#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
IsProcessInJob(
      HANDLE ProcessHandle,
      HANDLE JobHandle,
      PBOOL Result
    );


#line 60 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"

#line 62 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"
#pragma endregion


}
#line 67 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"

#line 69 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi.h"
#line 59 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"
 







#pragma once





















#line 32 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"

#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"



extern "C" {
#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"

#pragma region Desktop Family or OneCore Family




typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PCWSTR VolumeName;
    ULONG BaseIoSize;
    ULONG ControlFlags;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION;

__declspec(dllimport)
HANDLE
__stdcall
CreateJobObjectW(
      LPSECURITY_ATTRIBUTES lpJobAttributes,
      LPCWSTR lpName
    );




__declspec(dllimport)
void
__stdcall
FreeMemoryJobObject(
        void * Buffer
    );

#line 73 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenJobObjectW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );



__declspec(dllimport)
BOOL
__stdcall
AssignProcessToJobObject(
      HANDLE hJob,
      HANDLE hProcess
    );



__declspec(dllimport)
BOOL
__stdcall
TerminateJobObject(
      HANDLE hJob,
      UINT uExitCode
    );



__declspec(dllimport)
BOOL
__stdcall
SetInformationJobObject(
      HANDLE hJob,
      JOBOBJECTINFOCLASS JobObjectInformationClass,
      LPVOID lpJobObjectInformation,
      DWORD cbJobObjectInformationLength
    );




__declspec(dllimport)
DWORD
__stdcall
SetIoRateControlInformationJobObject(
      HANDLE hJob,
      JOBOBJECT_IO_RATE_CONTROL_INFORMATION * IoRateControlInfo
    );

#line 127 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"

__declspec(dllimport)
BOOL
__stdcall
QueryInformationJobObject(
      HANDLE hJob,
      JOBOBJECTINFOCLASS JobObjectInformationClass,
      LPVOID lpJobObjectInformation,
      DWORD cbJobObjectInformationLength,
      LPDWORD lpReturnLength
    );




__declspec(dllimport)
DWORD
__stdcall
QueryIoRateControlInformationJobObject(
      HANDLE hJob,
      PCWSTR VolumeName,
     JOBOBJECT_IO_RATE_CONTROL_INFORMATION ** InfoBlocks,
      ULONG * InfoBlockCount
    );

#line 153 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"

#line 155 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"

#pragma endregion


}
#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"


#line 164 "E:\\sdk\\include\\10.0.16299.0\\um\\jobapi2.h"
#line 60 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
























#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"



extern "C" {
#line 45 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#pragma region Desktop Family or OneCore Family








__declspec(dllimport)
BOOL
__stdcall
Wow64DisableWow64FsRedirection(
      PVOID * OldValue
    );


__declspec(dllimport)
BOOL
__stdcall
Wow64RevertWow64FsRedirection(
      PVOID OlValue
    );


#line 72 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
#line 73 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 75 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
IsWow64Process(
      HANDLE hProcess,
      PBOOL Wow64Process
    );


#line 94 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 96 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family











__declspec(dllimport)
 
 
UINT
__stdcall
GetSystemWow64DirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
 
UINT
__stdcall
GetSystemWow64DirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 135 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 137 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
#line 138 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"




__declspec(dllimport)
USHORT
__stdcall
Wow64SetThreadDefaultGuestMachine(
      USHORT Machine
    );


__declspec(dllimport)
BOOL
__stdcall
IsWow64Process2(
      HANDLE hProcess,
      USHORT * pProcessMachine,
      USHORT * pNativeMachine
    );


__declspec(dllimport)
 
 
UINT
__stdcall
GetSystemWow64Directory2A(
      LPSTR lpBuffer,
      UINT uSize,
      WORD ImageFileMachineType
    );

__declspec(dllimport)
 
 
UINT
__stdcall
GetSystemWow64Directory2W(
      LPWSTR lpBuffer,
      UINT uSize,
      WORD ImageFileMachineType
    );





#line 187 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 189 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 191 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"







__declspec(dllimport)
 
HRESULT
__stdcall
IsWow64GuestMachineSupported(
      USHORT WowGuestMachine,
      BOOL * MachineIsSupported
    );


#line 209 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 211 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"


#line 214 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
#pragma endregion


}
#line 219 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"

#line 221 "E:\\sdk\\include\\10.0.16299.0\\um\\wow64apiset.h"
#line 61 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
 
 











#pragma once
#line 16 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"






























#line 47 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 49 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"



extern "C" {
#line 54 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#pragma region Desktop Family or OneCore Family















typedef struct tagENUMUILANG {
    ULONG  NumOfEnumUILang;    
    ULONG  SizeOfEnumUIBuffer; 
    LANGID *pEnumUIBuffer;
} ENUMUILANG, *PENUMUILANG;



typedef BOOL (__stdcall* ENUMRESLANGPROCA)(
      HMODULE hModule,
      LPCSTR lpType,
      LPCSTR lpName,
      WORD wLanguage,
      LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESLANGPROCW)(
      HMODULE hModule,
      LPCWSTR lpType,
      LPCWSTR lpName,
      WORD wLanguage,
      LONG_PTR lParam);




#line 96 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

typedef BOOL (__stdcall* ENUMRESNAMEPROCA)(
      HMODULE hModule,
      LPCSTR lpType,
      LPSTR lpName,
      LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESNAMEPROCW)(
      HMODULE hModule,
      LPCWSTR lpType,
      LPWSTR lpName,
      LONG_PTR lParam);




#line 112 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

typedef BOOL (__stdcall* ENUMRESTYPEPROCA)(
      HMODULE hModule,
      LPSTR lpType,
      LONG_PTR lParam
    );
typedef BOOL (__stdcall* ENUMRESTYPEPROCW)(
      HMODULE hModule,
      LPWSTR lpType,
      LONG_PTR lParam
    );




#line 128 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

























#line 154 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 156 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion





#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
DisableThreadLibraryCalls(
      HMODULE hLibModule
    );


#line 175 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceExW(
      HMODULE hModule,
      LPCWSTR lpType,
      LPCWSTR lpName,
      WORD wLanguage
    );






#line 198 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
int
__stdcall
FindStringOrdinal(
      DWORD dwFindStringOrdinalFlags,
      LPCWSTR lpStringSource,
      int cchSource,
      LPCWSTR lpStringValue,
      int cchValue,
      BOOL bIgnoreCase
    );


#line 221 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
FreeLibrary(
      HMODULE hLibModule
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
FreeLibraryAndExitThread(
      HMODULE hLibModule,
      DWORD dwExitCode
    );

    
#line 241 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
FreeResource(
      HGLOBAL hResData
    );

    
#line 256 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
 
 
DWORD
__stdcall
GetModuleFileNameA(
      HMODULE hModule,
      LPSTR lpFilename,
      DWORD nSize
    );

__declspec(dllimport)
 
 
DWORD
__stdcall
GetModuleFileNameW(
      HMODULE hModule,
      LPWSTR lpFilename,
      DWORD nSize
    );





#line 289 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 291 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleA(
      LPCSTR lpModuleName
    );

__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleW(
      LPCWSTR lpModuleName
    );





#line 320 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"








typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXA)(
             DWORD        dwFlags,
         LPCSTR     lpModuleName,
     HMODULE*    phModule
    );
typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXW)(
             DWORD        dwFlags,
         LPCWSTR     lpModuleName,
     HMODULE*    phModule
    );




#line 349 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExA(
      DWORD dwFlags,
      LPCSTR lpModuleName,
      HMODULE * phModule
    );

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExW(
      DWORD dwFlags,
      LPCWSTR lpModuleName,
      HMODULE * phModule
    );





#line 373 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 375 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 377 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
FARPROC
__stdcall
GetProcAddress(
      HMODULE hModule,
      LPCSTR lpProcName
    );


#line 393 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryExA(
      LPCSTR lpLibFileName,
      HANDLE hFile,
      DWORD dwFlags
    );

__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryExW(
      LPCWSTR lpLibFileName,
      HANDLE hFile,
      DWORD dwFlags
    );





#line 424 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"































#line 456 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"






#line 463 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

__declspec(dllimport)
 
HGLOBAL
__stdcall
LoadResource(
      HMODULE hModule,
      HRSRC hResInfo
    );


#line 475 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
int
__stdcall
LoadStringA(
      HINSTANCE hInstance,
      UINT uID,
      LPSTR lpBuffer,
      int cchBufferMax
    );

__declspec(dllimport)
int
__stdcall
LoadStringW(
      HINSTANCE hInstance,
      UINT uID,
      LPWSTR lpBuffer,
      int cchBufferMax
    );





#line 508 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 510 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
LPVOID
__stdcall
LockResource(
      HGLOBAL hResData
    );


__declspec(dllimport)
DWORD
__stdcall
SizeofResource(
      HMODULE hModule,
      HRSRC hResInfo
    );


#line 536 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family



typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;

__declspec(dllimport)
DLL_DIRECTORY_COOKIE
__stdcall
AddDllDirectory(
      PCWSTR NewDirectory
    );


__declspec(dllimport)
BOOL
__stdcall
RemoveDllDirectory(
      DLL_DIRECTORY_COOKIE Cookie
    );


__declspec(dllimport)
BOOL
__stdcall
SetDefaultDllDirectories(
      DWORD DirectoryFlags
    );


#line 571 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion






#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExA(
      HMODULE hModule,
      LPCSTR lpType,
      LPCSTR lpName,
      ENUMRESLANGPROCA lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExW(
      HMODULE hModule,
      LPCWSTR lpType,
      LPCWSTR lpName,
      ENUMRESLANGPROCW lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 616 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExA(
      HMODULE hModule,
      LPCSTR lpType,
      ENUMRESNAMEPROCA lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExW(
      HMODULE hModule,
      LPCWSTR lpType,
      ENUMRESNAMEPROCW lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 646 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExA(
      HMODULE hModule,
      ENUMRESTYPEPROCA lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExW(
      HMODULE hModule,
      ENUMRESTYPEPROCW lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 674 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 676 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 678 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#line 681 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"






#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceW(
      HMODULE hModule,
      LPCWSTR lpName,
      LPCWSTR lpType
    );






__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryA(
      LPCSTR lpLibFileName
    );

__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryW(
      LPCWSTR lpLibFileName
    );





#line 727 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 729 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#line 732 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"




#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesW(
      HMODULE hModule,
      LPCWSTR lpType,
      ENUMRESNAMEPROCW lpEnumFunc,
      LONG_PTR lParam
    );






#line 756 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"
#pragma endregion

#line 759 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"





}
#line 766 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 768 "E:\\sdk\\include\\10.0.16299.0\\um\\libloaderapi.h"

#line 62 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
 
 










#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"


























#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"



extern "C" {
#line 49 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"










#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AccessCheck(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      PGENERIC_MAPPING GenericMapping,
      PPRIVILEGE_SET PrivilegeSet,
      LPDWORD PrivilegeSetLength,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPWSTR ObjectTypeName,
      LPWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      DWORD DesiredAccess,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByType(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID PrincipalSelfSid,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      PPRIVILEGE_SET PrivilegeSet,
      LPDWORD PrivilegeSetLength,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultList(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID PrincipalSelfSid,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      PPRIVILEGE_SET PrivilegeSet,
      LPDWORD PrivilegeSetLength,
      LPDWORD GrantedAccessList,
      LPDWORD AccessStatusList
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPCWSTR ObjectTypeName,
      LPCWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
      DWORD DesiredAccess,
      AUDIT_EVENT_TYPE AuditType,
      DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPCWSTR ObjectTypeName,
      LPCWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
      DWORD DesiredAccess,
      AUDIT_EVENT_TYPE AuditType,
      DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccessList,
      LPDWORD AccessStatusList,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      HANDLE ClientToken,
      LPCWSTR ObjectTypeName,
      LPCWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
      DWORD DesiredAccess,
      AUDIT_EVENT_TYPE AuditType,
      DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccessList,
      LPDWORD AccessStatusList,
      LPBOOL pfGenerateOnClose
    );






#line 219 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAceEx(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid
    );


#line 249 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedObjectAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      GUID * ObjectTypeGuid,
      GUID * InheritedObjectTypeGuid,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAceEx(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedObjectAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      GUID * ObjectTypeGuid,
      GUID * InheritedObjectTypeGuid,
      PSID pSid
    );


#line 307 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AddAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD dwStartingAceIndex,
      LPVOID pAceList,
      DWORD nAceListLength
    );


#line 326 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD dwAccessMask,
      PSID pSid,
      BOOL bAuditSuccess,
      BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAceEx(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD dwAccessMask,
      PSID pSid,
      BOOL bAuditSuccess,
      BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessObjectAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      GUID * ObjectTypeGuid,
      GUID * InheritedObjectTypeGuid,
      PSID pSid,
      BOOL bAuditSuccess,
      BOOL bAuditFailure
    );


#line 376 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
AddMandatoryAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD MandatoryPolicy,
      PSID pLabelSid
    );


#line 398 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

#line 400 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion






#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AddResourceAttributeAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid,
      PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo,
      PDWORD pReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AddScopedPolicyIDAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid
    );


#line 438 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#line 441 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"



#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AdjustTokenGroups(
      HANDLE TokenHandle,
      BOOL ResetToDefault,
      PTOKEN_GROUPS NewState,
      DWORD BufferLength,
      PTOKEN_GROUPS PreviousState,
      PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenPrivileges(
      HANDLE TokenHandle,
      BOOL DisableAllPrivileges,
      PTOKEN_PRIVILEGES NewState,
      DWORD BufferLength,
      PTOKEN_PRIVILEGES PreviousState,
      PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateAndInitializeSid(
      PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
      BYTE nSubAuthorityCount,
      DWORD nSubAuthority0,
      DWORD nSubAuthority1,
      DWORD nSubAuthority2,
      DWORD nSubAuthority3,
      DWORD nSubAuthority4,
      DWORD nSubAuthority5,
      DWORD nSubAuthority6,
      DWORD nSubAuthority7,
     PSID * pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateLocallyUniqueId(
      PLUID Luid
    );


#line 501 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AreAllAccessesGranted(
      DWORD GrantedAccess,
      DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
AreAnyAccessesGranted(
      DWORD GrantedAccess,
      DWORD DesiredAccess
    );


#line 526 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembership(
      HANDLE TokenHandle,
      PSID SidToCheck,
      PBOOL IsMember
    );


#line 543 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion






#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CheckTokenCapability(
      HANDLE TokenHandle,
      PSID CapabilitySidToCheck,
      PBOOL HasCapability
    );


__declspec(dllimport)
BOOL
__stdcall
GetAppContainerAce(
      PACL Acl,
      DWORD StartingAceIndex,
     PVOID * AppContainerAce,
      DWORD * AppContainerAceIndex
    );


#line 576 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembershipEx(
      HANDLE TokenHandle,
      PSID SidToCheck,
      DWORD Flags,
      PBOOL IsMember
    );


#line 594 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#line 597 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"



#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
ConvertToAutoInheritPrivateObjectSecurity(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
     PSECURITY_DESCRIPTOR * NewSecurityDescriptor,
      GUID * ObjectType,
      BOOLEAN IsDirectoryObject,
      PGENERIC_MAPPING GenericMapping
    );


#line 618 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CopySid(
      DWORD nDestinationSidLength,
      PSID pDestinationSid,
      PSID pSourceSid
    );


#line 635 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurity(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR * NewDescriptor,
      BOOL IsDirectoryObject,
      HANDLE Token,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityEx(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR * NewDescriptor,
      GUID * ObjectType,
      BOOL IsContainerObject,
      ULONG AutoInheritFlags,
      HANDLE Token,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityWithMultipleInheritance(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR * NewDescriptor,
      GUID ** ObjectTypes,
      ULONG GuidCount,
      BOOL IsContainerObject,
      ULONG AutoInheritFlags,
      HANDLE Token,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreateRestrictedToken(
      HANDLE ExistingTokenHandle,
      DWORD Flags,
      DWORD DisableSidCount,
      PSID_AND_ATTRIBUTES SidsToDisable,
      DWORD DeletePrivilegeCount,
      PLUID_AND_ATTRIBUTES PrivilegesToDelete,
      DWORD RestrictedSidCount,
      PSID_AND_ATTRIBUTES SidsToRestrict,
     PHANDLE NewTokenHandle
    );


#line 702 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
 
BOOL
__stdcall
CreateWellKnownSid(
      WELL_KNOWN_SID_TYPE WellKnownSidType,
      PSID DomainSid,
      PSID pSid,
      DWORD * cbSid
    );


__declspec(dllimport)
 
BOOL
__stdcall
EqualDomainSid(
      PSID pSid1,
      PSID pSid2,
      BOOL * pfEqual
    );


#line 735 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteAce(
      PACL pAcl,
      DWORD dwAceIndex
    );


#line 746 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
DestroyPrivateObjectSecurity(
        PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


#line 761 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
DuplicateToken(
      HANDLE ExistingTokenHandle,
      SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
     PHANDLE DuplicateTokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateTokenEx(
      HANDLE hExistingToken,
      DWORD dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpTokenAttributes,
      SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
      TOKEN_TYPE TokenType,
     PHANDLE phNewToken
    );


#line 791 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
EqualPrefixSid(
      PSID pSid1,
      PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
EqualSid(
      PSID pSid1,
      PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
FindFirstFreeAce(
      PACL pAcl,
     LPVOID * pAce
    );


#line 825 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
PVOID
__stdcall
FreeSid(
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetAce(
      PACL pAcl,
      DWORD dwAceIndex,
     LPVOID * pAce
    );


__declspec(dllimport)
BOOL
__stdcall
GetAclInformation(
      PACL pAcl,
      LPVOID pAclInformation,
      DWORD nAclInformationLength,
      ACL_INFORMATION_CLASS dwAclInformationClass
    );


#line 861 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityW(
      LPCWSTR lpFileName,
      SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD nLength,
      LPDWORD lpnLengthNeeded
    );






#line 884 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetKernelObjectSecurity(
      HANDLE Handle,
      SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD nLength,
      LPDWORD lpnLengthNeeded
    );


__declspec(dllimport)
 
 
DWORD
__stdcall
GetLengthSid(
        PSID pSid
    );


#line 913 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
 
BOOL
__stdcall
GetPrivateObjectSecurity(
      PSECURITY_DESCRIPTOR ObjectDescriptor,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR ResultantDescriptor,
      DWORD DescriptorLength,
      PDWORD ReturnLength
    );


#line 933 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorControl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSECURITY_DESCRIPTOR_CONTROL pControl,
      LPDWORD lpdwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorDacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      LPBOOL lpbDaclPresent,
     PACL * pDacl,
      LPBOOL lpbDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorGroup(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID * pGroup,
      LPBOOL lpbGroupDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorLength(
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorOwner(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID * pOwner,
      LPBOOL lpbOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorRMControl(
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorSacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      LPBOOL lpbSaclPresent,
     PACL * pSacl,
      LPBOOL lpbSaclDefaulted
    );


__declspec(dllimport)
PSID_IDENTIFIER_AUTHORITY
__stdcall
GetSidIdentifierAuthority(
      PSID pSid
    );


__declspec(dllimport)
DWORD
__stdcall
GetSidLengthRequired(
      UCHAR nSubAuthorityCount
    );


__declspec(dllimport)
PDWORD
__stdcall
GetSidSubAuthority(
      PSID pSid,
      DWORD nSubAuthority
    );


__declspec(dllimport)
PUCHAR
__stdcall
GetSidSubAuthorityCount(
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetTokenInformation(
      HANDLE TokenHandle,
      TOKEN_INFORMATION_CLASS TokenInformationClass,
      LPVOID TokenInformation,
      DWORD TokenInformationLength,
      PDWORD ReturnLength
    );





__declspec(dllimport)
 
BOOL
__stdcall
GetWindowsAccountDomainSid(
      PSID pSid,
      PSID pDomainSid,
      DWORD * cbDomainSid
    );


#line 1068 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

#line 1070 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
ImpersonateAnonymousToken(
      HANDLE ThreadHandle
    );


 
__declspec(dllimport)
BOOL
__stdcall
ImpersonateLoggedOnUser(
      HANDLE hToken
    );


 
__declspec(dllimport)
BOOL
__stdcall
ImpersonateSelf(
      SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


#line 1103 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
InitializeAcl(
      PACL pAcl,
      DWORD nAclLength,
      DWORD dwAclRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSecurityDescriptor(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD dwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSid(
      PSID Sid,
      PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
      BYTE nSubAuthorityCount
    );


#line 1139 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
IsTokenRestricted(
      HANDLE TokenHandle
    );


#line 1154 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
IsValidAcl(
      PACL pAcl
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSecurityDescriptor(
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSid(
      PSID pSid
    );





__declspec(dllimport)
BOOL
__stdcall
IsWellKnownSid(
      PSID pSid,
      WELL_KNOWN_SID_TYPE WellKnownSidType
    );


#line 1197 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
MakeAbsoluteSD(
      PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
      PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
      LPDWORD lpdwAbsoluteSecurityDescriptorSize,
      PACL pDacl,
      LPDWORD lpdwDaclSize,
      PACL pSacl,
      LPDWORD lpdwSaclSize,
      PSID pOwner,
      LPDWORD lpdwOwnerSize,
      PSID pPrimaryGroup,
      LPDWORD lpdwPrimaryGroupSize
    );


__declspec(dllimport)
 
BOOL
__stdcall
MakeSelfRelativeSD(
      PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
      PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
      LPDWORD lpdwBufferLength
    );


#line 1229 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
void
__stdcall
MapGenericMask(
      PDWORD AccessMask,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPWSTR ObjectTypeName,
      LPWSTR ObjectName,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      DWORD GrantedAccess,
      PPRIVILEGE_SET Privileges,
      BOOL ObjectCreation,
      BOOL AccessGranted,
      LPBOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );






__declspec(dllimport)
BOOL
__stdcall
PrivilegeCheck(
      HANDLE ClientToken,
      PPRIVILEGE_SET RequiredPrivileges,
      LPBOOL pfResult
    );


__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmW(
      LPCWSTR SubsystemName,
      LPCWSTR ServiceName,
      HANDLE ClientToken,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );









__declspec(dllimport)
void
__stdcall
QuerySecurityAccessMask(
      SECURITY_INFORMATION SecurityInformation,
      LPDWORD DesiredAccess
    );


#line 1351 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
RevertToSelf(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetAclInformation(
      PACL pAcl,
      LPVOID pAclInformation,
      DWORD nAclInformationLength,
      ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityW(
      LPCWSTR lpFileName,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );





#line 1385 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetKernelObjectSecurity(
      HANDLE Handle,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR SecurityDescriptor
    );


#line 1402 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurity(
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR ModificationDescriptor,
      PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
      PGENERIC_MAPPING GenericMapping,
      HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurityEx(
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR ModificationDescriptor,
      PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
      ULONG AutoInheritFlags,
      PGENERIC_MAPPING GenericMapping,
      HANDLE Token
    );





__declspec(dllimport)
void
__stdcall
SetSecurityAccessMask(
      SECURITY_INFORMATION SecurityInformation,
      LPDWORD DesiredAccess
    );


#line 1446 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

#line 1448 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorControl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
      SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorDacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      BOOL bDaclPresent,
      PACL pDacl,
      BOOL bDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorGroup(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID pGroup,
      BOOL bGroupDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorOwner(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID pOwner,
      BOOL bOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
SetSecurityDescriptorRMControl(
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorSacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      BOOL bSaclPresent,
      PACL pSacl,
      BOOL bSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetTokenInformation(
      HANDLE TokenHandle,
      TOKEN_INFORMATION_CLASS TokenInformationClass,
      LPVOID TokenInformation,
      DWORD TokenInformationLength
    );


#line 1527 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion






#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetCachedSigningLevel(
      PHANDLE SourceFiles,
      ULONG SourceFileCount,
      ULONG Flags,
      HANDLE TargetFile
    );


__declspec(dllimport)
BOOL
__stdcall
GetCachedSigningLevel(
      HANDLE File,
      PULONG Flags,
      PULONG SigningLevel,
      PUCHAR Thumbprint,
      PULONG ThumbprintSize,
      PULONG ThumbprintAlgorithm
    );


#line 1563 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#line 1566 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"




#pragma region Application Family or OneCore Family



__declspec(dllimport)
LONG
__stdcall
CveEventWrite(
      PCWSTR CveId,
      PCWSTR AdditionalDetails
    );


#line 1584 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#line 1587 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"




#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
DeriveCapabilitySidsFromName(
      LPCWSTR CapName,
     PSID ** CapabilityGroupSids,
      DWORD * CapabilityGroupSidCount,
     PSID ** CapabilitySids,
      DWORD * CapabilitySidCount
    );


#line 1608 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"
#pragma endregion

#line 1611 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"




}
#line 1617 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"

#line 1619 "E:\\sdk\\include\\10.0.16299.0\\um\\securitybaseapi.h"


#line 63 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"




















#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"

#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"



extern "C" {
#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"

#pragma region Desktop Family or OneCore Family





__declspec(dllimport)
HANDLE
__stdcall
CreatePrivateNamespaceW(
      LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
      LPVOID lpBoundaryDescriptor,
      LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenPrivateNamespaceW(
      LPVOID lpBoundaryDescriptor,
      LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
BOOLEAN
__stdcall
ClosePrivateNamespace(
      HANDLE Handle,
      ULONG Flags
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateBoundaryDescriptorW(
      LPCWSTR Name,
      ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
AddSIDToBoundaryDescriptor(
      HANDLE * BoundaryDescriptor,
      PSID RequiredSid
    );


__declspec(dllimport)
void
__stdcall
DeleteBoundaryDescriptor(
      HANDLE BoundaryDescriptor
    );


#line 103 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"
#pragma endregion


}
#line 108 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"

#line 110 "E:\\sdk\\include\\10.0.16299.0\\um\\namespaceapi.h"
#line 64 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"






















#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"

#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"



extern "C" {
#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetNumaHighestNodeNumber(
      PULONG HighestNodeNumber
    );





__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMaskEx(
      USHORT Node,
      PGROUP_AFFINITY ProcessorMask
    );


#line 69 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"







__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNodeEx(
      ULONG ProximityId,
      PUSHORT NodeNumber
    );


#line 86 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"

#line 88 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"

#line 90 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"
#pragma endregion


}
#line 95 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"

#line 97 "E:\\sdk\\include\\10.0.16299.0\\um\\systemtopologyapi.h"
#line 65 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"






















#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"

#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"



extern "C" {
#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetProcessGroupAffinity(
      HANDLE hProcess,
      PUSHORT GroupCount,
      PUSHORT GroupArray
    );


#line 62 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"

#line 64 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"
#pragma endregion


#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
GetThreadGroupAffinity(
      HANDLE hThread,
      PGROUP_AFFINITY GroupAffinity
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadGroupAffinity(
      HANDLE hThread,
      const GROUP_AFFINITY * GroupAffinity,
      PGROUP_AFFINITY PreviousGroupAffinity
    );


#line 94 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"

#line 96 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"
#pragma endregion


}
#line 101 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"

#line 103 "E:\\sdk\\include\\10.0.16299.0\\um\\processtopologyapi.h"
#line 66 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"






















#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"

#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"


#pragma region Desktop Family or OneCore Family




extern "C" {
#line 47 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"








BOOL
__stdcall
GetAppContainerNamedObjectPath(
      HANDLE Token,
      PSID AppContainerSid,
      ULONG ObjectPathLength,
      LPWSTR ObjectPath,
      PULONG ReturnLength
    );


#line 67 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"


}
#line 71 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"

#line 73 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"
#pragma endregion

#line 76 "E:\\sdk\\include\\10.0.16299.0\\um\\securityappcontainer.h"
#line 67 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"























#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"

#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"



extern "C" {
#line 44 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
QueryThreadCycleTime(
      HANDLE ThreadHandle,
      PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessCycleTime(
      HANDLE ProcessHandle,
      PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTime(
      PULONG BufferLength,
      PULONG64 ProcessorIdleCycleTime
    );


#line 80 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"




__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTimeEx(
      USHORT Group,
      PULONG BufferLength,
      PULONG64 ProcessorIdleCycleTime
    );

    
#line 95 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"

#line 97 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
void
__stdcall
QueryInterruptTimePrecise(
      PULONGLONG lpInterruptTimePrecise
    );


__declspec(dllimport)
void
__stdcall
QueryUnbiasedInterruptTimePrecise(
      PULONGLONG lpUnbiasedInterruptTimePrecise
    );


__declspec(dllimport)
void
__stdcall
QueryInterruptTime(
      PULONGLONG lpInterruptTime
    );


#line 131 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"




__declspec(dllimport)
BOOL
__stdcall
QueryUnbiasedInterruptTime(
      PULONGLONG UnbiasedTime
    );


#line 144 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"




__declspec(dllimport)
HRESULT
__stdcall
QueryAuxiliaryCounterFrequency(
      PULONGLONG lpAuxiliaryCounterFrequency
    );


__declspec(dllimport)
HRESULT
__stdcall
ConvertAuxiliaryCounterToPerformanceCounter(
      ULONGLONG ullAuxiliaryCounterValue,
      PULONGLONG lpPerformanceCounterValue,
      PULONGLONG lpConversionError
    );


__declspec(dllimport)
HRESULT
__stdcall
ConvertPerformanceCounterToAuxiliaryCounter(
      ULONGLONG ullPerformanceCounterValue,
      PULONGLONG lpAuxiliaryCounterValue,
      PULONGLONG lpConversionError
    );


#line 177 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"

#line 179 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"
#pragma endregion


}
#line 184 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"

#line 186 "E:\\sdk\\include\\10.0.16299.0\\um\\realtimeapiset.h"
#line 68 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


extern "C" {
#line 72 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Application Family












#line 87 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




#line 95 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family






















































#line 153 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




































#line 190 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"














#line 205 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"






#line 212 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 214 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"











#line 226 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 228 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"






























































typedef void (__stdcall *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

typedef LPVOID (__stdcall *PFIBER_CALLOUT_ROUTINE)(
    LPVOID lpParameter
    );
#line 299 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"










#line 310 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
typedef LPVOID LPLDT_ENTRY;
#line 312 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





































































































typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;







typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
















typedef struct _DCB {
    DWORD DCBlength;      
    DWORD BaudRate;       
    DWORD fBinary: 1;     
    DWORD fParity: 1;     
    DWORD fOutxCtsFlow:1; 
    DWORD fOutxDsrFlow:1; 
    DWORD fDtrControl:2;  
    DWORD fDsrSensitivity:1; 
    DWORD fTXContinueOnXoff: 1; 
    DWORD fOutX: 1;       
    DWORD fInX: 1;        
    DWORD fErrorChar: 1;  
    DWORD fNull: 1;       
    DWORD fRtsControl:2;  
    DWORD fAbortOnError:1; 
    DWORD fDummy2:17;     
    WORD wReserved;       
    WORD XonLim;          
    WORD XoffLim;         
    BYTE ByteSize;        
    BYTE Parity;          
    BYTE StopBits;        
    char XonChar;         
    char XoffChar;        
    char ErrorChar;       
    char EofChar;         
    char EvtChar;         
    WORD wReserved1;      
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          
    DWORD ReadTotalTimeoutMultiplier;   
    DWORD ReadTotalTimeoutConstant;     
    DWORD WriteTotalTimeoutMultiplier;  
    DWORD WriteTotalTimeoutConstant;    
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               
    WORD wVersion;              
    WORD wReserved;             
    DCB dcb;                    
    DWORD dwProviderSubType;    

    DWORD dwProviderOffset;     

    DWORD dwProviderSize;       
    WCHAR wcProviderData[1];    
} COMMCONFIG,*LPCOMMCONFIG;




































typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;





















































































typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;


typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#line 667 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"














#line 682 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





































































































































































































typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;






#line 894 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


int



#line 904 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
__stdcall
#line 906 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


#line 909 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
WinMain (
      HINSTANCE hInstance,
      HINSTANCE hPrevInstance,
      LPSTR lpCmdLine,
      int nShowCmd
    );

int


#line 920 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
__stdcall
#line 922 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
wWinMain(
      HINSTANCE hInstance,
      HINSTANCE hPrevInstance,
      LPWSTR lpCmdLine,
      int nShowCmd
    );

#line 930 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
 
 
__declspec(allocator)
HGLOBAL
__stdcall
GlobalAlloc(
      UINT uFlags,
      SIZE_T dwBytes
    );

#line 947 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
   
__declspec(allocator)
HGLOBAL
__stdcall
GlobalReAlloc (
      HGLOBAL hMem,
      SIZE_T dwBytes,
      UINT uFlags
    );

#line 964 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
SIZE_T
__stdcall
GlobalSize (
      HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnlock(
      HGLOBAL hMem
    );

__declspec(dllimport)
 
LPVOID
__stdcall
GlobalLock (
      HGLOBAL hMem
    );

#line 992 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GlobalFlags (
      HGLOBAL hMem
    );

__declspec(dllimport)
 
HGLOBAL
__stdcall
GlobalHandle (
      LPCVOID pMem
    );

#line 1013 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
 
 
HGLOBAL
__stdcall
GlobalFree(
      HGLOBAL hMem
    );

#line 1028 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SIZE_T
__stdcall
GlobalCompact(
      DWORD dwMinFree
    );

__declspec(dllimport)
void
__stdcall
GlobalFix(
      HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalUnfix(
      HGLOBAL hMem
    );

__declspec(dllimport)
LPVOID
__stdcall
GlobalWire(
      HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnWire(
      HGLOBAL hMem
    );

 
__declspec(dllimport)
void
__stdcall
GlobalMemoryStatus(
      LPMEMORYSTATUS lpBuffer
    );

#line 1077 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
 
 
__declspec(allocator)
HLOCAL
__stdcall
LocalAlloc(
      UINT uFlags,
      SIZE_T uBytes
    );

__declspec(dllimport)
   
__declspec(allocator)
HLOCAL
__stdcall
LocalReAlloc(
      HLOCAL hMem,
      SIZE_T uBytes,
      UINT uFlags
    );

#line 1105 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
 
LPVOID
__stdcall
LocalLock(
      HLOCAL hMem
    );

#line 1119 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
 
HLOCAL
__stdcall
LocalHandle(
      LPCVOID pMem
    );

#line 1133 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
LocalUnlock(
      HLOCAL hMem
    );

#line 1146 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SIZE_T
__stdcall
LocalSize(
      HLOCAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
LocalFlags(
      HLOCAL hMem
    );

#line 1166 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
 
 
HLOCAL
__stdcall
LocalFree(
      HLOCAL hMem
    );

#line 1181 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SIZE_T
__stdcall
LocalShrink(
      HLOCAL hMem,
      UINT cbNewSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalCompact(
      UINT uMinFree
    );















#line 1216 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeA(
       LPCSTR lpApplicationName,
      LPDWORD  lpBinaryType
    );
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeW(
       LPCWSTR lpApplicationName,
      LPDWORD  lpBinaryType
    );




#line 1236 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetShortPathNameA(
      LPCSTR lpszLongPath,
      LPSTR  lpszShortPath,
      DWORD cchBuffer
    );


#line 1249 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameTransactedA(
          LPCSTR lpszShortPath,
      LPSTR  lpszLongPath,
          DWORD cchBuffer,
          HANDLE hTransaction
    );
__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameTransactedW(
          LPCWSTR lpszShortPath,
      LPWSTR  lpszLongPath,
          DWORD cchBuffer,
          HANDLE hTransaction
    );




#line 1277 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1279 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1281 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessAffinityMask(
       HANDLE hProcess,
      PDWORD_PTR lpProcessAffinityMask,
      PDWORD_PTR lpSystemAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityMask(
      HANDLE hProcess,
      DWORD_PTR dwProcessAffinityMask
    );

#line 1304 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessIoCounters(
       HANDLE hProcess,
      PIO_COUNTERS lpIoCounters
    );

#line 1318 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSize(
       HANDLE hProcess,
      PSIZE_T lpMinimumWorkingSetSize,
      PSIZE_T lpMaximumWorkingSetSize
    );

#line 1333 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSize(
      HANDLE hProcess,
      SIZE_T dwMinimumWorkingSetSize,
      SIZE_T dwMaximumWorkingSetSize
    );

__declspec(dllimport)

void
__stdcall
FatalExit(
      int ExitCode
    );

#line 1356 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsA(
         LPCH NewEnvironment
    );


#line 1370 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1372 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion







#pragma region Application Family or OneCore Family




__declspec(dllimport)
void
__stdcall
SwitchToFiber(
      LPVOID lpFiber
    );

__declspec(dllimport)
void
__stdcall
DeleteFiber(
      LPVOID lpFiber
    );



__declspec(dllimport)
BOOL
__stdcall
ConvertFiberToThread(
    void
    );

#line 1409 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
LPVOID
__stdcall
CreateFiberEx(
          SIZE_T dwStackCommitSize,
          SIZE_T dwStackReserveSize,
          DWORD dwFlags,
          LPFIBER_START_ROUTINE lpStartAddress,
      LPVOID lpParameter
    );

__declspec(dllimport)
 
LPVOID
__stdcall
ConvertThreadToFiberEx(
      LPVOID lpParameter,
          DWORD dwFlags
    );

#line 1432 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
 
LPVOID
__stdcall
CreateFiber(
          SIZE_T dwStackSize,
          LPFIBER_START_ROUTINE lpStartAddress,
      LPVOID lpParameter
    );

__declspec(dllimport)
 
LPVOID
__stdcall
ConvertThreadToFiber(
      LPVOID lpParameter
    );

#line 1456 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion









#pragma region Desktop Family






typedef void *PUMS_CONTEXT;

typedef void *PUMS_COMPLETION_LIST;

typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

typedef struct _UMS_SCHEDULER_STARTUP_INFO {

    
    
    
    ULONG UmsVersion;

    
    
    
    PUMS_COMPLETION_LIST CompletionList;

    
    
    
    
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;

    
    
    
    PVOID SchedulerParam;

} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;

typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
    ULONG UmsVersion;
    union {
        struct {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
        } ;
        ULONG ThreadUmsFlags;
    } ;
} UMS_SYSTEM_THREAD_INFORMATION, *PUMS_SYSTEM_THREAD_INFORMATION;

 
__declspec(dllimport)
BOOL
__stdcall
CreateUmsCompletionList(
     PUMS_COMPLETION_LIST* UmsCompletionList
    );

__declspec(dllimport)
BOOL
__stdcall
DequeueUmsCompletionListItems(
      PUMS_COMPLETION_LIST UmsCompletionList,
      DWORD WaitTimeOut,
      PUMS_CONTEXT* UmsThreadList
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsCompletionListEvent(
      PUMS_COMPLETION_LIST UmsCompletionList,
      PHANDLE UmsCompletionEvent
    );

__declspec(dllimport)
BOOL
__stdcall
ExecuteUmsThread(
      PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
UmsThreadYield(
      PVOID SchedulerParam
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsCompletionList(
      PUMS_COMPLETION_LIST UmsCompletionList
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetCurrentUmsThread(
    void
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetNextUmsListItem(
      PUMS_CONTEXT UmsContext
    );

__declspec(dllimport)
BOOL
__stdcall
QueryUmsThreadInformation(
      PUMS_CONTEXT UmsThread,
      UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
      PVOID UmsThreadInformation,
      ULONG UmsThreadInformationLength,
      PULONG ReturnLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetUmsThreadInformation(
      PUMS_CONTEXT UmsThread,
      UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
      PVOID UmsThreadInformation,
      ULONG UmsThreadInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsThreadContext(
      PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
CreateUmsThreadContext(
     PUMS_CONTEXT *lpUmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
EnterUmsSchedulingMode(
      PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsSystemThreadInformation(
      HANDLE ThreadHandle,
      PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo
    );

#line 1630 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1632 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion





#line 1639 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD_PTR
__stdcall
SetThreadAffinityMask(
      HANDLE hThread,
      DWORD_PTR dwThreadAffinityMask
    );

#line 1652 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family







__declspec(dllimport)
BOOL
__stdcall
SetProcessDEPPolicy(
      DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessDEPPolicy(
      HANDLE hProcess,
      LPDWORD lpFlags,
      PBOOL lpPermanent
    );

#line 1679 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RequestWakeupLatency(
      LATENCY_TIME latency
    );

__declspec(dllimport)
BOOL
__stdcall
IsSystemResumeAutomatic(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadSelectorEntry(
       HANDLE hThread,
       DWORD dwSelector,
      LPLDT_ENTRY lpSelectorEntry
    );

__declspec(dllimport)
EXECUTION_STATE
__stdcall
SetThreadExecutionState(
      EXECUTION_STATE esFlags
    );







typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;

__declspec(dllimport)
HANDLE
__stdcall
PowerCreateRequest (
      PREASON_CONTEXT Context
    );

__declspec(dllimport)
BOOL
__stdcall
PowerSetRequest (
      HANDLE PowerRequest,
      POWER_REQUEST_TYPE RequestType
    );

__declspec(dllimport)
BOOL
__stdcall
PowerClearRequest (
      HANDLE PowerRequest,
      POWER_REQUEST_TYPE RequestType
    );

#line 1742 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1744 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family






#line 1754 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


















#line 1776 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1777 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#line 1781 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family




















__declspec(dllimport)
BOOL
__stdcall
SetFileCompletionNotificationModes(
      HANDLE FileHandle,
      UCHAR Flags
    );

#line 1813 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1815 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family











__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadContext(
         HANDLE hThread,
      PWOW64_CONTEXT lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
Wow64SetThreadContext(
      HANDLE hThread,
      const WOW64_CONTEXT *lpContext
    );

#line 1846 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadSelectorEntry(
      HANDLE hThread,
      DWORD dwSelector,
      PWOW64_LDT_ENTRY lpSelectorEntry
    );

#line 1859 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1861 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
DWORD
__stdcall
Wow64SuspendThread(
      HANDLE hThread
    );

#line 1872 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DebugSetProcessKillOnExit(
      BOOL KillOnExit
    );

__declspec(dllimport)
BOOL
__stdcall
DebugBreakProcess (
      HANDLE Process
    );

#line 1888 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




#line 1896 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 1898 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
PulseEvent(
      HANDLE hEvent
    );

__declspec(dllimport)
ATOM
__stdcall
GlobalDeleteAtom(
      ATOM nAtom
    );

__declspec(dllimport)
BOOL
__stdcall
InitAtomTable(
      DWORD nSize
    );

__declspec(dllimport)
ATOM
__stdcall
DeleteAtom(
      ATOM nAtom
    );

__declspec(dllimport)
UINT
__stdcall
SetHandleCount(
      UINT uNumber
    );

__declspec(dllimport)
BOOL
__stdcall
RequestDeviceWakeup(
      HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
CancelDeviceWakeupRequest(
      HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
GetDevicePowerState(
       HANDLE hDevice,
      BOOL *pfOn
    );

__declspec(dllimport)
BOOL
__stdcall
SetMessageWaitingIndicator(
      HANDLE hMsgIndicator,
      ULONG ulMsgCount
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameA(
      HANDLE hFile,
      LPCSTR lpShortName
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameW(
      HANDLE hFile,
      LPCWSTR lpShortName
    );




#line 1988 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"






__declspec(dllimport)
DWORD
__stdcall
LoadModule(
      LPCSTR lpModuleName,
      LPVOID lpParameterBlock
    );


 
__declspec(dllimport)
UINT
__stdcall
WinExec(
      LPCSTR lpCmdLine,
      UINT uCmdShow
    );


#line 2014 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore or App Family


__declspec(dllimport)
BOOL
__stdcall
ClearCommBreak(
      HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommError(
           HANDLE hFile,
      LPDWORD lpErrors,
      LPCOMSTAT lpStat
    );

__declspec(dllimport)
BOOL
__stdcall
SetupComm(
      HANDLE hFile,
      DWORD dwInQueue,
      DWORD dwOutQueue
    );

__declspec(dllimport)
BOOL
__stdcall
EscapeCommFunction(
      HANDLE hFile,
      DWORD dwFunc
    );

__declspec(dllimport)
 
BOOL
__stdcall
GetCommConfig(
           HANDLE hCommDev,
      LPCOMMCONFIG lpCC,
        LPDWORD lpdwSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommMask(
       HANDLE hFile,
      LPDWORD lpEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommProperties(
         HANDLE hFile,
      LPCOMMPROP lpCommProp
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommModemStatus(
       HANDLE hFile,
      LPDWORD lpModemStat
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommState(
       HANDLE hFile,
      LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommTimeouts(
       HANDLE hFile,
      LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
PurgeComm(
      HANDLE hFile,
      DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommBreak(
      HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommConfig(
      HANDLE hCommDev,
      LPCOMMCONFIG lpCC,
      DWORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommMask(
      HANDLE hFile,
      DWORD dwEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommState(
      HANDLE hFile,
      LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommTimeouts(
      HANDLE hFile,
      LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
TransmitCommChar(
      HANDLE hFile,
      char cChar
    );

__declspec(dllimport)
BOOL
__stdcall
WaitCommEvent(
             HANDLE hFile,
          LPDWORD lpEvtMask,
      LPOVERLAPPED lpOverlapped
    );




__declspec(dllimport)
HANDLE
__stdcall
OpenCommPort(
      ULONG uPortNumber,
      DWORD dwDesiredAccess,
      DWORD dwFlagsAndAttributes
    );

#line 2180 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 2182 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
SetTapePosition(
      HANDLE hDevice,
      DWORD dwPositionMethod,
      DWORD dwPartition,
      DWORD dwOffsetLow,
      DWORD dwOffsetHigh,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapePosition(
       HANDLE hDevice,
       DWORD dwPositionType,
      LPDWORD lpdwPartition,
      LPDWORD lpdwOffsetLow,
      LPDWORD lpdwOffsetHigh
    );

__declspec(dllimport)
DWORD
__stdcall
PrepareTape(
      HANDLE hDevice,
      DWORD dwOperation,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
EraseTape(
      HANDLE hDevice,
      DWORD dwEraseType,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
CreateTapePartition(
      HANDLE hDevice,
      DWORD dwPartitionMethod,
      DWORD dwCount,
      DWORD dwSize
    );

__declspec(dllimport)
DWORD
__stdcall
WriteTapemark(
      HANDLE hDevice,
      DWORD dwTapemarkType,
      DWORD dwTapemarkCount,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeStatus(
      HANDLE hDevice
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeParameters(
         HANDLE hDevice,
         DWORD dwOperation,
      LPDWORD lpdwSize,
      LPVOID lpTapeInformation
    );




__declspec(dllimport)
DWORD
__stdcall
SetTapeParameters(
      HANDLE hDevice,
      DWORD dwOperation,
      LPVOID lpTapeInformation
    );




#line 2281 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
int
__stdcall
MulDiv(
      int nNumber,
      int nNumerator,
      int nDenominator
    );

#line 2296 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;



__declspec(dllimport)
DEP_SYSTEM_POLICY_TYPE
__stdcall
GetSystemDEPPolicy(
    void
    );

#line 2319 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetSystemRegistryQuota(
      PDWORD pdwQuotaAllowed,
      PDWORD pdwQuotaUsed
    );

#line 2331 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
FileTimeToDosDateTime(
       const FILETIME *lpFileTime,
      LPWORD lpFatDate,
      LPWORD lpFatTime
    );

__declspec(dllimport)
BOOL
__stdcall
DosDateTimeToFileTime(
       WORD wFatDate,
       WORD wFatTime,
      LPFILETIME lpFileTime
    );

#line 2355 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family









__declspec(dllimport)
 
DWORD
__stdcall
FormatMessageA(
          DWORD dwFlags,
      LPCVOID lpSource,
          DWORD dwMessageId,
          DWORD dwLanguageId,
    
    
             LPSTR lpBuffer,
          DWORD nSize,
      va_list *Arguments
    );
__declspec(dllimport)
 
DWORD
__stdcall
FormatMessageW(
          DWORD dwFlags,
      LPCVOID lpSource,
          DWORD dwMessageId,
          DWORD dwLanguageId,
    
    
             LPWSTR lpBuffer,
          DWORD nSize,
      va_list *Arguments
    );




#line 2402 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





























#line 2432 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 2433 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"








#line 2442 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotA(
          LPCSTR lpName,
          DWORD nMaxMessageSize,
          DWORD lReadTimeout,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotW(
          LPCWSTR lpName,
          DWORD nMaxMessageSize,
          DWORD lReadTimeout,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 2471 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetMailslotInfo(
           HANDLE hMailslot,
      LPDWORD lpMaxMessageSize,
      LPDWORD lpNextSize,
      LPDWORD lpMessageCount,
      LPDWORD lpReadTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
SetMailslotInfo(
      HANDLE hMailslot,
      DWORD lReadTimeout
    );





__declspec(dllimport)
BOOL
__stdcall
EncryptFileA(
      LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
EncryptFileW(
      LPCWSTR lpFileName
    );




#line 2512 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DecryptFileA(
            LPCSTR lpFileName,
      DWORD dwReserved
    );
__declspec(dllimport)
BOOL
__stdcall
DecryptFileW(
            LPCWSTR lpFileName,
      DWORD dwReserved
    );




#line 2532 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
















__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusA(
       LPCSTR lpFileName,
      LPDWORD  lpStatus
    );
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusW(
       LPCWSTR lpFileName,
      LPDWORD  lpStatus
    );




#line 2567 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"







typedef
DWORD
(__stdcall *PFE_EXPORT_FUNC)(
      PBYTE pbData,
      PVOID pvCallbackContext,
          ULONG ulLength
    );

typedef
DWORD
(__stdcall *PFE_IMPORT_FUNC)(
      PBYTE pbData,
      PVOID pvCallbackContext,
       PULONG ulLength
    );













__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawA(
             LPCSTR lpFileName,
             ULONG    ulFlags,
     PVOID   *pvContext
    );
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawW(
             LPCWSTR lpFileName,
             ULONG    ulFlags,
     PVOID   *pvContext
    );




#line 2623 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
ReadEncryptedFileRaw(
          PFE_EXPORT_FUNC pfExportCallback,
      PVOID           pvCallbackContext,
          PVOID           pvContext
    );

__declspec(dllimport)
DWORD
__stdcall
WriteEncryptedFileRaw(
          PFE_IMPORT_FUNC pfImportCallback,
      PVOID           pvCallbackContext,
          PVOID           pvContext
    );

__declspec(dllimport)
void
__stdcall
CloseEncryptedFileRaw(
      PVOID           pvContext
    );

#line 2650 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion





#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
int
__stdcall
lstrcmpA(
      LPCSTR lpString1,
      LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpW(
      LPCWSTR lpString1,
      LPCWSTR lpString2
    );




#line 2678 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrcmpiA(
      LPCSTR lpString1,
      LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpiW(
      LPCWSTR lpString1,
      LPCWSTR lpString2
    );




#line 2698 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


#pragma warning(push)
#pragma warning(disable:4995)
#line 2703 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
 
 
 
LPSTR
__stdcall
lstrcpynA(
      LPSTR lpString1,
      LPCSTR lpString2,
      int iMaxLength
    );
__declspec(dllimport)
 
 
 
 
LPWSTR
__stdcall
lstrcpynW(
      LPWSTR lpString1,
      LPCWSTR lpString2,
      int iMaxLength
    );




#line 2733 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
LPSTR
__stdcall
lstrcpyA(
      LPSTR lpString1, 
       LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcpyW(
      LPWSTR lpString1, 
       LPCWSTR lpString2
    );




#line 2753 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
LPSTR
__stdcall
lstrcatA(
      LPSTR lpString1, 
         LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcatW(
      LPWSTR lpString1, 
         LPCWSTR lpString2
    );




#line 2773 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


#pragma warning(pop)
#line 2777 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrlenA(
      LPCSTR lpString
    );
__declspec(dllimport)
int
__stdcall
lstrlenW(
      LPCWSTR lpString
    );




#line 2795 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 2797 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HFILE
__stdcall
OpenFile(
         LPCSTR lpFileName,
      LPOFSTRUCT lpReOpenBuff,
         UINT uStyle
    );

__declspec(dllimport)
HFILE
__stdcall
_lopen(
      LPCSTR lpPathName,
      int iReadWrite
    );

__declspec(dllimport)
HFILE
__stdcall
_lcreat(
      LPCSTR lpPathName,
      int  iAttribute
    );

__declspec(dllimport)
UINT
__stdcall
_lread(
      HFILE hFile,
      LPVOID lpBuffer,
      UINT uBytes
    );

__declspec(dllimport)
UINT
__stdcall
_lwrite(
      HFILE hFile,
      LPCCH lpBuffer,
      UINT uBytes
    );

__declspec(dllimport)
long
__stdcall
_hread(
      HFILE hFile,
      LPVOID lpBuffer,
      long lBytes
    );

__declspec(dllimport)
long
__stdcall
_hwrite(
      HFILE hFile,
      LPCCH lpBuffer,
      long lBytes
    );

__declspec(dllimport)
HFILE
__stdcall
_lclose(
      HFILE hFile
    );

__declspec(dllimport)
LONG
__stdcall
_llseek(
      HFILE hFile,
      LONG lOffset,
      int iOrigin
    );

__declspec(dllimport)
BOOL
__stdcall
IsTextUnicode(
      const void* lpv,
             int iSize,
      LPINT lpiResult
    );

#line 2889 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
      HANDLE hObjectToSignal,
      HANDLE hObjectToWaitOn,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );
#line 2905 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 2907 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
BackupRead(
         HANDLE hFile,
      LPBYTE lpBuffer,
         DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
         BOOL bAbort,
         BOOL bProcessSecurity,
      LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupSeek(
         HANDLE hFile,
         DWORD  dwLowBytesToSeek,
         DWORD  dwHighBytesToSeek,
        LPDWORD lpdwLowByteSeeked,
        LPDWORD lpdwHighByteSeeked,
      LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupWrite(
         HANDLE hFile,
      LPBYTE lpBuffer,
         DWORD nNumberOfBytesToWrite,
        LPDWORD lpNumberOfBytesWritten,
         BOOL bAbort,
         BOOL bProcessSecurity,
      LPVOID *lpContext
    );




typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

















































#line 3010 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#line 3014 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;




typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;
#line 3032 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3034 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#line 3038 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
 
HANDLE
__stdcall
OpenMutexA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );


#line 3055 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreA(
      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
          LONG lInitialCount,
          LONG lMaximumCount,
      LPCSTR lpName
    );


#line 3069 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3071 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
 
HANDLE
__stdcall
OpenSemaphoreA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );


#line 3088 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3090 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerA(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
          BOOL bManualReset,
      LPCSTR lpTimerName
    );


#line 3109 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenWaitableTimerA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpTimerName
    );


#line 3122 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreExA(
         LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
         LPCSTR lpName,
       DWORD dwFlags,
             DWORD dwDesiredAccess
    );


#line 3140 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerExA(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
      LPCSTR lpTimerName,
          DWORD dwFlags,
          DWORD dwDesiredAccess
    );


#line 3154 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3156 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3158 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3160 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingA(
          HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
          DWORD flProtect,
          DWORD dwMaximumSizeHigh,
          DWORD dwMaximumSizeLow,
      LPCSTR lpName
    );


#line 3181 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingNumaA(
          HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
          DWORD flProtect,
          DWORD dwMaximumSizeHigh,
          DWORD dwMaximumSizeLow,
      LPCSTR lpName,
          DWORD nndPreferred
    );



#line 3201 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3203 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenFileMappingA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );


#line 3215 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3217 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
 
DWORD
__stdcall
GetLogicalDriveStringsA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );


#line 3233 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3235 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



#line 3242 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
 
HMODULE
__stdcall
LoadPackagedLibrary (
            LPCWSTR lpwLibFileName,
      DWORD Reserved
    );

#line 3259 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3261 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion































#line 3294 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameA(
      HANDLE hProcess,
      DWORD dwFlags,
      LPSTR lpExeName,
      PDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameW(
      HANDLE hProcess,
      DWORD dwFlags,
      LPWSTR lpExeName,
      PDWORD lpdwSize
    );




#line 3325 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3327 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"














typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess                = 0,
    ProcThreadAttributeHandleList                   = 2,

    ProcThreadAttributeGroupAffinity                = 3,
    ProcThreadAttributePreferredNode                = 4,
    ProcThreadAttributeIdealProcessor               = 5,
    ProcThreadAttributeUmsThread                    = 6,
    ProcThreadAttributeMitigationPolicy             = 7,
#line 3351 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

    ProcThreadAttributeSecurityCapabilities         = 9,
#line 3354 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
    ProcThreadAttributeProtectionLevel              = 11,

#line 3357 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

    ProcThreadAttributeJobList                      = 13,
    ProcThreadAttributeChildProcessPolicy           = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter                 = 16,
#line 3363 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

    ProcThreadAttributeSafeOpenPromptOriginClaim    = 17,
#line 3366 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

    ProcThreadAttributeDesktopAppPolicy = 18,
#line 3369 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
} PROC_THREAD_ATTRIBUTE_NUM;
#line 3371 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"












#line 3384 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"












#line 3397 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




#line 3402 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





#line 3408 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"










#line 3419 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"











































































































































































































#line 3623 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 3624 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 3625 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





























#line 3655 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




#line 3660 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"















#line 3676 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3678 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
void
__stdcall
GetStartupInfoA(
      LPSTARTUPINFOA lpStartupInfo
    );


#line 3693 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

































#line 3727 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



















#line 3747 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3749 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize
    );




#line 3777 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableExA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize,
      PDWORD pdwAttribubutes
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableExW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize,
      PDWORD pdwAttribubutes
    );




#line 3805 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3807 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pValue,
      DWORD    nSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pValue,
      DWORD    nSize
    );




#line 3831 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableExA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pValue,
      DWORD    nSize,
      DWORD    dwAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableExW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pValue,
      DWORD    nSize,
      DWORD    dwAttributes
    );




#line 3859 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3861 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 3863 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
GetFirmwareType (
      PFIRMWARE_TYPE FirmwareType
    );


__declspec(dllimport)
BOOL
__stdcall
IsNativeVhdBoot (
      PBOOL NativeVhdBoot
    );

#line 3886 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceA(
      HMODULE hModule,
          LPCSTR lpName,
          LPCSTR lpType
    );


#line 3899 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceExA(
      HMODULE hModule,
          LPCSTR lpType,
          LPCSTR lpName,
          WORD    wLanguage
    );


#line 3913 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesA(
      HMODULE hModule,
          ENUMRESTYPEPROCA lpEnumFunc,
          LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesW(
      HMODULE hModule,
          ENUMRESTYPEPROCW lpEnumFunc,
          LONG_PTR lParam
    );




#line 3935 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesA(
      HMODULE hModule,
          LPCSTR lpType,
          ENUMRESNAMEPROCA lpEnumFunc,
          LONG_PTR lParam
    );



#line 3949 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesA(
      HMODULE hModule,
          LPCSTR lpType,
          LPCSTR lpName,
          ENUMRESLANGPROCA lpEnumFunc,
          LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesW(
      HMODULE hModule,
          LPCWSTR lpType,
          LPCWSTR lpName,
          ENUMRESLANGPROCW lpEnumFunc,
          LONG_PTR lParam
    );




#line 3975 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceA(
      LPCSTR pFileName,
      BOOL bDeleteExistingResources
    );
__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceW(
      LPCWSTR pFileName,
      BOOL bDeleteExistingResources
    );




#line 3995 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateResourceA(
      HANDLE hUpdate,
      LPCSTR lpType,
      LPCSTR lpName,
      WORD wLanguage,
      LPVOID lpData,
      DWORD cb
    );
__declspec(dllimport)
BOOL
__stdcall
UpdateResourceW(
      HANDLE hUpdate,
      LPCWSTR lpType,
      LPCWSTR lpName,
      WORD wLanguage,
      LPVOID lpData,
      DWORD cb
    );




#line 4023 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceA(
      HANDLE hUpdate,
      BOOL   fDiscard
    );
__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceW(
      HANDLE hUpdate,
      BOOL   fDiscard
    );




#line 4043 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomW(
      LPCWSTR lpString
    );




#line 4063 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExA(
      LPCSTR lpString,
      DWORD Flags
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExW(
      LPCWSTR lpString,
      DWORD Flags
    );




#line 4083 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomW(
      LPCWSTR lpString
    );




#line 4101 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameA(
      ATOM nAtom,
      LPSTR lpBuffer,
      int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameW(
      ATOM nAtom,
      LPWSTR lpBuffer,
      int nSize
    );




#line 4123 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
AddAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
AddAtomW(
      LPCWSTR lpString
    );




#line 4141 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
FindAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
FindAtomW(
      LPCWSTR lpString
    );




#line 4159 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetAtomNameA(
      ATOM nAtom,
      LPSTR lpBuffer,
      int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GetAtomNameW(
      ATOM nAtom,
      LPWSTR lpBuffer,
      int nSize
    );




#line 4181 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4183 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetProfileIntA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      INT nDefault
    );
__declspec(dllimport)
UINT
__stdcall
GetProfileIntW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      INT nDefault
    );




#line 4209 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpDefault,
      LPSTR lpReturnedString,
          DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpDefault,
      LPWSTR lpReturnedString,
          DWORD nSize
    );




#line 4235 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4237 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpString
    );




#line 4263 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4265 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionA(
      LPCSTR lpAppName,
      LPSTR lpReturnedString,
      DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionW(
      LPCWSTR lpAppName,
      LPWSTR lpReturnedString,
      DWORD nSize
    );




#line 4291 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4293 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionA(
      LPCSTR lpAppName,
      LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionW(
      LPCWSTR lpAppName,
      LPCWSTR lpString
    );




#line 4317 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4319 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntA(
          LPCSTR lpAppName,
          LPCSTR lpKeyName,
          INT nDefault,
      LPCSTR lpFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntW(
          LPCWSTR lpAppName,
          LPCWSTR lpKeyName,
          INT nDefault,
      LPCWSTR lpFileName
    );




#line 4347 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"























#line 4371 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpDefault,
      LPSTR lpReturnedString,
          DWORD nSize,
      LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpDefault,
      LPWSTR lpReturnedString,
          DWORD nSize,
      LPCWSTR lpFileName
    );




#line 4399 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



























#line 4427 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpString,
      LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpString,
      LPCWSTR lpFileName
    );




#line 4451 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionA(
          LPCSTR lpAppName,
      LPSTR lpReturnedString,
          DWORD nSize,
      LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionW(
          LPCWSTR lpAppName,
      LPWSTR lpReturnedString,
          DWORD nSize,
      LPCWSTR lpFileName
    );




#line 4475 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"























#line 4499 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionA(
      LPCSTR lpAppName,
      LPCSTR lpString,
      LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionW(
      LPCWSTR lpAppName,
      LPCWSTR lpString,
      LPCWSTR lpFileName
    );




#line 4521 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4523 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesA(
      LPSTR lpszReturnBuffer,
          DWORD nSize,
      LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesW(
      LPWSTR lpszReturnBuffer,
          DWORD nSize,
      LPCWSTR lpFileName
    );




#line 4549 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





















#line 4571 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructA(
          LPCSTR lpszSection,
          LPCSTR lpszKey,
      LPVOID   lpStruct,
          UINT     uSizeStruct,
      LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructW(
          LPCWSTR lpszSection,
          LPCWSTR lpszKey,
      LPVOID   lpStruct,
          UINT     uSizeStruct,
      LPCWSTR szFile
    );




#line 4597 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

























#line 4623 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructA(
          LPCSTR lpszSection,
          LPCSTR lpszKey,
      LPVOID lpStruct,
          UINT     uSizeStruct,
      LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructW(
          LPCWSTR lpszSection,
          LPCWSTR lpszKey,
      LPVOID lpStruct,
          UINT     uSizeStruct,
      LPCWSTR szFile
    );




#line 4649 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"























#line 4673 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




__declspec(dllimport)
BOOLEAN
__stdcall
Wow64EnableWow64FsRedirection (
      BOOLEAN Wow64FsEnableRedirection
    );




typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_A)(  LPSTR lpBuffer,   UINT uSize);
typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_W)(  LPWSTR lpBuffer,   UINT uSize);





















#line 4711 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4713 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 4714 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

















#line 4732 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



















#line 4752 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryA(
      LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryW(
      LPCWSTR lpPathName
    );




#line 4772 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetDllDirectoryA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );
__declspec(dllimport)
 
DWORD
__stdcall
GetDllDirectoryW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );




#line 4794 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4796 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
SetSearchPathMode (
      DWORD Flags
    );

#line 4810 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




















#line 4834 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4836 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExA(
          LPCSTR lpTemplateDirectory,
          LPCSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExW(
          LPCWSTR lpTemplateDirectory,
          LPCWSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 4862 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4864 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedA(
      LPCSTR lpTemplateDirectory,
          LPCSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedW(
      LPCWSTR lpTemplateDirectory,
          LPCWSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
          HANDLE hTransaction
    );




#line 4894 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedA(
      LPCSTR lpPathName,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedW(
      LPCWSTR lpPathName,
          HANDLE hTransaction
    );




#line 4914 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameTransactedA(
                 LPCSTR lpFileName,
                 DWORD nBufferLength,
      LPSTR lpBuffer,
     LPSTR *lpFilePart,
                 HANDLE hTransaction
    );
__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameTransactedW(
                 LPCWSTR lpFileName,
                 DWORD nBufferLength,
      LPWSTR lpBuffer,
     LPWSTR *lpFilePart,
                 HANDLE hTransaction
    );




#line 4942 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4944 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4946 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family








__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceA(
          DWORD dwFlags,
          LPCSTR lpDeviceName,
      LPCSTR lpTargetPath
    );


#line 4968 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceA(
      LPCSTR lpDeviceName,
      LPSTR lpTargetPath,
          DWORD ucchMax
    );


#line 4980 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 4982 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedA(
            LPCSTR lpFileName,
            DWORD dwDesiredAccess,
            DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            DWORD dwCreationDisposition,
            DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile,
            HANDLE hTransaction,
        PUSHORT pusMiniVersion,
      PVOID  lpExtendedParameter
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedW(
            LPCWSTR lpFileName,
            DWORD dwDesiredAccess,
            DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            DWORD dwCreationDisposition,
            DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile,
            HANDLE hTransaction,
        PUSHORT pusMiniVersion,
      PVOID  lpExtendedParameter
    );




#line 5026 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5028 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5030 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
HANDLE
__stdcall
ReOpenFile(
      HANDLE  hOriginalFile,
      DWORD   dwDesiredAccess,
      DWORD   dwShareMode,
      DWORD   dwFlagsAndAttributes
    );

#line 5048 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5050 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedA(
          LPCSTR lpFileName,
          DWORD dwFileAttributes,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedW(
          LPCWSTR lpFileName,
          DWORD dwFileAttributes,
          HANDLE hTransaction
    );




#line 5079 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedA(
       LPCSTR lpFileName,
       GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedW(
       LPCWSTR lpFileName,
       GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation,
          HANDLE hTransaction
    );




#line 5103 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedA(
           LPCSTR lpFileName,
      LPDWORD  lpFileSizeHigh,
           HANDLE hTransaction
    );
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedW(
           LPCWSTR lpFileName,
      LPDWORD  lpFileSizeHigh,
           HANDLE hTransaction
    );




#line 5125 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedA(
          LPCSTR lpFileName,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedW(
          LPCWSTR lpFileName,
          HANDLE hTransaction
    );




#line 5145 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5147 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5149 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


















#line 5171 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5173 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3A(
           LPCSTR lpName,
      LPSTR lpOemName,
           DWORD OemNameSize,
      PBOOL pbNameContainsSpaces ,
          PBOOL pbNameLegal
    );
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3W(
           LPCWSTR lpName,
      LPSTR lpOemName,
           DWORD OemNameSize,
      PBOOL pbNameContainsSpaces ,
          PBOOL pbNameLegal
    );




#line 5205 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5207 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5209 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family




__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedA(
            LPCSTR lpFileName,
            FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
            FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
            DWORD dwAdditionalFlags,
            HANDLE hTransaction
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedW(
            LPCWSTR lpFileName,
            FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
            FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
            DWORD dwAdditionalFlags,
            HANDLE hTransaction
    );




#line 5247 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5249 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5251 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 5254 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CopyFileA(
      LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
      BOOL bFailIfExists
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileW(
      LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
      BOOL bFailIfExists
    );




#line 5280 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





















#line 5302 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5304 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef
DWORD
(__stdcall *LPPROGRESS_ROUTINE)(
          LARGE_INTEGER TotalFileSize,
          LARGE_INTEGER TotalBytesTransferred,
          LARGE_INTEGER StreamSize,
          LARGE_INTEGER StreamBytesTransferred,
          DWORD dwStreamNumber,
          DWORD dwCallbackReason,
          HANDLE hSourceFile,
          HANDLE hDestinationFile,
      LPVOID lpData
    );

__declspec(dllimport)
BOOL
__stdcall
CopyFileExA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
         LPPROGRESS_ROUTINE lpProgressRoutine,
         LPVOID lpData,
    
      LPBOOL pbCancel,
             DWORD dwCopyFlags
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileExW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
         LPPROGRESS_ROUTINE lpProgressRoutine,
         LPVOID lpData,
    
      LPBOOL pbCancel,
             DWORD dwCopyFlags
    );




#line 5354 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5356 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedA(
          LPCSTR lpExistingFileName,
          LPCSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
      LPBOOL pbCancel,
          DWORD dwCopyFlags,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedW(
          LPCWSTR lpExistingFileName,
          LPCWSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
      LPBOOL pbCancel,
          DWORD dwCopyFlags,
          HANDLE hTransaction
    );




#line 5392 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5394 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5396 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family








typedef enum _COPYFILE2_MESSAGE_TYPE {
     COPYFILE2_CALLBACK_NONE = 0,
     COPYFILE2_CALLBACK_CHUNK_STARTED,
     COPYFILE2_CALLBACK_CHUNK_FINISHED,
     COPYFILE2_CALLBACK_STREAM_STARTED,
     COPYFILE2_CALLBACK_STREAM_FINISHED,
     COPYFILE2_CALLBACK_POLL_CONTINUE,
     COPYFILE2_CALLBACK_ERROR,
     COPYFILE2_CALLBACK_MAX,
} COPYFILE2_MESSAGE_TYPE;

typedef enum _COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE,
} COPYFILE2_MESSAGE_ACTION;

typedef enum _COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,
    
    COPYFILE2_PHASE_MAX,
} COPYFILE2_COPY_PHASE;



typedef struct COPYFILE2_MESSAGE {

    COPYFILE2_MESSAGE_TYPE  Type;
    DWORD                   dwPadding;

    union {

        struct {
            DWORD           dwStreamNumber; 
            DWORD           dwReserved;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliChunkNumber; 
            ULARGE_INTEGER  uliChunkSize;  
            ULARGE_INTEGER  uliStreamSize; 
            ULARGE_INTEGER  uliTotalFileSize; 
        } ChunkStarted;

        struct {
            DWORD           dwStreamNumber; 
            DWORD           dwFlags;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliChunkNumber; 
            ULARGE_INTEGER  uliChunkSize;  
            ULARGE_INTEGER  uliStreamSize; 
            ULARGE_INTEGER  uliStreamBytesTransferred; 
            ULARGE_INTEGER  uliTotalFileSize; 
            ULARGE_INTEGER  uliTotalBytesTransferred; 
        } ChunkFinished;

        struct {
            DWORD           dwStreamNumber;
            DWORD           dwReserved;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliStreamSize; 
            ULARGE_INTEGER  uliTotalFileSize; 
        } StreamStarted;

        struct {
            DWORD           dwStreamNumber;
            DWORD           dwReserved;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliStreamSize;
            ULARGE_INTEGER  uliStreamBytesTransferred;
            ULARGE_INTEGER  uliTotalFileSize;
            ULARGE_INTEGER  uliTotalBytesTransferred;
        } StreamFinished;

        struct {
            DWORD           dwReserved;
        } PollContinue;

        struct {
            COPYFILE2_COPY_PHASE    CopyPhase;
            DWORD                   dwStreamNumber;
            HRESULT                 hrFailure;
            DWORD                   dwReserved;
            ULARGE_INTEGER          uliChunkNumber;
            ULARGE_INTEGER          uliStreamSize;
            ULARGE_INTEGER          uliStreamBytesTransferred;
            ULARGE_INTEGER          uliTotalFileSize;
            ULARGE_INTEGER          uliTotalBytesTransferred;
        } Error;

    } Info;

} COPYFILE2_MESSAGE;

typedef
COPYFILE2_MESSAGE_ACTION (__stdcall *PCOPYFILE2_PROGRESS_ROUTINE)(
         const COPYFILE2_MESSAGE     *pMessage,
     PVOID                       pvCallbackContext
);

typedef struct COPYFILE2_EXTENDED_PARAMETERS {
  DWORD                         dwSize;
  DWORD                         dwCopyFlags;
  BOOL                          *pfCancel;
  PCOPYFILE2_PROGRESS_ROUTINE   pProgressRoutine;
  PVOID                         pvCallbackContext;
} COPYFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HRESULT
__stdcall
CopyFile2(
         PCWSTR                          pwszExistingFileName,
         PCWSTR                          pwszNewFileName,
     COPYFILE2_EXTENDED_PARAMETERS   *pExtendedParameters
);

#line 5535 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5537 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 5540 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MoveFileA(
      LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileW(
      LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName
    );




#line 5563 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



















#line 5583 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5585 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
MoveFileExA(
          LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
          DWORD    dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileExW(
          LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
          DWORD    dwFlags
    );




#line 5611 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5613 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressA(
          LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressW(
          LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags
    );




#line 5644 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 5645 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5647 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedA(
          LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedW(
          LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags,
          HANDLE hTransaction
    );




#line 5680 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 5681 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5683 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family









#line 5696 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5698 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



#line 5705 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




__declspec(dllimport)
BOOL
__stdcall
ReplaceFileA(
            LPCSTR lpReplacedFileName,
            LPCSTR lpReplacementFileName,
        LPCSTR lpBackupFileName,
            DWORD    dwReplaceFlags,
      LPVOID   lpExclude,
      LPVOID  lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileW(
            LPCWSTR lpReplacedFileName,
            LPCWSTR lpReplacementFileName,
        LPCWSTR lpBackupFileName,
            DWORD    dwReplaceFlags,
      LPVOID   lpExclude,
      LPVOID  lpReserved
    );




#line 5739 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 5740 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5742 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family







__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkA(
            LPCSTR lpFileName,
            LPCSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkW(
            LPCWSTR lpFileName,
            LPCWSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 5773 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5775 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5777 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family







__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedA(
            LPCSTR lpFileName,
            LPCSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedW(
            LPCWSTR lpFileName,
            LPCWSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            HANDLE hTransaction
    );




#line 5810 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5812 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamTransactedW (
            LPCWSTR lpFileName,
            STREAM_INFO_LEVELS InfoLevel,
      LPVOID lpFindStreamData,
      DWORD dwFlags,
            HANDLE hTransaction
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameTransactedW (
          LPCWSTR lpFileName,
          DWORD dwFlags,
       LPDWORD StringLength,
      PWSTR LinkName,
      HANDLE hTransaction
    );

#line 5838 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5840 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeA(
          LPCSTR lpName,
          DWORD dwOpenMode,
          DWORD dwPipeMode,
          DWORD nMaxInstances,
          DWORD nOutBufferSize,
          DWORD nInBufferSize,
          DWORD nDefaultTimeOut,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );


#line 5861 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5863 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateA(
           HANDLE hNamedPipe,
      LPDWORD lpState,
      LPDWORD lpCurInstances,
      LPDWORD lpMaxCollectionCount,
      LPDWORD lpCollectDataTimeout,
      LPSTR lpUserName,
           DWORD nMaxUserNameSize
    );


#line 5883 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeA(
       LPCSTR lpNamedPipeName,
      LPVOID lpInBuffer,
       DWORD nInBufferSize,
      LPVOID lpOutBuffer,
       DWORD nOutBufferSize,
      LPDWORD lpBytesRead,
       DWORD nTimeOut
    );



#line 5900 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeA(
      LPCSTR lpNamedPipeName,
      DWORD nTimeOut
    );


#line 5911 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5913 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family



#line 5922 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameA(
      HANDLE Pipe,
       LPSTR ClientComputerName,
      ULONG ClientComputerNameLength
    );



#line 5939 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 5941 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientProcessId(
      HANDLE Pipe,
      PULONG ClientProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientSessionId(
      HANDLE Pipe,
      PULONG ClientSessionId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerProcessId(
      HANDLE Pipe,
      PULONG ServerProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerSessionId(
      HANDLE Pipe,
      PULONG ServerSessionId
    );

#line 5979 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 5982 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Application Family or Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelA(
      LPCSTR lpRootPathName,
      LPCSTR lpVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelW(
      LPCWSTR lpRootPathName,
      LPCWSTR lpVolumeName
    );




#line 6005 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6007 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
BOOL
__stdcall
SetFileBandwidthReservation(
       HANDLE  hFile,
       DWORD   nPeriodMilliseconds,
       DWORD   nBytesPerPeriod,
       BOOL    bDiscardable,
      LPDWORD lpTransferSize,
      LPDWORD lpNumOutstandingRequests
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileBandwidthReservation(
       HANDLE  hFile,
      LPDWORD lpPeriodMilliseconds,
      LPDWORD lpBytesPerPeriod,
      LPBOOL  pDiscardable,
      LPDWORD lpTransferSize,
      LPDWORD lpNumOutstandingRequests
    );

#line 6040 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
ClearEventLogA (
          HANDLE hEventLog,
      LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
ClearEventLogW (
          HANDLE hEventLog,
      LPCWSTR lpBackupFileName
    );




#line 6064 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BackupEventLogA (
      HANDLE hEventLog,
      LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
BackupEventLogW (
      HANDLE hEventLog,
      LPCWSTR lpBackupFileName
    );




#line 6084 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CloseEventLog (
      HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
DeregisterEventSource (
      HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyChangeEventLog(
      HANDLE  hEventLog,
      HANDLE  hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfEventLogRecords (
       HANDLE hEventLog,
      PDWORD NumberOfRecords
    );

__declspec(dllimport)
BOOL
__stdcall
GetOldestEventLogRecord (
       HANDLE hEventLog,
      PDWORD OldestRecord
    );

__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogA (
      LPCSTR lpUNCServerName,
          LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogW (
      LPCWSTR lpUNCServerName,
          LPCWSTR lpSourceName
    );




#line 6142 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceA (
      LPCSTR lpUNCServerName,
          LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceW (
      LPCWSTR lpUNCServerName,
          LPCWSTR lpSourceName
    );




#line 6162 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogA (
      LPCSTR lpUNCServerName,
          LPCSTR lpFileName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogW (
      LPCWSTR lpUNCServerName,
          LPCWSTR lpFileName
    );




#line 6182 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReadEventLogA (
       HANDLE     hEventLog,
       DWORD      dwReadFlags,
       DWORD      dwRecordOffset,
      LPVOID     lpBuffer,
       DWORD      nNumberOfBytesToRead,
      DWORD      *pnBytesRead,
      DWORD      *pnMinNumberOfBytesNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
ReadEventLogW (
       HANDLE     hEventLog,
       DWORD      dwReadFlags,
       DWORD      dwRecordOffset,
      LPVOID     lpBuffer,
       DWORD      nNumberOfBytesToRead,
      DWORD      *pnBytesRead,
      DWORD      *pnMinNumberOfBytesNeeded
    );




#line 6212 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReportEventA (
          HANDLE     hEventLog,
          WORD       wType,
          WORD       wCategory,
          DWORD      dwEventID,
      PSID       lpUserSid,
          WORD       wNumStrings,
          DWORD      dwDataSize,
      LPCSTR *lpStrings,
      LPVOID lpRawData
    );
__declspec(dllimport)
BOOL
__stdcall
ReportEventW (
          HANDLE     hEventLog,
          WORD       wType,
          WORD       wCategory,
          DWORD      dwEventID,
      PSID       lpUserSid,
          WORD       wNumStrings,
          DWORD      dwDataSize,
      LPCWSTR *lpStrings,
      LPVOID lpRawData
    );




#line 6246 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD    dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetEventLogInformation (
       HANDLE     hEventLog,
       DWORD      dwInfoLevel,
      LPVOID lpBuffer,
       DWORD      cbBufSize,
      LPDWORD    pcbBytesNeeded
    );








typedef ULONG OPERATION_ID;





typedef struct _OPERATION_START_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_START_PARAMETERS, *POPERATION_START_PARAMETERS;







typedef struct _OPERATION_END_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_END_PARAMETERS, *POPERATION_END_PARAMETERS;



__declspec(dllimport)
BOOL
__stdcall
OperationStart (
      OPERATION_START_PARAMETERS* OperationStartParams
    );

__declspec(dllimport)
BOOL
__stdcall
OperationEnd (
      OPERATION_END_PARAMETERS* OperationEndParams
    );

#line 6315 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"







__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmA (
          LPCSTR SubsystemName,
      LPVOID HandleId,
          LPSTR ObjectTypeName,
      LPSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
          DWORD DesiredAccess,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
         LPDWORD GrantedAccess,
         LPBOOL AccessStatus,
         LPBOOL pfGenerateOnClose
    );


#line 6341 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          LPCSTR ObjectTypeName,
      LPCSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
          DWORD DesiredAccess,
          AUDIT_EVENT_TYPE AuditType,
          DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
          DWORD ObjectTypeListLength,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
         LPDWORD GrantedAccess,
         LPBOOL AccessStatus,
         LPBOOL pfGenerateOnClose
    );


#line 6368 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          LPCSTR ObjectTypeName,
      LPCSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
          DWORD DesiredAccess,
          AUDIT_EVENT_TYPE AuditType,
          DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
          DWORD ObjectTypeListLength,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
         LPBOOL pfGenerateOnClose
    );


#line 6393 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          HANDLE ClientToken,
          LPCSTR ObjectTypeName,
      LPCSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
          DWORD DesiredAccess,
          AUDIT_EVENT_TYPE AuditType,
          DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
          DWORD ObjectTypeListLength,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
         LPBOOL pfGenerateOnClose
    );


#line 6419 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 6420 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          LPSTR ObjectTypeName,
      LPSTR ObjectName,
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
          HANDLE ClientToken,
          DWORD DesiredAccess,
          DWORD GrantedAccess,
      PPRIVILEGE_SET Privileges,
          BOOL ObjectCreation,
          BOOL AccessGranted,
         LPBOOL GenerateOnClose
    );


#line 6441 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmA (
      LPCSTR SubsystemName,
      LPVOID HandleId,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );


#line 6456 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmA (
      LPCSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );


#line 6468 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmA (
      LPCSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );


#line 6480 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmA (
      LPCSTR SubsystemName,
      LPCSTR ServiceName,
      HANDLE ClientToken,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );


#line 6494 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
AddConditionalAce (
      PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         UCHAR AceType,
         DWORD AccessMask,
         PSID pSid,
        PWCHAR ConditionStr,
      DWORD *ReturnLength
    );
#line 6510 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6512 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityA (
      LPCSTR lpFileName,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


#line 6528 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityA (
       LPCSTR lpFileName,
       SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
       DWORD nLength,
      LPDWORD lpnLengthNeeded
    );


#line 6542 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6544 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesW(
             HANDLE hDirectory,
      LPVOID lpBuffer,
             DWORD nBufferLength,
             BOOL bWatchSubtree,
             DWORD dwNotifyFilter,
        LPDWORD lpBytesReturned,
      LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesExW(
             HANDLE hDirectory,
      LPVOID lpBuffer,
             DWORD nBufferLength,
             BOOL bWatchSubtree,
             DWORD dwNotifyFilter,
        LPDWORD lpBytesReturned,
      LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
             READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass
    );
#line 6580 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 6581 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6583 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
  
LPVOID
__stdcall
MapViewOfFileExNuma(
          HANDLE hFileMappingObject,
          DWORD dwDesiredAccess,
          DWORD dwFileOffsetHigh,
          DWORD dwFileOffsetLow,
          SIZE_T dwNumberOfBytesToMap,
      LPVOID lpBaseAddress,
          DWORD nndPreferred
    );

#line 6605 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsBadReadPtr(
      const void *lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadWritePtr(
      LPVOID lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeReadPtr(
      const void *lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeWritePtr(
      LPVOID lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadCodePtr(
      FARPROC lpfn
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrA(
      LPCSTR lpsz,
          UINT_PTR ucchMax
    );
__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrW(
      LPCWSTR lpsz,
          UINT_PTR ucchMax
    );




#line 6664 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6666 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidA(
      LPCSTR lpSystemName,
      PSID Sid,
      LPSTR Name,
       LPDWORD cchName,
      LPSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidW(
      LPCWSTR lpSystemName,
      PSID Sid,
      LPWSTR Name,
       LPDWORD cchName,
      LPWSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );




#line 6700 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameA(
      LPCSTR lpSystemName,
          LPCSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameW(
      LPCWSTR lpSystemName,
          LPCWSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPWSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );




#line 6730 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6732 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameLocalA(
          LPCSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameLocalW(
          LPCWSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPWSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );




#line 6766 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidLocalA(
      PSID Sid,
      LPSTR Name,
       LPDWORD cchName,
      LPSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidLocalW(
      PSID Sid,
      LPWSTR Name,
       LPDWORD cchName,
      LPWSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );




#line 6794 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"























#line 6818 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6820 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueA(
      LPCSTR lpSystemName,
          LPCSTR lpName,
         PLUID   lpLuid
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueW(
      LPCWSTR lpSystemName,
          LPCWSTR lpName,
         PLUID   lpLuid
    );




#line 6846 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeNameA(
      LPCSTR lpSystemName,
          PLUID   lpLuid,
      LPSTR lpName,
       LPDWORD cchName
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeNameW(
      LPCWSTR lpSystemName,
          PLUID   lpLuid,
      LPWSTR lpName,
       LPDWORD cchName
    );




#line 6870 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeDisplayNameA(
      LPCSTR lpSystemName,
          LPCSTR lpName,
      LPSTR lpDisplayName,
       LPDWORD cchDisplayName,
         LPDWORD lpLanguageId
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeDisplayNameW(
      LPCWSTR lpSystemName,
          LPCWSTR lpName,
      LPWSTR lpDisplayName,
       LPDWORD cchDisplayName,
         LPDWORD lpLanguageId
    );




#line 6896 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 6898 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBA(
       LPCSTR lpDef,
      LPDCB lpDCB
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBW(
       LPCWSTR lpDef,
      LPDCB lpDCB
    );




#line 6922 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsA(
       LPCSTR lpDef,
      LPDCB lpDCB,
      LPCOMMTIMEOUTS lpCommTimeouts
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsW(
       LPCWSTR lpDef,
      LPDCB lpDCB,
      LPCOMMTIMEOUTS lpCommTimeouts
    );




#line 6944 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogA(
          LPCSTR lpszName,
      HWND hWnd,
       LPCOMMCONFIG lpCC
    );
__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogW(
          LPCWSTR lpszName,
      HWND hWnd,
       LPCOMMCONFIG lpCC
    );




#line 6966 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigA(
         LPCSTR lpszName,
      LPCOMMCONFIG lpCC,
      LPDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigW(
         LPCWSTR lpszName,
      LPCOMMCONFIG lpCC,
      LPDWORD lpdwSize
    );




#line 6988 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigA(
      LPCSTR lpszName,
      LPCOMMCONFIG lpCC,
      DWORD dwSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigW(
      LPCWSTR lpszName,
      LPCOMMCONFIG lpCC,
      DWORD dwSize
    );




#line 7010 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7012 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family






#line 7022 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameA (
      LPSTR lpBuffer,
      LPDWORD nSize
    );
__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameW (
      LPWSTR lpBuffer,
      LPDWORD nSize
    );




#line 7044 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7046 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
 
BOOL
__stdcall
DnsHostnameToComputerNameA (
         LPCSTR Hostname,
      LPSTR ComputerName,
      LPDWORD nSize
    );
__declspec(dllimport)
 
BOOL
__stdcall
DnsHostnameToComputerNameW (
         LPCWSTR Hostname,
      LPWSTR ComputerName,
      LPDWORD nSize
    );




#line 7077 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7079 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetUserNameA (
      LPSTR lpBuffer,
      LPDWORD pcbBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
GetUserNameW (
      LPWSTR lpBuffer,
      LPDWORD pcbBuffer
    );




#line 7099 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"













#line 7113 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





#line 7119 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


#line 7122 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


#line 7125 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
LogonUserA (
             LPCSTR lpszUsername,
         LPCSTR lpszDomain,
         LPCSTR lpszPassword,
             DWORD dwLogonType,
             DWORD dwLogonProvider,
     PHANDLE phToken
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserW (
             LPCWSTR lpszUsername,
         LPCWSTR lpszDomain,
         LPCWSTR lpszPassword,
             DWORD dwLogonType,
             DWORD dwLogonProvider,
     PHANDLE phToken
    );




#line 7155 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LogonUserExA (
                 LPCSTR lpszUsername,
             LPCSTR lpszDomain,
             LPCSTR lpszPassword,
                 DWORD dwLogonType,
                 DWORD dwLogonProvider,
     PHANDLE phToken,
     PSID  *ppLogonSid,
     PVOID *ppProfileBuffer,
            LPDWORD pdwProfileLength,
            PQUOTA_LIMITS pQuotaLimits
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserExW (
                 LPCWSTR lpszUsername,
             LPCWSTR lpszDomain,
             LPCWSTR lpszPassword,
                 DWORD dwLogonType,
                 DWORD dwLogonProvider,
     PHANDLE phToken,
     PSID  *ppLogonSid,
     PVOID *ppProfileBuffer,
            LPDWORD pdwProfileLength,
            PQUOTA_LIMITS pQuotaLimits
    );




#line 7191 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7193 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion




#line 7199 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family











__declspec(dllimport)
  BOOL
__stdcall
CreateProcessWithLogonW(
             LPCWSTR lpUsername,
         LPCWSTR lpDomain,
             LPCWSTR lpPassword,
             DWORD dwLogonFlags,
         LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
             DWORD dwCreationFlags,
         LPVOID lpEnvironment,
         LPCWSTR lpCurrentDirectory,
             LPSTARTUPINFOW lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
      );

__declspec(dllimport)
  BOOL
__stdcall
CreateProcessWithTokenW(
             HANDLE hToken,
             DWORD dwLogonFlags,
         LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
             DWORD dwCreationFlags,
         LPVOID lpEnvironment,
         LPCWSTR lpCurrentDirectory,
             LPSTARTUPINFOW lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
      );

#line 7245 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsTokenUntrusted(
      HANDLE TokenHandle
    );







__declspec(dllimport)
BOOL
__stdcall
RegisterWaitForSingleObject(
     PHANDLE phNewWaitObject,
             HANDLE hObject,
             WAITORTIMERCALLBACK Callback,
         PVOID Context,
             ULONG dwMilliseconds,
             ULONG dwFlags
    );

__declspec(dllimport)
 
BOOL
__stdcall
UnregisterWait(
      HANDLE WaitHandle
    );

__declspec(dllimport)
BOOL
__stdcall
BindIoCompletionCallback (
      HANDLE FileHandle,
      LPOVERLAPPED_COMPLETION_ROUTINE Function,
      ULONG Flags
    );

__declspec(dllimport)
HANDLE
__stdcall
SetTimerQueueTimer(
      HANDLE TimerQueue,
          WAITORTIMERCALLBACK Callback,
      PVOID Parameter,
          DWORD DueTime,
          DWORD Period,
          BOOL PreferIo
    );

__declspec(dllimport)
 
BOOL
__stdcall
CancelTimerQueueTimer(
      HANDLE TimerQueue,
          HANDLE Timer
    );

__declspec(dllimport)
 
BOOL
__stdcall
DeleteTimerQueue(
      HANDLE TimerQueue
    );

#line 7318 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7320 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"









__forceinline
void
InitializeThreadpoolEnvironment(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

__forceinline
void
SetThreadpoolCallbackPool(
      PTP_CALLBACK_ENVIRON pcbe,
         PTP_POOL             ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

__forceinline
void
SetThreadpoolCallbackCleanupGroup(
       PTP_CALLBACK_ENVIRON              pcbe,
          PTP_CLEANUP_GROUP                 ptpcg,
      PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

__forceinline
void
SetThreadpoolCallbackRunsLong(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

__forceinline
void
SetThreadpoolCallbackLibrary(
      PTP_CALLBACK_ENVIRON pcbe,
         PVOID                mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}



__forceinline
void
SetThreadpoolCallbackPriority(
      PTP_CALLBACK_ENVIRON pcbe,
         TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}

#line 7391 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__forceinline
void
DestroyThreadpoolEnvironment(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}

#line 7402 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7404 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7406 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7408 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#pragma region Desktop Family




__forceinline
void
SetThreadpoolCallbackPersistent(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}

#line 7426 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7428 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
 
HANDLE
__stdcall
CreatePrivateNamespaceA(
      LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
          LPVOID lpBoundaryDescriptor,
          LPCSTR lpAliasPrefix
    );





#line 7452 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenPrivateNamespaceA(
          LPVOID lpBoundaryDescriptor,
          LPCSTR lpAliasPrefix
    );





#line 7467 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"






__declspec(dllimport)
 
HANDLE
__stdcall
CreateBoundaryDescriptorA(
      LPCSTR Name,
      ULONG Flags
    );





#line 7487 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7489 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
AddIntegrityLabelToBoundaryDescriptor(
      HANDLE * BoundaryDescriptor,
      PSID IntegrityLabel
    );

#line 7503 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 7506 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family
















typedef struct tagHW_PROFILE_INFOA {
    DWORD  dwDockInfo;
    CHAR   szHwProfileGuid[39];
    CHAR   szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD  dwDockInfo;
    WCHAR  szHwProfileGuid[39];
    WCHAR  szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;




typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
#line 7541 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileA (
      LPHW_PROFILE_INFOA  lpHwProfileInfo
    );
__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileW (
      LPHW_PROFILE_INFOW  lpHwProfileInfo
    );




#line 7560 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 7561 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoA(
      LPOSVERSIONINFOEXA lpVersionInformation,
         DWORD dwTypeMask,
         DWORDLONG dwlConditionMask
    );
__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoW(
      LPOSVERSIONINFOEXW lpVersionInformation,
         DWORD dwTypeMask,
         DWORDLONG dwlConditionMask
    );




#line 7583 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


#line 7586 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion





#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"












#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23882 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 28295 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"



constexpr
#line 28300 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"
__forceinline   HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}


#line 28304 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"










































#line 28347 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"


























































































































































































#line 28534 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
 
 
 
 




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 48015 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 59797 "E:\\sdk\\include\\10.0.16299.0\\shared\\winerror.h"

#line 7593 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"
 










#pragma once
#line 14 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"




















#line 35 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"

#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"



extern "C" {
#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"



#pragma region Application Family or OneCore Family







typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

__declspec(dllimport)
 
BOOL
__stdcall
SystemTimeToTzSpecificLocalTime(
      const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpUniversalTime,
      LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
TzSpecificLocalTimeToSystemTime(
      const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpLocalTime,
      LPSYSTEMTIME lpUniversalTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
FileTimeToSystemTime(
      const FILETIME * lpFileTime,
      LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
SystemTimeToFileTime(
      const SYSTEMTIME * lpSystemTime,
      LPFILETIME lpFileTime
    );


__declspec(dllimport)
 
DWORD
__stdcall
GetTimeZoneInformation(
      LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );


#line 127 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetTimeZoneInformation(
      const TIME_ZONE_INFORMATION * lpTimeZoneInformation
    );





__declspec(dllimport)
BOOL
__stdcall
SetDynamicTimeZoneInformation(
      const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation
    );


#line 153 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"

#line 155 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






__declspec(dllimport)
 
DWORD
__stdcall
GetDynamicTimeZoneInformation(
      PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );


#line 174 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"




 
BOOL
__stdcall
GetTimeZoneInformationForYear(
      USHORT wYear,
      PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
      LPTIME_ZONE_INFORMATION ptzi
    );


#line 189 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"






__declspec(dllimport)
 
DWORD
__stdcall
EnumDynamicTimeZoneInformation(
      const DWORD dwIndex,
      PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation
    );


__declspec(dllimport)
 
DWORD
__stdcall
GetDynamicTimeZoneInformationEffectiveYears(
      const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation,
      LPDWORD FirstYear,
      LPDWORD LastYear
    );


__declspec(dllimport)
 
BOOL
__stdcall
SystemTimeToTzSpecificLocalTimeEx(
      const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpUniversalTime,
      LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
TzSpecificLocalTimeToSystemTimeEx(
      const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpLocalTime,
      LPSYSTEMTIME lpUniversalTime
    );


#line 239 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"

#line 241 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"
#pragma endregion




}
#line 248 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"

#line 250 "E:\\sdk\\include\\10.0.16299.0\\um\\timezoneapi.h"

#line 7594 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family














__declspec(dllimport)
BOOL
__stdcall
SetSystemPowerState(
      BOOL fSuspend,
      BOOL fForce
    );

#line 7619 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7621 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region  Desktop or PC Family

























typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE SystemStatusFlag;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

__declspec(dllimport)
BOOL
__stdcall
GetSystemPowerStatus(
      LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

#line 7666 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7668 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion






#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MapUserPhysicalPagesScatter(
      PVOID *VirtualAddresses,
      ULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );

#line 7688 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
 
HANDLE
__stdcall
CreateJobObjectA(
      LPSECURITY_ATTRIBUTES lpJobAttributes,
      LPCSTR lpName
    );





#line 7707 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenJobObjectA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );





#line 7723 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7725 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
CreateJobSet (
      ULONG NumJob,
      PJOB_SET_ARRAY UserJobSet,
      ULONG Flags);

#line 7739 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeA(
      LPSTR lpszVolumeName,
      DWORD cchBufferLength
    );


#line 7754 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeA(
      HANDLE hFindVolume,
      LPSTR lpszVolumeName,
         DWORD cchBufferLength
    );


#line 7766 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7768 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointA(
      LPCSTR lpszRootPathName,
      LPSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointW(
      LPCWSTR lpszRootPathName,
      LPWSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );




#line 7794 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointA(
      HANDLE hFindVolumeMountPoint,
      LPSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointW(
      HANDLE hFindVolumeMountPoint,
      LPWSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );




#line 7816 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindVolumeMountPointClose(
      HANDLE hFindVolumeMountPoint
    );

__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointA(
      LPCSTR lpszVolumeMountPoint,
      LPCSTR lpszVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointW(
      LPCWSTR lpszVolumeMountPoint,
      LPCWSTR lpszVolumeName
    );




#line 7843 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7845 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointA(
      LPCSTR lpszVolumeMountPoint
    );


#line 7859 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7861 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




#line 7869 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointA(
      LPCSTR lpszVolumeMountPoint,
      LPSTR lpszVolumeName,
      DWORD cchBufferLength
);

__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameA(
      LPCSTR lpszFileName,
      LPSTR lpszVolumePathName,
      DWORD cchBufferLength
    );


#line 7890 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7892 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 7895 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameA(
       LPCSTR lpszVolumeName,
         LPCH lpszVolumePathNames,
       DWORD cchBufferLength,
      PDWORD lpcchReturnLength
    );



#line 7914 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 7916 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"












typedef struct tagACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} ACTCTXW, *PACTCTXW;




typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
#line 7957 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;



typedef PCACTCTXA PCACTCTX;
#line 7965 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxA(
      PCACTCTXA pActCtx
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxW(
      PCACTCTXW pActCtx
    );




#line 7985 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
void
__stdcall
AddRefActCtx(
      HANDLE hActCtx
    );


__declspec(dllimport)
void
__stdcall
ReleaseActCtx(
      HANDLE hActCtx
    );

__declspec(dllimport)
BOOL
__stdcall
ZombifyActCtx(
      HANDLE hActCtx
    );


 
__declspec(dllimport)
BOOL
__stdcall
ActivateActCtx(
      HANDLE hActCtx,
        ULONG_PTR *lpCookie
    );




 
__declspec(dllimport)
BOOL
__stdcall
DeactivateActCtx(
      DWORD dwFlags,
      ULONG_PTR ulCookie
    );

__declspec(dllimport)
BOOL
__stdcall
GetCurrentActCtx(
     HANDLE *lphActCtx);


typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;

    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;







 
__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringA(
            DWORD dwFlags,
      const GUID *lpExtensionGuid,
            ULONG ulSectionId,
            LPCSTR lpStringToFind,
           PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
 
__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringW(
            DWORD dwFlags,
      const GUID *lpExtensionGuid,
            ULONG ulSectionId,
            LPCWSTR lpStringToFind,
           PACTCTX_SECTION_KEYED_DATA ReturnedData
    );




#line 8110 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionGuid(
            DWORD dwFlags,
      const GUID *lpExtensionGuid,
            ULONG ulSectionId,
        const GUID *lpGuidToFind,
           PACTCTX_SECTION_KEYED_DATA ReturnedData
    );





typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE  hActCtx;
    DWORD   dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;



#line 8136 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 8137 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




































 
__declspec(dllimport)
BOOL
__stdcall
QueryActCtxW(
           DWORD dwFlags,
           HANDLE hActCtx,
       PVOID pvSubInstance,
           ULONG ulInfoClass,
      PVOID pvBuffer,
           SIZE_T cbBuffer,
      SIZE_T *pcbWrittenOrRequired
    );

typedef   BOOL (__stdcall * PQUERYACTCTXW_FUNC)(
           DWORD dwFlags,
           HANDLE hActCtx,
       PVOID pvSubInstance,
           ULONG ulInfoClass,
      PVOID pvBuffer,
           SIZE_T cbBuffer,
      SIZE_T *pcbWrittenOrRequired
    );

#line 8198 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8200 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
DWORD
__stdcall
WTSGetActiveConsoleSessionId(
    void
    );

#line 8216 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
DWORD
__stdcall
WTSGetServiceSessionId(
    void
    );

__declspec(dllimport)
BOOLEAN
__stdcall
WTSIsServerContainer(
    void
    );

#line 8234 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
WORD
__stdcall
GetActiveProcessorGroupCount(
    void
    );

__declspec(dllimport)
WORD
__stdcall
GetMaximumProcessorGroupCount(
    void
    );

__declspec(dllimport)
DWORD
__stdcall
GetActiveProcessorCount(
      WORD GroupNumber
    );

__declspec(dllimport)
DWORD
__stdcall
GetMaximumProcessorCount(
      WORD GroupNumber
    );

#line 8266 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNode(
       UCHAR Processor,
      PUCHAR NodeNumber
    );



__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeNumberFromHandle(
       HANDLE hFile,
      PUSHORT NodeNumber
    );

#line 8290 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNodeEx(
       PPROCESSOR_NUMBER Processor,
      PUSHORT NodeNumber
    );

#line 8302 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMask(
       UCHAR Node,
      PULONGLONG ProcessorMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNode(
       UCHAR Node,
      PULONGLONG AvailableBytes
    );



__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNodeEx(
       USHORT Node,
      PULONGLONG AvailableBytes
    );

#line 8330 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNode(
       ULONG ProximityId,
      PUCHAR NodeNumber
    );

#line 8342 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8344 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family





typedef DWORD (__stdcall *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);





























#line 8383 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRecoveryCallback(
       APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
       PVOID pvParameter,
      DWORD dwPingInterval,
      DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRecoveryCallback(void);

__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRestart(
      PCWSTR pwzCommandline,
      DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRestart(void);

#line 8419 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8421 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRecoveryCallback(
       HANDLE hProcess,
      APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
     PVOID* ppvParameter,
      PDWORD pdwPingInterval,
      PDWORD pdwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRestartSettings(
      HANDLE hProcess,
      PWSTR pwzCommandline,
      PDWORD pcchSize,
      PDWORD pdwFlags
    );

#line 8450 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8452 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
HRESULT
__stdcall
ApplicationRecoveryInProgress(
      PBOOL pbCancelled
    );

__declspec(dllimport)
void
__stdcall
ApplicationRecoveryFinished(
      BOOL bSuccess
    );

#line 8474 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8476 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;

typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;




#line 8508 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#line 8512 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

typedef struct _FILE_RENAME_INFO {

    union {
        BOOLEAN ReplaceIfExists;  
        DWORD Flags;              
    } ;


#line 8522 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;

typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;

typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileA;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;








typedef struct _FILE_DISPOSITION_INFO_EX {
    DWORD Flags;
} FILE_DISPOSITION_INFO_EX, *PFILE_DISPOSITION_INFO_EX;
#line 8572 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

typedef struct _FILE_FULL_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;

typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;





typedef struct _FILE_ALIGNMENT_INFO {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFO, *PFILE_ALIGNMENT_INFO;




















typedef struct _FILE_STORAGE_INFO {
    ULONG LogicalBytesPerSector;
    ULONG PhysicalBytesPerSectorForAtomicity;
    ULONG PhysicalBytesPerSectorForPerformance;
    ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    ULONG Flags;
    ULONG ByteOffsetForSectorAlignment;
    ULONG ByteOffsetForPartitionAlignment;
} FILE_STORAGE_INFO, *PFILE_STORAGE_INFO;




typedef struct _FILE_ID_INFO {
    ULONGLONG VolumeSerialNumber;
    FILE_ID_128 FileId;
} FILE_ID_INFO, *PFILE_ID_INFO;




typedef struct _FILE_ID_EXTD_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    WCHAR FileName[1];
} FILE_ID_EXTD_DIR_INFO, *PFILE_ID_EXTD_DIR_INFO;

#line 8683 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"












#line 8696 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"









#line 8706 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"










#line 8717 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

typedef struct _FILE_REMOTE_PROTOCOL_INFO
{
    
    USHORT StructureVersion;     
    USHORT StructureSize;        

    ULONG  Protocol;             

    
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;

    
    ULONG  Flags;

    struct {
        ULONG Reserved[8];
    } GenericReserved;

    





#line 8747 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


    union {

        struct {

            struct {
                ULONG Capabilities;
            } Server;

            struct {
                ULONG Capabilities;
                ULONG CachingFlags;
            } Share;

        } Smb2;

        ULONG Reserved[16];

    } ProtocolSpecific;

#line 8769 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandleEx(
       HANDLE hFile,
       FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
      LPVOID lpFileInformation,
       DWORD dwBufferSize
);

#line 8783 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      ExtendedFileIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;

typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize;  
    FILE_ID_TYPE Type; 
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;

        FILE_ID_128 ExtendedFileId;
#line 8804 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
    } ;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;

__declspec(dllimport)
HANDLE
__stdcall
OpenFileById (
          HANDLE hVolumeHint,
          LPFILE_ID_DESCRIPTOR lpFileId,
          DWORD dwDesiredAccess,
          DWORD dwShareMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
          DWORD dwFlagsAndAttributes
    );

#line 8820 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 8823 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#pragma region Desktop Family or OneCore Family























__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkA (
      LPCSTR lpSymlinkFileName,
      LPCSTR lpTargetFileName,
      DWORD dwFlags
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkW (
      LPCWSTR lpSymlinkFileName,
      LPCWSTR lpTargetFileName,
      DWORD dwFlags
    );




#line 8869 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8871 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
QueryActCtxSettingsW(
           DWORD dwFlags,
           HANDLE hActCtx,
           PCWSTR settingsNameSpace,
               PCWSTR settingName,
      PWSTR pvBuffer,
           SIZE_T dwBuffer,
      SIZE_T *pdwWrittenOrRequired
    );

#line 8888 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8890 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedA (
          LPCSTR lpSymlinkFileName,
          LPCSTR lpTargetFileName,
          DWORD dwFlags,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedW (
          LPCWSTR lpSymlinkFileName,
          LPCWSTR lpTargetFileName,
          DWORD dwFlags,
          HANDLE hTransaction
    );




#line 8920 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8922 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
ReplacePartitionUnit (
      PWSTR TargetPartition,
      PWSTR SparePartition,
      ULONG Flags
    );

#line 8935 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
AddSecureMemoryCacheCallback(
       PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveSecureMemoryCacheCallback(
       PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

#line 8954 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 8956 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


 
__declspec(dllimport)
BOOL
__stdcall
CopyContext(
      PCONTEXT Destination,
      DWORD ContextFlags,
      PCONTEXT Source
    );

#line 8974 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


 
__declspec(dllimport)
BOOL
__stdcall
InitializeContext(
      PVOID Buffer,
      DWORD ContextFlags,
      PCONTEXT* Context,
      PDWORD ContextLength
    );
#line 8990 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion



#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD64
__stdcall
GetEnabledXStateFeatures(
    void
    );

 
__declspec(dllimport)
BOOL
__stdcall
GetXStateFeaturesMask(
      PCONTEXT Context,
      PDWORD64 FeatureMask
    );

 
__declspec(dllimport)
PVOID
__stdcall
LocateXStateFeature(
      PCONTEXT Context,
      DWORD FeatureId,
      PDWORD Length
    );

#line 9024 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


 
__declspec(dllimport)
BOOL
__stdcall
SetXStateFeaturesMask(
      PCONTEXT Context,
      DWORD64 FeatureMask
    );

#line 9039 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 9042 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 9044 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
EnableThreadProfiling(
      HANDLE ThreadHandle,
      DWORD Flags,
      DWORD64 HardwareCounters,
      HANDLE *PerformanceDataHandle
    );

__declspec(dllimport)
DWORD
__stdcall
DisableThreadProfiling(
      HANDLE PerformanceDataHandle
    );

__declspec(dllimport)
DWORD
__stdcall
QueryThreadProfiling(
      HANDLE ThreadHandle,
      PBOOLEAN Enabled
    );

__declspec(dllimport)
DWORD
__stdcall
ReadThreadProfilingData(
      HANDLE PerformanceDataHandle,
      DWORD Flags,
      PPERFORMANCE_DATA PerformanceData
    );

#line 9085 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#pragma endregion

#line 9088 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"






#line 9095 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9096 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"


}
#line 9100 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#pragma warning(pop)




#line 9109 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9110 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



#line 9114 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




























#pragma once
#line 9144 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"










#line 9155 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"





extern "C++" {

__forceinline
unsigned
_InterlockedIncrement(
       unsigned volatile *Addend
    )
{
    return (unsigned) _InterlockedIncrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedIncrement(
       unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedIncrement((volatile long*) Addend);
}




__forceinline
unsigned __int64
_InterlockedIncrement(
       unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) (_InterlockedIncrement64)((volatile __int64*) Addend);
}

#line 9193 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__forceinline
unsigned
_InterlockedDecrement(
       unsigned volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedDecrement(
       unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}




__forceinline
unsigned __int64
_InterlockedDecrement(
       unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) (_InterlockedDecrement64)((volatile __int64*) Addend);
}

#line 9225 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"



__forceinline
unsigned
_InterlockedExchange(
       unsigned volatile *Target,
      unsigned Value
    )
{
    return (unsigned) _InterlockedExchange((volatile long*) Target, (long) Value);
}

__forceinline
unsigned long
_InterlockedExchange(
       unsigned long volatile *Target,
      unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchange(
       unsigned __int64 volatile *Target,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchange64((volatile __int64*) Target, (__int64) Value);
}

#line 9261 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__forceinline
unsigned
_InterlockedExchangeAdd(
       unsigned volatile *Addend,
      unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned
InterlockedExchangeSubtract(
       unsigned volatile *Addend,
      unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}

__forceinline
unsigned long
_InterlockedExchangeAdd(
       unsigned long volatile *Addend,
      unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned long
InterlockedExchangeSubtract(
       unsigned long volatile *Addend,
      unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchangeAdd(
       unsigned __int64 volatile *Addend,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64((volatile __int64*) Addend,  (__int64) Value);
}

__forceinline
unsigned __int64
InterlockedExchangeSubtract(
       unsigned __int64 volatile *Addend,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64((volatile __int64*) Addend,  - (__int64) Value);
}

#line 9325 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

__forceinline
unsigned
_InterlockedCompareExchange(
       unsigned volatile *Destination,
      unsigned Exchange,
      unsigned Comperand
    )
{
    return (unsigned) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}

__forceinline
unsigned long
_InterlockedCompareExchange(
       unsigned long volatile *Destination,
      unsigned long Exchange,
      unsigned long Comperand
    )
{
    return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}



__forceinline
unsigned __int64
_InterlockedCompareExchange(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Exchange,
      unsigned __int64 Comperand
    )
{
    return (unsigned __int64) _InterlockedCompareExchange64((volatile __int64*) Destination, (__int64) Exchange, (__int64) Comperand);
}

__forceinline
unsigned __int64
_InterlockedAnd(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedAnd64((volatile __int64*) Destination, (__int64) Value);
}

__forceinline
unsigned __int64
_InterlockedOr(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedOr64((volatile __int64*) Destination, (__int64) Value);
}

__forceinline
unsigned __int64
_InterlockedXor(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedXor64((volatile __int64*) Destination, (__int64) Value);
}

#line 9392 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 9394 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

} 
#line 9397 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 9399 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"




#line 9404 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9405 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9406 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9407 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9408 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"
#line 9409 "E:\\sdk\\include\\10.0.16299.0\\um\\winbase.h"

#line 173 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"














#pragma once


#pragma warning(push)
#pragma warning(disable: 4201)      



#pragma warning(disable: 4820)      
#line 25 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"














#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"









#line 50 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


extern "C" {
#line 54 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
















































#line 103 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





#line 109 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"






#line 116 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"






























#line 147 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"













#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

















#line 179 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
















#line 196 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#line 199 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#line 202 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"














































































#line 281 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"








#pragma region Desktop Family



typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
#line 300 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 302 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 305 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





































































































#line 407 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"











#pragma region Desktop Family






typedef struct _PSINJECTDATA {

    DWORD   DataBytes;      
    WORD    InjectionPoint; 
    WORD    PageNumber;     

    

} PSINJECTDATA, *PPSINJECTDATA;

#line 436 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



































































#line 505 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family






typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;





typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

#line 535 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



















































#pragma region Application Family


typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM,  *LPXFORM;


typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP,  *NPBITMAP,  *LPBITMAP;

#line 613 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"























#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack1.h"
#line 616 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE,  *NPRGBTRIPLE,  *LPRGBTRIPLE;

#line 627 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 630 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

#line 642 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef RGBQUAD * LPRGBQUAD;

#line 650 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion


















#pragma region Application Family


typedef LONG   LCSCSTYPE;



typedef LONG    LCSGAMUTMATCH;



























typedef long            FXPT16DOT16,  *LPFXPT16DOT16;
typedef long            FXPT2DOT30,  *LPFXPT2DOT30;




typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;

#line 718 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef CIEXYZ   *LPCIEXYZ;

#line 726 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;

#line 739 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef CIEXYZTRIPLE     *LPCIEXYZTRIPLE;

#line 747 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family







typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;




typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
#line 788 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 790 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 793 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family



typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER,  *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

#line 807 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER,  *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

#line 827 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER,  *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

#line 858 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion
#line 860 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



#pragma region Desktop Family

typedef struct {
        DWORD        bV5Size;
        LONG         bV5Width;
        LONG         bV5Height;
        WORD         bV5Planes;
        WORD         bV5BitCount;
        DWORD        bV5Compression;
        DWORD        bV5SizeImage;
        LONG         bV5XPelsPerMeter;
        LONG         bV5YPelsPerMeter;
        DWORD        bV5ClrUsed;
        DWORD        bV5ClrImportant;
        DWORD        bV5RedMask;
        DWORD        bV5GreenMask;
        DWORD        bV5BlueMask;
        DWORD        bV5AlphaMask;
        DWORD        bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD        bV5GammaRed;
        DWORD        bV5GammaGreen;
        DWORD        bV5GammaBlue;
        DWORD        bV5Intent;
        DWORD        bV5ProfileData;
        DWORD        bV5ProfileSize;
        DWORD        bV5Reserved;
} BITMAPV5HEADER,  *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

#line 893 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion




#line 899 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"









#line 909 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO,  *LPBITMAPINFO, *PBITMAPINFO;

#line 919 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO,  *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#line 930 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 933 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER,  *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;

#line 946 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 949 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"






#pragma region Application Family


typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

#line 965 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO,  *NPCHARSETINFO,  *LPCHARSETINFO;

#line 978 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion






#line 986 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;

#line 998 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1001 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 1002 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



#pragma region Application Family




typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE,  *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;

#line 1023 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagMETARECORD __unaligned *PMETARECORD;

#line 1031 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagMETARECORD __unaligned  *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
  } METAFILEPICT,  *LPMETAFILEPICT;

#line 1047 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 1050 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER __unaligned *PMETAHEADER;
typedef struct tagMETAHEADER __unaligned  *LPMETAHEADER;

#line 1068 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 1071 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family



typedef struct tagENHMETARECORD
{
    DWORD   iType;              
    DWORD   nSize;              
    DWORD   dParm[1];           
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              
    DWORD   nSize;              
                                
    RECTL   rclBounds;          
    RECTL   rclFrame;           
    DWORD   dSignature;         
    DWORD   nVersion;           
    DWORD   nBytes;             
    DWORD   nRecords;           
    WORD    nHandles;           
                                
    WORD    sReserved;          
    DWORD   nDescription;       
                                
    DWORD   offDescription;     
                                
    DWORD   nPalEntries;        
    SIZEL   szlDevice;          
    SIZEL   szlMillimeters;     

    DWORD   cbPixelFormat;      
                                
    DWORD   offPixelFormat;     
                                
    DWORD   bOpenGL;            
                                
#line 1112 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

    SIZEL   szlMicrometers;     
#line 1115 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

#line 1119 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1122 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"









#pragma region Desktop Family








    typedef BYTE BCHAR;
#line 1142 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1144 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 1149 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA,  *NPTEXTMETRICA,  *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW,  *NPTEXTMETRICW,  *LPTEXTMETRICW;






typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;
#line 1210 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1212 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 1215 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 1216 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"















#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack4.h"
#line 1232 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA,  *NPNEWTEXTMETRICA,  *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW,  *NPNEWTEXTMETRICW,  *LPNEWTEXTMETRICW;






typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;
#line 1301 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1303 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 1306 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



#pragma region Desktop Family


typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;



typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
#line 1327 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1329 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion
#line 1331 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1333 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



#pragma region Desktop Family


typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY,  *NPPELARRAY,  *LPPELARRAY;

#line 1349 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family



typedef struct tagLOGBRUSH
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG_PTR   lbHatch;
  } LOGBRUSH, *PLOGBRUSH,  *NPLOGBRUSH,  *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG       lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32,  *NPLOGBRUSH32,  *LPLOGBRUSH32;

#line 1370 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN         *NPPATTERN;
typedef PATTERN          *LPPATTERN;

#line 1381 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family



typedef struct tagLOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN,  *NPLOGPEN,  *LPLOGPEN;

#line 1395 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagEXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG_PTR   elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN,  *NPEXTLOGPEN,  *LPEXTLOGPEN;

#line 1411 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagEXTLOGPEN32 {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG       elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32,  *NPEXTLOGPEN32,  *LPEXTLOGPEN32;



typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY,  *LPPALETTEENTRY;
#line 1435 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
      PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE,  *NPLOGPALETTE,  *LPLOGPALETTE;
#line 1445 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[32];
} LOGFONTA, *PLOGFONTA,  *NPLOGFONTA,  *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[32];
} LOGFONTW, *PLOGFONTW,  *NPLOGFONTW,  *LPLOGFONTW;






typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
#line 1495 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1497 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family



typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[64];
    BYTE     elfStyle[32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;

typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[64];
    WCHAR    elfStyle[32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;




typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;
#line 1525 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64];
    BYTE        elfStyle[32];
    BYTE        elfScript[32];
} ENUMLOGFONTEXA,  *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64];
    WCHAR       elfStyle[32];
    WCHAR       elfScript[32];
} ENUMLOGFONTEXW,  *LPENUMLOGFONTEXW;




typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
#line 1548 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 1549 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1551 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion





















#line 1574 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"








#line 1583 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




#line 1588 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"






#line 1595 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"








































#line 1636 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




                                    

                                    

                                    



































#pragma region Application Family


typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, * LPPANOSE;

















































































































typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64];
    BYTE        elfStyle[32];
    DWORD       elfVersion;     
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4];
    DWORD       elfCulture;     
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA,  *NPEXTLOGFONTA,  *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64];
    WCHAR       elfStyle[32];
    DWORD       elfVersion;     
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4];
    DWORD       elfCulture;     
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW,  *NPEXTLOGFONTW,  *LPEXTLOGFONTW;






typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
#line 1844 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 1846 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion
















































































#line 1928 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




#line 1933 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"







#line 1941 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


































































































                             

                             

                             





#line 2050 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"










































































#line 2125 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





































#line 2163 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




























#pragma region Application Family



typedef struct _devicemodeA {
    BYTE   dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      } ;
      
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput;
      } ;
    } ;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    } ;
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 2247 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 2248 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR  dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      } ;
      
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput;
      } ;
    } ;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    } ;
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 2301 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 2302 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;






typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
#line 2314 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"












































































































#line 2423 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 2425 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion








#line 2435 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"










#line 2446 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#line 2449 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"






















#line 2472 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#line 2475 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"













































































#line 2553 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




















































#line 2606 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"







#line 2614 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"












































#line 2659 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
















#line 2676 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

















































#line 2726 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
    CHAR   DeviceID[128];
    CHAR   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;





typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
#line 2755 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 2757 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion








#line 2767 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#line 2770 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





#line 2776 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



#line 2780 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





#line 2786 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




                                          
                                          

#pragma region Application Family


typedef struct DISPLAYCONFIG_RATIONAL
{
    UINT32    Numerator;
    UINT32    Denominator;
} DISPLAYCONFIG_RATIONAL;

typedef enum
{
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER                   = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15                    =  0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO                  =  1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO         =  2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO         =  3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI                     =  4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI                    =  5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS                    =  6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN                   =  8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI                     =  9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL    = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED    = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL            = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED            = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE              = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST                = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED          = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL                = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32            = 0xFFFFFFFF
} DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;

typedef enum
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED                 = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE                 = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED                  = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST  = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST  = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32                = 0xFFFFFFFF
} DISPLAYCONFIG_SCANLINE_ORDERING;

typedef struct DISPLAYCONFIG_2DREGION
{
    UINT32 cx;
    UINT32 cy;
} DISPLAYCONFIG_2DREGION;

typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
{
    UINT64                          pixelRate;
    DISPLAYCONFIG_RATIONAL          hSyncFreq;
    DISPLAYCONFIG_RATIONAL          vSyncFreq;
    DISPLAYCONFIG_2DREGION          activeSize;
    DISPLAYCONFIG_2DREGION          totalSize;

    union
    {
        struct
        {
            UINT32 videoStandard : 16;

            
            UINT32 vSyncFreqDivider : 6;

            UINT32 reserved : 10;
        } AdditionalSignalInfo;

        UINT32 videoStandard;
    } ;

    
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
} DISPLAYCONFIG_VIDEO_SIGNAL_INFO;

typedef enum
{
    DISPLAYCONFIG_SCALING_IDENTITY                  = 1,
    DISPLAYCONFIG_SCALING_CENTERED                  = 2,
    DISPLAYCONFIG_SCALING_STRETCHED                 = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX    = 4,
    DISPLAYCONFIG_SCALING_CUSTOM                    = 5,
    DISPLAYCONFIG_SCALING_PREFERRED                 = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32              = 0xFFFFFFFF
} DISPLAYCONFIG_SCALING;

typedef enum
{
    DISPLAYCONFIG_ROTATION_IDENTITY     = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90     = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180    = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270    = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_ROTATION;

typedef enum
{
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE        = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET        = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_MODE_INFO_TYPE;

typedef enum
{
    DISPLAYCONFIG_PIXELFORMAT_8BPP          = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP         = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP         = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP         = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI        = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32  = 0xffffffff
} DISPLAYCONFIG_PIXELFORMAT;

typedef struct DISPLAYCONFIG_SOURCE_MODE
{
    UINT32                      width;
    UINT32                      height;
    DISPLAYCONFIG_PIXELFORMAT   pixelFormat;
    POINTL                      position;
} DISPLAYCONFIG_SOURCE_MODE;

typedef struct DISPLAYCONFIG_TARGET_MODE
{
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO   targetVideoSignalInfo;
} DISPLAYCONFIG_TARGET_MODE;

typedef struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO
{
    POINTL PathSourceSize;
    RECTL DesktopImageRegion;
    RECTL DesktopImageClip;
} DISPLAYCONFIG_DESKTOP_IMAGE_INFO;

typedef struct DISPLAYCONFIG_MODE_INFO
{
    DISPLAYCONFIG_MODE_INFO_TYPE    infoType;
    UINT32                          id;
    LUID                            adapterId;
    union
    {
        DISPLAYCONFIG_TARGET_MODE   targetMode;
        DISPLAYCONFIG_SOURCE_MODE   sourceMode;
        DISPLAYCONFIG_DESKTOP_IMAGE_INFO    desktopImageInfo;
    } ;
} DISPLAYCONFIG_MODE_INFO;







typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO
{
    LUID    adapterId;
    UINT32  id;
    union
    {
        UINT32 modeInfoIdx;
        struct
        {
            UINT32 cloneGroupId       : 16;
            UINT32 sourceModeInfoIdx  : 16;
        } ;
    } ;

    UINT32  statusFlags;
} DISPLAYCONFIG_PATH_SOURCE_INFO;







typedef struct DISPLAYCONFIG_PATH_TARGET_INFO
{
    LUID                                    adapterId;
    UINT32                                  id;
    union
    {
        UINT32                                  modeInfoIdx;
        struct
        {
            UINT32 desktopModeInfoIdx : 16;
            UINT32 targetModeInfoIdx  : 16;
        } ;
    } ;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY   outputTechnology;
    DISPLAYCONFIG_ROTATION                  rotation;
    DISPLAYCONFIG_SCALING                   scaling;
    DISPLAYCONFIG_RATIONAL                  refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING         scanLineOrdering;
    BOOL                                    targetAvailable;
    UINT32                                  statusFlags;
} DISPLAYCONFIG_PATH_TARGET_INFO;











typedef struct DISPLAYCONFIG_PATH_INFO
{
    DISPLAYCONFIG_PATH_SOURCE_INFO  sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO  targetInfo;
    UINT32                          flags;
} DISPLAYCONFIG_PATH_INFO;










typedef enum DISPLAYCONFIG_TOPOLOGY_ID
{
      DISPLAYCONFIG_TOPOLOGY_INTERNAL       = 0x00000001,
      DISPLAYCONFIG_TOPOLOGY_CLONE          = 0x00000002,
      DISPLAYCONFIG_TOPOLOGY_EXTEND         = 0x00000004,
      DISPLAYCONFIG_TOPOLOGY_EXTERNAL       = 0x00000008,
      DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32   = 0xFFFFFFFF
} DISPLAYCONFIG_TOPOLOGY_ID;


typedef enum
{
      DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME                 = 1,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME                 = 2,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE       = 3,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME                = 4,
      DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE          = 5,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE            = 6,
      DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION  = 7,
      DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION  = 8,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO         = 9,
      DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE        = 10,
      DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32                = 0xFFFFFFFF
} DISPLAYCONFIG_DEVICE_INFO_TYPE;

#line 3042 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion


#pragma region Application Family


typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER
{
    DISPLAYCONFIG_DEVICE_INFO_TYPE  type;
    UINT32                          size;
    LUID                            adapterId;
    UINT32                          id;
} DISPLAYCONFIG_DEVICE_INFO_HEADER;

#line 3057 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER            header;
    WCHAR                                       viewGdiDeviceName[32];
} DISPLAYCONFIG_SOURCE_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
{
    union
    {
        struct
        {
            UINT32  friendlyNameFromEdid : 1;
            UINT32  friendlyNameForced : 1;
            UINT32  edidIdsValid : 1;
            UINT32  reserved : 29;
        } ;
        UINT32  value;
    } ;
} DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER            header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS      flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY       outputTechnology;
    UINT16                                      edidManufactureId;
    UINT16                                      edidProductCodeId;
    UINT32                                      connectorInstance;
    WCHAR                                       monitorFriendlyDeviceName[64];
    WCHAR                                       monitorDevicePath[128];
} DISPLAYCONFIG_TARGET_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    UINT32                              width;
    UINT32                              height;
    DISPLAYCONFIG_TARGET_MODE           targetMode;
} DISPLAYCONFIG_TARGET_PREFERRED_MODE;

typedef struct DISPLAYCONFIG_ADAPTER_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    WCHAR                               adapterDevicePath[128];
} DISPLAYCONFIG_ADAPTER_NAME;

typedef struct DISPLAYCONFIG_TARGET_BASE_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER      header;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
} DISPLAYCONFIG_TARGET_BASE_TYPE;

typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    union
    {
        struct
        {
            UINT32 bootPersistenceOn    : 1;
            UINT32 reserved             : 31;
        } ;
        UINT32 value;
    } ;
} DISPLAYCONFIG_SET_TARGET_PERSISTENCE;

typedef struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    union
    {
        struct
        {
            UINT32 disableMonitorVirtualResolution  : 1;
            UINT32 reserved                         : 31;
        } ;
        UINT32 value;
    } ;
} DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION;

typedef enum _DISPLAYCONFIG_COLOR_ENCODING
{
    DISPLAYCONFIG_COLOR_ENCODING_RGB           = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444      = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422      = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420      = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY     = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32  = 0xFFFFFFFF
} DISPLAYCONFIG_COLOR_ENCODING;

typedef struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union
    {
        struct
        {
          UINT32 advancedColorSupported  :1;
          UINT32 advancedColorEnabled    :1;
          UINT32 wideColorEnforced       :1;
          UINT32 reserved  :29;
        } ;

        UINT32 value;
    } ;

    DISPLAYCONFIG_COLOR_ENCODING colorEncoding;
    UINT32 bitsPerColorChannel;
} DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;

typedef struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union
    {
        struct
        {
          UINT32 enableAdvancedColor  :1;
          UINT32 reserved  :31;
        } ;

        UINT32 value;
    };
} DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;

#line 3188 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



































#line 3225 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





#pragma region Application Family


typedef struct _RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA,  *NPRGNDATA,  *LPRGNDATA;

#line 3247 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion






#pragma region Desktop Family


typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC,  *NPABC,  *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT,  *NPABCFLOAT,  *LPABCFLOAT;

#line 3270 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion







#pragma region Desktop Family


typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA,  *NPOUTLINETEXTMETRICA,  *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW,  *NPOUTLINETEXTMETRICW,  *LPOUTLINETEXTMETRICW;






typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
#line 3360 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 3362 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion





#line 3369 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA,  *NPPOLYTEXTA,  *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW,  *NPPOLYTEXTW,  *LPPOLYTEXTW;






typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
#line 3404 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 3406 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _FIXED {

    WORD    fract;
    short   value;



#line 3419 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2,  *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS,  *LPGLYPHMETRICS;

#line 3440 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion













#line 3455 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



#line 3459 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"







#pragma region Desktop Family


typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;

#line 3490 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion













































#pragma region Desktop Family


typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;




typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
#line 3570 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 3572 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion
#line 3574 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct _RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS,  *LPRASTERIZER_STATUS;

#line 3585 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion





#pragma region Application Family



typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR,  *LPPIXELFORMATDESCRIPTOR;

#line 3626 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion


































#pragma region Desktop Family





typedef int (__stdcall* OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (__stdcall* OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);




#line 3674 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"








#line 3683 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

typedef OLDFONTENUMPROCA    FONTENUMPROCA;
typedef OLDFONTENUMPROCW    FONTENUMPROCW;



typedef FONTENUMPROCA FONTENUMPROC;
#line 3691 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

typedef int (__stdcall* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (__stdcall* LINEDDAPROC)(int, int, LPARAM);











#line 3706 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 3708 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport) int __stdcall AddFontResourceA(  LPCSTR);
__declspec(dllimport) int __stdcall AddFontResourceW(  LPCWSTR);




#line 3722 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

 __declspec(dllimport) BOOL  __stdcall AnimatePalette(   HPALETTE hPal,   UINT iStartIndex,    UINT cEntries,   const PALETTEENTRY * ppe);
 __declspec(dllimport) BOOL  __stdcall Arc(   HDC hdc,   int x1,   int y1,   int x2,   int y2,   int x3,   int y3,   int x4,   int y4);
 __declspec(dllimport) BOOL  __stdcall BitBlt(   HDC hdc,   int x,   int y,   int cx,   int cy,   HDC hdcSrc,   int x1,   int y1,   DWORD rop);
__declspec(dllimport) BOOL  __stdcall CancelDC(   HDC hdc);
 __declspec(dllimport) BOOL  __stdcall Chord(   HDC hdc,   int x1,   int y1,   int x2,   int y2,   int x3,   int y3,   int x4,   int y4);
__declspec(dllimport) int   __stdcall ChoosePixelFormat(   HDC hdc,   const PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) HMETAFILE  __stdcall CloseMetaFile(   HDC hdc);
__declspec(dllimport) int     __stdcall CombineRgn(   HRGN hrgnDst,   HRGN hrgnSrc1,   HRGN hrgnSrc2,   int iMode);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA(   HMETAFILE,   LPCSTR);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW(   HMETAFILE,   LPCWSTR);




#line 3738 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
 __declspec(dllimport) HBITMAP __stdcall CreateBitmap(   int nWidth,   int nHeight,   UINT nPlanes,   UINT nBitCount,   const void *lpBits);
 __declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect(   const BITMAP *pbm);
 __declspec(dllimport) HBRUSH  __stdcall CreateBrushIndirect(   const LOGBRUSH *plbrush);
__declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap(   HDC hdc,   int cx,   int cy);
__declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap(   HDC hdc,   int cx,   int cy);
__declspec(dllimport) HDC     __stdcall CreateCompatibleDC(   HDC hdc);
__declspec(dllimport) HDC     __stdcall CreateDCA(   LPCSTR pwszDriver,   LPCSTR pwszDevice,   LPCSTR pszPort,   const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateDCW(   LPCWSTR pwszDriver,   LPCWSTR pwszDevice,   LPCWSTR pszPort,   const DEVMODEW * pdm);




#line 3751 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HBITMAP __stdcall CreateDIBitmap(   HDC hdc,   const BITMAPINFOHEADER *pbmih,   DWORD flInit,   const void *pjBits,   const BITMAPINFO *pbmi,   UINT iUsage);
__declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrush(   HGLOBAL h,   UINT iUsage);
 __declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrushPt(   const void *lpPackedDIB,   UINT iUsage);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgn(   int x1,   int y1,   int x2,   int y2);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgnIndirect(   const RECT *lprect);
 __declspec(dllimport) HFONT   __stdcall CreateFontIndirectA(   const LOGFONTA *lplf);
 __declspec(dllimport) HFONT   __stdcall CreateFontIndirectW(   const LOGFONTW *lplf);




#line 3763 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HFONT   __stdcall CreateFontA(   int cHeight,   int cWidth,   int cEscapement,   int cOrientation,   int cWeight,   DWORD bItalic,
                               DWORD bUnderline,   DWORD bStrikeOut,   DWORD iCharSet,   DWORD iOutPrecision,   DWORD iClipPrecision,
                               DWORD iQuality,   DWORD iPitchAndFamily,   LPCSTR pszFaceName);
__declspec(dllimport) HFONT   __stdcall CreateFontW(   int cHeight,   int cWidth,   int cEscapement,   int cOrientation,   int cWeight,   DWORD bItalic,
                               DWORD bUnderline,   DWORD bStrikeOut,   DWORD iCharSet,   DWORD iOutPrecision,   DWORD iClipPrecision,
                               DWORD iQuality,   DWORD iPitchAndFamily,   LPCWSTR pszFaceName);




#line 3774 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) HBRUSH  __stdcall CreateHatchBrush(   int iHatch,   COLORREF color);
__declspec(dllimport) HDC     __stdcall CreateICA(   LPCSTR pszDriver,   LPCSTR pszDevice,   LPCSTR pszPort,   const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateICW(   LPCWSTR pszDriver,   LPCWSTR pszDevice,   LPCWSTR pszPort,   const DEVMODEW * pdm);




#line 3783 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HDC     __stdcall CreateMetaFileA(   LPCSTR pszFile);
__declspec(dllimport) HDC     __stdcall CreateMetaFileW(   LPCWSTR pszFile);




#line 3790 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
 __declspec(dllimport) HPALETTE __stdcall CreatePalette(   const LOGPALETTE * plpal);
__declspec(dllimport) HPEN    __stdcall CreatePen(   int iStyle,   int cWidth,   COLORREF color);
 __declspec(dllimport) HPEN    __stdcall CreatePenIndirect(   const LOGPEN *plpen);
__declspec(dllimport) HRGN    __stdcall CreatePolyPolygonRgn(    const POINT *pptl,
                                                  const INT  *pc,
                                                  int cPoly,
                                                  int iMode);
 __declspec(dllimport) HBRUSH  __stdcall CreatePatternBrush(   HBITMAP hbm);
__declspec(dllimport) HRGN    __stdcall CreateRectRgn(   int x1,   int y1,   int x2,   int y2);
__declspec(dllimport) HRGN    __stdcall CreateRectRgnIndirect(   const RECT *lprect);
__declspec(dllimport) HRGN    __stdcall CreateRoundRectRgn(   int x1,   int y1,   int x2,   int y2,   int w,   int h);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceA(   DWORD fdwHidden,   LPCSTR lpszFont,   LPCSTR lpszFile,   LPCSTR lpszPath);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceW(   DWORD fdwHidden,   LPCWSTR lpszFont,   LPCWSTR lpszFile,   LPCWSTR lpszPath);




#line 3808 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HBRUSH  __stdcall CreateSolidBrush(   COLORREF color);

__declspec(dllimport) BOOL __stdcall DeleteDC(   HDC hdc);
__declspec(dllimport) BOOL __stdcall DeleteMetaFile(   HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall DeleteObject(   HGDIOBJ ho);
__declspec(dllimport) int  __stdcall DescribePixelFormat(    HDC hdc,
                                              int iPixelFormat,
                                              UINT nBytes,
                                              LPPIXELFORMATDESCRIPTOR ppfd);





typedef UINT   (__stdcall* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (__stdcall* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

#line 3827 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion






































#line 3867 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


















#line 3886 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 3887 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

















#line 3905 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesA(
                     LPCSTR         pDevice,
                 LPCSTR         pPort,
                     WORD             fwCapability,
      LPSTR          pOutput,
                 const DEVMODEA   *pDevMode
    );
__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesW(
                     LPCWSTR         pDevice,
                 LPCWSTR         pPort,
                     WORD             fwCapability,
      LPWSTR          pOutput,
                 const DEVMODEW   *pDevMode
    );




#line 3934 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) int  __stdcall DrawEscape(     HDC    hdc,
                                      int    iEscape,
                                      int    cjIn,
                                      LPCSTR lpIn);

 __declspec(dllimport) BOOL __stdcall Ellipse(   HDC hdc,   int left,   int top,    int right,   int bottom);


__declspec(dllimport) int  __stdcall EnumFontFamiliesExA(   HDC hdc,   LPLOGFONTA lpLogfont,   FONTENUMPROCA lpProc,   LPARAM lParam,   DWORD dwFlags);
__declspec(dllimport) int  __stdcall EnumFontFamiliesExW(   HDC hdc,   LPLOGFONTW lpLogfont,   FONTENUMPROCW lpProc,   LPARAM lParam,   DWORD dwFlags);




#line 3950 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 3951 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) int  __stdcall EnumFontFamiliesA(   HDC hdc,   LPCSTR lpLogfont,   FONTENUMPROCA lpProc,   LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontFamiliesW(   HDC hdc,   LPCWSTR lpLogfont,   FONTENUMPROCW lpProc,   LPARAM lParam);




#line 3959 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) int  __stdcall EnumFontsA(   HDC hdc,   LPCSTR lpLogfont,    FONTENUMPROCA lpProc,   LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontsW(   HDC hdc,   LPCWSTR lpLogfont,    FONTENUMPROCW lpProc,   LPARAM lParam);




#line 3966 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


__declspec(dllimport) int  __stdcall EnumObjects(   HDC hdc,   int nType,   GOBJENUMPROC lpFunc,   LPARAM lParam);


#line 3972 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


__declspec(dllimport) BOOL __stdcall EqualRgn(   HRGN hrgn1,   HRGN hrgn2);
 __declspec(dllimport) int  __stdcall Escape(     HDC hdc,
                                  int iEscape,
                                  int cjIn,
                                  LPCSTR pvIn,
                                  LPVOID pvOut);
__declspec(dllimport) int  __stdcall ExtEscape(      HDC hdc,
                                      int iEscape,
                                      int cjInput,
                                      LPCSTR lpInData,
                                      int cjOutput,
                                      LPSTR lpOutData);
 __declspec(dllimport) int  __stdcall ExcludeClipRect(   HDC hdc,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) HRGN __stdcall ExtCreateRegion(   const XFORM * lpx,   DWORD nCount,   const RGNDATA * lpData);
 __declspec(dllimport) BOOL __stdcall ExtFloodFill(   HDC hdc,   int x,   int y,   COLORREF color,   UINT type);
 __declspec(dllimport) BOOL __stdcall FillRgn(   HDC hdc,   HRGN hrgn,   HBRUSH hbr);
 __declspec(dllimport) BOOL __stdcall FloodFill(   HDC hdc,   int x,   int y,   COLORREF color);
 __declspec(dllimport) BOOL __stdcall FrameRgn(   HDC hdc,   HRGN hrgn,   HBRUSH hbr,   int w,   int h);
__declspec(dllimport) int  __stdcall GetROP2(   HDC hdc);
__declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx(   HDC hdc,   LPSIZE lpsize);
__declspec(dllimport) COLORREF __stdcall GetBkColor(   HDC hdc);


__declspec(dllimport) COLORREF __stdcall GetDCBrushColor(   HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCPenColor(   HDC hdc);
#line 4000 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport)
int
__stdcall
GetBkMode(
      HDC hdc
    );

__declspec(dllimport)
LONG
__stdcall
GetBitmapBits(
      HBITMAP hbit,
      LONG cb,
      LPVOID lpvBits
    );

__declspec(dllimport) BOOL  __stdcall GetBitmapDimensionEx(   HBITMAP hbit,   LPSIZE lpsize);
__declspec(dllimport) UINT  __stdcall GetBoundsRect(   HDC hdc,   LPRECT lprect,   UINT flags);

__declspec(dllimport) BOOL  __stdcall GetBrushOrgEx(   HDC hdc,   LPPOINT lppt);

__declspec(dllimport) BOOL  __stdcall GetCharWidthA(   HDC hdc,   UINT iFirst,   UINT iLast,   LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthW(   HDC hdc,   UINT iFirst,   UINT iLast,   LPINT lpBuffer);




#line 4029 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidth32A(   HDC hdc,   UINT iFirst,   UINT iLast,    LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidth32W(   HDC hdc,   UINT iFirst,   UINT iLast,    LPINT lpBuffer);




#line 4036 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatA(   HDC hdc,   UINT iFirst,   UINT iLast,   PFLOAT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatW(   HDC hdc,   UINT iFirst,   UINT iLast,   PFLOAT lpBuffer);




#line 4043 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsA(   HDC hdc,
                                              UINT wFirst,
                                              UINT wLast,
                                              LPABC lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsW(   HDC hdc,
                                              UINT wFirst,
                                              UINT wLast,
                                              LPABC lpABC);




#line 4057 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatA(   HDC hdc,   UINT iFirst,   UINT iLast,   LPABCFLOAT lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatW(   HDC hdc,   UINT iFirst,   UINT iLast,   LPABCFLOAT lpABC);




#line 4065 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) int   __stdcall GetClipBox(   HDC hdc,    LPRECT lprect);
__declspec(dllimport) int   __stdcall GetClipRgn(   HDC hdc,   HRGN hrgn);
__declspec(dllimport) int   __stdcall GetMetaRgn(   HDC hdc,   HRGN hrgn);
__declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject(   HDC hdc,   UINT type);
__declspec(dllimport) BOOL  __stdcall GetCurrentPositionEx(   HDC hdc,    LPPOINT lppt);
__declspec(dllimport) int   __stdcall GetDeviceCaps(   HDC hdc,   int index);
__declspec(dllimport) int   __stdcall GetDIBits(   HDC hdc,   HBITMAP hbm,   UINT start,   UINT cLines,
      LPVOID lpvBits,  LPBITMAPINFO lpbmi,   UINT usage);  

 
__declspec(dllimport) DWORD __stdcall GetFontData (      HDC     hdc,
                                          DWORD   dwTable,
                                          DWORD   dwOffset,
                                          PVOID pvBuffer,
                                          DWORD   cjBuffer
                                        );

__declspec(dllimport) DWORD __stdcall GetGlyphOutlineA(      HDC hdc,
                                              UINT uChar,
                                              UINT fuFormat,
                                              LPGLYPHMETRICS lpgm,
                                              DWORD cjBuffer,
                                              LPVOID pvBuffer,
                                              const MAT2 *lpmat2
                                        );
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineW(      HDC hdc,
                                              UINT uChar,
                                              UINT fuFormat,
                                              LPGLYPHMETRICS lpgm,
                                              DWORD cjBuffer,
                                              LPVOID pvBuffer,
                                              const MAT2 *lpmat2
                                        );




#line 4103 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) int   __stdcall GetGraphicsMode(   HDC hdc);
__declspec(dllimport) int   __stdcall GetMapMode(   HDC hdc);
__declspec(dllimport) UINT  __stdcall GetMetaFileBitsEx(  HMETAFILE hMF,   UINT cbBuffer,   LPVOID lpData);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileA(   LPCSTR lpName);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileW(   LPCWSTR lpName);




#line 4114 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) COLORREF __stdcall GetNearestColor(   HDC hdc,   COLORREF color);
__declspec(dllimport) UINT  __stdcall GetNearestPaletteIndex(   HPALETTE h,   COLORREF color);
__declspec(dllimport) DWORD __stdcall GetObjectType(   HGDIOBJ h);



__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA(   HDC hdc,
                                                  UINT cjCopy,
                                                  LPOUTLINETEXTMETRICA potm);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW(   HDC hdc,
                                                  UINT cjCopy,
                                                  LPOUTLINETEXTMETRICW potm);




#line 4131 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 4133 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

 
__declspec(dllimport) UINT  __stdcall GetPaletteEntries(     HPALETTE hpal,
                                              UINT iStart,
                                              UINT cEntries,
                                              LPPALETTEENTRY pPalEntries);
__declspec(dllimport) COLORREF __stdcall GetPixel(   HDC hdc,   int x,   int y);
__declspec(dllimport) int   __stdcall GetPixelFormat(   HDC hdc);
__declspec(dllimport) int   __stdcall GetPolyFillMode(   HDC hdc);
__declspec(dllimport) BOOL  __stdcall GetRasterizerCaps(     LPRASTERIZER_STATUS lpraststat,
                                              UINT cjBytes);

__declspec(dllimport) int   __stdcall GetRandomRgn (  HDC hdc,   HRGN hrgn,   INT i);
__declspec(dllimport) DWORD __stdcall GetRegionData(     HRGN hrgn,
                                          DWORD nCount,
                                          LPRGNDATA lpRgnData);
__declspec(dllimport) int   __stdcall GetRgnBox(   HRGN hrgn,    LPRECT lprc);
__declspec(dllimport) HGDIOBJ __stdcall GetStockObject(   int i);
__declspec(dllimport) int   __stdcall GetStretchBltMode(  HDC hdc);
__declspec(dllimport)
UINT
__stdcall
GetSystemPaletteEntries(
      HDC  hdc,
      UINT iStart,
      UINT cEntries,
      LPPALETTEENTRY pPalEntries
    );

__declspec(dllimport) UINT  __stdcall GetSystemPaletteUse(  HDC hdc);
__declspec(dllimport) int   __stdcall GetTextCharacterExtra(  HDC hdc);
__declspec(dllimport) UINT  __stdcall GetTextAlign(  HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetTextColor(  HDC hdc);

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointA(
      HDC hdc,
      LPCSTR lpString,
      int c,
      LPSIZE lpsz
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointW(
      HDC hdc,
      LPCWSTR lpString,
      int c,
      LPSIZE lpsz
    );




#line 4190 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32A(
      HDC hdc,
      LPCSTR lpString,
      int c,
      LPSIZE psizl
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32W(
      HDC hdc,
      LPCWSTR lpString,
      int c,
      LPSIZE psizl
    );




#line 4214 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointA(
      HDC hdc,
      LPCSTR lpszString,
      int cchString,
      int nMaxExtent,
      LPINT lpnFit,
      LPINT lpnDx,
      LPSIZE lpSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointW(
      HDC hdc,
      LPCWSTR lpszString,
      int cchString,
      int nMaxExtent,
      LPINT lpnFit,
      LPINT lpnDx,
      LPSIZE lpSize
    );




#line 4244 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


__declspec(dllimport) int __stdcall GetTextCharset(   HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharsetInfo(   HDC hdc,   LPFONTSIGNATURE lpSig,   DWORD dwFlags);
__declspec(dllimport) BOOL __stdcall TranslateCharsetInfo(   DWORD  *lpSrc,    LPCHARSETINFO lpCs,   DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetFontLanguageInfo(   HDC hdc);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementA(    HDC hdc,   LPCSTR lpString,   int nCount,   int nMexExtent,   LPGCP_RESULTSA lpResults,   DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementW(    HDC hdc,   LPCWSTR lpString,   int nCount,   int nMexExtent,   LPGCP_RESULTSW lpResults,   DWORD dwFlags);




#line 4257 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 4258 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 4260 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagWCRANGE
{
    WCHAR  wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD    cbThis;
    DWORD    flAccel;
    DWORD    cGlyphsSupported;
    DWORD    cRanges;
    WCRANGE  ranges[1];
} GLYPHSET, *PGLYPHSET,  *LPGLYPHSET;









__declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges(   HDC hdc,   LPGLYPHSET lpgs);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesA(   HDC hdc,   LPCSTR lpstr,   int c,   LPWORD pgi,   DWORD fl);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesW(   HDC hdc,   LPCWSTR lpstr,   int c,   LPWORD pgi,   DWORD fl);




#line 4299 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetTextExtentPointI(  HDC hdc,   LPWORD pgiIn,   int cgi,   LPSIZE psize);
__declspec(dllimport) BOOL  __stdcall GetTextExtentExPointI (    HDC hdc,
                                                  LPWORD lpwszString,
                                                  int cwchString,
                                                  int nMaxExtent,
                                                  LPINT lpnFit,
                                                  LPINT lpnDx,
                                                  LPSIZE lpSize
                                                );

__declspec(dllimport) BOOL  __stdcall GetCharWidthI(     HDC hdc,
                                          UINT giFirst,
                                          UINT cgi,
                                          LPWORD pgi,
                                          LPINT piWidths
                                        );

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsI(     HDC    hdc,
                                              UINT   giFirst,
                                              UINT   cgi,
                                              LPWORD pgi,
                                              LPABC  pabc
                                        );









typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR,  *LPDESIGNVECTOR;

__declspec(dllimport) int  __stdcall AddFontResourceExA(   LPCSTR name,   DWORD fl,   PVOID res);
__declspec(dllimport) int  __stdcall AddFontResourceExW(   LPCWSTR name,   DWORD fl,   PVOID res);




#line 4345 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExA(   LPCSTR name,   DWORD fl,   PVOID pdv);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExW(   LPCWSTR name,   DWORD fl,   PVOID pdv);




#line 4352 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx(     PVOID pFileView,
                                                  DWORD cjSize,
                                                  PVOID pvResrved,
                                                  DWORD* pNumFonts);

__declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx(   HANDLE h);









typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[16];
} AXISINFOA, *PAXISINFOA,  *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[16];
} AXISINFOW, *PAXISINFOW,  *LPAXISINFOW;





typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;
#line 4388 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA,  *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW,  *LPAXESLISTW;





typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;
#line 4410 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA,  *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW,  *LPENUMLOGFONTEXDVW;





typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;
#line 4434 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExA(   const ENUMLOGFONTEXDVA *);
__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExW(   const ENUMLOGFONTEXDVW *);




#line 4442 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA,  *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW,  *LPENUMTEXTMETRICW;





typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
#line 4463 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#line 4464 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 4466 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 4469 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family


__declspec(dllimport) BOOL  __stdcall GetViewportExtEx(   HDC hdc,   LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetViewportOrgEx(   HDC hdc,   LPPOINT lppoint);
__declspec(dllimport) BOOL  __stdcall GetWindowExtEx(   HDC hdc,   LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetWindowOrgEx(   HDC hdc,   LPPOINT lppoint);

 __declspec(dllimport) int  __stdcall IntersectClipRect(   HDC hdc,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) BOOL __stdcall InvertRgn(   HDC hdc,   HRGN hrgn);
__declspec(dllimport) BOOL __stdcall LineDDA(   int xStart,   int yStart,   int xEnd,   int yEnd,   LINEDDAPROC lpProc,   LPARAM data);
 __declspec(dllimport) BOOL __stdcall LineTo(   HDC hdc,   int x,   int y);
__declspec(dllimport) BOOL __stdcall MaskBlt(   HDC hdcDest,   int xDest,   int yDest,   int width,   int height,
                HDC hdcSrc,   int xSrc,   int ySrc,   HBITMAP hbmMask,   int xMask,   int yMask,   DWORD rop);
__declspec(dllimport) BOOL __stdcall PlgBlt(   HDC hdcDest,   const POINT * lpPoint,   HDC hdcSrc,   int xSrc,   int ySrc,   int width,
                       int height,   HBITMAP hbmMask,   int xMask,   int yMask);

 __declspec(dllimport) int  __stdcall OffsetClipRgn(  HDC hdc,   int x,   int y);
__declspec(dllimport) int  __stdcall OffsetRgn(  HRGN hrgn,   int x,   int y);
 __declspec(dllimport) BOOL __stdcall PatBlt(  HDC hdc,   int x,   int y,   int w,   int h,   DWORD rop);
 __declspec(dllimport) BOOL __stdcall Pie(  HDC hdc,   int left,   int top,   int right,   int bottom,   int xr1,   int yr1,   int xr2,   int yr2);
__declspec(dllimport) BOOL __stdcall PlayMetaFile(  HDC hdc,   HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall PaintRgn(  HDC hdc,   HRGN hrgn);
 __declspec(dllimport) BOOL __stdcall PolyPolygon(  HDC hdc,    const POINT *apt,    const INT *asz,    int csz);
__declspec(dllimport) BOOL __stdcall PtInRegion(  HRGN hrgn,   int x,   int y);
__declspec(dllimport) BOOL __stdcall PtVisible(  HDC hdc,   int x,   int y);
__declspec(dllimport) BOOL __stdcall RectInRegion(  HRGN hrgn,   const RECT * lprect);
__declspec(dllimport) BOOL __stdcall RectVisible(  HDC hdc,   const RECT * lprect);
 __declspec(dllimport) BOOL __stdcall Rectangle(  HDC hdc,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) BOOL __stdcall RestoreDC(  HDC hdc,   int nSavedDC);
 __declspec(dllimport) HDC  __stdcall ResetDCA(  HDC hdc,   const DEVMODEA * lpdm);
 __declspec(dllimport) HDC  __stdcall ResetDCW(  HDC hdc,   const DEVMODEW * lpdm);




#line 4507 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
 __declspec(dllimport) UINT __stdcall RealizePalette(  HDC hdc);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceA(  LPCSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceW(  LPCWSTR lpFileName);




#line 4515 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
 __declspec(dllimport) BOOL  __stdcall RoundRect(  HDC hdc,   int left,   int top,   int right,   int bottom,   int width,   int height);
 __declspec(dllimport) BOOL __stdcall ResizePalette(  HPALETTE hpal,   UINT n);

 __declspec(dllimport) int  __stdcall SaveDC(  HDC hdc);
 __declspec(dllimport) int  __stdcall SelectClipRgn(  HDC hdc,   HRGN hrgn);
__declspec(dllimport) int  __stdcall ExtSelectClipRgn(  HDC hdc,   HRGN hrgn,   int mode);
__declspec(dllimport) int  __stdcall SetMetaRgn(  HDC hdc);
 __declspec(dllimport) HGDIOBJ __stdcall SelectObject(  HDC hdc,   HGDIOBJ h);
 __declspec(dllimport) HPALETTE __stdcall SelectPalette(  HDC hdc,   HPALETTE hPal,   BOOL bForceBkgd);
 __declspec(dllimport) COLORREF __stdcall SetBkColor(  HDC hdc,   COLORREF color);


__declspec(dllimport) COLORREF __stdcall SetDCBrushColor(  HDC hdc,   COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCPenColor(  HDC hdc,   COLORREF color);
#line 4530 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

 __declspec(dllimport) int   __stdcall SetBkMode(  HDC hdc,   int mode);

__declspec(dllimport)
LONG __stdcall
SetBitmapBits(
      HBITMAP hbm,
      DWORD cb,
      const void *pvBits);

__declspec(dllimport) UINT  __stdcall SetBoundsRect(  HDC hdc,   const RECT * lprect,   UINT flags);
__declspec(dllimport) int   __stdcall SetDIBits(  HDC hdc,   HBITMAP hbm,   UINT start,   UINT cLines,   const void *lpBits,   const BITMAPINFO * lpbmi,   UINT ColorUse);
 __declspec(dllimport) int   __stdcall SetDIBitsToDevice(  HDC hdc,   int xDest,   int yDest,   DWORD w,   DWORD h,   int xSrc,
          int ySrc,   UINT StartScan,   UINT cLines,   const void * lpvBits,   const BITMAPINFO * lpbmi,   UINT ColorUse);
 __declspec(dllimport) DWORD __stdcall SetMapperFlags(  HDC hdc,   DWORD flags);
__declspec(dllimport) int   __stdcall SetGraphicsMode(  HDC hdc,   int iMode);
 __declspec(dllimport) int   __stdcall SetMapMode(  HDC hdc,   int iMode);


 __declspec(dllimport) DWORD __stdcall SetLayout(  HDC hdc,   DWORD l);
__declspec(dllimport) DWORD __stdcall GetLayout(  HDC hdc);
#line 4552 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) HMETAFILE   __stdcall SetMetaFileBitsEx(  UINT cbBuffer,   const BYTE *lpData);
 __declspec(dllimport) UINT  __stdcall SetPaletteEntries(     HPALETTE hpal,
                                              UINT iStart,
                                              UINT cEntries,
                                              const PALETTEENTRY *pPalEntries);
 __declspec(dllimport) COLORREF __stdcall SetPixel(  HDC hdc,   int x,   int y,   COLORREF color);
__declspec(dllimport) BOOL   __stdcall SetPixelV(  HDC hdc,   int x,   int y,   COLORREF color);
__declspec(dllimport) BOOL  __stdcall SetPixelFormat(  HDC hdc,   int format,   const PIXELFORMATDESCRIPTOR * ppfd);
 __declspec(dllimport) int   __stdcall SetPolyFillMode(  HDC hdc,   int mode);
 __declspec(dllimport) BOOL  __stdcall StretchBlt(  HDC hdcDest,   int xDest,   int yDest,   int wDest,   int hDest,   HDC hdcSrc,   int xSrc,   int ySrc,   int wSrc,   int hSrc,   DWORD rop);
__declspec(dllimport) BOOL   __stdcall SetRectRgn(  HRGN hrgn,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) int   __stdcall StretchDIBits(  HDC hdc,   int xDest,   int yDest,   int DestWidth,   int DestHeight,   int xSrc,   int ySrc,   int SrcWidth,   int SrcHeight,
          const void * lpBits,   const BITMAPINFO * lpbmi,   UINT iUsage,   DWORD rop);
 __declspec(dllimport) int   __stdcall SetROP2(  HDC hdc,   int rop2);
 __declspec(dllimport) int   __stdcall SetStretchBltMode(  HDC hdc,   int mode);
__declspec(dllimport) UINT  __stdcall SetSystemPaletteUse(  HDC hdc,   UINT use);
 __declspec(dllimport) int   __stdcall SetTextCharacterExtra(  HDC hdc,   int extra);
 __declspec(dllimport) COLORREF __stdcall SetTextColor(  HDC hdc,   COLORREF color);
 __declspec(dllimport) UINT  __stdcall SetTextAlign(  HDC hdc,   UINT align);
 __declspec(dllimport) BOOL  __stdcall SetTextJustification(  HDC hdc,   int extra,   int count);
__declspec(dllimport) BOOL  __stdcall UpdateColors(  HDC hdc);

#line 4576 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion












































#pragma region Application Family


typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG    x;
    LONG    y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;

#line 4637 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;

#line 4656 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct _BLENDFUNCTION
{
    BYTE   BlendOp;
    BYTE   BlendFlags;
    BYTE   SourceConstantAlpha;
    BYTE   AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;

#line 4670 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family















__declspec(dllimport) BOOL __stdcall AlphaBlend(
      HDC hdcDest,
      int xoriginDest,
      int yoriginDest,
      int wDest,
      int hDest,
      HDC hdcSrc,
      int xoriginSrc,
      int yoriginSrc,
      int wSrc,
      int hSrc,
      BLENDFUNCTION ftn);

__declspec(dllimport) BOOL __stdcall TransparentBlt(
      HDC hdcDest,
      int xoriginDest,
      int yoriginDest,
      int wDest,
      int hDest,
      HDC hdcSrc,
      int xoriginSrc,
      int yoriginSrc,
      int wSrc,
      int hSrc,
      UINT crTransparent);











__declspec(dllimport)
BOOL
__stdcall
GradientFill(
      HDC hdc,
      PTRIVERTEX pVertex,
      ULONG nVertex,
      PVOID pMesh,
      ULONG nMesh,
      ULONG ulMode
    );

#line 4737 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 4740 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family





__declspec(dllimport) BOOL  __stdcall GdiAlphaBlend(  HDC hdcDest,   int xoriginDest,   int yoriginDest,   int wDest,   int hDest,   HDC hdcSrc,   int xoriginSrc,   int yoriginSrc,   int wSrc,   int hSrc,   BLENDFUNCTION ftn);

__declspec(dllimport) BOOL  __stdcall GdiTransparentBlt(  HDC hdcDest,  int xoriginDest,   int yoriginDest,   int wDest,   int hDest,   HDC hdcSrc,
                                             int xoriginSrc,   int yoriginSrc,   int wSrc,   int hSrc,   UINT crTransparent);

__declspec(dllimport) BOOL  __stdcall GdiGradientFill(   HDC hdc,
                                          PTRIVERTEX pVertex,
                                          ULONG nVertex,
                                          PVOID pMesh,
                                          ULONG nCount,
                                          ULONG ulMode);

#line 4760 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





__declspec(dllimport) BOOL  __stdcall PlayMetaFileRecord(    HDC hdc,
                                              LPHANDLETABLE lpHandleTable,
                                              LPMETARECORD lpMR,
                                              UINT noObjs);

typedef int (__stdcall* MFENUMPROC)(   HDC hdc,   HANDLETABLE * lpht,   METARECORD * lpMR,   int nObj,   LPARAM param);
__declspec(dllimport) BOOL  __stdcall EnumMetaFile(   HDC hdc,   HMETAFILE hmf,   MFENUMPROC proc,   LPARAM param);

typedef int (__stdcall* ENHMFENUMPROC)(  HDC hdc,   HANDLETABLE * lpht,   const ENHMETARECORD * lpmr,   int nHandles,   LPARAM data);



__declspec(dllimport) HENHMETAFILE __stdcall CloseEnhMetaFile(   HDC hdc);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileA(   HENHMETAFILE hEnh,   LPCSTR lpFileName);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileW(   HENHMETAFILE hEnh,   LPCWSTR lpFileName);




#line 4785 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileA(   HDC hdc,   LPCSTR lpFilename,   const RECT *lprc,   LPCSTR lpDesc);
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileW(   HDC hdc,   LPCWSTR lpFilename,   const RECT *lprc,   LPCWSTR lpDesc);




#line 4792 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall DeleteEnhMetaFile(   HENHMETAFILE hmf);
__declspec(dllimport) BOOL  __stdcall EnumEnhMetaFile(   HDC hdc,   HENHMETAFILE hmf,   ENHMFENUMPROC proc,
                                          LPVOID param,   const RECT * lpRect);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileA(   LPCSTR lpName);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileW(   LPCWSTR lpName);




#line 4802 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileBits(    HENHMETAFILE hEMF,
                                              UINT nSize,
                                              LPBYTE lpData);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileDescriptionA(    HENHMETAFILE hemf,
                                                      UINT cchBuffer,
                                                      LPSTR lpDescription);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileDescriptionW(    HENHMETAFILE hemf,
                                                      UINT cchBuffer,
                                                      LPWSTR lpDescription);




#line 4816 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileHeader(      HENHMETAFILE hemf,
                                                  UINT nSize,
                                                  LPENHMETAHEADER lpEnhMetaHeader);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePaletteEntries(  HENHMETAFILE hemf,
                                                      UINT nNumEntries,
                                                      LPPALETTEENTRY lpPaletteEntries);

__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePixelFormat(     HENHMETAFILE hemf,
                                                      UINT cbBuffer,
                                                      PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) UINT  __stdcall GetWinMetaFileBits(    HENHMETAFILE hemf,
                                              UINT cbData16,
                                              LPBYTE pData16,
                                              INT iMapMode,
                                              HDC hdcRef);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFile(   HDC hdc,   HENHMETAFILE hmf,   const RECT * lprect);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFileRecord(     HDC hdc,
                                                  LPHANDLETABLE pht,
                                                  const ENHMETARECORD *pmr,
                                                  UINT cht);

__declspec(dllimport) HENHMETAFILE  __stdcall SetEnhMetaFileBits(    UINT nSize,
                                                      const BYTE * pb);

__declspec(dllimport) HENHMETAFILE  __stdcall SetWinMetaFileBits(    UINT nSize,
                                                      const BYTE *lpMeta16Data,
                                                      HDC hdcRef,
                                                      const METAFILEPICT *lpMFP);
__declspec(dllimport) BOOL  __stdcall GdiComment(  HDC hdc,   UINT nSize,   const BYTE *lpData);

#line 4847 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



__declspec(dllimport) BOOL __stdcall GetTextMetricsA(   HDC hdc,   LPTEXTMETRICA lptm);
__declspec(dllimport) BOOL __stdcall GetTextMetricsW(   HDC hdc,   LPTEXTMETRICW lptm);




#line 4857 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



















#line 4877 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 4879 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



typedef struct tagDIBSECTION {
    BITMAP       dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION,  *LPDIBSECTION, *PDIBSECTION;


__declspec(dllimport) BOOL __stdcall AngleArc(   HDC hdc,   int x,   int y,   DWORD r,   FLOAT StartAngle,   FLOAT SweepAngle);
__declspec(dllimport) BOOL __stdcall PolyPolyline(  HDC hdc,   const POINT *apt,   const DWORD *asz,   DWORD csz);
__declspec(dllimport) BOOL __stdcall GetWorldTransform(   HDC hdc,   LPXFORM lpxf);
__declspec(dllimport) BOOL __stdcall SetWorldTransform(   HDC hdc,   const XFORM * lpxf);
__declspec(dllimport) BOOL __stdcall ModifyWorldTransform(   HDC hdc,   const XFORM * lpxf,   DWORD mode);
__declspec(dllimport) BOOL __stdcall CombineTransform(   LPXFORM lpxfOut,   const XFORM *lpxf1,   const XFORM *lpxf2);






__declspec(dllimport)   HBITMAP __stdcall CreateDIBSection(
             HDC               hdc,
                 const BITMAPINFO *pbmi,
                 UINT              usage,
    
    
                    void            **ppvBits,
             HANDLE            hSection,
                 DWORD             offset);


 
__declspec(dllimport) UINT __stdcall GetDIBColorTable(   HDC  hdc,
                                          UINT iStart,
                                          UINT cEntries,
                                          RGBQUAD *prgbq);
__declspec(dllimport) UINT __stdcall SetDIBColorTable(   HDC  hdc,
                                          UINT iStart,
                                          UINT cEntries,
                                          const RGBQUAD *prgbq);




































typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT,  *LPCOLORADJUSTMENT;

__declspec(dllimport) BOOL __stdcall SetColorAdjustment(   HDC hdc,   const COLORADJUSTMENT *lpca);
__declspec(dllimport) BOOL __stdcall GetColorAdjustment(   HDC hdc,   LPCOLORADJUSTMENT lpca);
__declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette(   HDC hdc);


typedef BOOL (__stdcall* ABORTPROC)(   HDC,   int);


#line 4983 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

typedef struct _DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;

    LPCSTR   lpszDatatype;
    DWORD    fwType;
#line 4992 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;

    LPCWSTR  lpszDatatype;
    DWORD    fwType;
#line 5001 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
} DOCINFOW, *LPDOCINFOW;




typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;
#line 5009 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




#line 5014 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

 __declspec(dllimport) int __stdcall StartDocA(  HDC hdc,   const DOCINFOA *lpdi);
 __declspec(dllimport) int __stdcall StartDocW(  HDC hdc,   const DOCINFOW *lpdi);




#line 5022 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
 __declspec(dllimport) int __stdcall EndDoc(  HDC hdc);
 __declspec(dllimport) int __stdcall StartPage(  HDC hdc);
 __declspec(dllimport) int __stdcall EndPage(  HDC hdc);
 __declspec(dllimport) int __stdcall AbortDoc(  HDC hdc);
__declspec(dllimport) int __stdcall SetAbortProc(  HDC hdc,   ABORTPROC proc);

__declspec(dllimport) BOOL __stdcall AbortPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall ArcTo(  HDC hdc,   int left,   int top,   int right,   int bottom,   int xr1,   int yr1,   int xr2,   int yr2);
__declspec(dllimport) BOOL __stdcall BeginPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall CloseFigure(  HDC hdc);
__declspec(dllimport) BOOL __stdcall EndPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall FillPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall FlattenPath(  HDC hdc);
__declspec(dllimport) int  __stdcall GetPath(  HDC hdc,   LPPOINT apt,   LPBYTE aj, int cpt);
__declspec(dllimport) HRGN __stdcall PathToRegion(  HDC hdc);
__declspec(dllimport) BOOL __stdcall PolyDraw(  HDC hdc,   const POINT * apt,   const BYTE * aj,   int cpt);
__declspec(dllimport) BOOL __stdcall SelectClipPath(  HDC hdc,   int mode);
__declspec(dllimport) int  __stdcall SetArcDirection(  HDC hdc,   int dir);
__declspec(dllimport) BOOL __stdcall SetMiterLimit(  HDC hdc,   FLOAT limit,   PFLOAT old);
__declspec(dllimport) BOOL __stdcall StrokeAndFillPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall StrokePath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall WidenPath(  HDC hdc);
__declspec(dllimport) HPEN __stdcall ExtCreatePen(   DWORD iPenStyle,
                                      DWORD cWidth,
                                      const LOGBRUSH *plbrush,
                                      DWORD cStyle,
                                      const DWORD *pstyle);
__declspec(dllimport) BOOL __stdcall GetMiterLimit(  HDC hdc,   PFLOAT plimit);
__declspec(dllimport) int  __stdcall GetArcDirection(  HDC hdc);

__declspec(dllimport) int   __stdcall GetObjectA(  HANDLE h,   int c,   LPVOID pv);
__declspec(dllimport) int   __stdcall GetObjectW(  HANDLE h,   int c,   LPVOID pv);




#line 5059 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




















#line 5080 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


 __declspec(dllimport) BOOL  __stdcall MoveToEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall TextOutA(   HDC hdc,   int x,   int y,   LPCSTR lpString,   int c);
 __declspec(dllimport) BOOL  __stdcall TextOutW(   HDC hdc,   int x,   int y,   LPCWSTR lpString,   int c);




#line 5090 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
 __declspec(dllimport) BOOL  __stdcall ExtTextOutA(   HDC hdc,   int x,   int y,   UINT options,   const RECT * lprect,   LPCSTR lpString,   UINT c,   const INT * lpDx);
 __declspec(dllimport) BOOL  __stdcall ExtTextOutW(   HDC hdc,   int x,   int y,   UINT options,   const RECT * lprect,   LPCWSTR lpString,   UINT c,   const INT * lpDx);




#line 5097 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall PolyTextOutA(  HDC hdc,   const POLYTEXTA * ppt,   int nstrings);
__declspec(dllimport) BOOL  __stdcall PolyTextOutW(  HDC hdc,   const POLYTEXTW * ppt,   int nstrings);




#line 5104 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) HRGN  __stdcall CreatePolygonRgn(      const POINT *pptl,
                                              int cPoint,
                                              int iMode);
__declspec(dllimport) BOOL  __stdcall DPtoLP(   HDC hdc,   LPPOINT lppt,   int c);
__declspec(dllimport) BOOL  __stdcall LPtoDP(   HDC hdc,   LPPOINT lppt,   int c);
 __declspec(dllimport) BOOL  __stdcall Polygon(  HDC hdc,   const POINT *apt,   int cpt);
 __declspec(dllimport) BOOL  __stdcall Polyline(  HDC hdc,   const POINT *apt,   int cpt);

__declspec(dllimport) BOOL  __stdcall PolyBezier(  HDC hdc,   const POINT * apt,   DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolyBezierTo(  HDC hdc,   const POINT * apt,   DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolylineTo(  HDC hdc,   const POINT * apt,   DWORD cpt);

 __declspec(dllimport) BOOL  __stdcall SetViewportExtEx(   HDC hdc,   int x,   int y,   LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall SetViewportOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall SetWindowExtEx(   HDC hdc,   int x,   int y,   LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall SetWindowOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);

 __declspec(dllimport) BOOL  __stdcall OffsetViewportOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall OffsetWindowOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall ScaleViewportExtEx(   HDC hdc,   int xn,   int dx,   int yn,   int yd,   LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall ScaleWindowExtEx(   HDC hdc,   int xn,   int xd,   int yn,   int yd,   LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBitmapDimensionEx(   HBITMAP hbm,   int w,   int h,   LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBrushOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);

__declspec(dllimport) int   __stdcall GetTextFaceA(   HDC hdc,   int c,    LPSTR lpName);
__declspec(dllimport) int   __stdcall GetTextFaceW(   HDC hdc,   int c,    LPWSTR lpName);




#line 5136 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

__declspec(dllimport) DWORD __stdcall GetKerningPairsA(      HDC hdc,
                                              DWORD nPairs,
                                              LPKERNINGPAIR   lpKernPair);
__declspec(dllimport) DWORD __stdcall GetKerningPairsW(      HDC hdc,
                                              DWORD nPairs,
                                              LPKERNINGPAIR   lpKernPair);




#line 5156 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


__declspec(dllimport) BOOL  __stdcall GetDCOrgEx(   HDC hdc,   LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall FixBrushOrgEx(   HDC hdc,   int x,   int y,    LPPOINT ptl);
__declspec(dllimport) BOOL  __stdcall UnrealizeObject(   HGDIOBJ h);

__declspec(dllimport) BOOL  __stdcall GdiFlush(void);
__declspec(dllimport) DWORD __stdcall GdiSetBatchLimit(   DWORD dw);
__declspec(dllimport) DWORD __stdcall GdiGetBatchLimit(void);








typedef int (__stdcall* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (__stdcall* ICMENUMPROCW)(LPWSTR, LPARAM);




#line 5180 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) int         __stdcall SetICMMode(   HDC hdc,   int mode);
__declspec(dllimport) BOOL        __stdcall CheckColorsInGamut(      HDC hdc,
                                                      LPRGBTRIPLE lpRGBTriple,
                                                      LPVOID dlpBuffer,
                                                      DWORD nCount);

__declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace(   HDC hdc);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceA(   HCOLORSPACE hColorSpace,
                                                  LPLOGCOLORSPACEA lpBuffer,
                                                  DWORD nSize);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceW(   HCOLORSPACE hColorSpace,
                                                  LPLOGCOLORSPACEW lpBuffer,
                                                  DWORD nSize);




#line 5199 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA(   LPLOGCOLORSPACEA lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW(   LPLOGCOLORSPACEW lplcs);




#line 5207 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace(   HDC hdc,   HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall DeleteColorSpace(   HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall GetICMProfileA(      HDC hdc,
                                                  LPDWORD pBufSize,
                                                  LPSTR pszFilename);
__declspec(dllimport) BOOL        __stdcall GetICMProfileW(      HDC hdc,
                                                  LPDWORD pBufSize,
                                                  LPWSTR pszFilename);




#line 5220 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) BOOL        __stdcall SetICMProfileA(   HDC hdc,   LPSTR lpFileName);
__declspec(dllimport) BOOL        __stdcall SetICMProfileW(   HDC hdc,   LPWSTR lpFileName);




#line 5228 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL        __stdcall GetDeviceGammaRamp(   HDC hdc,   LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall SetDeviceGammaRamp(   HDC hdc,    LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall ColorMatchToTarget(   HDC hdc,   HDC hdcTarget,   DWORD action);
__declspec(dllimport) int         __stdcall EnumICMProfilesA(   HDC hdc,   ICMENUMPROCA proc,   LPARAM param);
__declspec(dllimport) int         __stdcall EnumICMProfilesW(   HDC hdc,   ICMENUMPROCW proc,   LPARAM param);




#line 5238 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

__declspec(dllimport) BOOL        __stdcall UpdateICMRegKeyA(   DWORD reserved,   LPSTR lpszCMID,   LPSTR lpszFileName,   UINT command);

__declspec(dllimport) BOOL        __stdcall UpdateICMRegKeyW(   DWORD reserved,   LPWSTR lpszCMID,   LPWSTR lpszFileName,   UINT command);




#line 5247 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#pragma deprecated (UpdateICMRegKeyW)
#pragma deprecated (UpdateICMRegKeyA)
#line 5252 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 5254 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


__declspec(dllimport) BOOL        __stdcall ColorCorrectPalette(   HDC hdc,   HPALETTE hPal,   DWORD deFirst,   DWORD num);
#line 5258 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"









#line 5268 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




















































































































#line 5385 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
















#line 5402 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"





#line 5408 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"









#line 5418 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



typedef struct tagEMR
{
    DWORD   iType;              
    DWORD   nSize;              
                                
} EMR, *PEMR;



typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              
                                
} EMRTEXT, *PEMRTEXT;



typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,

  EMRSETLAYOUT,         *PEMRSETLAYOUT,
#line 5466 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,        *PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      
                                
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        
    DWORD   offPalEntries;      
    DWORD   nSizeLast;          
                                
                                
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;


typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cptl;               
    POINTL  aptl[1];            
    BYTE    abTypes[1];         
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cpts;               
    POINTS  apts[1];            
    BYTE    abTypes[1];         
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   nPolys;             
    DWORD   cptl;               
    DWORD   aPolyCounts[1];     
    POINTL  aptl[1];            
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   nPolys;             
    DWORD   cpts;               
    DWORD   aPolyCounts[1];     
    POINTS  apts[1];            
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    DWORD   ihBrush;            
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    DWORD   ihBrush;            
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   iGraphicsMode;      
    FLOAT   exScale;            
    FLOAT   eyScale;            
    EMRTEXT emrtext;            
                                
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   iGraphicsMode;      
    FLOAT   exScale;            
    FLOAT   eyScale;            
    LONG    cStrings;
    EMRTEXT aemrtext[1];        
                                
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         
    DWORD   offBmiMask;         
    DWORD   cbBmiMask;          
    DWORD   offBitsMask;        
    DWORD   cbBitsMask;         
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         
    DWORD   offBmiMask;         
    DWORD   cbBmiMask;          
    DWORD   offBitsMask;        
    DWORD   cbBitsMask;         
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    DWORD   iUsageSrc;          
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    DWORD   iUsageSrc;          
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
    LOGPALETTE lgpl;            
                                
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              
    DWORD   offBmi;             
    DWORD   cbBmi;              
                                
                                
    DWORD   offBits;            
    DWORD   cbBits;             
    EXTLOGPEN32 elp;            
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR        emr;
    DWORD      ihBrush;          
    LOGBRUSH32 lb;               
                                 
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            
    DWORD   iUsage;             
    DWORD   offBmi;             
    DWORD   cbBmi;              
    DWORD   offBits;            
    DWORD   cbBits;             
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            
    DWORD   iUsage;             
    DWORD   offBmi;             
    DWORD   cbBmi;              
                                
                                
    DWORD   offBits;            
    DWORD   cbBits;             
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD   dSignature;         
    DWORD   nVersion;           
    DWORD   cbData;             
    DWORD   offData;            
                                
} EMRFORMAT, *PEMRFORMAT;



typedef struct tagEMRGLSRECORD
{
    EMR     emr;
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;

typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

typedef struct tagEMRPIXELFORMAT
{
    EMR     emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;

typedef struct tagEMRCREATECOLORSPACE
{
    EMR             emr;
    DWORD           ihCS;       
    LOGCOLORSPACEA  lcs;        
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

typedef struct tagEMRSETCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               
} EMRSETCOLORSPACE,    *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;

#line 6049 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"



typedef struct tagEMREXTESCAPE
{
    EMR     emr;
    INT     iEscape;            
    INT     cbEscData;          
    BYTE    EscData[1];         
} EMREXTESCAPE,  *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;

typedef struct tagEMRNAMEDESCAPE
{
    EMR     emr;
    INT     iEscape;            
    INT     cbDriver;           
    INT     cbEscData;          
    BYTE    EscData[1];         
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;



typedef struct tagEMRSETICMPROFILE
{
    EMR     emr;
    DWORD   dwFlags;            
    DWORD   cbName;             
    DWORD   cbData;             
    BYTE    Data[1];            
} EMRSETICMPROFILE,  *PEMRSETICMPROFILE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;



typedef struct tagEMRCREATECOLORSPACEW
{
    EMR             emr;
    DWORD           ihCS;       
    LOGCOLORSPACEW  lcs;        
    DWORD           dwFlags;    
    DWORD           cbData;     
    BYTE            Data[1];    
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;



typedef struct tagCOLORMATCHTOTARGET
{
    EMR     emr;
    DWORD   dwAction;           
    DWORD   dwFlags;            
    DWORD   cbName;             
    DWORD   cbData;             
    BYTE    Data[1];            
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

typedef struct tagCOLORCORRECTPALETTE
{
    EMR     emr;
    DWORD   ihPalette;          
    DWORD   nFirstEntry;        
    DWORD   nPalEntries;        
    DWORD   nReserved;          
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

typedef struct tagEMRALPHABLEND
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;

typedef struct tagEMRGRADIENTFILL
{
    EMR       emr;
    RECTL     rclBounds;          
    DWORD     nVer;
    DWORD     nTri;
    ULONG     ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;

typedef struct tagEMRTRANSPARENTBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;


#line 6174 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"










#line 6185 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"




__declspec(dllimport) BOOL  __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
__declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
__declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
__declspec(dllimport) BOOL  __stdcall wglDeleteContext(HGLRC);
__declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void);
__declspec(dllimport) HDC   __stdcall wglGetCurrentDC(void);
__declspec(dllimport) PROC  __stdcall wglGetProcAddress(LPCSTR);
__declspec(dllimport) BOOL  __stdcall wglMakeCurrent(HDC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglShareLists(HGLRC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);




#line 6205 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT,  *LPGLYPHMETRICSFLOAT;



__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);




#line 6231 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


typedef struct tagLAYERPLANEDESCRIPTOR { 
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    BYTE  bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR,  *LPLAYERPLANEDESCRIPTOR;

















































__declspec(dllimport) BOOL  __stdcall wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
__declspec(dllimport) int   __stdcall wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
__declspec(dllimport) int   __stdcall wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
__declspec(dllimport) BOOL  __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
__declspec(dllimport) BOOL  __stdcall wglSwapLayerBuffers(HDC, UINT);



typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP,  *LPWGLSWAP;



__declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP *);

#line 6330 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 6332 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion

#line 6335 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#pragma region Desktop Family



#line 6341 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"
#pragma endregion


}
#line 6346 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#pragma warning(pop)
#line 6350 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"

#line 6352 "E:\\sdk\\include\\10.0.16299.0\\um\\wingdi.h"


#line 174 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















#pragma once










#line 30 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 38 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






extern "C" {
#line 46 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma warning(push)



#pragma warning(disable:4820) 
#line 53 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 63 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family


typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;



typedef MENUTEMPLATEA MENUTEMPLATE;
#line 77 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;



typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
#line 84 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef LRESULT (__stdcall* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

#line 88 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef INT_PTR (__stdcall* DLGPROC)(HWND, UINT, WPARAM, LPARAM);

#line 98 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef void (__stdcall* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (__stdcall* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (__stdcall* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (__stdcall* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (__stdcall* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (__stdcall* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (__stdcall* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (__stdcall* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (__stdcall* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (__stdcall* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (__stdcall* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);


typedef BOOL (__stdcall* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#line 121 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 124 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





































#line 163 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family







typedef PROPENUMPROCA        PROPENUMPROC;
typedef PROPENUMPROCEXA      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA   EDITWORDBREAKPROC;
#line 176 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



typedef BOOL (__stdcall* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (__stdcall* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA   WINSTAENUMPROCA;
typedef NAMEENUMPROCA   DESKTOPENUMPROCA;
typedef NAMEENUMPROCW   WINSTAENUMPROCW;
typedef NAMEENUMPROCW   DESKTOPENUMPROCW;












#line 199 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







typedef WINSTAENUMPROCA     WINSTAENUMPROC;
typedef DESKTOPENUMPROCA    DESKTOPENUMPROC;

#line 210 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 212 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#line 222 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




























#line 251 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 270 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family



#pragma warning(push)
#pragma warning(disable:4995)
#line 278 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
wvsprintfA(
      LPSTR,
        LPCSTR,
      va_list arglist);
__declspec(dllimport)
int
__stdcall
wvsprintfW(
      LPWSTR,
        LPCWSTR,
      va_list arglist);




#line 298 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__cdecl
wsprintfA(
      LPSTR,
        LPCSTR,
    ...);
__declspec(dllimport)
int
__cdecl
wsprintfW(
      LPWSTR,
        LPCWSTR,
    ...);




#line 318 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma warning(pop)
#line 322 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 324 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




































#line 362 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










































#line 405 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 421 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


























#line 448 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











































































































































#line 588 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























































#line 644 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















































#line 693 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






















#line 716 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 723 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





































#line 761 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


















#line 780 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 786 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 791 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 798 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 801 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





























#pragma region Desktop Family





typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;



typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;




typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#line 856 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

#line 867 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family





typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;

} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;

#line 885 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

















#line 904 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



























#line 932 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 936 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 941 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 947 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 949 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





























































#line 1011 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 1015 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#line 1027 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;




typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG,  *NPEVENTMSGMSG,  *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG,  *NPEVENTMSG,  *LPEVENTMSG;




typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT,  *NPCWPSTRUCT,  *LPCWPSTRUCT;





typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT,  *NPCWPRETSTRUCT,  *LPCWPRETSTRUCT;

#line 1073 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 1075 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion
















#pragma region Desktop Family





typedef struct tagKBDLLHOOKSTRUCT {
    DWORD   vkCode;
    DWORD   scanCode;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT,  *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;




typedef struct tagMSLLHOOKSTRUCT {
    POINT   pt;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT,  *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#line 1118 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1121 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO,  *NPDEBUGHOOKINFO, * LPDEBUGHOOKINFO;




typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT,  *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;



typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    DWORD   mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;






#line 1160 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 1161 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT,  *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#line 1173 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 1175 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1178 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"














#line 1193 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 1198 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 1208 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#pragma region Desktop Family


__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutA(
      LPCSTR pwszKLID,
      UINT Flags);
__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutW(
      LPCWSTR pwszKLID,
      UINT Flags);




#line 1234 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
HKL
__stdcall
ActivateKeyboardLayout(
      HKL hkl,
      UINT Flags);







#line 1251 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
ToUnicodeEx(
      UINT wVirtKey,
      UINT wScanCode,
      const BYTE *lpKeyState,
      LPWSTR pwszBuff,
      int cchBuff,
      UINT wFlags,
      HKL dwhkl);
#line 1265 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnloadKeyboardLayout(
      HKL hkl);

__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameA(
      LPSTR pwszKLID);
__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameW(
      LPWSTR pwszKLID);




#line 1287 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
GetKeyboardLayoutList(
      int nBuff,
      HKL  *lpList);

__declspec(dllimport)
HKL
__stdcall
GetKeyboardLayout(
      DWORD idThread);

#line 1303 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 1306 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagMOUSEMOVEPOINT {
    int   x;
    int   y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, * LPMOUSEMOVEPOINT;

#line 1321 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetMouseMovePointsEx(
      UINT cbSize,
      LPMOUSEMOVEPOINT lppt,
      LPMOUSEMOVEPOINT lpptBuf,
      int nBufPoints,
      DWORD resolution);

#line 1343 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1346 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#pragma region Desktop Family


__declspec(dllimport)
HDESK
__stdcall
CreateDesktopA(
      LPCSTR lpszDesktop,
      LPCSTR lpszDevice,
      DEVMODEA* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopW(
      LPCWSTR lpszDesktop,
      LPCWSTR lpszDevice,
      DEVMODEW* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);




#line 1397 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExA(
      LPCSTR lpszDesktop,
      LPCSTR lpszDevice,
      DEVMODEA* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa,
      ULONG ulHeapSize,
      PVOID pvoid);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExW(
      LPCWSTR lpszDesktop,
      LPCWSTR lpszDevice,
      DEVMODEW* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa,
      ULONG ulHeapSize,
      PVOID pvoid);




#line 1427 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 1429 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1432 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 1433 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HDESK
__stdcall
OpenDesktopA(
      LPCSTR lpszDesktop,
      DWORD dwFlags,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HDESK
__stdcall
OpenDesktopW(
      LPCWSTR lpszDesktop,
      DWORD dwFlags,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);




#line 1458 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
OpenInputDesktop(
      DWORD dwFlags,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);


__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsA(
      HWINSTA hwinsta,
      DESKTOPENUMPROCA lpEnumFunc,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsW(
      HWINSTA hwinsta,
      DESKTOPENUMPROCW lpEnumFunc,
      LPARAM lParam);




#line 1487 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumDesktopWindows(
      HDESK hDesktop,
      WNDENUMPROC lpfn,
      LPARAM lParam);


__declspec(dllimport)
BOOL
__stdcall
SwitchDesktop(
      HDESK hDesktop);


__declspec(dllimport)
BOOL
__stdcall
SetThreadDesktop(
       HDESK hDesktop);

__declspec(dllimport)
BOOL
__stdcall
CloseDesktop(
      HDESK hDesktop);

__declspec(dllimport)
HDESK
__stdcall
GetThreadDesktop(
      DWORD dwThreadId);

#line 1523 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1526 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





























#pragma region Desktop Family


__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationA(
      LPCSTR lpwinsta,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationW(
      LPCWSTR lpwinsta,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);




#line 1579 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationA(
      LPCSTR lpszWinSta,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationW(
      LPCWSTR lpszWinSta,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);




#line 1599 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsA(
      WINSTAENUMPROCA lpEnumFunc,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsW(
      WINSTAENUMPROCW lpEnumFunc,
      LPARAM lParam);




#line 1617 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CloseWindowStation(
      HWINSTA hWinSta);

__declspec(dllimport)
BOOL
__stdcall
SetProcessWindowStation(
      HWINSTA hWinSta);

__declspec(dllimport)
HWINSTA
__stdcall
GetProcessWindowStation(
    void);

#line 1637 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1640 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetUserObjectSecurity(
      HANDLE hObj,
      PSECURITY_INFORMATION pSIRequested,
      PSECURITY_DESCRIPTOR pSID);

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectSecurity(
      HANDLE hObj,
      PSECURITY_INFORMATION pSIRequested,
      PSECURITY_DESCRIPTOR pSID,
      DWORD nLength,
      LPDWORD lpnLengthNeeded);

#line 1665 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#line 1675 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family


typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationA(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength,
      LPDWORD lpnLengthNeeded);
__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationW(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength,
      LPDWORD lpnLengthNeeded);




#line 1709 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationA(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength);
__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationW(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength);




#line 1731 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 1733 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 1736 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family



typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,  *NPWNDCLASSEXA,  *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW,  *NPWNDCLASSEXW,  *LPWNDCLASSEXW;






typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#line 1784 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 1785 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA,  *NPWNDCLASSA,  *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW,  *NPWNDCLASSW,  *LPWNDCLASSW;






typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#line 1821 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsHungAppWindow(
      HWND hwnd);



__declspec(dllimport)
void
__stdcall
DisableProcessWindowsGhosting(
    void);
#line 1836 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 1838 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




#pragma region Application Family or OneCore Family





typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;



} MSG, *PMSG,  *NPMSG,  *LPMSG;

#line 1862 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion











#line 1875 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





















#line 1897 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 1921 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#line 1933 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 1943 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



































#line 1979 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 1987 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"














#pragma region Desktop Family





typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#line 2016 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



















#line 2037 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 2038 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#pragma region Desktop Family





typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
      PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;


typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU,  * LPMDINEXTMENU;
#line 2077 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2079 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion






















#line 2103 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 2114 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















#line 2132 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2137 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2141 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 2158 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 2165 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"












#line 2178 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"































#line 2210 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 2211 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 2212 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2214 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 2215 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 2239 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2244 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 2247 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 2257 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 2267 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 2278 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 2289 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

































#pragma region Desktop Family


typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;


#line 2333 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 2336 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2338 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 2339 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2341 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2345 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 2369 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2374 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 2394 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 2404 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 2407 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2411 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2416 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2420 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 2427 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2431 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2436 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

























#line 2462 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2466 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2470 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2475 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 2482 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2487 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2492 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 2495 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 2504 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 2512 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




















#line 2533 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




































#line 2570 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 2581 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 2584 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2586 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2588 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 2605 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageA(
      LPCSTR lpString);
__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageW(
      LPCWSTR lpString);




#line 2625 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2627 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





















#pragma region Desktop Family





typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;




typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

#line 2674 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




























#line 2704 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 2706 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 2716 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 2722 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family


typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

__declspec(dllimport)
BOOL
__stdcall
TrackMouseEvent(
      LPTRACKMOUSEEVENT lpEventTrack);

#line 2742 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 2745 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2749 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 2750 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 2753 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


































































#line 2820 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















#line 2838 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2843 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 2848 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2852 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2856 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2860 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 2863 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




















#line 2884 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 2888 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























































#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawEdge(
      HDC hdc,
      LPRECT qrc,
      UINT edge,
      UINT grfFlags);

#line 2956 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









#line 2967 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

































#line 3001 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawFrameControl(
      HDC,
      LPRECT,
      UINT,
      UINT);


#line 3020 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion










#line 3032 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 3035 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawCaption(
      HWND hwnd,
      HDC hdc,
      const RECT * lprect,
      UINT flags);


#line 3050 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawAnimatedRects(
      HWND hwnd,
      int idAni,
      const RECT *lprcFrom,
      const RECT *lprcTo);

#line 3068 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 3071 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
























#line 3096 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 3099 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 3107 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




















#line 3128 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#pragma region Desktop Family


typedef struct tagACCEL {

    BYTE   fVirt;               
    WORD   key;
    WORD   cmd;




#line 3151 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;




typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
#line 3197 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;



} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;





#line 3216 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 3218 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef struct tagNMHDR
{
    HWND      hwndFrom;
    UINT_PTR  idFrom;
    UINT      code;         
}   NMHDR;

#line 3233 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef NMHDR  * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;

#line 3247 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion
#line 3249 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#line 3261 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 3281 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 3288 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 3289 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
} MEASUREITEMSTRUCT,  *PMEASUREITEMSTRUCT,  *LPMEASUREITEMSTRUCT;




typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    ULONG_PTR   itemData;
} DRAWITEMSTRUCT,  *PDRAWITEMSTRUCT,  *LPDRAWITEMSTRUCT;




typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    ULONG_PTR  itemData;
} DELETEITEMSTRUCT,  *PDELETEITEMSTRUCT,  *LPDELETEITEMSTRUCT;




typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    ULONG_PTR   itemData1;
    UINT        itemID2;
    ULONG_PTR   itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT,  *PCOMPAREITEMSTRUCT,  *LPCOMPAREITEMSTRUCT;

#line 3346 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
GetMessageA(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax);
__declspec(dllimport)
BOOL
__stdcall
GetMessageW(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax);




#line 3378 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 3402 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
TranslateMessage(
      const MSG *lpMsg);

__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageA(
      const MSG *lpMsg);
__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageW(
      const MSG *lpMsg);




#line 3425 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















#line 3443 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMessageQueue(
      int cMessagesMax);

__declspec(dllimport)
BOOL
__stdcall
PeekMessageA(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax,
      UINT wRemoveMsg);
__declspec(dllimport)
BOOL
__stdcall
PeekMessageW(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax,
      UINT wRemoveMsg);




#line 3473 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 3475 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion












#line 3489 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 3492 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterHotKey(
      HWND hWnd,
      int id,
      UINT fsModifiers,
      UINT vk);

__declspec(dllimport)
BOOL
__stdcall
UnregisterHotKey(
      HWND hWnd,
      int id);

#line 3513 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion







#line 3522 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 3538 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 3542 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 3545 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 3548 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 3557 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 3561 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family





#line 3572 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
__declspec(dllimport)
BOOL
__stdcall
ExitWindowsEx(
      UINT uFlags,
      DWORD dwReason);

__declspec(dllimport)
BOOL
__stdcall
SwapMouseButton(
      BOOL fSwap);

__declspec(dllimport)
DWORD
__stdcall
GetMessagePos(
    void);

__declspec(dllimport)
LONG
__stdcall
GetMessageTime(
    void);

__declspec(dllimport)
LPARAM
__stdcall
GetMessageExtraInfo(
    void);


__declspec(dllimport)
DWORD
__stdcall
GetUnpredictedMessagePos(
    void);
#line 3610 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
IsWow64Message(
    void);
#line 3618 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
LPARAM
__stdcall
SetMessageExtraInfo(
      LPARAM lParam);
#line 3626 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LRESULT
__stdcall
SendMessageA(
      HWND hWnd,
      UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageW(
      HWND hWnd,
      UINT Msg,
        WPARAM wParam,
        LPARAM lParam);




#line 3648 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 3672 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      UINT fuFlags,
      UINT uTimeout,
      PDWORD_PTR lpdwResult);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      UINT fuFlags,
      UINT uTimeout,
      PDWORD_PTR lpdwResult);




#line 3702 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3724 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      SENDASYNCPROC lpResultCallBack,
      ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      SENDASYNCPROC lpResultCallBack,
      ULONG_PTR dwData);




#line 3750 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


typedef struct {
    UINT  cbSize;
    HDESK hdesk;
    HWND  hwnd;
    LUID  luid;
} BSMINFO, *PBSMINFO;

__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExA(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      PBSMINFO pbsmInfo);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExW(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      PBSMINFO pbsmInfo);




#line 3784 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 3785 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 3787 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family



__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageA(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageW(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3818 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"












#line 3831 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 3833 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




















#line 3855 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 3859 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 3862 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family



typedef  PVOID           HDEVNOTIFY;
typedef  HDEVNOTIFY     *PHDEVNOTIFY;





#line 3877 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationA(
      HANDLE hRecipient,
      LPVOID NotificationFilter,
      DWORD Flags);
__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationW(
      HANDLE hRecipient,
      LPVOID NotificationFilter,
      DWORD Flags);




#line 3897 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterDeviceNotification(
      HDEVNOTIFY Handle
    );







typedef  PVOID           HPOWERNOTIFY;
typedef  HPOWERNOTIFY   *PHPOWERNOTIFY;

#line 3915 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterPowerSettingNotification(
     HANDLE hRecipient,
     LPCGUID PowerSettingGuid,
     DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterPowerSettingNotification(
     HPOWERNOTIFY Handle
    );

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterSuspendResumeNotification (
     HANDLE hRecipient,
     DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterSuspendResumeNotification (
     HPOWERNOTIFY Handle
    );


#line 3949 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 3950 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 3952 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
PostMessageA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostMessageW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3978 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageA(
      DWORD idThread,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageW(
      DWORD idThread,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 4000 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4002 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









#line 4013 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 4022 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
AttachThreadInput(
      DWORD idAttach,
      DWORD idAttachTo,
      BOOL fAttach);


__declspec(dllimport)
BOOL
__stdcall
ReplyMessage(
      LRESULT lResult);

__declspec(dllimport)
BOOL
__stdcall
WaitMessage(
    void);


#line 4049 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
DWORD
__stdcall
WaitForInputIdle(
      HANDLE hProcess,
      DWORD dwMilliseconds);

__declspec(dllimport)

LRESULT
__stdcall



#line 4066 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
DefWindowProcA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 4079 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
DefWindowProcW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 4089 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
void
__stdcall
PostQuitMessage(
      int nExitCode);



__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcA(
      WNDPROC lpPrevWndFunc,
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcW(
      WNDPROC lpPrevWndFunc,
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 4121 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



























#line 4149 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
InSendMessage(
    void);

#line 4157 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
InSendMessageEx(
      LPVOID lpReserved);

#line 4171 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









#line 4182 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetDoubleClickTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetDoubleClickTime(
      UINT);

__declspec(dllimport)
ATOM
__stdcall
RegisterClassA(
      const WNDCLASSA *lpWndClass);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassW(
      const WNDCLASSW *lpWndClass);




#line 4214 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterClassA(
      LPCSTR lpClassName,
      HINSTANCE hInstance);
__declspec(dllimport)
BOOL
__stdcall
UnregisterClassW(
      LPCWSTR lpClassName,
      HINSTANCE hInstance);




#line 4232 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoA(
      HINSTANCE hInstance,
      LPCSTR lpClassName,
      LPWNDCLASSA lpWndClass);
 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoW(
      HINSTANCE hInstance,
      LPCWSTR lpClassName,
      LPWNDCLASSW lpWndClass);




#line 4254 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
ATOM
__stdcall
RegisterClassExA(
      const WNDCLASSEXA *);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassExW(
      const WNDCLASSEXW *);




#line 4271 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExA(
      HINSTANCE hInstance,
      LPCSTR lpszClass,
      LPWNDCLASSEXA lpwcx);
 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExW(
      HINSTANCE hInstance,
      LPCWSTR lpszClass,
      LPWNDCLASSEXW lpwcx);




#line 4293 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4295 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4297 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family



typedef BOOLEAN (__stdcall * PREGISTERCLASSNAMEW)(LPCWSTR);
#line 4312 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateWindowExA(
      DWORD dwExStyle,
      LPCSTR lpClassName,
      LPCSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HMENU hMenu,
      HINSTANCE hInstance,
      LPVOID lpParam);
__declspec(dllimport)
HWND
__stdcall
CreateWindowExW(
      DWORD dwExStyle,
      LPCWSTR lpClassName,
      LPCWSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HMENU hMenu,
      HINSTANCE hInstance,
      LPVOID lpParam);




#line 4350 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4352 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion













#line 4367 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
IsWindow(
      HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
IsMenu(
      HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
IsChild(
      HWND hWndParent,
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
DestroyWindow(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowWindow(
      HWND hWnd,
      int nCmdShow);


__declspec(dllimport)
BOOL
__stdcall
AnimateWindow(
      HWND hWnd,
      DWORD dwTime,
      DWORD dwFlags);
#line 4414 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4416 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindow(
      HWND hWnd,
      HDC hdcDst,
      POINT* pptDst,
      SIZE* psize,
      HDC hdcSrc,
      POINT* pptSrc,
      COLORREF crKey,
      BLENDFUNCTION* pblend,
      DWORD dwFlags);




typedef struct tagUPDATELAYEREDWINDOWINFO
{
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;




#line 4459 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindowIndirect(
      HWND hWnd,
      const UPDATELAYEREDWINDOWINFO* pULWInfo);

#line 4467 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 4470 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetLayeredWindowAttributes(
      HWND hwnd,
      COLORREF* pcrKey,
      BYTE* pbAlpha,
      DWORD* pdwFlags);





#line 4490 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
PrintWindow(
      HWND hwnd,
      HDC hdcBlt,
      UINT nFlags);

#line 4501 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 4504 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetLayeredWindowAttributes(
      HWND hwnd,
      COLORREF crKey,
      BYTE bAlpha,
      DWORD dwFlags);

#line 4518 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion











#line 4531 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
ShowWindowAsync(
       HWND hWnd,
       int nCmdShow);
#line 4545 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
FlashWindow(
       HWND hWnd,
       BOOL bInvert);


typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

__declspec(dllimport)
BOOL
__stdcall
FlashWindowEx(
      PFLASHWINFO pfwi);








#line 4576 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ShowOwnedPopups(
       HWND hWnd,
       BOOL fShow);

__declspec(dllimport)
BOOL
__stdcall
OpenIcon(
       HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
CloseWindow(
       HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
MoveWindow(
      HWND hWnd,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      BOOL bRepaint);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPos(
      HWND hWnd,
      HWND hWndInsertAfter,
      int X,
      int Y,
      int cx,
      int cy,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
GetWindowPlacement(
      HWND hWnd,
      WINDOWPLACEMENT *lpwndpl);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPlacement(
      HWND hWnd,
      const WINDOWPLACEMENT *lpwndpl);






__declspec(dllimport)
BOOL
__stdcall
GetWindowDisplayAffinity(
      HWND hWnd,
      DWORD* pdwAffinity);

__declspec(dllimport)
BOOL
__stdcall
SetWindowDisplayAffinity(
      HWND hWnd,
      DWORD dwAffinity);

#line 4653 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4655 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport)
HDWP
__stdcall
BeginDeferWindowPos(
      int nNumWindows);

__declspec(dllimport)
HDWP
__stdcall
DeferWindowPos(
      HDWP hWinPosInfo,
      HWND hWnd,
      HWND hWndInsertAfter,
      int x,
      int y,
      int cx,
      int cy,
      UINT uFlags);


__declspec(dllimport)
BOOL
__stdcall
EndDeferWindowPos(
      HDWP hWinPosInfo);

#line 4689 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 4692 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
IsWindowVisible(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsIconic(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
AnyPopup(
    void);

__declspec(dllimport)
BOOL
__stdcall
BringWindowToTop(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsZoomed(
      HWND hWnd);

#line 4727 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion






















#line 4751 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"














#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 34 "E:\\sdk\\include\\10.0.16299.0\\shared\\pshpack2.h"
#line 4766 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Application Family or OneCore Family





typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;

#line 4784 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;



typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
#line 4796 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4798 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Application Family or OneCore Family


typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;



typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
#line 4810 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4812 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family





typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;



typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
#line 4837 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;



typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
#line 4844 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 4846 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"


#line 36 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 37 "E:\\sdk\\include\\10.0.16299.0\\shared\\poppack.h"
#line 4850 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
CreateDialogParamA(
      HINSTANCE hInstance,
      LPCSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogParamW(
      HINSTANCE hInstance,
      LPCWSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4877 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamA(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEA lpTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamW(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEW lpTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4901 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 4911 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 4921 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamA(
      HINSTANCE hInstance,
      LPCSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamW(
      HINSTANCE hInstance,
      LPCWSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4945 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamA(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEA hDialogTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamW(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEW hDialogTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4969 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 4979 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 4989 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EndDialog(
      HWND hDlg,
      INT_PTR nResult);

__declspec(dllimport)
HWND
__stdcall
GetDlgItem(
      HWND hDlg,
      int nIDDlgItem);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemInt(
      HWND hDlg,
      int nIDDlgItem,
      UINT uValue,
      BOOL bSigned);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemInt(
      HWND hDlg,
      int nIDDlgItem,
      BOOL *lpTranslated,
      BOOL bSigned);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextA(
      HWND hDlg,
      int nIDDlgItem,
      LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextW(
      HWND hDlg,
      int nIDDlgItem,
      LPCWSTR lpString);




#line 5041 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

 
__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextA(
      HWND hDlg,
      int nIDDlgItem,
      LPSTR lpString,
      int cchMax);
 
__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextW(
      HWND hDlg,
      int nIDDlgItem,
      LPWSTR lpString,
      int cchMax);




#line 5065 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CheckDlgButton(
      HWND hDlg,
      int nIDButton,
      UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
CheckRadioButton(
      HWND hDlg,
      int nIDFirstButton,
      int nIDLastButton,
      int nIDCheckButton);

__declspec(dllimport)
UINT
__stdcall
IsDlgButtonChecked(
      HWND hDlg,
      int nIDButton);

__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageA(
      HWND hDlg,
      int nIDDlgItem,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageW(
      HWND hDlg,
      int nIDDlgItem,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 5113 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetNextDlgGroupItem(
      HWND hDlg,
      HWND hCtl,
      BOOL bPrevious);

__declspec(dllimport)
HWND
__stdcall
GetNextDlgTabItem(
      HWND hDlg,
      HWND hCtl,
      BOOL bPrevious);

__declspec(dllimport)
int
__stdcall
GetDlgCtrlID(
      HWND hWnd);

__declspec(dllimport)
long
__stdcall
GetDialogBaseUnits(void);


__declspec(dllimport)

LRESULT
__stdcall



#line 5150 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
DefDlgProcA(
      HWND hDlg,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 5163 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
DefDlgProcW(
      HWND hDlg,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 5173 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


typedef enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
     DCDC_DEFAULT                  = 0x0000,
     DCDC_DISABLE_FONT_UPDATE      = 0x0001,
     DCDC_DISABLE_RELAYOUT         = 0x0002,
} DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;


extern "C++" { inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator | (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator |= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator & (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator &= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator ~ (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator ^ (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator ^= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } };
#line 5184 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

BOOL
__stdcall
SetDialogControlDpiChangeBehavior(
      HWND hWnd,
      DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask,
      DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);

DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
__stdcall
GetDialogControlDpiChangeBehavior(
      HWND hWnd);

typedef enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT                     = 0x0000,
    DDC_DISABLE_ALL                 = 0x0001,
    DDC_DISABLE_RESIZE              = 0x0002,
    DDC_DISABLE_CONTROL_RELAYOUT    = 0x0004,
} DIALOG_DPI_CHANGE_BEHAVIORS;


extern "C++" { inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator | (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator |= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator & (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator &= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator ~ (DIALOG_DPI_CHANGE_BEHAVIORS a) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator ^ (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator ^= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } };
#line 5207 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

BOOL
__stdcall
SetDialogDpiChangeBehavior(
      HWND hDlg,
      DIALOG_DPI_CHANGE_BEHAVIORS mask,
      DIALOG_DPI_CHANGE_BEHAVIORS values);

DIALOG_DPI_CHANGE_BEHAVIORS
__stdcall
GetDialogDpiChangeBehavior(
      HWND hDlg);

#line 5221 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#line 5231 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5233 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterA(
      LPMSG lpMsg,
      int nCode);
__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterW(
      LPMSG lpMsg,
      int nCode);




#line 5256 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5258 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







__declspec(dllimport)
BOOL
__stdcall
OpenClipboard(
      HWND hWndNewOwner);

__declspec(dllimport)
BOOL
__stdcall
CloseClipboard(
    void);




__declspec(dllimport)
DWORD
__stdcall
GetClipboardSequenceNumber(
    void);

#line 5287 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetClipboardOwner(
    void);

__declspec(dllimport)
HWND
__stdcall
SetClipboardViewer(
      HWND hWndNewViewer);

__declspec(dllimport)
HWND
__stdcall
GetClipboardViewer(
    void);

__declspec(dllimport)
BOOL
__stdcall
ChangeClipboardChain(
      HWND hWndRemove,
      HWND hWndNewNext);

__declspec(dllimport)
HANDLE
__stdcall
SetClipboardData(
      UINT uFormat,
      HANDLE hMem);

__declspec(dllimport)
HANDLE
__stdcall
GetClipboardData(
      UINT uFormat);

__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatA(
      LPCSTR lpszFormat);
__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatW(
      LPCWSTR lpszFormat);




#line 5341 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
CountClipboardFormats(
    void);

__declspec(dllimport)
UINT
__stdcall
EnumClipboardFormats(
      UINT format);

__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameA(
      UINT format,
      LPSTR lpszFormatName,
      int cchMaxCount);
__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameW(
      UINT format,
      LPWSTR lpszFormatName,
      int cchMaxCount);




#line 5373 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EmptyClipboard(
    void);

__declspec(dllimport)
BOOL
__stdcall
IsClipboardFormatAvailable(
      UINT format);

__declspec(dllimport)
int
__stdcall
GetPriorityClipboardFormat(
      UINT *paFormatPriorityList,
      int cFormats);

__declspec(dllimport)
HWND
__stdcall
GetOpenClipboardWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
AddClipboardFormatListener(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
RemoveClipboardFormatListener(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
GetUpdatedClipboardFormats(
      PUINT lpuiFormats,
      UINT cFormats,
      PUINT pcFormatsOut);
#line 5420 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5422 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
CharToOemA(
      LPCSTR pSrc,
      LPSTR pDst);
__declspec(dllimport)
BOOL
__stdcall
CharToOemW(
      LPCWSTR pSrc,
      LPSTR pDst);




#line 5444 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

 
__declspec(dllimport)
BOOL
__stdcall
OemToCharA(
      LPCSTR pSrc,
      LPSTR pDst);
 
__declspec(dllimport)
BOOL
__stdcall
OemToCharW(
      LPCSTR pSrc,
      LPWSTR pDst);




#line 5464 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffA(
      LPCSTR lpszSrc,
      LPSTR lpszDst,
      DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffW(
      LPCWSTR lpszSrc,
      LPSTR lpszDst,
      DWORD cchDstLength);




#line 5484 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffA(
      LPCSTR lpszSrc,
      LPSTR lpszDst,
      DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffW(
      LPCSTR lpszSrc,
      LPWSTR lpszDst,
      DWORD cchDstLength);




#line 5504 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5506 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
LPSTR
__stdcall
CharUpperA(
      LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharUpperW(
      LPWSTR lpsz);




#line 5526 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffA(
      LPSTR lpsz,
      DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffW(
      LPWSTR lpsz,
      DWORD cchLength);




#line 5544 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharLowerA(
      LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharLowerW(
      LPWSTR lpsz);




#line 5560 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffA(
      LPSTR lpsz,
      DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffW(
      LPWSTR lpsz,
      DWORD cchLength);




#line 5578 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharNextA(
      LPCSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharNextW(
      LPCWSTR lpsz);




#line 5594 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharPrevA(
      LPCSTR lpszStart,
      LPCSTR lpszCurrent);
__declspec(dllimport)
LPWSTR
__stdcall
CharPrevW(
      LPCWSTR lpszStart,
      LPCWSTR lpszCurrent);




#line 5612 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
LPSTR
__stdcall
CharNextExA(
       WORD CodePage,
       LPCSTR lpCurrentChar,
       DWORD dwFlags);

__declspec(dllimport)
LPSTR
__stdcall
CharPrevExA(
       WORD CodePage,
       LPCSTR lpStart,
       LPCSTR lpCurrentChar,
       DWORD dwFlags);
#line 5631 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5633 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion















#pragma region Desktop or OneCore Family







__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaW(
      WCHAR ch);




#line 5672 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericW(
      WCHAR ch);




#line 5688 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharUpperA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharUpperW(
      WCHAR ch);




#line 5704 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharLowerA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharLowerW(
      WCHAR ch);




#line 5720 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5722 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5724 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
SetFocus(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
GetActiveWindow(
    void);

__declspec(dllimport)
HWND
__stdcall
GetFocus(
    void);

__declspec(dllimport)
UINT
__stdcall
GetKBCodePage(
    void);

__declspec(dllimport)
SHORT
__stdcall
GetKeyState(
      int nVirtKey);

__declspec(dllimport)
SHORT
__stdcall
GetAsyncKeyState(
      int vKey);

__declspec(dllimport)
 
BOOL
__stdcall
GetKeyboardState(
      PBYTE lpKeyState);

__declspec(dllimport)
BOOL
__stdcall
SetKeyboardState(
      LPBYTE lpKeyState);


#line 5780 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region  Desktop or PC Family


__declspec(dllimport)
int
__stdcall
GetKeyNameTextA(
      LONG lParam,
      LPSTR lpString,
      int cchSize);
__declspec(dllimport)
int
__stdcall
GetKeyNameTextW(
      LONG lParam,
      LPWSTR lpString,
      int cchSize);




#line 5804 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 5806 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
int
__stdcall
GetKeyboardType(
      int nTypeFlag);

__declspec(dllimport)
int
__stdcall
ToAscii(
      UINT uVirtKey,
      UINT uScanCode,
      const BYTE *lpKeyState,
      LPWORD lpChar,
      UINT uFlags);


__declspec(dllimport)
int
__stdcall
ToAsciiEx(
      UINT uVirtKey,
      UINT uScanCode,
      const BYTE *lpKeyState,
      LPWORD lpChar,
      UINT uFlags,
      HKL dwhkl);
#line 5840 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
ToUnicode(
      UINT wVirtKey,
      UINT wScanCode,
      const BYTE *lpKeyState,
      LPWSTR pwszBuff,
      int cchBuff,
      UINT wFlags);

__declspec(dllimport)
DWORD
__stdcall
OemKeyScan(
      WORD wOemChar);

__declspec(dllimport)
SHORT
__stdcall
VkKeyScanA(
      CHAR ch);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanW(
      WCHAR ch);




#line 5873 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExA(
      CHAR ch,
      HKL dwhkl);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExW(
      WCHAR ch,
      HKL dwhkl);




#line 5892 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 5893 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 5899 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
void
__stdcall
keybd_event(
      BYTE bVk,
      BYTE bScan,
      DWORD dwFlags,
      ULONG_PTR dwExtraInfo);

#line 5910 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion













#line 5925 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 5928 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
mouse_event(
      DWORD dwFlags,
      DWORD dx,
      DWORD dy,
      DWORD dwData,
      ULONG_PTR dwExtraInfo);

#line 5945 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



typedef struct tagMOUSEINPUT {
    LONG    dx;
    LONG    dy;
    DWORD   mouseData;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD    wVk;
    WORD    wScan;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, * LPKEYBDINPUT;

#pragma region Desktop Family


typedef struct tagHARDWAREINPUT {
    DWORD   uMsg;
    WORD    wParamL;
    WORD    wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, * LPHARDWAREINPUT;





typedef struct tagINPUT {
    DWORD   type;

    union
    {
        MOUSEINPUT      mi;
        KEYBDINPUT      ki;
        HARDWAREINPUT   hi;
    } ;
} INPUT, *PINPUT, * LPINPUT;

__declspec(dllimport)
UINT
__stdcall
SendInput(
      UINT cInputs,                     
      LPINPUT pInputs,  
      int cbSize);                      

#line 5999 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 6002 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family









struct HTOUCHINPUT__{int unused;}; typedef struct HTOUCHINPUT__ *HTOUCHINPUT;

typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const * PCTOUCHINPUT;


#line 6033 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

























#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetTouchInputInfo(
      HTOUCHINPUT hTouchInput,               
      UINT cInputs,                          
      PTOUCHINPUT pInputs,  
      int cbSize);                           

__declspec(dllimport)
BOOL
__stdcall
CloseTouchInputHandle(
      HTOUCHINPUT hTouchInput);                   


#line 6079 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterTouchWindow(
      HWND hwnd,
      ULONG ulFlags);

__declspec(dllimport)
BOOL
__stdcall
UnregisterTouchWindow(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
IsTouchWindow(
      HWND hwnd,
      PULONG pulFlags);

#line 6112 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 6115 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family




enum tagPOINTER_INPUT_TYPE {
    PT_POINTER  = 1,   
    PT_TOUCH    = 2,   
    PT_PEN      = 3,   
    PT_MOUSE    = 4,   

    PT_TOUCHPAD = 5,   
#line 6131 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
};


typedef DWORD POINTER_INPUT_TYPE;

typedef UINT32 POINTER_FLAGS;

#line 6139 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




























#pragma region Desktop Family


typedef enum tagPOINTER_BUTTON_CHANGE_TYPE {
    POINTER_CHANGE_NONE,
    POINTER_CHANGE_FIRSTBUTTON_DOWN,
    POINTER_CHANGE_FIRSTBUTTON_UP,
    POINTER_CHANGE_SECONDBUTTON_DOWN,
    POINTER_CHANGE_SECONDBUTTON_UP,
    POINTER_CHANGE_THIRDBUTTON_DOWN,
    POINTER_CHANGE_THIRDBUTTON_UP,
    POINTER_CHANGE_FOURTHBUTTON_DOWN,
    POINTER_CHANGE_FOURTHBUTTON_UP,
    POINTER_CHANGE_FIFTHBUTTON_DOWN,
    POINTER_CHANGE_FIFTHBUTTON_UP,
} POINTER_BUTTON_CHANGE_TYPE;

typedef struct tagPOINTER_INFO {
    POINTER_INPUT_TYPE    pointerType;
    UINT32          pointerId;
    UINT32          frameId;
    POINTER_FLAGS   pointerFlags;
    HANDLE          sourceDevice;
    HWND            hwndTarget;
    POINT           ptPixelLocation;
    POINT           ptHimetricLocation;
    POINT           ptPixelLocationRaw;
    POINT           ptHimetricLocationRaw;
    DWORD           dwTime;
    UINT32          historyCount;
    INT32           InputData;
    DWORD           dwKeyStates;
    UINT64          PerformanceCount;
    POINTER_BUTTON_CHANGE_TYPE ButtonChangeType;
} POINTER_INFO;


typedef UINT32 TOUCH_FLAGS;


typedef UINT32 TOUCH_MASK;





typedef struct tagPOINTER_TOUCH_INFO {
    POINTER_INFO    pointerInfo;
    TOUCH_FLAGS     touchFlags;
    TOUCH_MASK      touchMask;
    RECT            rcContact;
    RECT            rcContactRaw;
    UINT32          orientation;
    UINT32          pressure;
} POINTER_TOUCH_INFO;

typedef UINT32 PEN_FLAGS;





typedef UINT32 PEN_MASK;






typedef struct tagPOINTER_PEN_INFO {
    POINTER_INFO    pointerInfo;
    PEN_FLAGS       penFlags;
    PEN_MASK        penMask;
    UINT32          pressure;
    UINT32          rotation;
    INT32           tiltX;
    INT32           tiltY;
} POINTER_PEN_INFO;

#line 6248 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion














































#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
InitializeTouchInjection(
      UINT32 maxCount,
      DWORD dwMode);

__declspec(dllimport)
BOOL
__stdcall
InjectTouchInput(
      UINT32 count,
      const POINTER_TOUCH_INFO *contacts);

typedef struct tagUSAGE_PROPERTIES {
    USHORT level;
    USHORT page;
    USHORT usage;
    INT32 logicalMinimum;
    INT32 logicalMaximum;
    USHORT unit;
    USHORT exponent;
    BYTE   count;
    INT32 physicalMinimum;
    INT32 physicalMaximum;
}USAGE_PROPERTIES, *PUSAGE_PROPERTIES;

typedef struct tagPOINTER_TYPE_INFO {
    POINTER_INPUT_TYPE  type;
    union{
        POINTER_TOUCH_INFO touchInfo;
        POINTER_PEN_INFO   penInfo;
    } ;
}POINTER_TYPE_INFO, *PPOINTER_TYPE_INFO;

typedef struct tagINPUT_INJECTION_VALUE {
    USHORT page;
    USHORT usage;
    INT32  value;
    USHORT index;
}INPUT_INJECTION_VALUE, *PINPUT_INJECTION_VALUE;

__declspec(dllimport)
BOOL
__stdcall
GetPointerType(
      UINT32 pointerId,
      POINTER_INPUT_TYPE *pointerType);

__declspec(dllimport)
BOOL
__stdcall
GetPointerCursorId(
      UINT32 pointerId,
      UINT32 *cursorId);

__declspec(dllimport)
BOOL
__stdcall
GetPointerInfo(
      UINT32 pointerId,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameInfo(
      UINT32 pointerId,
      UINT32 *pointerCount,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      UINT32 *pointerCount,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerTouchInfo(
      UINT32 pointerId,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerTouchInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameTouchInfo(
      UINT32 pointerId,
      UINT32 *pointerCount,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameTouchInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      UINT32 *pointerCount,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerPenInfo(
      UINT32 pointerId,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerPenInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFramePenInfo(
      UINT32 pointerId,
      UINT32 *pointerCount,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFramePenInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      UINT32 *pointerCount,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
SkipPointerFrameMessages(
      UINT32 pointerId);

__declspec(dllimport)
BOOL
__stdcall
RegisterPointerInputTarget(
      HWND hwnd,
      POINTER_INPUT_TYPE pointerType);

__declspec(dllimport)
BOOL
__stdcall
UnregisterPointerInputTarget(
      HWND hwnd,
      POINTER_INPUT_TYPE pointerType);

__declspec(dllimport)
BOOL
__stdcall
RegisterPointerInputTargetEx(
      HWND hwnd,
      POINTER_INPUT_TYPE pointerType,
      BOOL fObserve);

__declspec(dllimport)
BOOL
__stdcall
UnregisterPointerInputTargetEx(
      HWND hwnd,
      POINTER_INPUT_TYPE pointerType);


__declspec(dllimport)
BOOL
__stdcall
EnableMouseInPointer(
      BOOL fEnable);

__declspec(dllimport)
BOOL
__stdcall
IsMouseInPointerEnabled(
    void);


__declspec(dllimport)
BOOL
__stdcall
EnableMouseInPointerForThread();
#line 6504 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
RegisterTouchHitTestingWindow(
      HWND hwnd,
      ULONG value);

typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION
{
    UINT16 score;
    POINT adjustedPoint;
} TOUCH_HIT_TESTING_PROXIMITY_EVALUATION, *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;





typedef struct tagTOUCH_HIT_TESTING_INPUT
{
    UINT32 pointerId;
    POINT point;
    RECT boundingBox;
    RECT nonOccludedBoundingBox;
    UINT32 orientation;
} TOUCH_HIT_TESTING_INPUT, *PTOUCH_HIT_TESTING_INPUT;





__declspec(dllimport)
BOOL
__stdcall
EvaluateProximityToRect(
      const RECT *controlBoundingBox,
      const TOUCH_HIT_TESTING_INPUT *pHitTestingInput,
      TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);

__declspec(dllimport)
BOOL
__stdcall
EvaluateProximityToPolygon(
    UINT32 numVertices,
      const POINT *controlPolygon,
      const TOUCH_HIT_TESTING_INPUT *pHitTestingInput,
      TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);

__declspec(dllimport)
LRESULT
__stdcall
PackTouchHitTestingProximityEvaluation(
      const TOUCH_HIT_TESTING_INPUT *pHitTestingInput,
      const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);


typedef enum tagFEEDBACK_TYPE {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION    = 2,
    FEEDBACK_PEN_TAP                    = 3,
    FEEDBACK_PEN_DOUBLETAP              = 4,
    FEEDBACK_PEN_PRESSANDHOLD           = 5,
    FEEDBACK_PEN_RIGHTTAP               = 6,
    FEEDBACK_TOUCH_TAP                  = 7,
    FEEDBACK_TOUCH_DOUBLETAP            = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD         = 9,
    FEEDBACK_TOUCH_RIGHTTAP             = 10,
    FEEDBACK_GESTURE_PRESSANDTAP        = 11,
    FEEDBACK_MAX                        = 0xFFFFFFFF
} FEEDBACK_TYPE;





__declspec(dllimport)
BOOL
__stdcall
GetWindowFeedbackSetting(
      HWND hwnd,
      FEEDBACK_TYPE feedback,
      DWORD dwFlags,
      UINT32* pSize,
      void* config);

__declspec(dllimport)
BOOL
__stdcall
SetWindowFeedbackSetting(
      HWND hwnd,
      FEEDBACK_TYPE feedback,
      DWORD dwFlags,
      UINT32 size,
      const void* configuration);


#line 6605 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 6608 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family




#pragma warning(push)
#line 6618 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma warning(disable : 4201)

typedef struct tagINPUT_TRANSFORM {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;
        } ;
        float m[4][4];
    } ;
} INPUT_TRANSFORM;


#pragma warning(pop)
#line 6635 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetPointerInputTransform(
      UINT32 pointerId,
      UINT32 historyCount,
      INPUT_TRANSFORM *inputTransform);

#line 6646 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 6649 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


#line 6654 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

__declspec(dllimport)
BOOL
__stdcall
GetLastInputInfo(
      PLASTINPUTINFO plii);
#line 6671 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 6673 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or PC Family


__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyA(
      UINT uCode,
      UINT uMapType);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyW(
      UINT uCode,
      UINT uMapType);




#line 6695 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExA(
      UINT uCode,
      UINT uMapType,
      HKL dwhkl);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExW(
      UINT uCode,
      UINT uMapType,
      HKL dwhkl);




#line 6716 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 6718 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family






#line 6728 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 6731 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetInputState(
    void);

__declspec(dllimport)
DWORD
__stdcall
GetQueueStatus(
      UINT flags);


__declspec(dllimport)
HWND
__stdcall
GetCapture(
    void);

__declspec(dllimport)
HWND
__stdcall
SetCapture(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ReleaseCapture(
    void);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjects(
      DWORD nCount,
      const HANDLE *pHandles,
      BOOL fWaitAll,
      DWORD dwMilliseconds,
      DWORD dwWakeMask);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjectsEx(
      DWORD nCount,
      const HANDLE *pHandles,
      DWORD dwMilliseconds,
      DWORD dwWakeMask,
      DWORD dwFlags);


#line 6785 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




















#line 6807 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 6813 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





















#line 6835 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


















#pragma region Desktop Family






__declspec(dllimport)
UINT_PTR
__stdcall
SetTimer(
      HWND hWnd,
      UINT_PTR nIDEvent,
      UINT uElapse,
      TIMERPROC lpTimerFunc);









__declspec(dllimport)
UINT_PTR
__stdcall
SetCoalescableTimer(
      HWND hWnd,
      UINT_PTR nIDEvent,
      UINT uElapse,
      TIMERPROC lpTimerFunc,
      ULONG uToleranceDelay);

#line 6888 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
KillTimer(
      HWND hWnd,
      UINT_PTR uIDEvent);

__declspec(dllimport)
BOOL
__stdcall
IsWindowUnicode(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
EnableWindow(
      HWND hWnd,
      BOOL bEnable);

__declspec(dllimport)
BOOL
__stdcall
IsWindowEnabled(
      HWND hWnd);

__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsA(
      HINSTANCE hInstance,
      LPCSTR lpTableName);
__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsW(
      HINSTANCE hInstance,
      LPCWSTR lpTableName);




#line 6932 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableA(
      LPACCEL paccel,
      int cAccel);
__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableW(
      LPACCEL paccel,
      int cAccel);




#line 6950 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DestroyAcceleratorTable(
      HACCEL hAccel);

__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableA(
      HACCEL hAccelSrc,
      LPACCEL lpAccelDst,
      int cAccelEntries);
__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableW(
      HACCEL hAccelSrc,
      LPACCEL lpAccelDst,
      int cAccelEntries);




#line 6976 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
int
__stdcall
TranslateAcceleratorA(
      HWND hWnd,
      HACCEL hAccTable,
      LPMSG lpMsg);
__declspec(dllimport)
int
__stdcall
TranslateAcceleratorW(
      HWND hWnd,
      HACCEL hAccTable,
      LPMSG lpMsg);




#line 6998 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7000 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7002 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

















































































#line 7085 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 7092 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 7096 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 7104 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 7107 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 7111 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 7118 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 7123 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 7129 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 7133 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7135 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7137 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7139 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7141 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 7149 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 7153 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 7157 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 7162 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7164 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetSystemMetrics(
      int nIndex);



__declspec(dllimport)
int
__stdcall
GetSystemMetricsForDpi(
      int nIndex,
      UINT dpi);

#line 7185 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7187 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 7190 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
HMENU
__stdcall
LoadMenuA(
      HINSTANCE hInstance,
      LPCSTR lpMenuName);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuW(
      HINSTANCE hInstance,
      LPCWSTR lpMenuName);




#line 7213 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectA(
      const MENUTEMPLATEA *lpMenuTemplate);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectW(
      const MENUTEMPLATEW *lpMenuTemplate);




#line 7229 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
GetMenu(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetMenu(
      HWND hWnd,
      HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
ChangeMenuA(
      HMENU hMenu,
      UINT cmd,
      LPCSTR lpszNewItem,
      UINT cmdInsert,
      UINT flags);
__declspec(dllimport)
BOOL
__stdcall
ChangeMenuW(
      HMENU hMenu,
      UINT cmd,
      LPCWSTR lpszNewItem,
      UINT cmdInsert,
      UINT flags);




#line 7266 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
HiliteMenuItem(
      HWND hWnd,
      HMENU hMenu,
      UINT uIDHiliteItem,
      UINT uHilite);

__declspec(dllimport)
int
__stdcall
GetMenuStringA(
      HMENU hMenu,
      UINT uIDItem,
      LPSTR lpString,
      int cchMax,
      UINT flags);
__declspec(dllimport)
int
__stdcall
GetMenuStringW(
      HMENU hMenu,
      UINT uIDItem,
      LPWSTR lpString,
      int cchMax,
      UINT flags);




#line 7299 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetMenuState(
      HMENU hMenu,
      UINT uId,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DrawMenuBar(
      HWND hWnd);




#line 7318 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
HMENU
__stdcall
GetSystemMenu(
      HWND hWnd,
      BOOL bRevert);


__declspec(dllimport)
HMENU
__stdcall
CreateMenu(
    void);

__declspec(dllimport)
HMENU
__stdcall
CreatePopupMenu(
    void);

__declspec(dllimport)
BOOL
__stdcall
DestroyMenu(
      HMENU hMenu);

__declspec(dllimport)
DWORD
__stdcall
CheckMenuItem(
      HMENU hMenu,
      UINT uIDCheckItem,
      UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
EnableMenuItem(
      HMENU hMenu,
      UINT uIDEnableItem,
      UINT uEnable);

__declspec(dllimport)
HMENU
__stdcall
GetSubMenu(
      HMENU hMenu,
      int nPos);

__declspec(dllimport)
UINT
__stdcall
GetMenuItemID(
      HMENU hMenu,
      int nPos);

__declspec(dllimport)
int
__stdcall
GetMenuItemCount(
      HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
InsertMenuA(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuW(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCWSTR lpNewItem);




#line 7405 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
AppendMenuA(
      HMENU hMenu,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
AppendMenuW(
      HMENU hMenu,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCWSTR lpNewItem);




#line 7427 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ModifyMenuA(
      HMENU hMnu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
ModifyMenuW(
      HMENU hMnu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCWSTR lpNewItem);




#line 7451 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall RemoveMenu(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DeleteMenu(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemBitmaps(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags,
      HBITMAP hBitmapUnchecked,
      HBITMAP hBitmapChecked);

__declspec(dllimport)
LONG
__stdcall
GetMenuCheckMarkDimensions(
    void);

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenu(
      HMENU hMenu,
      UINT uFlags,
      int x,
      int y,
      int nReserved,
      HWND hWnd,
      const RECT *prcRect);








typedef struct tagTPMPARAMS
{
    UINT    cbSize;     
    RECT    rcExclude;  
}   TPMPARAMS;
typedef TPMPARAMS  *LPTPMPARAMS;

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenuEx(
      HMENU hMenu,
      UINT uFlags,
      int x,
      int y,
      HWND hwnd,
      LPTPMPARAMS lptpm);
#line 7520 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
CalculatePopupWindowPosition(
      const POINT *anchorPoint,
      const SIZE *windowSize,
      UINT  flags,
      RECT *excludeRect,
      RECT *popupWindowPosition);

#line 7533 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}   MENUINFO,  *LPMENUINFO;
typedef MENUINFO const  *LPCMENUINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuInfo(
      HMENU,
      LPMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
SetMenuInfo(
      HMENU,
      LPCMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
EndMenu(
        void);







typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;












#line 7609 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 7618 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















#line 7636 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


typedef struct tagMENUITEMINFOA
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         
    UINT     fState;        
    UINT     wID;           
    HMENU    hSubMenu;      
    HBITMAP  hbmpChecked;   
    HBITMAP  hbmpUnchecked; 
    ULONG_PTR dwItemData;   
    LPSTR    dwTypeData;    
    UINT     cch;           

    HBITMAP  hbmpItem;      
#line 7654 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
}   MENUITEMINFOA,  *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         
    UINT     fState;        
    UINT     wID;           
    HMENU    hSubMenu;      
    HBITMAP  hbmpChecked;   
    HBITMAP  hbmpUnchecked; 
    ULONG_PTR dwItemData;   
    LPWSTR   dwTypeData;    
    UINT     cch;           

    HBITMAP  hbmpItem;      
#line 7671 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
}   MENUITEMINFOW,  *LPMENUITEMINFOW;




typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
#line 7679 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
typedef MENUITEMINFOA const  *LPCMENUITEMINFOA;
typedef MENUITEMINFOW const  *LPCMENUITEMINFOW;



typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
#line 7686 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemA(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPCMENUITEMINFOA lpmi);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemW(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPCMENUITEMINFOW lpmi);




#line 7709 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoA(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoW(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPMENUITEMINFOW lpmii);




#line 7731 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoA(
      HMENU hmenu,
      UINT item,
      BOOL fByPositon,
      LPCMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoW(
      HMENU hmenu,
      UINT item,
      BOOL fByPositon,
      LPCMENUITEMINFOW lpmii);




#line 7753 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
UINT
__stdcall
GetMenuDefaultItem(
      HMENU hMenu,
      UINT fByPos,
      UINT gmdiFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuDefaultItem(
      HMENU hMenu,
      UINT uItem,
      UINT fByPos);

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemRect(
      HWND hWnd,
      HMENU hMenu,
      UINT uItem,
      LPRECT lprcItem);

__declspec(dllimport)
int
__stdcall
MenuItemFromPoint(
      HWND hWnd,
      HMENU hMenu,
      POINT ptScreen);
#line 7791 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


















#line 7810 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 7819 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 7822 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 7823 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 7826 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 7829 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 7831 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family






typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    ULONG_PTR dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#line 7854 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion











#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
DragObject(
      HWND hwndParent,
      HWND hwndFrom,
      UINT fmt,
      ULONG_PTR data,
      HCURSOR hcur);

__declspec(dllimport)
BOOL
__stdcall
DragDetect(
      HWND hwnd,
      POINT pt);

#line 7887 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 7890 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawIcon(
      HDC hDC,
      int X,
      int Y,
      HICON hIcon);

#line 7904 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


































#line 7940 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 7941 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS,  *LPDRAWTEXTPARAMS;

#line 7955 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 7958 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family










__declspec(dllimport)
 
int
__stdcall
DrawTextA(
      HDC hdc,
    
    
    LPCSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format);
__declspec(dllimport)
 
int
__stdcall
DrawTextW(
      HDC hdc,
    
    
    LPCWSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format);




#line 8000 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

























#line 8026 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
 
int
__stdcall
DrawTextExA(
      HDC hdc,
    
    
    
    LPSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format,
      LPDRAWTEXTPARAMS lpdtp);
__declspec(dllimport)
 
int
__stdcall
DrawTextExW(
      HDC hdc,
    
    
    
    LPWSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format,
      LPDRAWTEXTPARAMS lpdtp);




#line 8062 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 8063 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 8065 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 8068 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GrayStringA(
      HDC hDC,
      HBRUSH hBrush,
      GRAYSTRINGPROC lpOutputFunc,
      LPARAM lpData,
      int nCount,
      int X,
      int Y,
      int nWidth,
      int nHeight);
__declspec(dllimport)
BOOL
__stdcall
GrayStringW(
      HDC hDC,
      HBRUSH hBrush,
      GRAYSTRINGPROC lpOutputFunc,
      LPARAM lpData,
      int nCount,
      int X,
      int Y,
      int nWidth,
      int nHeight);




#line 8103 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 8105 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


















#line 8125 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawStateA(
      HDC hdc,
      HBRUSH hbrFore,
      DRAWSTATEPROC qfnCallBack,
      LPARAM lData,
      WPARAM wData,
      int x,
      int y,
      int cx,
      int cy,
      UINT uFlags);
__declspec(dllimport)
BOOL
__stdcall
DrawStateW(
      HDC hdc,
      HBRUSH hbrFore,
      DRAWSTATEPROC qfnCallBack,
      LPARAM lData,
      WPARAM wData,
      int x,
      int y,
      int cx,
      int cy,
      UINT uFlags);




#line 8163 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 8165 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 8168 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
LONG
__stdcall
TabbedTextOutA(
      HDC hdc,
      int x,
      int y,
      LPCSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions,
      int nTabOrigin);
__declspec(dllimport)
LONG
__stdcall
TabbedTextOutW(
      HDC hdc,
      int x,
      int y,
      LPCWSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions,
      int nTabOrigin);




#line 8201 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentA(
      HDC hdc,
      LPCSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions);
__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentW(
      HDC hdc,
      LPCWSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions);




#line 8225 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateWindow(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetActiveWindow(
      HWND hWnd);


__declspec(dllimport)
HWND
__stdcall
GetForegroundWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
PaintDesktop(
      HDC hdc);

__declspec(dllimport)
void
__stdcall
SwitchToThisWindow(
      HWND hwnd,
      BOOL fUnknown);
#line 8259 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
SetForegroundWindow(
      HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
AllowSetForegroundWindow(
      DWORD dwProcessId);



__declspec(dllimport)
BOOL
__stdcall
LockSetForegroundWindow(
      UINT uLockCode);




#line 8286 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
WindowFromDC(
      HDC hDC);

__declspec(dllimport)
HDC
__stdcall
GetDC(
      HWND hWnd);

__declspec(dllimport)
HDC
__stdcall
GetDCEx(
      HWND hWnd,
      HRGN hrgnClip,
      DWORD flags);

#line 8308 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


















#pragma region Desktop Family


__declspec(dllimport)
HDC
__stdcall
GetWindowDC(
      HWND hWnd);

__declspec(dllimport)
int
__stdcall
ReleaseDC(
      HWND hWnd,
      HDC hDC);

__declspec(dllimport)
HDC
__stdcall
BeginPaint(
      HWND hWnd,
      LPPAINTSTRUCT lpPaint);

__declspec(dllimport)
BOOL
__stdcall
EndPaint(
      HWND hWnd,
      const PAINTSTRUCT *lpPaint);

__declspec(dllimport)
BOOL
__stdcall
GetUpdateRect(
      HWND hWnd,
      LPRECT lpRect,
      BOOL bErase);

__declspec(dllimport)
int
__stdcall
GetUpdateRgn(
      HWND hWnd,
      HRGN hRgn,
      BOOL bErase);

__declspec(dllimport)
int
__stdcall
SetWindowRgn(
      HWND hWnd,
      HRGN hRgn,
      BOOL bRedraw);

#line 8382 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetWindowRgn(
      HWND hWnd,
      HRGN hRgn);



__declspec(dllimport)
int
__stdcall
GetWindowRgnBox(
      HWND hWnd,
      LPRECT lprc);

#line 8405 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
ExcludeUpdateRgn(
      HDC hDC,
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRect(
      HWND hWnd,
      const RECT *lpRect,
      BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRect(
      HWND hWnd,
      const RECT *lpRect);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRgn(
      HWND hWnd,
      HRGN hRgn,
      BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRgn(
      HWND hWnd,
      HRGN hRgn);


__declspec(dllimport)
BOOL
__stdcall
RedrawWindow(
      HWND hWnd,
      const RECT *lprcUpdate,
      HRGN hrgnUpdate,
      UINT flags);

#line 8454 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion






















#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
LockWindowUpdate(
      HWND hWndLock);

__declspec(dllimport)
BOOL
__stdcall
ScrollWindow(
      HWND hWnd,
      int XAmount,
      int YAmount,
      const RECT *lpRect,
      const RECT *lpClipRect);

__declspec(dllimport)
BOOL
__stdcall
ScrollDC(
      HDC hDC,
      int dx,
      int dy,
      const RECT *lprcScroll,
      const RECT *lprcClip,
      HRGN hrgnUpdate,
      LPRECT lprcUpdate);

__declspec(dllimport)
int
__stdcall
ScrollWindowEx(
      HWND hWnd,
      int dx,
      int dy,
      const RECT *prcScroll,
      const RECT *prcClip,
      HRGN hrgnUpdate,
      LPRECT prcUpdate,
      UINT flags);

#line 8526 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion






#line 8534 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
int
__stdcall
SetScrollPos(
      HWND hWnd,
      int nBar,
      int nPos,
      BOOL bRedraw);

__declspec(dllimport)
int
__stdcall
GetScrollPos(
      HWND hWnd,
      int nBar);

__declspec(dllimport)
BOOL
__stdcall
SetScrollRange(
      HWND hWnd,
      int nBar,
      int nMinPos,
      int nMaxPos,
      BOOL bRedraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollRange(
      HWND hWnd,
      int nBar,
      LPINT lpMinPos,
      LPINT lpMaxPos);

__declspec(dllimport)
BOOL
__stdcall
ShowScrollBar(
      HWND hWnd,
      int wBar,
      BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
EnableScrollBar(
      HWND hWnd,
      UINT wSBflags,
      UINT wArrows);


















#line 8609 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetPropA(
      HWND hWnd,
      LPCSTR lpString,
      HANDLE hData);
__declspec(dllimport)
BOOL
__stdcall
SetPropW(
      HWND hWnd,
      LPCWSTR lpString,
      HANDLE hData);




#line 8629 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
GetPropA(
      HWND hWnd,
      LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
GetPropW(
      HWND hWnd,
      LPCWSTR lpString);




#line 8647 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
RemovePropA(
      HWND hWnd,
      LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
RemovePropW(
      HWND hWnd,
      LPCWSTR lpString);




#line 8665 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsExA(
      HWND hWnd,
      PROPENUMPROCEXA lpEnumFunc,
      LPARAM lParam);
__declspec(dllimport)
int
__stdcall
EnumPropsExW(
      HWND hWnd,
      PROPENUMPROCEXW lpEnumFunc,
      LPARAM lParam);




#line 8685 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsA(
      HWND hWnd,
      PROPENUMPROCA lpEnumFunc);
__declspec(dllimport)
int
__stdcall
EnumPropsW(
      HWND hWnd,
      PROPENUMPROCW lpEnumFunc);




#line 8703 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetWindowTextA(
      HWND hWnd,
      LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetWindowTextW(
      HWND hWnd,
      LPCWSTR lpString);




#line 8721 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

 
__declspec(dllimport)
int
__stdcall
GetWindowTextA(
      HWND hWnd,
      LPSTR lpString,
      int nMaxCount);
 
__declspec(dllimport)
int
__stdcall
GetWindowTextW(
      HWND hWnd,
      LPWSTR lpString,
      int nMaxCount);




#line 8743 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetWindowTextLengthA(
      HWND hWnd);
__declspec(dllimport)
int
__stdcall
GetWindowTextLengthW(
      HWND hWnd);




#line 8759 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetClientRect(
      HWND hWnd,
      LPRECT lpRect);

__declspec(dllimport)
BOOL
__stdcall
GetWindowRect(
      HWND hWnd,
      LPRECT lpRect);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRect(
      LPRECT lpRect,
      DWORD dwStyle,
      BOOL bMenu);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRectEx(
      LPRECT lpRect,
      DWORD dwStyle,
      BOOL bMenu,
      DWORD dwExStyle);


__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRectExForDpi(
      LPRECT lpRect,
      DWORD dwStyle,
      BOOL bMenu,
      DWORD dwExStyle,
      UINT dpi);
#line 8802 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 8805 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagHELPINFO      
{
    UINT    cbSize;             
    int     iContextType;       
    int     iCtrlId;            
    HANDLE  hItemHandle;        
    DWORD_PTR dwContextId;      
    POINT   MousePos;           
}  HELPINFO,  *LPHELPINFO;

__declspec(dllimport)
BOOL
__stdcall
SetWindowContextHelpId(
      HWND,
      DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetWindowContextHelpId(
      HWND);

__declspec(dllimport)
BOOL
__stdcall
SetMenuContextHelpId(
      HMENU,
      DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetMenuContextHelpId(
      HMENU);

#line 8851 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 8854 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 8870 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#line 8882 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 8892 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 8899 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 8910 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 8917 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 8919 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
MessageBoxA(
      HWND hWnd,
      LPCSTR lpText,
      LPCSTR lpCaption,
      UINT uType);
__declspec(dllimport)
int
__stdcall
MessageBoxW(
      HWND hWnd,
      LPCWSTR lpText,
      LPCWSTR lpCaption,
      UINT uType);




#line 8950 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 8974 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxExA(
      HWND hWnd,
      LPCSTR lpText,
      LPCSTR lpCaption,
      UINT uType,
      WORD wLanguageId);
__declspec(dllimport)
int
__stdcall
MessageBoxExW(
      HWND hWnd,
      LPCWSTR lpText,
      LPCWSTR lpCaption,
      UINT uType,
      WORD wLanguageId);




#line 8998 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



typedef void (__stdcall *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;





typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
#line 9038 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxIndirectA(
      const MSGBOXPARAMSA * lpmbp);
__declspec(dllimport)
int
__stdcall
MessageBoxIndirectW(
      const MSGBOXPARAMSW * lpmbp);




#line 9054 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 9055 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 9058 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MessageBeep(
      UINT uType);

#line 9071 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 9074 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
int
__stdcall
ShowCursor(
      BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
SetCursorPos(
      int X,
      int Y);


__declspec(dllimport)
BOOL
__stdcall
SetPhysicalCursorPos(
      int X,
      int Y);
#line 9100 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
SetCursor(
      HCURSOR hCursor);

__declspec(dllimport)
BOOL
__stdcall
GetCursorPos(
      LPPOINT lpPoint);


__declspec(dllimport)
BOOL
__stdcall
GetPhysicalCursorPos(
      LPPOINT lpPoint);
#line 9120 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetClipCursor(
      LPRECT lpRect);

__declspec(dllimport)
HCURSOR
__stdcall
GetCursor(
    void);

__declspec(dllimport)
BOOL
__stdcall
CreateCaret(
      HWND hWnd,
      HBITMAP hBitmap,
      int nWidth,
      int nHeight);

__declspec(dllimport)
UINT
__stdcall
GetCaretBlinkTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetCaretBlinkTime(
      UINT uMSeconds);

__declspec(dllimport)
BOOL
__stdcall
DestroyCaret(
    void);

__declspec(dllimport)
BOOL
__stdcall
HideCaret(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowCaret(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetCaretPos(
      int X,
      int Y);

__declspec(dllimport)
BOOL
__stdcall
GetCaretPos(
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ClientToScreen(
      HWND hWnd,
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ScreenToClient(
      HWND hWnd,
      LPPOINT lpPoint);


__declspec(dllimport)
BOOL
__stdcall
LogicalToPhysicalPoint(
      HWND hWnd,
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
PhysicalToLogicalPoint(
      HWND hWnd,
      LPPOINT lpPoint);

#line 9216 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
LogicalToPhysicalPointForPerMonitorDPI(
      HWND hWnd,
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
PhysicalToLogicalPointForPerMonitorDPI(
      HWND hWnd,
      LPPOINT lpPoint);

#line 9233 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MapWindowPoints(
      HWND hWndFrom,
      HWND hWndTo,
      LPPOINT lpPoints,
      UINT cPoints);

__declspec(dllimport)
HWND
__stdcall
WindowFromPoint(
      POINT Point);


__declspec(dllimport)
HWND
__stdcall
WindowFromPhysicalPoint(
      POINT Point);
#line 9256 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPoint(
      HWND hWndParent,
      POINT Point);

#line 9265 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or PC Family

__declspec(dllimport)
BOOL
__stdcall
ClipCursor(
      const RECT *lpRect);
#line 9275 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPointEx(
      HWND hwnd,
      POINT pt,
      UINT flags);

#line 9295 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 9298 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










































#line 9341 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 9350 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 9351 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 9360 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
GetSysColor(
      int nIndex);


__declspec(dllimport)
HBRUSH
__stdcall
GetSysColorBrush(
      int nIndex);


#line 9380 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetSysColors(
      int cElements,
      const INT * lpaElements,
      const COLORREF * lpaRgbValues);

#line 9390 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 9393 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawFocusRect(
      HDC hDC,
      const RECT * lprc);

__declspec(dllimport)
int
__stdcall
FillRect(
      HDC hDC,
      const RECT *lprc,
      HBRUSH hbr);

__declspec(dllimport)
int
__stdcall
FrameRect(
      HDC hDC,
      const RECT *lprc,
      HBRUSH hbr);

__declspec(dllimport)
BOOL
__stdcall
InvertRect(
      HDC hDC,
      const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
SetRect(
      LPRECT lprc,
      int xLeft,
      int yTop,
      int xRight,
      int yBottom);

__declspec(dllimport)
BOOL
__stdcall
SetRectEmpty(
      LPRECT lprc);

__declspec(dllimport)
BOOL
__stdcall
CopyRect(
      LPRECT lprcDst,
      const RECT *lprcSrc);

__declspec(dllimport)
BOOL
__stdcall
InflateRect(
      LPRECT lprc,
      int dx,
      int dy);

__declspec(dllimport)
BOOL
__stdcall
IntersectRect(
      LPRECT lprcDst,
      const RECT *lprcSrc1,
      const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
UnionRect(
      LPRECT lprcDst,
      const RECT *lprcSrc1,
      const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
SubtractRect(
      LPRECT lprcDst,
      const RECT *lprcSrc1,
      const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
OffsetRect(
      LPRECT lprc,
      int dx,
      int dy);

__declspec(dllimport)
BOOL
__stdcall
IsRectEmpty(
      const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
EqualRect(
      const RECT *lprc1,
      const RECT *lprc2);

__declspec(dllimport)
BOOL
__stdcall
PtInRect(
      const RECT *lprc,
      POINT pt);



__declspec(dllimport)
WORD
__stdcall
GetWindowWord(
      HWND hWnd,
      int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetWindowWord(
      HWND hWnd,
      int nIndex,
      WORD wNewWord);

__declspec(dllimport)
LONG
__stdcall
GetWindowLongA(
      HWND hWnd,
      int nIndex);
__declspec(dllimport)
LONG
__stdcall
GetWindowLongW(
      HWND hWnd,
      int nIndex);




#line 9544 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
SetWindowLongA(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);
__declspec(dllimport)
LONG
__stdcall
SetWindowLongW(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);




#line 9564 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
LONG_PTR
__stdcall
GetWindowLongPtrA(
      HWND hWnd,
      int nIndex);
__declspec(dllimport)
LONG_PTR
__stdcall
GetWindowLongPtrW(
      HWND hWnd,
      int nIndex);




#line 9584 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LONG_PTR
__stdcall
SetWindowLongPtrA(
      HWND hWnd,
      int nIndex,
      LONG_PTR dwNewLong);
__declspec(dllimport)
LONG_PTR
__stdcall
SetWindowLongPtrW(
      HWND hWnd,
      int nIndex,
      LONG_PTR dwNewLong);




#line 9604 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 9624 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
WORD
__stdcall
GetClassWord(
      HWND hWnd,
      int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetClassWord(
      HWND hWnd,
      int nIndex,
      WORD wNewWord);

__declspec(dllimport)
DWORD
__stdcall
GetClassLongA(
      HWND hWnd,
      int nIndex);
__declspec(dllimport)
DWORD
__stdcall
GetClassLongW(
      HWND hWnd,
      int nIndex);




#line 9657 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
SetClassLongA(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);
__declspec(dllimport)
DWORD
__stdcall
SetClassLongW(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);




#line 9677 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
ULONG_PTR
__stdcall
GetClassLongPtrA(
      HWND hWnd,
      int nIndex);
__declspec(dllimport)
ULONG_PTR
__stdcall
GetClassLongPtrW(
      HWND hWnd,
      int nIndex);




#line 9697 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
ULONG_PTR
__stdcall
SetClassLongPtrA(
      HWND hWnd,
      int nIndex,
      LONG_PTR dwNewLong);
__declspec(dllimport)
ULONG_PTR
__stdcall
SetClassLongPtrW(
      HWND hWnd,
      int nIndex,
      LONG_PTR dwNewLong);




#line 9717 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 9737 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 9739 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetProcessDefaultLayout(
      DWORD *pdwDefaultLayout);

__declspec(dllimport)
BOOL
__stdcall
SetProcessDefaultLayout(
      DWORD dwDefaultLayout);
#line 9753 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetDesktopWindow(
    void);


__declspec(dllimport)
HWND
__stdcall
GetParent(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetParent(
      HWND hWndChild,
      HWND hWndNewParent);

__declspec(dllimport)
BOOL
__stdcall
EnumChildWindows(
      HWND hWndParent,
      WNDENUMPROC lpEnumFunc,
      LPARAM lParam);


__declspec(dllimport)
HWND
__stdcall
FindWindowA(
      LPCSTR lpClassName,
      LPCSTR lpWindowName);
__declspec(dllimport)
HWND
__stdcall
FindWindowW(
      LPCWSTR lpClassName,
      LPCWSTR lpWindowName);




#line 9800 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
HWND
__stdcall
FindWindowExA(
      HWND hWndParent,
      HWND hWndChildAfter,
      LPCSTR lpszClass,
      LPCSTR lpszWindow);
__declspec(dllimport)
HWND
__stdcall
FindWindowExW(
      HWND hWndParent,
      HWND hWndChildAfter,
      LPCWSTR lpszClass,
      LPCWSTR lpszWindow);




#line 9823 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetShellWindow(
    void);

#line 9831 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
RegisterShellHookWindow(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
DeregisterShellHookWindow(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
EnumWindows(
      WNDENUMPROC lpEnumFunc,
      LPARAM lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumThreadWindows(
      DWORD dwThreadId,
      WNDENUMPROC lpfn,
      LPARAM lParam);




__declspec(dllimport)
int
__stdcall
GetClassNameA(
      HWND hWnd,
      LPSTR lpClassName,
      int nMaxCount
    );
__declspec(dllimport)
int
__stdcall
GetClassNameW(
      HWND hWnd,
      LPWSTR lpClassName,
      int nMaxCount
    );




#line 9884 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





















#line 9906 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
HWND
__stdcall
GetTopWindow(
      HWND hWnd);





__declspec(dllimport)
DWORD
__stdcall
GetWindowThreadProcessId(
      HWND hWnd,
      LPDWORD lpdwProcessId);


__declspec(dllimport)
BOOL
__stdcall
IsGUIThread(
      BOOL bConvert);

#line 9934 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
HWND
__stdcall
GetLastActivePopup(
      HWND hWnd);












#line 9957 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 9960 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetWindow(
      HWND hWnd,
      UINT uCmd);






__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookA(
      int nFilterType,
      HOOKPROC pfnFilterProc);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookW(
      int nFilterType,
      HOOKPROC pfnFilterProc);




#line 9990 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





















#line 10012 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHook(
      int nCode,
      HOOKPROC pfnFilterProc);

__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExA(
      int idHook,
      HOOKPROC lpfn,
      HINSTANCE hmod,
      DWORD dwThreadId);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExW(
      int idHook,
      HOOKPROC lpfn,
      HINSTANCE hmod,
      DWORD dwThreadId);




#line 10041 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHookEx(
      HHOOK hhk);

__declspec(dllimport)
LRESULT
__stdcall
CallNextHookEx(
      HHOOK hhk,
      int nCode,
      WPARAM wParam,
      LPARAM lParam);










#line 10067 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 10068 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 10070 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








































#line 10112 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10117 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10122 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






















#line 10145 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CheckMenuRadioItem(
      HMENU hmenu,
      UINT first,
      UINT last,
      UINT check,
      UINT flags);
#line 10162 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;


#line 10179 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 10182 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



























#line 10210 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 10214 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 10224 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#pragma region Desktop Family


__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapA(
      HINSTANCE hInstance,
      LPCSTR lpBitmapName);
__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapW(
      HINSTANCE hInstance,
      LPCWSTR lpBitmapName);




#line 10249 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorA(
      HINSTANCE hInstance,
      LPCSTR lpCursorName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorW(
      HINSTANCE hInstance,
      LPCWSTR lpCursorName);




#line 10267 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileA(
      LPCSTR lpFileName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileW(
      LPCWSTR lpFileName);




#line 10283 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
CreateCursor(
      HINSTANCE hInst,
      int xHotSpot,
      int yHotSpot,
      int nWidth,
      int nHeight,
      const void *pvANDPlane,
      const void *pvXORPlane);

__declspec(dllimport)
BOOL
__stdcall
DestroyCursor(
      HCURSOR hCursor);









#line 10311 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 10313 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion



















#line 10334 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 10338 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10343 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetSystemCursor(
      HCURSOR hcur,
      DWORD id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

__declspec(dllimport)
HICON
__stdcall
LoadIconA(
      HINSTANCE hInstance,
      LPCSTR lpIconName);
__declspec(dllimport)
HICON
__stdcall
LoadIconW(
      HINSTANCE hInstance,
      LPCWSTR lpIconName);




#line 10380 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsA(
      LPCSTR szFileName,
      int nIconIndex,
      int cxIcon,
      int cyIcon,
      HICON *phicon,
      UINT *piconid,
      UINT nIcons,
      UINT flags);
__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsW(
      LPCWSTR szFileName,
      int nIconIndex,
      int cxIcon,
      int cyIcon,
      HICON *phicon,
      UINT *piconid,
      UINT nIcons,
      UINT flags);




#line 10411 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIcon(
      HINSTANCE hInstance,
      int nWidth,
      int nHeight,
      BYTE cPlanes,
      BYTE cBitsPixel,
      const BYTE *lpbANDbits,
      const BYTE *lpbXORbits);

__declspec(dllimport)
BOOL
__stdcall
DestroyIcon(
      HICON hIcon);

__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectory(
      PBYTE presbits,
      BOOL fIcon);


__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectoryEx(
      PBYTE presbits,
      BOOL fIcon,
      int cxDesired,
      int cyDesired,
      UINT Flags);
#line 10448 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIconFromResource(
      PBYTE presbits,
      DWORD dwResSize,
      BOOL fIcon,
      DWORD dwVer);


__declspec(dllimport)
HICON
__stdcall
CreateIconFromResourceEx(
      PBYTE presbits,
      DWORD dwResSize,
      BOOL fIcon,
      DWORD dwVer,
      int cxDesired,
      int cyDesired,
      UINT Flags);


typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE,  *LPCURSORSHAPE;
#line 10483 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 10485 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





















#pragma region Desktop Family


__declspec(dllimport)
HANDLE
__stdcall
LoadImageA(
      HINSTANCE hInst,
      LPCSTR name,
      UINT type,
      int cx,
      int cy,
      UINT fuLoad);
__declspec(dllimport)
HANDLE
__stdcall
LoadImageW(
      HINSTANCE hInst,
      LPCWSTR name,
      UINT type,
      int cx,
      int cy,
      UINT fuLoad);




#line 10535 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
CopyImage(
      HANDLE h,
      UINT type,
      int cx,
      int cy,
      UINT flags);








#line 10554 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport) BOOL __stdcall DrawIconEx(
      HDC hdc,
      int xLeft,
      int yTop,
      HICON hIcon,
      int cxWidth,
      int cyWidth,
      UINT istepIfAniCur,
      HBRUSH hbrFlickerFreeDraw,
      UINT diFlags);

#line 10567 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 10570 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HICON
__stdcall
CreateIconIndirect(
      PICONINFO piconinfo);

__declspec(dllimport)
HICON
__stdcall
CopyIcon(
      HICON hIcon);

__declspec(dllimport)
BOOL
__stdcall
GetIconInfo(
      HICON hIcon,
      PICONINFO piconinfo);


typedef struct _ICONINFOEXA {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    CHAR    szModName[260];
    CHAR    szResName[260];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    WCHAR   szModName[260];
    WCHAR   szResName[260];
} ICONINFOEXW, *PICONINFOEXW;




typedef ICONINFOEXA ICONINFOEX;
typedef PICONINFOEXA PICONINFOEX;
#line 10623 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetIconInfoExA(
      HICON hicon,
      PICONINFOEXA piconinfo);
__declspec(dllimport)
BOOL
__stdcall
GetIconInfoExW(
      HICON hicon,
      PICONINFOEXW piconinfo);




#line 10641 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 10642 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10647 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 10649 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


















































































































#line 10765 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 10768 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 10769 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 10775 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 10778 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















































#line 10827 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10832 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10837 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 10838 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





























#line 10868 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 10871 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 10888 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10893 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 10900 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 10910 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"













































#line 10956 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 10961 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 10965 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 10968 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





typedef enum {
    EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT  = 0,
    EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS                       = 1,
} EDIT_CONTROL_FEATURE;
#line 10978 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









































#line 11020 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 11037 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"













#line 11051 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 11054 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 11062 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

























#line 11088 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 11091 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"












#line 11104 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 11121 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11123 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 11143 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#pragma region Desktop Family








__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageA(
      HWND hDlg,
      LPMSG lpMsg);
__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageW(
      HWND hDlg,
      LPMSG lpMsg);




#line 11174 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11176 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
MapDialogRect(
      HWND hDlg,
      LPRECT lpRect);

__declspec(dllimport)
int
__stdcall
DlgDirListA(
      HWND hDlg,
      LPSTR lpPathSpec,
      int nIDListBox,
      int nIDStaticPath,
      UINT uFileType);
__declspec(dllimport)
int
__stdcall
DlgDirListW(
      HWND hDlg,
      LPWSTR lpPathSpec,
      int nIDListBox,
      int nIDStaticPath,
      UINT uFileType);




#line 11207 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11209 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion















#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExA(
      HWND hwndDlg,
      LPSTR lpString,
      int chCount,
      int idListBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExW(
      HWND hwndDlg,
      LPWSTR lpString,
      int chCount,
      int idListBox);




#line 11249 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxA(
      HWND hDlg,
      LPSTR lpPathSpec,
      int nIDComboBox,
      int nIDStaticPath,
      UINT uFiletype);
__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxW(
      HWND hDlg,
      LPWSTR lpPathSpec,
      int nIDComboBox,
      int nIDStaticPath,
      UINT uFiletype);




#line 11273 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExA(
      HWND hwndDlg,
      LPSTR lpString,
      int cchOut,
      int idComboBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExW(
      HWND hwndDlg,
      LPWSTR lpString,
      int cchOut,
      int idComboBox);




#line 11295 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11297 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

























#line 11324 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 11328 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 11336 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


































                                  




























































#line 11432 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 11435 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 11440 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 11450 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11452 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"























#line 11476 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 11482 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"












































#line 11527 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11529 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











































#line 11573 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 11574 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 11578 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#line 11588 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 11589 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




















#line 11610 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 11613 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"














#line 11628 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 11632 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"









#pragma region Desktop Family


typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO,  *LPSCROLLINFO;
typedef SCROLLINFO const  *LPCSCROLLINFO;

__declspec(dllimport)
int
__stdcall
SetScrollInfo(
      HWND hwnd,
      int nBar,
      LPCSCROLLINFO lpsi,
      BOOL redraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollInfo(
      HWND hwnd,
      int nBar,
      LPSCROLLINFO lpsi);


#line 11675 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion
#line 11677 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11679 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 11680 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 11697 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;




typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
#line 11730 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcA(
      HWND hWnd,
      HWND hWndMDIClient,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcW(
      HWND hWnd,
      HWND hWndMDIClient,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);




#line 11759 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)

LRESULT
__stdcall



#line 11768 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
DefMDIChildProcA(
      HWND hWnd,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 11781 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
DefMDIChildProcW(
      HWND hWnd,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);




#line 11791 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
TranslateMDISysAccel(
      HWND hWndClient,
      LPMSG lpMsg);

#line 11802 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
ArrangeIconicWindows(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowA(
      LPCSTR lpClassName,
      LPCSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HINSTANCE hInstance,
      LPARAM lParam);
__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowW(
      LPCWSTR lpClassName,
      LPCWSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HINSTANCE hInstance,
      LPARAM lParam);




#line 11842 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
WORD
__stdcall
TileWindows(
      HWND hwndParent,
      UINT wHow,
      const RECT * lpRect,
      UINT cKids,
      const HWND  * lpKids);

__declspec(dllimport)
WORD
__stdcall CascadeWindows(
      HWND hwndParent,
      UINT wHow,
      const RECT * lpRect,
      UINT cKids,
      const HWND  * lpKids);

#line 11864 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11866 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 11869 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11871 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family




typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {

    DWORD  mkSize;


#line 11886 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {

    DWORD  mkSize;


#line 11895 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;





typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
#line 11907 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;





typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
#line 11935 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





































#line 11973 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
WinHelpA(
      HWND hWndMain,
      LPCSTR lpszHelp,
      UINT uCommand,
      ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
WinHelpW(
      HWND hWndMain,
      LPCWSTR lpszHelp,
      UINT uCommand,
      ULONG_PTR dwData);




#line 11997 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 11999 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 12001 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





#line 12008 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 12012 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 12016 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetGuiResources(
      HANDLE hProcess,
      DWORD uiFlags);
#line 12028 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 12030 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family



#line 12038 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




















































































#line 12124 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 12140 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 12146 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 12162 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 12166 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 12174 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#line 12182 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




























#line 12211 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#pragma region Desktop Family


typedef struct tagTouchPredictionParameters
{
    UINT cbSize;
    UINT dwLatency;       
    UINT dwSampleTime;    
    UINT bUseHWTimeStamp; 
} TOUCHPREDICTIONPARAMETERS, *PTOUCHPREDICTIONPARAMETERS;










#line 12236 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion













#line 12251 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"












































#line 12296 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"













#line 12310 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"








#line 12319 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 12322 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


































#line 12357 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 12364 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 12384 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





    
    

    
#line 12394 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 12395 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



















#line 12415 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 12420 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 12422 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"













#pragma region Desktop Family


typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;

    int     iPaddedBorderWidth;
#line 12458 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;

    int     iPaddedBorderWidth;
#line 12479 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, * LPNONCLIENTMETRICSW;





typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
#line 12489 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 12491 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 12494 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 12495 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#pragma region Desktop Family


typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;



typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;





typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
#line 12549 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 12550 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 12551 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;




typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
#line 12585 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;




typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
#line 12611 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 12613 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion






















#line 12637 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\tvout.h"











#pragma once
#line 14 "E:\\sdk\\include\\10.0.16299.0\\shared\\tvout.h"





#pragma region Desktop Family


typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         
    ULONG dwOffset;                     
    ULONG dwCommand;                    
    ULONG dwFlags;                      
    ULONG dwMode;                       
    ULONG dwTVStandard;                 
    ULONG dwAvailableModes;             
    ULONG dwAvailableTVStandard;        
    ULONG dwFlickerFilter;              
    ULONG dwOverScanX;                  
    ULONG dwOverScanY;                  
    ULONG dwMaxUnscaledX;               
    ULONG dwMaxUnscaledY;               
    ULONG dwPositionX;                  
    ULONG dwPositionY;                  
    ULONG dwBrightness;                 
    ULONG dwContrast;                   
    ULONG dwCPType;                     
    ULONG dwCPCommand;                  
    ULONG dwCPStandard;                 
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;           
    UCHAR bOEMCopyProtection[256];      
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;


                                        












































#line 95 "E:\\sdk\\include\\10.0.16299.0\\shared\\tvout.h"
#pragma endregion

#line 98 "E:\\sdk\\include\\10.0.16299.0\\shared\\tvout.h"
#line 12642 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#line 12654 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family





__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsA(
      DEVMODEA* lpDevMode,
      DWORD dwFlags);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsW(
      DEVMODEW* lpDevMode,
      DWORD dwFlags);




#line 12678 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExA(
      LPCSTR lpszDeviceName,
      DEVMODEA* lpDevMode,
      HWND hwnd,
      DWORD dwflags,
      LPVOID lParam);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExW(
      LPCWSTR lpszDeviceName,
      DEVMODEW* lpDevMode,
      HWND hwnd,
      DWORD dwflags,
      LPVOID lParam);




#line 12702 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsA(
      LPCSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEA* lpDevMode);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsW(
      LPCWSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEW* lpDevMode);




#line 12726 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExA(
      LPCSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEA* lpDevMode,
      DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExW(
      LPCWSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEW* lpDevMode,
      DWORD dwFlags);




#line 12750 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesA(
      LPCSTR lpDevice,
      DWORD iDevNum,
      PDISPLAY_DEVICEA lpDisplayDevice,
      DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesW(
      LPCWSTR lpDevice,
      DWORD iDevNum,
      PDISPLAY_DEVICEW lpDisplayDevice,
      DWORD dwFlags);




#line 12776 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 12781 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
LONG
__stdcall
GetDisplayConfigBufferSizes(
      UINT32 flags,
      UINT32* numPathArrayElements,
      UINT32* numModeInfoArrayElements);

__declspec(dllimport)
LONG
__stdcall
SetDisplayConfig(
      UINT32 numPathArrayElements,
      DISPLAYCONFIG_PATH_INFO* pathArray,
      UINT32 numModeInfoArrayElements,
      DISPLAYCONFIG_MODE_INFO* modeInfoArray,
      UINT32 flags);

__declspec(dllimport)
  LONG
__stdcall
QueryDisplayConfig(
      UINT32 flags,
      UINT32* numPathArrayElements,
      DISPLAYCONFIG_PATH_INFO* pathArray,
      UINT32* numModeInfoArrayElements,
      DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    
    
        DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);

__declspec(dllimport)
LONG
__stdcall
DisplayConfigGetDeviceInfo(
      DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);

__declspec(dllimport)
LONG
__stdcall
DisplayConfigSetDeviceInfo(
      DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);

#line 12828 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 12831 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 12832 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
 
BOOL
__stdcall
SystemParametersInfoA(
      UINT uiAction,
      UINT uiParam,
        PVOID pvParam,
      UINT fWinIni);
__declspec(dllimport)
 
BOOL
__stdcall
SystemParametersInfoW(
      UINT uiAction,
      UINT uiParam,
        PVOID pvParam,
      UINT fWinIni);




#line 12857 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
 
BOOL
__stdcall
SystemParametersInfoForDpi(
      UINT uiAction,
      UINT uiParam,
        PVOID pvParam,
      UINT fWinIni,
      UINT dpi);

#line 12872 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 12874 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 12877 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            
    DWORD iDelayMSec;           
    DWORD iRepeatMSec;          
    DWORD iBounceMSec;          
} FILTERKEYS, *LPFILTERKEYS;

#line 12895 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion












#pragma region Desktop Family


typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

#line 12918 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion






























#line 12950 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

#line 12966 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


















#line 12986 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

#line 12998 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion
























#pragma region Desktop Family


typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;




typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
#line 13063 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 13065 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#pragma region Desktop or PC Family


__declspec(dllimport)
BOOL
__stdcall
SoundSentry(void);
#line 13082 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 13083 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family

typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

#line 13094 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion











#pragma region Desktop Family



typedef struct tagAUDIODESCRIPTION {
    UINT cbSize;   
    BOOL Enabled;  
    LCID Locale;   
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;
#line 13116 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






__declspec(dllimport)
void
__stdcall
SetDebugErrorLevel(
      DWORD dwLevel);

#line 13129 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
SetLastErrorEx(
      DWORD dwErrCode,
      DWORD dwType);

__declspec(dllimport)
int
__stdcall
InternalGetWindowText(
      HWND hWnd,
      LPWSTR pString,
      int cchMaxCount);










#line 13167 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CancelShutdown(
    void);

#line 13175 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion












#pragma region Desktop Family


__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromPoint(
      POINT pt,
      DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromRect(
      LPCRECT lprc,
      DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromWindow(
      HWND hwnd,
      DWORD dwFlags);

#line 13213 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;


typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;




typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#line 13248 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


















#line 13267 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoA(
      HMONITOR hMonitor,
      LPMONITORINFO lpmi);
__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoW(
      HMONITOR hMonitor,
      LPMONITORINFO lpmi);




#line 13285 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

typedef BOOL (__stdcall* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDisplayMonitors(
      HDC hdc,
      LPCRECT lprcClip,
      MONITORENUMPROC lpfnEnum,
      LPARAM dwData);

#line 13298 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family






__declspec(dllimport)
void
__stdcall
NotifyWinEvent(
      DWORD event,
      HWND  hwnd,
      LONG  idObject,
      LONG  idChild);

typedef void (__stdcall* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime);

__declspec(dllimport)
HWINEVENTHOOK
__stdcall
SetWinEventHook(
      DWORD eventMin,
      DWORD eventMax,
      HMODULE hmodWinEventProc,
      WINEVENTPROC pfnWinEventProc,
      DWORD idProcess,
      DWORD idThread,
      DWORD dwFlags);


__declspec(dllimport)
BOOL
__stdcall
IsWinEventHookInstalled(
      DWORD event);
#line 13347 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 13349 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UnhookWinEvent(
      HWINEVENTHOOK hWinEventHook);

#line 13369 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion















































































































































































































#line 13578 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
















#line 13595 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"















#line 13611 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"













#line 13625 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

















#line 13643 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 13650 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 13654 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






































































































































































































#line 13853 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#line 13857 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










































































#line 13932 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






#line 13939 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"






































#pragma region Desktop Family


typedef struct tagGUITHREADINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HWND    hwndActive;
    HWND    hwndFocus;
    HWND    hwndCapture;
    HWND    hwndMenuOwner;
    HWND    hwndMoveSize;
    HWND    hwndCaret;
    RECT    rcCaret;
} GUITHREADINFO, *PGUITHREADINFO,  * LPGUITHREADINFO;

#line 13994 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion











#line 14007 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 14008 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetGUIThreadInfo(
      DWORD idThread,
      PGUITHREADINFO pgui);

__declspec(dllimport)
BOOL
__stdcall
BlockInput(
    BOOL fBlockIt);





__declspec(dllimport)
BOOL
__stdcall
SetProcessDPIAware(
    void);

__declspec(dllimport)
BOOL
__stdcall
IsProcessDPIAware(
    void);

#line 14042 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
DPI_AWARENESS_CONTEXT
__stdcall
SetThreadDpiAwarenessContext(
      DPI_AWARENESS_CONTEXT dpiContext);

__declspec(dllimport)
DPI_AWARENESS_CONTEXT
__stdcall
GetThreadDpiAwarenessContext(
    void);

__declspec(dllimport)
DPI_AWARENESS_CONTEXT
__stdcall
GetWindowDpiAwarenessContext(
      HWND hwnd);

__declspec(dllimport)
DPI_AWARENESS
__stdcall
GetAwarenessFromDpiAwarenessContext(
      DPI_AWARENESS_CONTEXT value);

__declspec(dllimport)
BOOL
__stdcall
AreDpiAwarenessContextsEqual(
      DPI_AWARENESS_CONTEXT dpiContextA,
      DPI_AWARENESS_CONTEXT dpiContextB);

__declspec(dllimport)
BOOL
__stdcall
IsValidDpiAwarenessContext(
      DPI_AWARENESS_CONTEXT value);

__declspec(dllimport)
UINT
__stdcall
GetDpiForWindow(
      HWND hwnd);

__declspec(dllimport)
UINT
__stdcall
GetDpiForSystem(
    void);

__declspec(dllimport)
BOOL
__stdcall
EnableNonClientDpiScaling(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
InheritWindowMonitor(
      HWND hwnd,
      HWND hwndInherit);

#line 14107 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
SetProcessDpiAwarenessContext(
      DPI_AWARENESS_CONTEXT value);

#line 14116 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameA(
      HWND hwnd,
      LPSTR pszFileName,
      UINT cchFileNameMax);
__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameW(
      HWND hwnd,
      LPWSTR pszFileName,
      UINT cchFileNameMax);




#line 14137 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 14139 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


































#line 14175 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#pragma region Desktop Family





typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;




#line 14197 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetCursorInfo(
      PCURSORINFO pci);




typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;



__declspec(dllimport)
BOOL
__stdcall
GetWindowInfo(
      HWND hwnd,
      PWINDOWINFO pwi);




typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetTitleBarInfo(
      HWND hwnd,
      PTITLEBARINFO pti);


typedef struct tagTITLEBARINFOEX
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
    RECT rgrect[5 + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;
#line 14256 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          
    HMENU hMenu;         
    HWND hwndMenu;       
    BOOL fBarFocused:1;  
    BOOL fFocused:1;     
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuBarInfo(
      HWND hwnd,
      LONG idObject,
      LONG idItem,
      PMENUBARINFO pmbi);




typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetScrollBarInfo(
      HWND hwnd,
      LONG idObject,
      PSCROLLBARINFO psbi);




typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

__declspec(dllimport)
BOOL
__stdcall
GetComboBoxInfo(
      HWND hwndCombo,
      PCOMBOBOXINFO pcbi);

#line 14323 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
GetAncestor(
      HWND hwnd,
      UINT gaFlags);








__declspec(dllimport)
HWND
__stdcall
RealChildWindowFromPoint(
      HWND hwndParent,
      POINT ptParentClientCoords);






__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassA(
      HWND hwnd,
      LPSTR ptszClassName,
      UINT cchClassNameMax);




__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassW(
      HWND hwnd,
      LPWSTR ptszClassName,
      UINT cchClassNameMax);




#line 14384 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoA(
      HWND hwnd,
      int iItem,
      PALTTABINFO pati,
      LPSTR pszItemText,
      UINT cchItemText);
__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoW(
      HWND hwnd,
      int iItem,
      PALTTABINFO pati,
      LPWSTR pszItemText,
      UINT cchItemText);




#line 14424 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
DWORD
__stdcall
GetListBoxInfo(
      HWND hwnd);

#line 14436 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 14439 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 14440 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
LockWorkStation(
    void);
#line 14452 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
UserHandleGrantAccess(
      HANDLE hUserHandle,
      HANDLE hJob,
      BOOL   bGrant);

#line 14464 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 14466 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


struct HRAWINPUT__{int unused;}; typedef struct HRAWINPUT__ *HRAWINPUT;

#line 14480 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion























#pragma region Desktop Family





typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

#line 14518 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









#pragma region Desktop Family




#pragma warning(push)
#line 14535 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma warning(disable : 4201)




typedef struct tagRAWMOUSE {
    


    USHORT usFlags;

    


    union {
        ULONG ulButtons;
        struct  {
            USHORT  usButtonFlags;
            USHORT  usButtonData;
        } ;
    } ;


    


    ULONG ulRawButtons;

    


    LONG lLastX;

    


    LONG lLastY;

    


    ULONG ulExtraInformation;

} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;


#pragma warning(pop)
#line 14583 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 14585 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion































#line 14618 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 14629 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagRAWKEYBOARD {
    


    USHORT MakeCode;

    



    USHORT Flags;

    USHORT Reserved;

    


    USHORT VKey;
    UINT   Message;

    


    ULONG ExtraInformation;


} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;

#line 14665 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

















#pragma region Desktop Family





typedef struct tagRAWHID {
    DWORD dwSizeHid;    
    DWORD dwCount;      
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;

#line 14696 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE    mouse;
        RAWKEYBOARD keyboard;
        RAWHID      hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;

#line 14715 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





#line 14722 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetRawInputData(
      HRAWINPUT hRawInput,
      UINT uiCommand,
      LPVOID pData,
      PUINT pcbSize,
      UINT cbSizeHeader);

#line 14746 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL  fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;

typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;

typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;

    


    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;

typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    } ;
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;

__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceInfoA(
      HANDLE hDevice,
      UINT uiCommand,
      LPVOID pData,
      PUINT pcbSize);
__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceInfoW(
      HANDLE hDevice,
      UINT uiCommand,
      LPVOID pData,
      PUINT pcbSize);




#line 14817 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





__declspec(dllimport)
UINT
__stdcall
GetRawInputBuffer(
      PRAWINPUT pData,
      PUINT pcbSize,
      UINT cbSizeHeader);




typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage; 
    USHORT usUsage;     
    DWORD dwFlags;
    HWND hwndTarget;    
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;

#line 14843 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion












#line 14857 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"










#line 14868 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 14874 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterRawInputDevices(
      PCRAWINPUTDEVICE pRawInputDevices,
      UINT uiNumDevices,
      UINT cbSize);

__declspec(dllimport)
UINT
__stdcall
GetRegisteredRawInputDevices(
      PRAWINPUTDEVICE pRawInputDevices,
      PUINT puiNumDevices,
      UINT cbSize);


typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;

__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceList(
      PRAWINPUTDEVICELIST pRawInputDeviceList,
      PUINT puiNumDevices,
      UINT cbSize);

__declspec(dllimport)
LRESULT
__stdcall
DefRawInputProc(
      PRAWINPUT* paRawInput,
      INT nInput,
      UINT cbSizeHeader);

#line 14917 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 14920 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





















#pragma region Desktop Family


typedef enum tagPOINTER_DEVICE_TYPE {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN   = 0x00000002,
    POINTER_DEVICE_TYPE_TOUCH          = 0x00000003,

    POINTER_DEVICE_TYPE_TOUCH_PAD      = 0x00000004,
#line 14951 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
    POINTER_DEVICE_TYPE_MAX            = 0xFFFFFFFF
} POINTER_DEVICE_TYPE;

typedef struct tagPOINTER_DEVICE_INFO {
    DWORD displayOrientation;
    HANDLE device;
    POINTER_DEVICE_TYPE pointerDeviceType;
    HMONITOR monitor;
    ULONG startingCursorId;
    USHORT maxActiveContacts;
    WCHAR productString[520];
} POINTER_DEVICE_INFO;

typedef struct tagPOINTER_DEVICE_PROPERTY {
    INT32 logicalMin;
    INT32 logicalMax;
    INT32 physicalMin;
    INT32 physicalMax;
    UINT32 unit;
    UINT32 unitExponent;
    USHORT usagePageId;
    USHORT usageId;
} POINTER_DEVICE_PROPERTY;

typedef enum tagPOINTER_DEVICE_CURSOR_TYPE {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN   = 0x00000000,
    POINTER_DEVICE_CURSOR_TYPE_TIP       = 0x00000001,
    POINTER_DEVICE_CURSOR_TYPE_ERASER    = 0x00000002,
    POINTER_DEVICE_CURSOR_TYPE_MAX       = 0xFFFFFFFF
} POINTER_DEVICE_CURSOR_TYPE;

typedef struct tagPOINTER_DEVICE_CURSOR_INFO {
    UINT32 cursorId;
    POINTER_DEVICE_CURSOR_TYPE cursor;
} POINTER_DEVICE_CURSOR_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetPointerDevices(
      UINT32* deviceCount,
      POINTER_DEVICE_INFO *pointerDevices);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDevice(
      HANDLE device,
      POINTER_DEVICE_INFO *pointerDevice);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDeviceProperties(
      HANDLE device,
      UINT32* propertyCount,
      POINTER_DEVICE_PROPERTY *pointerProperties);

__declspec(dllimport)
BOOL
__stdcall
RegisterPointerDeviceNotifications(
      HWND window,
      BOOL notifyRange);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDeviceRects(
      HANDLE device,
      RECT* pointerDeviceRect,
      RECT* displayRect);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDeviceCursors(
      HANDLE device,
      UINT32* cursorCount,
      POINTER_DEVICE_CURSOR_INFO *deviceCursors);

__declspec(dllimport)
BOOL
__stdcall
GetRawPointerDeviceData(
      UINT32 pointerId,
      UINT32 historyCount,
      UINT32 propertiesCount,
      POINTER_DEVICE_PROPERTY* pProperties,
      LONG* pValues);


#line 15044 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 15047 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ChangeWindowMessageFilter(
      UINT message,
      DWORD dwFlag);

#line 15069 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 15072 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"











#pragma region Desktop Family


typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;

#line 15092 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ChangeWindowMessageFilterEx(
      HWND hwnd,                                         
      UINT message,                                      
      DWORD action,                                      
      PCHANGEFILTERSTRUCT pChangeFilterStruct);   

#line 15114 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 15117 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#line 15120 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#pragma region Desktop Family





struct HGESTUREINFO__{int unused;}; typedef struct HGESTUREINFO__ *HGESTUREINFO;

#line 15136 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




















#pragma region Desktop Family










typedef struct tagGESTUREINFO {
    UINT cbSize;                    
    DWORD dwFlags;                  
    DWORD dwID;                     
    HWND hwndTarget;                
    POINTS ptsLocation;             
    DWORD dwInstanceID;             
    DWORD dwSequenceID;             
    ULONGLONG ullArguments;         
    UINT cbExtraArgs;               
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const * PCGESTUREINFO;









typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize;                    
    DWORD dwFlags;                  
    HWND hwndTarget;                
    POINTS ptsLocation;             
    DWORD dwInstanceID;             
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;













__declspec(dllimport)
BOOL
__stdcall
GetGestureInfo(
      HGESTUREINFO hGestureInfo,
      PGESTUREINFO pGestureInfo);







__declspec(dllimport)
BOOL
__stdcall
GetGestureExtraArgs(
      HGESTUREINFO hGestureInfo,
      UINT cbExtraArgs,
      PBYTE pExtraArgs);











__declspec(dllimport)
BOOL
__stdcall
CloseGestureInfoHandle(
      HGESTUREINFO hGestureInfo);









typedef struct tagGESTURECONFIG {
    DWORD dwID;                     
    DWORD dwWant;                   
    DWORD dwBlock;                  
} GESTURECONFIG, *PGESTURECONFIG;

#line 15261 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion









































                                                        

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetGestureConfig(
      HWND hwnd,                                     
      DWORD dwReserved,                              
      UINT cIDs,                                     
      PGESTURECONFIG pGestureConfig,    
                                                        
      UINT cbSize);                                  



                                                        

__declspec(dllimport)
BOOL
__stdcall
GetGestureConfig(
      HWND hwnd,                                     
      DWORD dwReserved,                              
      DWORD dwFlags,                                 
      PUINT pcIDs,                                   
                                                        
      PGESTURECONFIG pGestureConfig,
                                                        
      UINT cbSize);                                  

#line 15337 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion


#line 15341 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"














#line 15356 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonCreate(
      HWND hWnd,
      LPCWSTR pwszReason);

__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonQuery(
      HWND hWnd,
      LPWSTR pwszBuff,
      DWORD *pcchBuff);

__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonDestroy(
      HWND hWnd);

#line 15385 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family





typedef enum tagINPUT_MESSAGE_DEVICE_TYPE  {
    IMDT_UNAVAILABLE        = 0x00000000,       
    IMDT_KEYBOARD           = 0x00000001,       
    IMDT_MOUSE              = 0x00000002,       
    IMDT_TOUCH              = 0x00000004,       
    IMDT_PEN                = 0x00000008,       

    IMDT_TOUCHPAD           = 0x00000010,       
#line 15405 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
 } INPUT_MESSAGE_DEVICE_TYPE;

typedef enum tagINPUT_MESSAGE_ORIGIN_ID {
     IMO_UNAVAILABLE = 0x00000000,  
     IMO_HARDWARE    = 0x00000001,  
     IMO_INJECTED    = 0x00000002,  
     IMO_SYSTEM      = 0x00000004,  
} INPUT_MESSAGE_ORIGIN_ID;




 typedef struct tagINPUT_MESSAGE_SOURCE {
     INPUT_MESSAGE_DEVICE_TYPE deviceType;
     INPUT_MESSAGE_ORIGIN_ID   originId;
 } INPUT_MESSAGE_SOURCE;





__declspec(dllimport)
BOOL
__stdcall
GetCurrentInputMessageSource(
      INPUT_MESSAGE_SOURCE *inputMessageSource);

__declspec(dllimport)
BOOL
__stdcall
GetCIMSSM(
      INPUT_MESSAGE_SOURCE *inputMessageSource);

#line 15439 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 15442 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Application Family or OneCore Family





typedef enum tagAR_STATE {
    AR_ENABLED        = 0x0,
    AR_DISABLED       = 0x1,
    AR_SUPPRESSED     = 0x2,
    AR_REMOTESESSION  = 0x4,
    AR_MULTIMON       = 0x8,
    AR_NOSENSOR       = 0x10,
    AR_NOT_SUPPORTED  = 0x20,
    AR_DOCKED         = 0x40,
    AR_LAPTOP         = 0x80
} AR_STATE, *PAR_STATE;

#line 15464 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion





extern "C++" { inline constexpr AR_STATE operator | (AR_STATE a, AR_STATE b) throw() { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator |= (AR_STATE &a, AR_STATE b) throw() { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline constexpr AR_STATE operator & (AR_STATE a, AR_STATE b) throw() { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator &= (AR_STATE &a, AR_STATE b) throw() { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline constexpr AR_STATE operator ~ (AR_STATE a) throw() { return AR_STATE(~((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a)); } inline constexpr AR_STATE operator ^ (AR_STATE a, AR_STATE b) throw() { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator ^= (AR_STATE &a, AR_STATE b) throw() { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } }
#line 15472 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#pragma region Desktop Family






typedef enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE              = 0x0,
    ORIENTATION_PREFERENCE_LANDSCAPE         = 0x1,
    ORIENTATION_PREFERENCE_PORTRAIT          = 0x2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED  = 0x8
} ORIENTATION_PREFERENCE;






extern "C++" { inline constexpr ORIENTATION_PREFERENCE operator | (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw() { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator |= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) throw() { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline constexpr ORIENTATION_PREFERENCE operator & (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw() { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator &= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) throw() { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline constexpr ORIENTATION_PREFERENCE operator ~ (ORIENTATION_PREFERENCE a) throw() { return ORIENTATION_PREFERENCE(~((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)); } inline constexpr ORIENTATION_PREFERENCE operator ^ (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw() { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator ^= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) throw() { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } }
#line 15495 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetAutoRotationState(
      PAR_STATE pState);

__declspec(dllimport)
BOOL
__stdcall
GetDisplayAutoRotationPreferences(
      ORIENTATION_PREFERENCE *pOrientation);

__declspec(dllimport)
BOOL
__stdcall
GetDisplayAutoRotationPreferencesByProcessId(
      DWORD dwProcessId,
      ORIENTATION_PREFERENCE *pOrientation,
      BOOL *fRotateScreen);

__declspec(dllimport)
BOOL
__stdcall
SetDisplayAutoRotationPreferences(
      ORIENTATION_PREFERENCE orientation);

#line 15523 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 15526 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"



#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
IsImmersiveProcess(
      HANDLE hProcess);

__declspec(dllimport)
BOOL
__stdcall
SetProcessRestrictionExemption(
      BOOL fEnableExemption);

#line 15546 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#pragma endregion

#line 15549 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


#pragma region Desktop Family



#line 15556 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"







#pragma warning(pop)
#line 15565 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"





#line 15571 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"
#line 15572 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"


}
#line 15576 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"

#line 15578 "E:\\sdk\\include\\10.0.16299.0\\um\\winuser.h"




#line 175 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"























extern "C" {
#line 26 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"
 












#pragma once
#line 16 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"
























#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"

#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"



extern "C" {
#line 48 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"







#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
int
__stdcall
GetDateFormatA(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpDate,
      LPCSTR lpFormat,
      LPSTR lpDateStr,
      int cchDate
    );


__declspec(dllimport)
int
__stdcall
GetDateFormatW(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpDate,
      LPCWSTR lpFormat,
      LPWSTR lpDateStr,
      int cchDate
    );





#line 90 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"



__declspec(dllimport)
int
__stdcall
GetTimeFormatA(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpTime,
      LPCSTR lpFormat,
      LPSTR lpTimeStr,
      int cchTime
    );


__declspec(dllimport)
int
__stdcall
GetTimeFormatW(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpTime,
      LPCWSTR lpFormat,
      LPWSTR lpTimeStr,
      int cchTime
    );





#line 123 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"

#line 125 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"
#pragma endregion








#pragma region Application Family or OneCore Family



__declspec(dllimport)
int
__stdcall
GetTimeFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      const SYSTEMTIME * lpTime,
      LPCWSTR lpFormat,
      LPWSTR lpTimeStr,
      int cchTime
    );


__declspec(dllimport)
int
__stdcall
GetDateFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      const SYSTEMTIME * lpDate,
      LPCWSTR lpFormat,
      LPWSTR lpDateStr,
      int cchDate,
      LPCWSTR lpCalendar
    );


#line 166 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"
#pragma endregion

#line 169 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"







#pragma region Desktop Family or OneCore Family





__declspec(dllimport)
int
__stdcall
GetDurationFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      const SYSTEMTIME * lpDuration,
      ULONGLONG ullDuration,
      LPCWSTR lpFormat,
      LPWSTR lpDurationStr,
      int cchDuration
    );


#line 197 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"
#pragma endregion

#line 200 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"








}
#line 210 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"


#line 213 "E:\\sdk\\include\\10.0.16299.0\\um\\datetimeapi.h"





#line 31 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 33 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#pragma warning(push)
#pragma warning(disable:4820) 
#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"










#line 50 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


















#line 69 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 71 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




#pragma region Application Family or OneCore Family










#line 87 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"









































































#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 165 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


























































































#line 256 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"








#line 265 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


















#line 284 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"










































#line 327 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 331 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"












































#line 376 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


















































































































































































#line 555 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




#line 560 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"














#line 575 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 579 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"































































































#line 675 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"









#line 685 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



















#line 705 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



                                                   
                                                   
                                                   
                                                   









#line 722 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 726 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




#line 731 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"















#line 747 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


























#line 774 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"





#line 780 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"































#line 812 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 816 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 820 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



























#line 848 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 852 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
























































#line 909 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"









#line 919 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




#line 924 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#line 928 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




#line 933 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



































































































#line 1033 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




















typedef DWORD LGRPID;




typedef DWORD LCTYPE;




typedef DWORD CALTYPE;





typedef DWORD CALID;











typedef struct _cpinfo {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
} CPINFO, *LPCPINFO;



typedef struct _cpinfoexA {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
    WCHAR   UnicodeDefaultChar;             
    UINT    CodePage;                       
    CHAR    CodePageName[260];         
} CPINFOEXA, *LPCPINFOEXA;

typedef struct _cpinfoexW {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
    WCHAR   UnicodeDefaultChar;             
    UINT    CodePage;                       
    WCHAR   CodePageName[260];         
} CPINFOEXW, *LPCPINFOEXW;




typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;
#line 1113 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"






typedef struct _numberfmtA {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPSTR   lpDecimalSep;              
    LPSTR   lpThousandSep;             
    UINT    NegativeOrder;             
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPWSTR  lpDecimalSep;              
    LPWSTR  lpThousandSep;             
    UINT    NegativeOrder;             
} NUMBERFMTW, *LPNUMBERFMTW;




typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
#line 1142 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"






typedef struct _currencyfmtA {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPSTR   lpDecimalSep;              
    LPSTR   lpThousandSep;             
    UINT    NegativeOrder;             
    UINT    PositiveOrder;             
    LPSTR   lpCurrencySymbol;          
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPWSTR  lpDecimalSep;              
    LPWSTR  lpThousandSep;             
    UINT    NegativeOrder;             
    UINT    PositiveOrder;             
    LPWSTR  lpCurrencySymbol;          
} CURRENCYFMTW, *LPCURRENCYFMTW;




typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
#line 1175 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"





enum SYSNLS_FUNCTION{
    COMPARE_STRING    =  0x0001,
};
typedef DWORD NLS_FUNCTION;














typedef struct _nlsversioninfo{
    DWORD dwNLSVersionInfoSize;     
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;         
    DWORD dwEffectiveId;            
    GUID  guidCustomVersion;        
} NLSVERSIONINFO, *LPNLSVERSIONINFO;













#line 1219 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




typedef struct _nlsversioninfoex{
    DWORD dwNLSVersionInfoSize;     
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;         
    DWORD dwEffectiveId;            
    GUID  guidCustomVersion;        
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;




typedef DWORD   GEOTYPE;
typedef DWORD   GEOCLASS;












typedef LONG    GEOID;





#line 1255 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"





enum SYSGEOTYPE {
    GEO_NATION      =       0x0001, 
    GEO_LATITUDE    =       0x0002,
    GEO_LONGITUDE   =       0x0003,
    GEO_ISO2        =       0x0004,
    GEO_ISO3        =       0x0005,
    GEO_RFC1766     =       0x0006, 
    GEO_LCID        =       0x0007, 
    GEO_FRIENDLYNAME=       0x0008,
    GEO_OFFICIALNAME=       0x0009,
    GEO_TIMEZONES   =       0x000A, 
    GEO_OFFICIALLANGUAGES = 0x000B, 
    GEO_ISO_UN_NUMBER =     0x000C,
    GEO_PARENT      =       0x000D,
    GEO_DIALINGCODE =       0x000E,
    GEO_CURRENCYCODE=       0x000F, 
    GEO_CURRENCYSYMBOL=     0x0010, 

    GEO_NAME        =       0x0011, 
    GEO_ID          =       0x0012  
#line 1281 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
};





enum SYSGEOCLASS {
    GEOCLASS_NATION  = 16,
    GEOCLASS_REGION  = 14,
    GEOCLASS_ALL = 0
};






typedef enum _NORM_FORM {
    NormalizationOther  = 0,       
    NormalizationC      = 0x1,     
    NormalizationD      = 0x2,     
    NormalizationKC     = 0x5,     
                                   
    NormalizationKD     = 0x6      
                                   
} NORM_FORM;













#line 1321 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"







typedef BOOL (__stdcall* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);    
typedef BOOL (__stdcall* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);          
typedef BOOL (__stdcall* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);                             
typedef BOOL (__stdcall* CODEPAGE_ENUMPROCA)(LPSTR);                                         
typedef BOOL (__stdcall* DATEFMT_ENUMPROCA)(LPSTR);                                          
typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);                                 
typedef BOOL (__stdcall* TIMEFMT_ENUMPROCA)(LPSTR);                                          
typedef BOOL (__stdcall* CALINFO_ENUMPROCA)(LPSTR);                                          
typedef BOOL (__stdcall* CALINFO_ENUMPROCEXA)(LPSTR, CALID);                                 
typedef BOOL (__stdcall* LOCALE_ENUMPROCA)(LPSTR);                                           
typedef BOOL (__stdcall* LOCALE_ENUMPROCW)(LPWSTR);                                          
typedef BOOL (__stdcall* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);  
typedef BOOL (__stdcall* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);         
typedef BOOL (__stdcall* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (__stdcall* CODEPAGE_ENUMPROCW)(LPWSTR);            
typedef BOOL (__stdcall* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall* GEO_ENUMPROC)(GEOID);                   

typedef BOOL (__stdcall* GEO_ENUMNAMEPROC)(PWSTR, LPARAM);
#line 1352 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




























#line 1381 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



























#line 1409 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"






typedef struct _FILEMUIINFO {
    DWORD       dwSize;                 
    DWORD       dwVersion;              
    DWORD       dwFileType;             
    BYTE        pChecksum[16];          
    BYTE        pServiceChecksum[16];   
    DWORD       dwLanguageNameOffset;   
    DWORD       dwTypeIDMainSize;       
    DWORD       dwTypeIDMainOffset;     
    DWORD       dwTypeNameMainOffset;   
    DWORD       dwTypeIDMUISize;        
    DWORD       dwTypeIDMUIOffset;      
    DWORD       dwTypeNameMUIOffset;    
    BYTE        abBuffer[8];             
} FILEMUIINFO, *PFILEMUIINFO;


#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"







#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"












#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"

#line 36 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"



extern "C" {
#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"




#pragma region Application or OneCore Family



__declspec(dllimport)
int
__stdcall
CompareStringEx(
      LPCWSTR lpLocaleName,
      DWORD dwCmpFlags,
      LPCWCH lpString1,
      int cchCount1,
      LPCWCH lpString2,
      int cchCount2,
      LPNLSVERSIONINFO lpVersionInformation,
      LPVOID lpReserved,
      LPARAM lParam
    );


__declspec(dllimport)
int
__stdcall
CompareStringOrdinal(
      LPCWCH lpString1,
      int cchCount1,
      LPCWCH lpString2,
      int cchCount2,
      BOOL bIgnoreCase
    );


#line 78 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"
#pragma endregion

#line 81 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"

#pragma region Desktop or OneCore Family



__declspec(dllimport)
int
__stdcall
CompareStringW(
      LCID Locale,
      DWORD dwCmpFlags,
      PCNZWCH lpString1,
      int cchCount1,
      PCNZWCH lpString2,
      int cchCount2
    );





__declspec(dllimport)
int
__stdcall
FoldStringW(
      DWORD dwMapFlags,
      LPCWCH lpSrcStr,
      int cchSrc,
      LPWSTR lpDestStr,
      int cchDest
    );





#line 118 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"
#pragma endregion

#pragma region Application or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExW(
      LCID Locale,
      DWORD dwInfoType,
      LPCWCH lpSrcStr,
      int cchSrc,
      LPWORD lpCharType
    );





__declspec(dllimport)
BOOL
__stdcall
GetStringTypeW(
      DWORD dwInfoType,
      LPCWCH lpSrcStr,
      int cchSrc,
      LPWORD lpCharType
    );







__declspec(dllimport)
 
         
int
__stdcall
MultiByteToWideChar(
      UINT CodePage,
      DWORD dwFlags,
      LPCCH lpMultiByteStr,
      int cbMultiByte,
      LPWSTR lpWideCharStr,
      int cchWideChar
    );


__declspec(dllimport)
 
         
int
__stdcall
WideCharToMultiByte(
      UINT CodePage,
      DWORD dwFlags,
      LPCWCH lpWideCharStr,
      int cchWideChar,
      LPSTR lpMultiByteStr,
      int cbMultiByte,
      LPCCH lpDefaultChar,
      LPBOOL lpUsedDefaultChar
    );


#line 188 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"
#pragma endregion


}
#line 193 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"


#line 196 "E:\\sdk\\include\\10.0.16299.0\\um\\stringapiset.h"
#line 1433 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#line 1434 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


































































__declspec(dllimport)
BOOL
__stdcall
IsValidCodePage(
      UINT  CodePage);

__declspec(dllimport)
UINT
__stdcall
GetACP(void);

#line 1512 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetOEMCP(void);

#line 1523 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or Pc Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetCPInfo(
      UINT       CodePage,
      LPCPINFO  lpCPInfo);


__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExA(
      UINT          CodePage,
      DWORD         dwFlags,
      LPCPINFOEXA  lpCPInfoEx);

__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExW(
      UINT          CodePage,
      DWORD         dwFlags,
      LPCPINFOEXW  lpCPInfoEx);




#line 1557 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 1559 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or OneCore Family







__declspec(dllimport)
int
__stdcall
CompareStringA(
      LCID     Locale,
      DWORD    dwCmpFlags,
      PCNZCH lpString1,
      int      cchCount1,
      PCNZCH  lpString2,
      int      cchCount2);



#line 1583 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



























#line 1611 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




__declspec(dllimport)
int
__stdcall
FindNLSString(
                         LCID Locale,
                         DWORD dwFindNLSStringFlags,
       LPCWSTR lpStringSource,
                         int cchSource,
        LPCWSTR lpStringValue,
                         int cchValue,
                    LPINT pcchFound);

#line 1628 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
LCMapStringW(
      LCID     Locale,
      DWORD    dwMapFlags,
      LPCWSTR  lpSrcStr,
      int      cchSrc,
      LPWSTR  lpDestStr,
      int      cchDest);





__declspec(dllimport)
int
__stdcall
LCMapStringA(
      LCID     Locale,
      DWORD    dwMapFlags,
      LPCSTR  lpSrcStr,
      int      cchSrc,
      LPSTR  lpDestStr,
      int      cchDest);


#line 1658 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 1660 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
int
__stdcall
GetLocaleInfoW(
      LCID     Locale,
      LCTYPE   LCType,
      LPWSTR lpLCData,
      int      cchData);
    





__declspec(dllimport)
int 
__stdcall 
GetLocaleInfoA(
      LCID Locale,
      LCTYPE LCType,
      LPSTR lpLCData,
      int cchData
    );



#line 1693 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 1695 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoA(
      LCID     Locale,
      LCTYPE   LCType,
      LPCSTR  lpLCData);
__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoW(
      LCID     Locale,
      LCTYPE   LCType,
      LPCWSTR  lpLCData);




#line 1719 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




__declspec(dllimport)
int
__stdcall
GetCalendarInfoA(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPSTR   lpCalData,
      int      cchData,
      LPDWORD  lpValue);

__declspec(dllimport)
int
__stdcall
GetCalendarInfoW(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPWSTR   lpCalData,
      int      cchData,
      LPDWORD  lpValue);




#line 1749 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoA(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPCSTR  lpCalData);
__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoW(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPCWSTR  lpCalData);




#line 1771 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#line 1772 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 1774 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family











        
__declspec(dllimport)                                
BOOL                                      
__stdcall                                    
LoadStringByReference(                    
            DWORD   Flags,             
            PCWSTR  Language,      
            PCWSTR  SourceString,      
        PWSTR   Buffer,     
            ULONG  cchBuffer,                      
        PCWSTR  Directory,                     
       PULONG  pcchBufferOut                  
    );                                                
#line 1802 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


#line 1805 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)         
BOOL               
__stdcall             
IsDBCSLeadByte(    
      BYTE  TestChar 
    );


__declspec(dllimport)
BOOL
__stdcall
IsDBCSLeadByteEx(
      UINT  CodePage,
      BYTE  TestChar
    );




__declspec(dllimport)
int
__stdcall
LCIDToLocaleName(
      LCID     Locale,
      LPWSTR  lpName,
      int      cchName,
      DWORD    dwFlags);



__declspec(dllimport)
LCID
__stdcall
LocaleNameToLCID(
      LPCWSTR lpName,
      DWORD dwFlags);

#line 1849 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 1851 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
int
__stdcall
GetDurationFormat(
      LCID             Locale,
      DWORD            dwFlags,
      const SYSTEMTIME *lpDuration,
      ULONGLONG ullDuration,
      LPCWSTR          lpFormat,
      LPWSTR          lpDurationStr,
      int              cchDuration);
#line 1870 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 1872 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
int
__stdcall
GetNumberFormatA(
      LCID             Locale,
      DWORD            dwFlags,
      LPCSTR          lpValue,
      const NUMBERFMTA *lpFormat,
      LPSTR          lpNumberStr,
      int              cchNumber);

__declspec(dllimport)
int
__stdcall
GetNumberFormatW(
      LCID             Locale,
      DWORD            dwFlags,
      LPCWSTR          lpValue,
      const NUMBERFMTW *lpFormat,
      LPWSTR          lpNumberStr,
      int              cchNumber);




#line 1904 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
GetCurrencyFormatA(
      LCID               Locale,
      DWORD              dwFlags,
      LPCSTR            lpValue,
      const CURRENCYFMTA *lpFormat,
      LPSTR            lpCurrencyStr,
      int                cchCurrency);

__declspec(dllimport)
int
__stdcall
GetCurrencyFormatW(
      LCID               Locale,
      DWORD              dwFlags,
      LPCWSTR            lpValue,
      const CURRENCYFMTW *lpFormat,
      LPWSTR            lpCurrencyStr,
      int                cchCurrency);




#line 1932 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoA(
      CALINFO_ENUMPROCA lpCalInfoEnumProc,
      LCID              Locale,
      CALID             Calendar,
      CALTYPE           CalType);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoW(
      CALINFO_ENUMPROCW lpCalInfoEnumProc,
      LCID              Locale,
      CALID             Calendar,
      CALTYPE           CalType);




#line 1956 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExA(
      CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
      LCID                Locale,
      CALID               Calendar,
      CALTYPE             CalType);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExW(
      CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
      LCID                Locale,
      CALID               Calendar,
      CALTYPE             CalType);




#line 1981 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#line 1982 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsA(
      TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsW(
      TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);




#line 2004 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsA(
      DATEFMT_ENUMPROCA lpDateFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsW(
      DATEFMT_ENUMPROCW lpDateFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);




#line 2026 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExA(
      DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
      LCID                Locale,
      DWORD               dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExW(
      DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
      LCID                Locale,
      DWORD               dwFlags);




#line 2049 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#line 2050 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
IsValidLanguageGroup(
      LGRPID  LanguageGroup,
      DWORD   dwFlags);
#line 2060 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
GetNLSVersion(
         NLS_FUNCTION     Function,
         LCID             Locale,
      LPNLSVERSIONINFO lpVersionInformation);

__declspec(dllimport)
BOOL
__stdcall
IsNLSDefinedString(
      NLS_FUNCTION     Function,
      DWORD            dwFlags,
      LPNLSVERSIONINFO lpVersionInformation,
      LPCWSTR          lpString,
      INT              cchStr);


__declspec(dllimport)
BOOL
__stdcall
IsValidLocale(
      LCID   Locale,
      DWORD  dwFlags);

#line 2089 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
int
__stdcall
GetGeoInfoA(
      GEOID       Location,
      GEOTYPE     GeoType,
      LPSTR     lpGeoData,
      int         cchData,
      LANGID      LangId);

__declspec(dllimport)
int
__stdcall
GetGeoInfoW(
      GEOID       Location,
      GEOTYPE     GeoType,
      LPWSTR     lpGeoData,
      int         cchData,
      LANGID      LangId);




#line 2119 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
GetGeoInfoEx(
      PWSTR       location,
      GEOTYPE     geoType,
      PWSTR    geoData,
      int         geoDataCount);
#line 2130 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2132 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
EnumSystemGeoID(
      GEOCLASS        GeoClass,
      GEOID           ParentGeoId,
      GEO_ENUMPROC    lpGeoEnumProc);


__declspec(dllimport)
BOOL
__stdcall
EnumSystemGeoNames(
      GEOCLASS            geoClass,
      GEO_ENUMNAMEPROC    geoEnumProc,
      LPARAM          data);
#line 2155 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2157 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion


#pragma region Application Family or OneCore Family



__declspec(dllimport)
GEOID
__stdcall
GetUserGeoID(
      GEOCLASS    GeoClass);

__declspec(dllimport)
int
__stdcall
GetUserDefaultGeoName(
      LPWSTR geoName,
      int geoNameCount
);

#line 2179 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
SetUserGeoID(
      GEOID       GeoId);



__declspec(dllimport)
BOOL
__stdcall
SetUserGeoName(
      PWSTR       geoName);
#line 2200 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
LCID
__stdcall
ConvertDefaultLocale(
      LCID   Locale);

__declspec(dllimport)
LCID
__stdcall
GetThreadLocale(void);

__declspec(dllimport)
BOOL
__stdcall
SetThreadLocale(
      LCID  Locale
    );



__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultUILanguage(void);

#line 2228 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultUILanguage(void);
#line 2239 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultLangID(void);

#line 2247 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultLangID(void);


__declspec(dllimport)
LCID
__stdcall
GetSystemDefaultLCID(void);


__declspec(dllimport)
LCID
__stdcall
GetUserDefaultLCID(void);

#line 2271 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family



#line 2278 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
LANGID
__stdcall
SetThreadUILanguage(  LANGID LangId);




__declspec(dllimport)
LANGID
__stdcall
GetThreadUILanguage(void);

__declspec(dllimport)
BOOL
__stdcall
GetProcessPreferredUILanguages(
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
SetProcessPreferredUILanguages(
             DWORD dwFlags,
         PCZZWSTR pwszLanguagesBuffer,
        PULONG pulNumLanguages
);

#line 2317 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#line 2318 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or Phone Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetUserPreferredUILanguages (
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);

#line 2335 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2337 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetSystemPreferredUILanguages (
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
GetThreadPreferredUILanguages(
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
SetThreadPreferredUILanguages(
             DWORD dwFlags,
         PCZZWSTR pwszLanguagesBuffer,
        PULONG pulNumLanguages
);

__declspec(dllimport)
 
BOOL
__stdcall
GetFileMUIInfo(
                        DWORD           dwFlags,
                     PCWSTR          pcwszFilePath,
      PFILEMUIINFO    pFileMUIInfo,
                  DWORD*          pcbFileMUIInfo);

__declspec(dllimport)
BOOL
__stdcall
GetFileMUIPath(
      DWORD      dwFlags,
      PCWSTR     pcwszFilePath ,
        PWSTR pwszLanguage,
      PULONG  pcchLanguage,
      PWSTR pwszFileMUIPath,
              PULONG pcchFileMUIPath,
              PULONGLONG pululEnumerator
);


__declspec(dllimport)
BOOL
__stdcall
GetUILanguageInfo(
      DWORD dwFlags,
      PCZZWSTR pwmszLanguage,
      PZZWSTR pwszFallbackLanguages,
      PDWORD pcchFallbackLanguages,
      PDWORD pAttributes
);

#line 2411 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2413 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
NotifyUILanguageChange(
             DWORD dwFlags,
         PCWSTR pcwstrNewLanguage,
         PCWSTR pcwstrPreviousLanguage,
             DWORD dwReserved,
        PDWORD pdwStatusRtrn
);

#line 2432 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2434 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion






#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExA(
                      LCID       Locale,
                      DWORD      dwInfoType,
        LPCSTR   lpSrcStr,
                      int        cchSrc,
      LPWORD     lpCharType);


#line 2456 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2458 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family













__declspec(dllimport)
BOOL
__stdcall
GetStringTypeA(
      LCID     Locale,
      DWORD    dwInfoType,
      LPCSTR   lpSrcStr,
      int      cchSrc,
      LPWORD  lpCharType);

__declspec(dllimport)
int
__stdcall
FoldStringA(
      DWORD    dwMapFlags,
      LPCSTR  lpSrcStr,
      int      cchSrc,
      LPSTR  lpDestStr,
      int      cchDest);


#line 2496 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesA(
      LOCALE_ENUMPROCA lpLocaleEnumProc,
      DWORD            dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesW(
      LOCALE_ENUMPROCW lpLocaleEnumProc,
      DWORD            dwFlags);




#line 2518 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2520 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"




__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsA(
      LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
      DWORD                   dwFlags,
      LONG_PTR                lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsW(
      LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
      DWORD                   dwFlags,
      LONG_PTR                lParam);




#line 2544 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesA(
      LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
      LGRPID                    LanguageGroup,
      DWORD                     dwFlags,
      LONG_PTR                  lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesW(
      LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
      LGRPID                    LanguageGroup,
      DWORD                     dwFlags,
      LONG_PTR                  lParam);




#line 2568 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2570 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesA(
      UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
      DWORD                dwFlags,
      LONG_PTR             lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesW(
      UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
      DWORD                dwFlags,
      LONG_PTR             lParam);




#line 2596 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2598 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2600 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesA(
      CODEPAGE_ENUMPROCA lpCodePageEnumProc,
      DWORD              dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesW(
      CODEPAGE_ENUMPROCW lpCodePageEnumProc,
      DWORD              dwFlags);




#line 2624 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2626 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion





#pragma region Application Family or OneCore Family




__declspec(dllimport)
int
__stdcall NormalizeString(                            NORM_FORM NormForm,
                               LPCWSTR   lpSrcString,
                                                   int       cwSrcLength,
                          LPWSTR    lpDstString,
                                                   int       cwDstLength );

__declspec(dllimport)
BOOL
__stdcall IsNormalizedString(                     NORM_FORM NormForm,
                              LPCWSTR   lpString,
                                               int       cwLength );


#line 2653 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"






__declspec(dllimport)
int
__stdcall IdnToAscii(                            DWORD    dwFlags,
                    	 LPCWSTR  lpUnicodeCharStr,
                                           	 int      cchUnicodeChar,
                    LPWSTR   lpASCIICharStr,
                                           	 int      cchASCIIChar);

#line 2668 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



__declspec(dllimport)
int
__stdcall IdnToNameprepUnicode(                             	DWORD   dwFlags,
                                  	LPCWSTR lpUnicodeCharStr,
                                                         	int     cchUnicodeChar,
                                LPWSTR  lpNameprepCharStr,
                                                         	int     cchNameprepChar);

#line 2680 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



__declspec(dllimport)
int
__stdcall IdnToUnicode(                          	 DWORD   dwFlags,
                         	 LPCWSTR lpASCIICharStr,
                                              	 int     cchASCIIChar,
                      LPWSTR  lpUnicodeCharStr,
                                              	 int     cchUnicodeChar);

#line 2692 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall VerifyScripts(
         DWORD   dwFlags,            
         LPCWSTR lpLocaleScripts,    
         int     cchLocaleScripts,   
         LPCWSTR lpTestScripts,      
         int     cchTestScripts);    

__declspec(dllimport)
int
__stdcall GetStringScripts(
                                  DWORD   dwFlags,        
                                  LPCWSTR lpString,       
                                  int     cchString,      
          LPWSTR  lpScripts,      
                                  int     cchScripts);    

#line 2714 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2716 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion



#pragma region Application Family or OneCore Family










__declspec(dllimport)
int
__stdcall
GetLocaleInfoEx(
      LPCWSTR lpLocaleName,
      LCTYPE LCType,
      LPWSTR lpLCData,
      int cchData
);

#line 2742 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


__declspec(dllimport)
int
__stdcall
GetCalendarInfoEx(
      LPCWSTR lpLocaleName,
      CALID Calendar,
      LPCWSTR lpReserved,
      CALTYPE CalType,
      LPWSTR lpCalData,
      int cchData,
      LPDWORD lpValue
);

#line 2761 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family

















#line 2782 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
int
__stdcall
GetNumberFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPCWSTR lpValue,
      const NUMBERFMTW *lpFormat,
      LPWSTR lpNumberStr,
      int cchNumber
);

__declspec(dllimport)
int
__stdcall
GetCurrencyFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPCWSTR lpValue,
      const CURRENCYFMTW *lpFormat,
      LPWSTR lpCurrencyStr,
      int cchCurrency
);

__declspec(dllimport)
int
__stdcall
GetUserDefaultLocaleName(
      LPWSTR lpLocaleName,
      int cchLocaleName
);

#line 2820 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


__declspec(dllimport)
int
__stdcall
GetSystemDefaultLocaleName(
      LPWSTR lpLocaleName,
      int cchLocaleName
);

__declspec(dllimport)
BOOL
__stdcall
GetNLSVersionEx(
     	    NLS_FUNCTION function,
         LPCWSTR lpLocaleName,
     	    LPNLSVERSIONINFOEX lpVersionInformation
);


__declspec(dllimport)
DWORD
__stdcall
IsValidNLSVersion(
             NLS_FUNCTION function,
         LPCWSTR lpLocaleName,
             LPNLSVERSIONINFOEX lpVersionInformation
);
#line 2852 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 2854 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
int
__stdcall
FindNLSStringEx(
      LPCWSTR lpLocaleName,
      DWORD dwFindNLSStringFlags,
      LPCWSTR lpStringSource,
      int cchSource,
      LPCWSTR lpStringValue,
      int cchValue,
      LPINT pcchFound,
      LPNLSVERSIONINFO lpVersionInformation,
      LPVOID lpReserved,
      LPARAM sortHandle
);





#line 2880 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
LCMapStringEx(
      LPCWSTR lpLocaleName,
      DWORD dwMapFlags,
      LPCWSTR lpSrcStr,
      int cchSrc,
      LPWSTR lpDestStr,
      int cchDest,
      LPNLSVERSIONINFO lpVersionInformation,
      LPVOID lpReserved,
      LPARAM sortHandle
);

__declspec(dllimport)
BOOL
__stdcall
IsValidLocaleName(
      LPCWSTR lpLocaleName
);
#line 2904 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


typedef BOOL (__stdcall* CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExEx(
      CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx,
      LPCWSTR lpLocaleName,
      CALID Calendar,
      LPCWSTR lpReserved,
      CALTYPE CalType,
      LPARAM lParam
);

typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExEx(
      DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx,
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPARAM lParam
);

typedef BOOL (__stdcall* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsEx(
      TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx,
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPARAM lParam
);

typedef BOOL (__stdcall* LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesEx(
      LOCALE_ENUMPROCEX lpLocaleEnumProcEx,
      DWORD dwFlags,
      LPARAM lParam,
      LPVOID lpReserved
);

#line 2960 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#line 2963 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"



#pragma region Application Family or OneCore Family


__declspec(dllimport)
int
__stdcall
ResolveLocaleName(
                             LPCWSTR lpNameToResolve,
      LPWSTR  lpLocaleName,
                                 int     cchLocaleName
);

#line 2979 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#line 2982 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#pragma region Desktop Family


    
#line 2988 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"
#pragma endregion

#line 2991 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"






#pragma warning(pop)
#line 2999 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


}
#line 3003 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"


#line 3006 "E:\\sdk\\include\\10.0.16299.0\\um\\winnls.h"

#line 177 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 178 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"


























#pragma once


extern "C" {
#line 32 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"



#line 41 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#pragma region Application Family


typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

#line 51 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

#line 64 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Application Family


typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;






















typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;




















#line 129 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

#line 154 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion











#pragma region Desktop Family or OneCore Family


typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

#line 178 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion























#pragma region Desktop Family or OneCore Family


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

typedef struct _CONSOLE_FONT_INFO {
    DWORD  nFont;
    COORD  dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;


typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[32];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
#line 245 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"



typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

#line 256 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion



#pragma region Desktop Family


typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

#line 270 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion










#line 282 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#pragma region Application Family






typedef
BOOL
(__stdcall *PHANDLER_ROUTINE)(
      DWORD CtrlType
    );

#line 297 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion


































#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputW(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsRead
    );




__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputA(
      HANDLE hConsoleInput,
      const INPUT_RECORD *lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputW(
      HANDLE hConsoleInput,
      const INPUT_RECORD *lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsWritten
    );




#line 375 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputA(
      HANDLE hConsoleOutput,
      PCHAR_INFO lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpReadRegion
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputW(
      HANDLE hConsoleOutput,
      PCHAR_INFO lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpReadRegion
    );




#line 401 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputA(
      HANDLE hConsoleOutput,
      const CHAR_INFO *lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpWriteRegion
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputW(
      HANDLE hConsoleOutput,
      const CHAR_INFO *lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpWriteRegion
    );




#line 427 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterA(
      HANDLE hConsoleOutput,
      LPSTR lpCharacter,
      DWORD nLength,
      COORD dwReadCoord,
      LPDWORD lpNumberOfCharsRead
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterW(
      HANDLE hConsoleOutput,
      LPWSTR lpCharacter,
      DWORD nLength,
      COORD dwReadCoord,
      LPDWORD lpNumberOfCharsRead
    );




#line 453 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputAttribute(
      HANDLE hConsoleOutput,
      LPWORD lpAttribute,
      DWORD nLength,
      COORD dwReadCoord,
      LPDWORD lpNumberOfAttrsRead
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterA(
      HANDLE hConsoleOutput,
      LPCSTR lpCharacter,
      DWORD nLength,
      COORD dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterW(
      HANDLE hConsoleOutput,
      LPCWSTR lpCharacter,
      DWORD nLength,
      COORD dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );




#line 490 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputAttribute(
      HANDLE hConsoleOutput,
      const WORD *lpAttribute,
      DWORD nLength,
      COORD dwWriteCoord,
      LPDWORD lpNumberOfAttrsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterA(
      HANDLE hConsoleOutput,
      CHAR  cCharacter,
      DWORD  nLength,
      COORD  dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterW(
      HANDLE hConsoleOutput,
      WCHAR  cCharacter,
      DWORD  nLength,
      COORD  dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );




#line 527 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputAttribute(
      HANDLE hConsoleOutput,
      WORD   wAttribute,
      DWORD  nLength,
      COORD  dwWriteCoord,
      LPDWORD lpNumberOfAttrsWritten
    );




__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfo(
      HANDLE hConsoleOutput,
      PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfoEx(
      HANDLE hConsoleOutput,
      PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferInfoEx(
      HANDLE hConsoleOutput,
      PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

__declspec(dllimport)
COORD
__stdcall
GetLargestConsoleWindowSize(
      HANDLE hConsoleOutput
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleCursorInfo(
      HANDLE hConsoleOutput,
      PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );

#line 580 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFont(
      HANDLE hConsoleOutput,
      BOOL bMaximumWindow,
      PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );


__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFontEx(
      HANDLE hConsoleOutput,
      BOOL bMaximumWindow,
      PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

__declspec(dllimport)
BOOL
__stdcall
SetCurrentConsoleFontEx(
      HANDLE hConsoleOutput,
      BOOL bMaximumWindow,
      PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
#line 613 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
GetConsoleHistoryInfo(
      PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

__declspec(dllimport)
BOOL
__stdcall
SetConsoleHistoryInfo(
      PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

__declspec(dllimport)
COORD
__stdcall
GetConsoleFontSize(
      HANDLE hConsoleOutput,
      DWORD nFont
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleSelectionInfo(
      PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );

#line 642 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleMouseButtons(
      LPDWORD lpNumberOfMouseButtons
    );

#line 651 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetConsoleActiveScreenBuffer(
      HANDLE hConsoleOutput
    );

__declspec(dllimport)
BOOL
__stdcall
FlushConsoleInputBuffer(
      HANDLE hConsoleInput
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferSize(
      HANDLE hConsoleOutput,
      COORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorPosition(
      HANDLE hConsoleOutput,
      COORD dwCursorPosition
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorInfo(
      HANDLE hConsoleOutput,
      const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );

__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferA(
      HANDLE hConsoleOutput,
      const SMALL_RECT *lpScrollRectangle,
      const SMALL_RECT *lpClipRectangle,
      COORD dwDestinationOrigin,
      const CHAR_INFO *lpFill
    );
__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferW(
      HANDLE hConsoleOutput,
      const SMALL_RECT *lpScrollRectangle,
      const SMALL_RECT *lpClipRectangle,
      COORD dwDestinationOrigin,
      const CHAR_INFO *lpFill
    );




#line 719 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleWindowInfo(
      HANDLE hConsoleOutput,
      BOOL bAbsolute,
      const SMALL_RECT *lpConsoleWindow
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTextAttribute(
      HANDLE hConsoleOutput,
      WORD wAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
GenerateConsoleCtrlEvent(
      DWORD dwCtrlEvent,
      DWORD dwProcessGroupId);

__declspec(dllimport)
BOOL
__stdcall
FreeConsole(
    void);


__declspec(dllimport)
BOOL
__stdcall
AttachConsole(
      DWORD dwProcessId);



#line 760 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleA(
      LPSTR lpConsoleTitle,
      DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleW(
      LPWSTR lpConsoleTitle,
      DWORD nSize
    );




#line 780 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 782 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetConsoleOriginalTitleA(
      LPSTR lpConsoleTitle,
      DWORD nSize);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleOriginalTitleW(
      LPWSTR lpConsoleTitle,
      DWORD nSize);




#line 805 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#line 806 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 808 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleA(
      LPCSTR lpConsoleTitle
    );
__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleW(
      LPCWSTR lpConsoleTitle
    );




#line 830 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 832 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Application Family


typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;

#line 845 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion




#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"
 









#pragma once
#line 13 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"





















#line 35 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"



extern "C" {
#line 42 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
AllocConsole(
    void
    );


__declspec(dllimport)
UINT
__stdcall
GetConsoleCP(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
GetConsoleMode(
      HANDLE hConsoleHandle,
      LPDWORD lpMode
    );


__declspec(dllimport)
UINT
__stdcall
GetConsoleOutputCP(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleInputEvents(
      HANDLE hConsoleInput,
      LPDWORD lpNumberOfEvents
    );


__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputA(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsRead
    );




#line 103 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleA(
      HANDLE hConsoleInput,
      LPVOID lpBuffer,
      DWORD nNumberOfCharsToRead,
        LPDWORD lpNumberOfCharsRead,
      PCONSOLE_READCONSOLE_CONTROL pInputControl
    );

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleW(
      HANDLE hConsoleInput,
      LPVOID lpBuffer,
      DWORD nNumberOfCharsToRead,
        LPDWORD lpNumberOfCharsRead,
      PCONSOLE_READCONSOLE_CONTROL pInputControl
    );





#line 133 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleInputA(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
        LPDWORD lpNumberOfEventsRead
    );

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleInputW(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
        LPDWORD lpNumberOfEventsRead
    );





#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCtrlHandler(
      PHANDLER_ROUTINE HandlerRoutine,
      BOOL Add
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleMode(
      HANDLE hConsoleHandle,
      DWORD dwMode
    );


__declspec(dllimport)
BOOL
__stdcall
WriteConsoleA(
      HANDLE hConsoleOutput,
      const void * lpBuffer,
      DWORD nNumberOfCharsToWrite,
      LPDWORD lpNumberOfCharsWritten,
      LPVOID lpReserved
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleW(
      HANDLE hConsoleOutput,
      const void * lpBuffer,
      DWORD nNumberOfCharsToWrite,
      LPDWORD lpNumberOfCharsWritten,
      LPVOID lpReserved
    );





#line 207 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

#line 209 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"
#pragma endregion


}
#line 214 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"

#line 216 "E:\\sdk\\include\\10.0.16299.0\\um\\consoleapi.h"
#line 851 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#line 852 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
CreateConsoleScreenBuffer(
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      const SECURITY_ATTRIBUTES *lpSecurityAttributes,
      DWORD dwFlags,
      LPVOID lpScreenBufferData
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCP(
      UINT wCodePageID
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleOutputCP(
      UINT wCodePageID
    );

#line 882 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family







__declspec(dllimport)
BOOL
__stdcall
GetConsoleDisplayMode(
      LPDWORD lpModeFlags);




BOOL
__stdcall
SetConsoleDisplayMode(
      HANDLE hConsoleOutput,
      DWORD dwFlags,
      PCOORD lpNewScreenBufferDimensions);

__declspec(dllimport)
HWND
__stdcall
GetConsoleWindow(
    void
    );

#line 916 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 918 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetConsoleProcessList(
      LPDWORD lpdwProcessList,
      DWORD dwProcessCount);

#line 933 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
AddConsoleAliasA(
      LPSTR Source,
      LPSTR Target,
      LPSTR ExeName);
__declspec(dllimport)
BOOL
__stdcall
AddConsoleAliasW(
      LPWSTR Source,
      LPWSTR Target,
      LPWSTR ExeName);




#line 961 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasA(
      LPSTR Source,
      LPSTR TargetBuffer,
      DWORD TargetBufferLength,
      LPSTR ExeName);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasW(
      LPWSTR Source,
      LPWSTR TargetBuffer,
      DWORD TargetBufferLength,
      LPWSTR ExeName);




#line 983 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesLengthA(
      LPSTR ExeName);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesLengthW(
      LPWSTR ExeName);




#line 999 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesLengthA(
    void);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesLengthW(
    void);




#line 1015 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesA(
      LPSTR AliasBuffer,
      DWORD AliasBufferLength,
      LPSTR ExeName);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesW(
      LPWSTR AliasBuffer,
      DWORD AliasBufferLength,
      LPWSTR ExeName);




#line 1035 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesA(
      LPSTR ExeNameBuffer,
      DWORD ExeNameBufferLength);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesW(
      LPWSTR ExeNameBuffer,
      DWORD ExeNameBufferLength);




#line 1053 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 1055 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"
#pragma endregion

#line 1058 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"



#pragma warning(pop)
#line 1063 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"


}
#line 1067 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 1069 "E:\\sdk\\include\\10.0.16299.0\\um\\wincon.h"

#line 180 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"


















#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"












#pragma region Application Family or OneCore Family












#line 27 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"




























































#line 88 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"
#pragma endregion

#pragma region Desktop Family










































extern "C" {
#line 135 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"
    











typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            
    DWORD   dwStrucVersion;         
    DWORD   dwFileVersionMS;        
    DWORD   dwFileVersionLS;        
    DWORD   dwProductVersionMS;     
    DWORD   dwProductVersionLS;     
    DWORD   dwFileFlagsMask;        
    DWORD   dwFileFlags;            
    DWORD   dwFileOS;               
    DWORD   dwFileType;             
    DWORD   dwFileSubtype;          
    DWORD   dwFileDateMS;           
    DWORD   dwFileDateLS;           
} VS_FIXEDFILEINFO;


}
#line 167 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"

#line 169 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"

#line 171 "E:\\sdk\\include\\10.0.16299.0\\um\\verrsrc.h"
#pragma endregion

#line 20 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"



extern "C" {
#line 25 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#pragma region Desktop Family or OneCore Family







DWORD
__stdcall
VerFindFileA(
                                  DWORD uFlags,
                                  LPCSTR szFileName,
                              LPCSTR szWinDir,
                                  LPCSTR szAppDir,
            LPSTR szCurDir,
                               PUINT puCurDirLen,
           LPSTR szDestDir,
                               PUINT puDestDirLen
        );
DWORD
__stdcall
VerFindFileW(
                                  DWORD uFlags,
                                  LPCWSTR szFileName,
                              LPCWSTR szWinDir,
                                  LPCWSTR szAppDir,
            LPWSTR szCurDir,
                               PUINT puCurDirLen,
           LPWSTR szDestDir,
                               PUINT puDestDirLen
        );




#line 63 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 65 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 67 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"
#pragma endregion

#pragma region Desktop Family




DWORD
__stdcall
VerInstallFileA(
                                  DWORD uFlags,
                                  LPCSTR szSrcFileName,
                                  LPCSTR szDestFileName,
                                  LPCSTR szSrcDir,
                                  LPCSTR szDestDir,
                                  LPCSTR szCurDir,
           LPSTR szTmpFile,
                               PUINT puTmpFileLen
        );
DWORD
__stdcall
VerInstallFileW(
                                  DWORD uFlags,
                                  LPCWSTR szSrcFileName,
                                  LPCWSTR szDestFileName,
                                  LPCWSTR szSrcDir,
                                  LPCWSTR szDestDir,
                                  LPCWSTR szCurDir,
           LPWSTR szTmpFile,
                               PUINT puTmpFileLen
        );




#line 103 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 105 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 107 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family





DWORD
__stdcall
GetFileVersionInfoSizeA(
                 LPCSTR lptstrFilename, 
          LPDWORD lpdwHandle       
        );

DWORD
__stdcall
GetFileVersionInfoSizeW(
                 LPCWSTR lptstrFilename, 
          LPDWORD lpdwHandle       
        );




#line 133 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"


BOOL
__stdcall
GetFileVersionInfoA(
                         LPCSTR lptstrFilename, 
                   DWORD dwHandle,          
                         DWORD dwLen,             
          LPVOID lpData            
        );

BOOL
__stdcall
GetFileVersionInfoW(
                         LPCWSTR lptstrFilename, 
                   DWORD dwHandle,          
                         DWORD dwLen,             
          LPVOID lpData            
        );




#line 157 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 159 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 161 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"
#pragma endregion

#pragma region Application or OneCore Family




DWORD __stdcall GetFileVersionInfoSizeExA(  DWORD dwFlags,   LPCSTR lpwstrFilename,   LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeExW(  DWORD dwFlags,   LPCWSTR lpwstrFilename,   LPDWORD lpdwHandle);




#line 175 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

BOOL __stdcall GetFileVersionInfoExA(  DWORD dwFlags,
                                      LPCSTR lpwstrFilename,
                                      DWORD dwHandle,
                                      DWORD dwLen,
                                      LPVOID lpData);
BOOL __stdcall GetFileVersionInfoExW(  DWORD dwFlags,
                                      LPCWSTR lpwstrFilename,
                                      DWORD dwHandle,
                                      DWORD dwLen,
                                      LPVOID lpData);




#line 191 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 193 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 195 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"
#pragma endregion

#pragma region Desktop Family





#line 204 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 206 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"
#pragma endregion

#pragma region Application Family or OneCore Family




DWORD
__stdcall
VerLanguageNameA(
                           DWORD wLang,
          LPSTR szLang,
                           DWORD cchLang
        );
DWORD
__stdcall
VerLanguageNameW(
                           DWORD wLang,
          LPWSTR szLang,
                           DWORD cchLang
        );




#line 232 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

BOOL
__stdcall
VerQueryValueA(
          LPCVOID pBlock,
          LPCSTR lpSubBlock,
         LPVOID * lplpBuffer,
          PUINT puLen
        );
BOOL
__stdcall
VerQueryValueW(
          LPCVOID pBlock,
          LPCWSTR lpSubBlock,
         LPVOID * lplpBuffer,
          PUINT puLen
        );




#line 254 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"


#line 257 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 259 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"
#pragma endregion


}
#line 264 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"


#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\winver.h"

#line 181 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 182 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
 








































#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 45 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"









extern "C" {
#line 56 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"



#pragma warning(push)
#pragma warning(disable:4820) 
#line 62 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#pragma region Application Family or Desktop Family or OneCore Family








typedef   LONG LSTATUS;






















#line 96 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"













typedef ACCESS_MASK REGSAM;























struct val_context {
    int valuelen;       
    LPVOID value_context;   
    LPVOID val_buff_ptr;    
};

typedef struct val_context  *PVALCONTEXT;

typedef struct pvalueA {           
    LPSTR   pv_valuename;          
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA,  *PPVALUEA;
typedef struct pvalueW {           
    LPWSTR  pv_valuename;          
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW,  *PPVALUEW;




typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
#line 160 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

typedef
DWORD __cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD  *total_outlen, DWORD input_blen);

typedef QUERYHANDLER  *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info  *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA,  *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW,  *PVALENTW;




typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#line 198 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 200 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


#line 203 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"








#line 212 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family
















#line 232 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"





__declspec(dllimport)
LSTATUS
__stdcall
RegCloseKey(
      HKEY hKey
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOverridePredefKey (
      HKEY hKey,
      HKEY hNewHKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenUserClassesRoot(
      HANDLE hToken,
      DWORD dwOptions,
      REGSAM samDesired,
      PHKEY phkResult
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOpenCurrentUser(
      REGSAM samDesired,
      PHKEY phkResult
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegDisablePredefinedCache(
    void
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDisablePredefinedCacheEx(
    void
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryA (
      LPCSTR lpMachineName,
      HKEY hKey,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryW (
      LPCWSTR lpMachineName,
      HKEY hKey,
      PHKEY phkResult
    );




#line 309 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryExA (
      LPCSTR lpMachineName,
      HKEY hKey,
      ULONG Flags,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryExW (
      LPCWSTR lpMachineName,
      HKEY hKey,
      ULONG Flags,
      PHKEY phkResult
    );




#line 333 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyA (
      HKEY hKey,
      LPCSTR lpSubKey,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      PHKEY phkResult
    );




#line 355 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyExA(
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD Reserved,
      LPSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyExW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD Reserved,
      LPWSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition
    );





#line 391 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyTransactedA (
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD Reserved,
      LPSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyTransactedW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD Reserved,
      LPWSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );




#line 429 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyA (
      HKEY hKey,
      LPCSTR lpSubKey
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey
    );




#line 449 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyExA(
      HKEY hKey,
      LPCSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyExW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved
    );





#line 475 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyTransactedA (
      HKEY hKey,
      LPCSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved,
             HANDLE hTransaction,
      PVOID  pExtendedParameter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyTransactedW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved,
             HANDLE hTransaction,
      PVOID  pExtendedParameter
    );




#line 503 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegDisableReflectionKey (
      HKEY hBase
    );

__declspec(dllimport)
LONG
__stdcall
RegEnableReflectionKey (
      HKEY hBase
    );

__declspec(dllimport)
LONG
__stdcall
RegQueryReflectionKey (
      HKEY hBase,
      BOOL *bIsReflectionDisabled
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteValueA(
      HKEY hKey,
      LPCSTR lpValueName
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteValueW(
      HKEY hKey,
      LPCWSTR lpValueName
    );





#line 547 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyA (
      HKEY hKey,
      DWORD dwIndex,
      LPSTR lpName,
      DWORD cchName
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyW (
      HKEY hKey,
      DWORD dwIndex,
      LPWSTR lpName,
      DWORD cchName
    );




#line 571 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyExA(
      HKEY hKey,
      DWORD dwIndex,
      LPSTR lpName,
      LPDWORD lpcchName,
      LPDWORD lpReserved,
      LPSTR lpClass,
      LPDWORD lpcchClass,
      PFILETIME lpftLastWriteTime
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyExW(
      HKEY hKey,
      DWORD dwIndex,
      LPWSTR lpName,
      LPDWORD lpcchName,
      LPDWORD lpReserved,
      LPWSTR lpClass,
      LPDWORD lpcchClass,
      PFILETIME lpftLastWriteTime
    );





#line 605 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumValueA(
      HKEY hKey,
      DWORD dwIndex,
      LPSTR lpValueName,
      LPDWORD lpcchValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
      LPDWORD lpcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumValueW(
      HKEY hKey,
      DWORD dwIndex,
      LPWSTR lpValueName,
      LPDWORD lpcchValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
      LPDWORD lpcbData
    );





#line 639 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegFlushKey(
      HKEY hKey
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegGetKeySecurity(
      HKEY hKey,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      LPDWORD lpcbSecurityDescriptor
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegLoadKeyA(
      HKEY hKey,
      LPCSTR lpSubKey,
      LPCSTR lpFile
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadKeyW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      LPCWSTR lpFile
    );





#line 682 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegNotifyChangeKeyValue(
      HKEY hKey,
      BOOL bWatchSubtree,
      DWORD dwNotifyFilter,
      HANDLE hEvent,
      BOOL fAsynchronous
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyA (
      HKEY hKey,
      LPCSTR lpSubKey,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      PHKEY phkResult
    );




#line 716 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyExA(
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyExW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult
    );





#line 744 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyTransactedA (
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyTransactedW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );




#line 774 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryInfoKeyA(
      HKEY hKey,
      LPSTR lpClass,
      LPDWORD lpcchClass,
      LPDWORD lpReserved,
      LPDWORD lpcSubKeys,
      LPDWORD lpcbMaxSubKeyLen,
      LPDWORD lpcbMaxClassLen,
      LPDWORD lpcValues,
      LPDWORD lpcbMaxValueNameLen,
      LPDWORD lpcbMaxValueLen,
      LPDWORD lpcbSecurityDescriptor,
      PFILETIME lpftLastWriteTime
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryInfoKeyW(
      HKEY hKey,
      LPWSTR lpClass,
      LPDWORD lpcchClass,
      LPDWORD lpReserved,
      LPDWORD lpcSubKeys,
      LPDWORD lpcbMaxSubKeyLen,
      LPDWORD lpcbMaxClassLen,
      LPDWORD lpcValues,
      LPDWORD lpcbMaxValueNameLen,
      LPDWORD lpcbMaxValueLen,
      LPDWORD lpcbSecurityDescriptor,
      PFILETIME lpftLastWriteTime
    );





#line 816 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueA (
      HKEY hKey,
      LPCSTR lpSubKey,
       LPSTR lpData,
      PLONG lpcbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueW (
      HKEY hKey,
      LPCWSTR lpSubKey,
       LPWSTR lpData,
      PLONG lpcbData
    );




#line 840 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"







__declspec(dllimport)
LSTATUS
__stdcall
RegQueryMultipleValuesA(
      HKEY hKey,
      PVALENTA val_list,
      DWORD num_vals,
       LPSTR lpValueBuf,
      LPDWORD ldwTotsize
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryMultipleValuesW(
      HKEY hKey,
      PVALENTW val_list,
      DWORD num_vals,
       LPWSTR lpValueBuf,
      LPDWORD ldwTotsize
    );





#line 874 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 876 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
#line 877 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueExA(
      HKEY hKey,
      LPCSTR lpValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
    
              LPDWORD lpcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueExW(
      HKEY hKey,
      LPCWSTR lpValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
    
              LPDWORD lpcbData
    );





#line 909 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegReplaceKeyA (
      HKEY hKey,
      LPCSTR lpSubKey,
      LPCSTR lpNewFile,
      LPCSTR lpOldFile
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegReplaceKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      LPCWSTR lpNewFile,
      LPCWSTR lpOldFile
    );




#line 933 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegRestoreKeyA(
      HKEY hKey,
      LPCSTR lpFile,
      DWORD dwFlags
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegRestoreKeyW(
      HKEY hKey,
      LPCWSTR lpFile,
      DWORD dwFlags
    );





#line 957 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegRenameKey(
      HKEY hKey,
      LPCWSTR lpSubKeyName,
      LPCWSTR lpNewKeyName
    );

#line 971 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyA (
      HKEY hKey,
      LPCSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyW (
      HKEY hKey,
      LPCWSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 993 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeySecurity(
      HKEY hKey,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueA (
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD dwType,
      LPCSTR lpData,
      DWORD cbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD dwType,
      LPCWSTR lpData,
      DWORD cbData
    );




#line 1029 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueExA(
      HKEY hKey,
      LPCSTR lpValueName,
      DWORD Reserved,
      DWORD dwType,
      const BYTE * lpData,
      DWORD cbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueExW(
      HKEY hKey,
      LPCWSTR lpValueName,
      DWORD Reserved,
      DWORD dwType,
      const BYTE * lpData,
      DWORD cbData
    );





#line 1059 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegUnLoadKeyA(
      HKEY hKey,
      LPCSTR lpSubKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegUnLoadKeyW(
      HKEY hKey,
      LPCWSTR lpSubKey
    );





#line 1081 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"










__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyValueA(
      HKEY hKey,
      LPCSTR lpSubKey,
      LPCSTR lpValueName
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyValueW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      LPCWSTR lpValueName
    );





#line 1114 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeyValueA(
      HKEY hKey,
      LPCSTR lpSubKey,
      LPCSTR lpValueName,
      DWORD dwType,
      LPCVOID lpData,
      DWORD cbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeyValueW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      LPCWSTR lpValueName,
      DWORD dwType,
      LPCVOID lpData,
      DWORD cbData
    );





#line 1144 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 1146 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteTreeA(
      HKEY hKey,
      LPCSTR lpSubKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteTreeW(
      HKEY hKey,
      LPCWSTR lpSubKey
    );





#line 1168 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCopyTreeA (
             HKEY     hKeySrc,
         LPCSTR  lpSubKey,
             HKEY     hKeyDest
    );


#line 1180 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 1182 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegGetValueA(
      HKEY hkey,
      LPCSTR lpSubKey,
      LPCSTR lpValue,
      DWORD dwFlags,
      LPDWORD pdwType,
    
#line 1200 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
        
#line 1202 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
      PVOID pvData,
      LPDWORD pcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegGetValueW(
      HKEY hkey,
      LPCWSTR lpSubKey,
      LPCWSTR lpValue,
      DWORD dwFlags,
      LPDWORD pdwType,
    
#line 1220 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
        
#line 1222 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
      PVOID pvData,
      LPDWORD pcbData
    );





#line 1231 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 1233 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegCopyTreeW(
      HKEY hKeySrc,
      LPCWSTR lpSubKey,
      HKEY hKeyDest
    );





__declspec(dllimport)
LSTATUS
__stdcall
RegLoadMUIStringA(
      HKEY hKey,
      LPCSTR pszValue,
      LPSTR pszOutBuf,
      DWORD cbOutBuf,
      LPDWORD pcbData,
      DWORD Flags,
      LPCSTR pszDirectory
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadMUIStringW(
      HKEY hKey,
      LPCWSTR pszValue,
      LPWSTR pszOutBuf,
      DWORD cbOutBuf,
      LPDWORD pcbData,
      DWORD Flags,
      LPCWSTR pszDirectory
    );





#line 1281 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadAppKeyA(
      LPCSTR lpFile,
      PHKEY phkResult,
      REGSAM samDesired,
      DWORD dwOptions,
      DWORD Reserved
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadAppKeyW(
      LPCWSTR lpFile,
      PHKEY phkResult,
      REGSAM samDesired,
      DWORD dwOptions,
      DWORD Reserved
    );





#line 1309 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

#line 1311 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"





 
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownA(
      LPSTR lpMachineName,
      LPSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown
    );
 
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownW(
      LPWSTR lpMachineName,
      LPWSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown
    );




#line 1343 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownA(
      LPSTR lpMachineName
    );
__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownW(
      LPWSTR lpMachineName
    );




#line 1362 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"





#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\reason.h"
















#pragma once

#pragma region Desktop Family







































































































#line 124 "E:\\sdk\\include\\10.0.16299.0\\um\\reason.h"
#pragma endregion

#line 127 "E:\\sdk\\include\\10.0.16299.0\\um\\reason.h"
#line 1368 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


















 

#line 1389 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExA(
      LPSTR lpMachineName,
      LPSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown,
      DWORD dwReason
    );
 

#line 1403 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExW(
      LPWSTR lpMachineName,
      LPWSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown,
      DWORD dwReason
    );




#line 1419 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"



















__declspec(dllimport)
DWORD
__stdcall
InitiateShutdownA(
      LPSTR lpMachineName,
      LPSTR lpMessage,
          DWORD dwGracePeriod,
          DWORD dwShutdownFlags,
          DWORD dwReason
    );
__declspec(dllimport)
DWORD
__stdcall
InitiateShutdownW(
      LPWSTR lpMachineName,
      LPWSTR lpMessage,
          DWORD dwGracePeriod,
          DWORD dwShutdownFlags,
          DWORD dwReason
    );




#line 1463 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"

__declspec(dllimport)
DWORD
__stdcall
CheckForHiberboot(
      PBOOLEAN pHiberboot,
      BOOLEAN bClearFlag
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyExA(
      HKEY hKey,
      LPCSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD Flags
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyExW(
      HKEY hKey,
      LPCWSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD Flags
    );





#line 1497 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


#line 1500 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"
#pragma endregion



#pragma warning(pop)
#line 1506 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


}
#line 1510 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


#line 1513 "E:\\sdk\\include\\10.0.16299.0\\um\\winreg.h"


#line 184 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 185 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"




























#pragma once



extern "C" {
#line 35 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 40 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


#pragma region Desktop Family or System Family








#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\wnnc.h"



























#pragma region Desktop Family or OneCore Family




















































































#line 114 "E:\\sdk\\include\\10.0.16299.0\\shared\\wnnc.h"
#pragma endregion

#line 117 "E:\\sdk\\include\\10.0.16299.0\\shared\\wnnc.h"



#line 52 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"











#line 64 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"






#line 71 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"









#line 81 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"













#line 95 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"



#line 99 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;




typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#line 127 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"





















#line 149 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"



#line 153 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


#line 156 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"






#line 163 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetAddConnectionA(
          LPCSTR   lpRemoteName,
      LPCSTR   lpPassword,
      LPCSTR   lpLocalName
    );
 
DWORD __stdcall
WNetAddConnectionW(
          LPCWSTR   lpRemoteName,
      LPCWSTR   lpPassword,
      LPCWSTR   lpLocalName
    );




#line 183 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetAddConnection2A(
          LPNETRESOURCEA lpNetResource,
      LPCSTR       lpPassword,
      LPCSTR       lpUserName,
          DWORD          dwFlags
    );
 
DWORD __stdcall
WNetAddConnection2W(
          LPNETRESOURCEW lpNetResource,
      LPCWSTR       lpPassword,
      LPCWSTR       lpUserName,
          DWORD          dwFlags
    );




#line 205 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetAddConnection3A(
      HWND           hwndOwner,
          LPNETRESOURCEA lpNetResource,
      LPCSTR       lpPassword,
      LPCSTR       lpUserName,
          DWORD          dwFlags
    );
 
DWORD __stdcall
WNetAddConnection3W(
      HWND           hwndOwner,
          LPNETRESOURCEW lpNetResource,
      LPCWSTR       lpPassword,
      LPCWSTR       lpUserName,
          DWORD          dwFlags
    );




#line 229 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetCancelConnectionA(
      LPCSTR lpName,
      BOOL     fForce
    );
 
DWORD __stdcall
WNetCancelConnectionW(
      LPCWSTR lpName,
      BOOL     fForce
    );




#line 247 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetCancelConnection2A(
      LPCSTR lpName,
      DWORD    dwFlags,
      BOOL     fForce
    );
 
DWORD __stdcall
WNetCancelConnection2W(
      LPCWSTR lpName,
      DWORD    dwFlags,
      BOOL     fForce
    );




#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetGetConnectionA(
      LPCSTR lpLocalName,
      LPSTR  lpRemoteName,
      LPDWORD lpnLength
    );
 
DWORD __stdcall
WNetGetConnectionW(
      LPCWSTR lpLocalName,
      LPWSTR  lpRemoteName,
      LPDWORD lpnLength
    );




#line 287 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


#line 290 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#pragma endregion

#pragma region Desktop Family



 
DWORD __stdcall
WNetRestoreSingleConnectionW(
      HWND    hwndParent,
          LPCWSTR lpDevice,
          BOOL    fUseUI
    );









#line 313 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

#line 315 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#pragma endregion

#pragma region Desktop Family or System Family



 
DWORD __stdcall
WNetUseConnectionA(
      HWND            hwndOwner,
          LPNETRESOURCEA  lpNetResource,
      LPCSTR        lpPassword,
      LPCSTR        lpUserId,
          DWORD           dwFlags,
      LPSTR lpAccessName,
      LPDWORD lpBufferSize,
      LPDWORD   lpResult
    );
 
DWORD __stdcall
WNetUseConnectionW(
      HWND            hwndOwner,
          LPNETRESOURCEW  lpNetResource,
      LPCWSTR        lpPassword,
      LPCWSTR        lpUserId,
          DWORD           dwFlags,
      LPWSTR lpAccessName,
      LPDWORD lpBufferSize,
      LPDWORD   lpResult
    );




#line 350 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#line 351 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"





 
DWORD __stdcall
WNetConnectionDialog(
      HWND  hwnd,
      DWORD dwType
    );

 
DWORD __stdcall
WNetDisconnectDialog(
      HWND hwnd,
      DWORD dwType
    );


typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       
    HWND hwndOwner;          
    LPNETRESOURCEA lpConnRes;
    DWORD dwFlags;           
    DWORD dwDevNum;          
} CONNECTDLGSTRUCTA,  *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       
    HWND hwndOwner;          
    LPNETRESOURCEW lpConnRes;
    DWORD dwFlags;           
    DWORD dwDevNum;          
} CONNECTDLGSTRUCTW,  *LPCONNECTDLGSTRUCTW;




typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
#line 392 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"














 
DWORD __stdcall
WNetConnectionDialog1A(
      LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
 
DWORD __stdcall
WNetConnectionDialog1W(
      LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );




#line 421 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      
    HWND            hwndOwner;        
    LPSTR           lpLocalName;      
    LPSTR           lpRemoteName;     
    DWORD           dwFlags;          
} DISCDLGSTRUCTA,  *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      
    HWND            hwndOwner;        
    LPWSTR          lpLocalName;      
    LPWSTR          lpRemoteName;     
    DWORD           dwFlags;          
} DISCDLGSTRUCTW,  *LPDISCDLGSTRUCTW;




typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
#line 443 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"




 
DWORD __stdcall
WNetDisconnectDialog1A(
      LPDISCDLGSTRUCTA lpConnDlgStruct
    );
 
DWORD __stdcall
WNetDisconnectDialog1W(
      LPDISCDLGSTRUCTW lpConnDlgStruct
    );




#line 462 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#line 463 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"





 
DWORD __stdcall
WNetOpenEnumA(
       DWORD          dwScope,
       DWORD          dwType,
       DWORD          dwUsage,
      LPNETRESOURCEA lpNetResource,
      LPHANDLE       lphEnum
    );
 
DWORD __stdcall
WNetOpenEnumW(
       DWORD          dwScope,
       DWORD          dwType,
       DWORD          dwUsage,
      LPNETRESOURCEW lpNetResource,
      LPHANDLE       lphEnum
    );




#line 491 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetEnumResourceA(
         HANDLE  hEnum,
      LPDWORD lpcCount,
      LPVOID  lpBuffer,
      LPDWORD lpBufferSize
    );
 
DWORD __stdcall
WNetEnumResourceW(
         HANDLE  hEnum,
      LPDWORD lpcCount,
      LPVOID  lpBuffer,
      LPDWORD lpBufferSize
    );




#line 513 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetCloseEnum(
      HANDLE   hEnum
    );


 
DWORD __stdcall
WNetGetResourceParentA(
      LPNETRESOURCEA lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer
    );
 
DWORD __stdcall
WNetGetResourceParentW(
      LPNETRESOURCEW lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer
    );




#line 540 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetGetResourceInformationA(
      LPNETRESOURCEA  lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer,
     LPSTR *lplpSystem
    );
 
DWORD __stdcall
WNetGetResourceInformationW(
      LPNETRESOURCEW  lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer,
     LPWSTR *lplpSystem
    );




#line 562 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#line 563 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"








typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;




typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
#line 584 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;




typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
#line 602 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

 
DWORD __stdcall
WNetGetUniversalNameA(
      LPCSTR lpLocalPath,
      DWORD    dwInfoLevel,
      LPVOID lpBuffer,
      LPDWORD lpBufferSize
    );
 
DWORD __stdcall
WNetGetUniversalNameW(
      LPCWSTR lpLocalPath,
      DWORD    dwInfoLevel,
      LPVOID lpBuffer,
      LPDWORD lpBufferSize
    );




#line 624 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"




 
DWORD __stdcall
WNetGetUserA(
      LPCSTR  lpName,
      LPSTR lpUserName,
       LPDWORD lpnLength
    );



 
DWORD __stdcall
WNetGetUserW(
      LPCWSTR  lpName,
      LPWSTR lpUserName,
       LPDWORD lpnLength
    );




#line 650 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"












#line 663 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"



 
DWORD __stdcall
WNetGetProviderNameA(
         DWORD   dwNetType,
      LPSTR lpProviderName,
      LPDWORD lpBufferSize
    );
 
DWORD __stdcall
WNetGetProviderNameW(
         DWORD   dwNetType,
      LPWSTR lpProviderName,
      LPDWORD lpBufferSize
    );




#line 685 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT,  *LPNETINFOSTRUCT;





 
DWORD __stdcall
WNetGetNetworkInformationA(
       LPCSTR        lpProvider,
      LPNETINFOSTRUCT lpNetInfoStruct
    );
 
DWORD __stdcall
WNetGetNetworkInformationW(
       LPCWSTR        lpProvider,
      LPNETINFOSTRUCT lpNetInfoStruct
    );




#line 718 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

#line 720 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"





 
DWORD __stdcall
WNetGetLastErrorA(
      LPDWORD    lpError,
      LPSTR lpErrorBuf,
      DWORD      nErrorBufSize,
      LPSTR  lpNameBuf,
      DWORD      nNameBufSize
    );
 
DWORD __stdcall
WNetGetLastErrorW(
      LPDWORD    lpError,
      LPWSTR lpErrorBuf,
      DWORD      nErrorBufSize,
      LPWSTR  lpNameBuf,
      DWORD      nNameBufSize
    );




#line 748 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"





























#line 778 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"




















#line 799 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"












#line 812 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"






typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;






 
DWORD __stdcall
MultinetGetConnectionPerformanceA(
       LPNETRESOURCEA lpNetResource,
      LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );
 
DWORD __stdcall
MultinetGetConnectionPerformanceW(
       LPNETRESOURCEW lpNetResource,
      LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );




#line 848 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#line 849 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


#line 852 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"
#pragma endregion



#pragma warning(pop)
#line 858 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


}
#line 862 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"


#line 865 "E:\\sdk\\include\\10.0.16299.0\\um\\winnetwk.h"

#line 187 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 188 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"




































#line 1 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"




















































#line 54 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"
#line 55 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"




#line 60 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

#line 62 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"
#line 63 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"


extern "C" {
#line 67 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

#pragma region Desktop Family












#pragma warning(push)
#pragma warning(disable:4127)
#line 84 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"








































#line 125 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"


















#line 144 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"







LPUWSTR
__stdcall
uaw_CharUpperW(
      LPUWSTR String
    );

int
__stdcall
uaw_lstrcmpW(
      PCUWSTR String1,
      PCUWSTR String2
    );

int
__stdcall
uaw_lstrcmpiW(
      PCUWSTR String1,
      PCUWSTR String2
    );

int
__stdcall
uaw_lstrlenW(
      LPCUWSTR String
    );

PUWSTR
__cdecl
uaw_wcschr(
      PCUWSTR String,
      WCHAR   Character
    );

PUWSTR
__cdecl
uaw_wcscpy(
      PUWSTR  Destination,
       PCUWSTR Source
    );

int
__cdecl
uaw_wcsicmp(
      PCUWSTR String1,
      PCUWSTR String2
    );

size_t
__cdecl
uaw_wcslen(
      PCUWSTR String
    );

PUWSTR
__cdecl
uaw_wcsrchr(
      PCUWSTR String,
      WCHAR   Character
    );









__inline
LPUWSTR
static
ua_CharUpperW(
      LPUWSTR String
    )
{
    if (1) {
        return CharUpperW( (PWSTR)String );
    } else {
        return uaw_CharUpperW( String );
    }
}
#line 233 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"


__inline
int
static
ua_lstrcmpW(
      LPCUWSTR String1,
      LPCUWSTR String2
    )
{
    if (1 && 1) {
        return lstrcmpW( (LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpW( String1, String2 );
    }
}
#line 250 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"


__inline
int
static
ua_lstrcmpiW(
      LPCUWSTR String1,
      LPCUWSTR String2
    )
{
    if (1 && 1) {
        return lstrcmpiW( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_lstrcmpiW( String1, String2 );
    }
}
#line 267 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"


__inline
int
static
ua_lstrlenW(
      LPCUWSTR String
    )
{
    if (1) {
#pragma warning(suppress: 28750) 
        return lstrlenW( (PCWSTR)String );
    } else {
        return uaw_lstrlenW( String );
    }
}
#line 284 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"
































typedef const WCHAR __unaligned *PUWSTR_C;


#line 320 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"





__inline
PUWSTR_C
static
ua_wcschr(
      PCUWSTR String,
      WCHAR   Character
    )
{
    if (1) {
        return wcschr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcschr(String, Character);
    }
}

__inline
PUWSTR_C
static
ua_wcsrchr(
      PCUWSTR String,
      WCHAR   Character
    )
{
    if (1) {
        return wcsrchr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcsrchr(String, Character);
    }
}



























































#line 414 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

__inline
PUWSTR
static
__declspec(deprecated)
ua_wcscpy(
      PUWSTR  Destination,
      PCUWSTR Source
    )
{
    if (1 && 1) {
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)



        return wcscpy( (PWSTR)Destination, (PCWSTR)Source );
#pragma warning(pop)
    } else {
        return uaw_wcscpy( Destination, Source );
    }
}



__inline
PUWSTR
static
ua_wcscpy_s(
      PUWSTR Destination,
      size_t  DestinationSize,
      PCUWSTR Source
    )
{
    if (1 && 1) {
        return (wcscpy_s( (PWSTR)Destination, DestinationSize, (PCWSTR)Source ) == 0 ? Destination : 0);
    } else {
        
        return uaw_wcscpy( Destination, Source );
    }
}
#line 457 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

__inline
size_t
static
ua_wcslen(
      PCUWSTR String
    )
{
    if (1) {
        return wcslen( (PCWSTR)String );
    } else {
        return uaw_wcslen( String );
    }
}

#line 473 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

__inline
int
static
ua_wcsicmp(
      PCUWSTR String1,
      PCUWSTR String2
    )
{
    if (1 && 1) {
        return _wcsicmp( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_wcsicmp( String1, String2 );
    }
}

#line 490 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"






































































#line 561 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"




































#line 598 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"











































#line 642 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"



#line 646 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"














#line 661 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"










#line 672 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

#line 674 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"


#pragma warning(pop)
#line 678 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

#line 680 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"
#pragma endregion


}
#line 685 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"

#line 687 "E:\\sdk\\include\\10.0.16299.0\\shared\\stralign.h"








#line 225 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"












#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
































#line 34 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"


extern "C" {
#line 43 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#pragma region Desktop Family or OneCore Family





































#line 83 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
























































































































































































































































































extern "C" const GUID  NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID;
#line 370 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

extern "C" const GUID  NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID;
#line 378 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




extern "C" const GUID  DOMAIN_JOIN_GUID;
#line 389 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

extern "C" const GUID  DOMAIN_LEAVE_GUID;
#line 397 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"





extern "C" const GUID  FIREWALL_PORT_OPEN_GUID;
#line 409 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

extern "C" const GUID  FIREWALL_PORT_CLOSE_GUID;
#line 417 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"





extern "C" const GUID  MACHINE_POLICY_PRESENT_GUID;
#line 429 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

extern "C" const GUID  USER_POLICY_PRESENT_GUID;
#line 437 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"





extern "C" const GUID  RPC_INTERFACE_EVENT_GUID;
#line 449 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

extern "C" const GUID  NAMED_PIPE_EVENT_GUID;
#line 457 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




extern "C" const GUID  CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID;
#line 468 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




typedef struct
{
    DWORD Data[2];
} SERVICE_TRIGGER_CUSTOM_STATE_ID;

typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
    union {
        SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
        struct {
            DWORD DataOffset;
            BYTE Data[1];
        } s;
    } u;
} SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM, *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
















typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR       lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;



typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR      lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;




typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
#line 518 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE          = 0,
        SC_ACTION_RESTART       = 1,
        SC_ACTION_REBOOT        = 2,
        SC_ACTION_RUN_COMMAND   = 3,
        SC_ACTION_OWN_RESTART   = 4
} SC_ACTION_TYPE;

typedef struct _SC_ACTION {
    SC_ACTION_TYPE  Type;
    DWORD           Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD       dwResetPeriod;
    LPSTR       lpRebootMsg;
    LPSTR       lpCommand;



    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD       dwResetPeriod;
    LPWSTR      lpRebootMsg;
    LPWSTR      lpCommand;



    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;




typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
#line 568 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL       fDelayedAutostart;      
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;




typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL       fFailureActionsOnNonCrashFailures;       
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;




typedef struct _SERVICE_SID_INFO {
    DWORD       dwServiceSidType;     
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;




typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR       pmszRequiredPrivileges;             
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;



typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR      pmszRequiredPrivileges;             
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;




typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;
#line 609 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD       dwPreshutdownTimeout;   
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;




typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    DWORD   dwDataType; 



    DWORD   cbData;     



    PBYTE   pData;      
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;




typedef struct _SERVICE_TRIGGER
{
    DWORD                       dwTriggerType;              
    DWORD                       dwAction;                   
    GUID    *                   pTriggerSubtype;            
                                                            
                                                            
                                                            



    DWORD                       cDataItems;                 



    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM  pDataItems;       
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;




typedef struct _SERVICE_TRIGGER_INFO {



    DWORD                   cTriggers;  



    PSERVICE_TRIGGER        pTriggers;  
    PBYTE                   pReserved;  
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;






typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT                  usPreferredNode;    
    BOOLEAN                 fDelete;            
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;




typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER   liNewTime;      
    LARGE_INTEGER   liOldTime;      
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;




typedef struct _SERVICE_LAUNCH_PROTECTED_INFO {
    DWORD       dwLaunchProtected;     
} SERVICE_LAUNCH_PROTECTED_INFO, *PSERVICE_LAUNCH_PROTECTED_INFO;





struct SC_HANDLE__{int unused;}; typedef struct SC_HANDLE__ *SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

struct SERVICE_STATUS_HANDLE__{int unused;}; typedef struct SERVICE_STATUS_HANDLE__ *SERVICE_STATUS_HANDLE;





typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO      = 0
} SC_STATUS_TYPE;




typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO        = 0
} SC_ENUM_TYPE;






typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
    DWORD   dwProcessId;
    DWORD   dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;






typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR             lpServiceName;
    LPSTR             lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR            lpServiceName;
    LPWSTR            lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;




typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#line 767 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR                     lpServiceName;
    LPSTR                     lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR                    lpServiceName;
    LPWSTR                    lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;




typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
#line 785 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"





typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;




typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#line 809 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"







typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;




typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#line 845 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"







typedef void __stdcall SERVICE_MAIN_FUNCTIONW (
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    );

typedef void __stdcall SERVICE_MAIN_FUNCTIONA (
    DWORD dwNumServicesArgs,
    LPTSTR *lpServiceArgVectors
    );





#line 867 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );





#line 883 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"






typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;




typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#line 904 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"





typedef void __stdcall HANDLER_FUNCTION (
    DWORD    dwControl
    );

typedef DWORD __stdcall HANDLER_FUNCTION_EX (
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );

typedef void (__stdcall *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );

typedef DWORD (__stdcall *LPHANDLER_FUNCTION_EX)(
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );




typedef
void
( __stdcall * PFN_SC_NOTIFY_CALLBACK ) (
      PVOID pParameter
    );




typedef struct _SERVICE_NOTIFY_1 {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

typedef struct _SERVICE_NOTIFY_2A {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPSTR                   pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPWSTR                  pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;




typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;
#line 976 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;




typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;
#line 986 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD                   dwReason;
    LPSTR                   pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;



typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD                   dwReason;
    LPWSTR                  pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;




typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;
#line 1010 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"




typedef struct _SERVICE_START_REASON {
    DWORD                   dwReason;
} SERVICE_START_REASON, *PSERVICE_START_REASON;





__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigA(
             SC_HANDLE    hService,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCSTR     lpBinaryPathName,
         LPCSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCSTR     lpDependencies,
         LPCSTR     lpServiceStartName,
         LPCSTR     lpPassword,
         LPCSTR     lpDisplayName
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigW(
             SC_HANDLE    hService,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCWSTR     lpBinaryPathName,
         LPCWSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCWSTR     lpDependencies,
         LPCWSTR     lpServiceStartName,
         LPCWSTR     lpPassword,
         LPCWSTR     lpDisplayName
    );




#line 1059 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2A(
             SC_HANDLE    hService,
             DWORD        dwInfoLevel,
         LPVOID       lpInfo
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2W(
             SC_HANDLE    hService,
             DWORD        dwInfoLevel,
         LPVOID       lpInfo
    );




#line 1081 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
CloseServiceHandle(
             SC_HANDLE   hSCObject
    );

__declspec(dllimport)
BOOL
__stdcall
ControlService(
             SC_HANDLE           hService,
             DWORD               dwControl,
            LPSERVICE_STATUS    lpServiceStatus
    );

 
__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceA(
             SC_HANDLE    hSCManager,
             LPCSTR     lpServiceName,
         LPCSTR     lpDisplayName,
             DWORD        dwDesiredAccess,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCSTR     lpBinaryPathName,
         LPCSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCSTR     lpDependencies,
         LPCSTR     lpServiceStartName,
         LPCSTR     lpPassword
    );
 
__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceW(
             SC_HANDLE    hSCManager,
             LPCWSTR     lpServiceName,
         LPCWSTR     lpDisplayName,
             DWORD        dwDesiredAccess,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCWSTR     lpBinaryPathName,
         LPCWSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCWSTR     lpDependencies,
         LPCWSTR     lpServiceStartName,
         LPCWSTR     lpPassword
    );




#line 1141 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteService(
             SC_HANDLE   hService
    );

 
__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesA(
                 SC_HANDLE               hService,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSA  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned
    );
 
__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesW(
                 SC_HANDLE               hService,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSW  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned
    );




#line 1180 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1182 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family


 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusA(
                 SC_HANDLE               hSCManager,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSA  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle
    );
 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusW(
                 SC_HANDLE               hSCManager,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSW  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle
    );




#line 1222 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1224 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExA(
                 SC_HANDLE               hSCManager,
                 SC_ENUM_TYPE            InfoLevel,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPBYTE                  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle,
             LPCSTR                pszGroupName
    );
 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExW(
                 SC_HANDLE               hSCManager,
                 SC_ENUM_TYPE            InfoLevel,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPBYTE                  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle,
             LPCWSTR                pszGroupName
    );




#line 1268 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameA(
                 SC_HANDLE               hSCManager,
                 LPCSTR                lpDisplayName,
     
                    LPSTR                 lpServiceName,
              LPDWORD                 lpcchBuffer
    );
 
__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameW(
                 SC_HANDLE               hSCManager,
                 LPCWSTR                lpDisplayName,
     
                    LPWSTR                 lpServiceName,
              LPDWORD                 lpcchBuffer
    );




#line 1296 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameA(
                 SC_HANDLE               hSCManager,
                 LPCSTR                lpServiceName,
     
                    LPSTR                 lpDisplayName,
              LPDWORD                 lpcchBuffer
    );
 
__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameW(
                 SC_HANDLE               hSCManager,
                 LPCWSTR                lpServiceName,
     
                    LPWSTR                 lpDisplayName,
              LPDWORD                 lpcchBuffer
    );




#line 1324 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1326 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SC_LOCK
__stdcall
LockServiceDatabase(
                 SC_HANDLE               hSCManager
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyBootConfigStatus(
                 BOOL                    BootAcceptable
    );

#line 1346 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerA(
             LPCSTR                lpMachineName,
             LPCSTR                lpDatabaseName,
                 DWORD                   dwDesiredAccess
    );
 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerW(
             LPCWSTR                lpMachineName,
             LPCWSTR                lpDatabaseName,
                 DWORD                   dwDesiredAccess
    );




#line 1374 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceA(
                 SC_HANDLE               hSCManager,
                 LPCSTR                lpServiceName,
                 DWORD                   dwDesiredAccess
    );
 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceW(
                 SC_HANDLE               hSCManager,
                 LPCWSTR                lpServiceName,
                 DWORD                   dwDesiredAccess
    );




#line 1398 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigA(
                 SC_HANDLE               hService,
     
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigW(
                 SC_HANDLE               hService,
     
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );




#line 1426 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"


#line 1429 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1431 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1434 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2A(
                 SC_HANDLE               hService,
                 DWORD                   dwInfoLevel,
     
                    LPBYTE                  lpBuffer,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );

#line 1448 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1450 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1453 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2W(
                 SC_HANDLE               hService,
                 DWORD                   dwInfoLevel,
     
                    LPBYTE                  lpBuffer,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );




#line 1470 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1472 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family


 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusA(
                 SC_HANDLE                       hSCManager,
     
                    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
                 DWORD                           cbBufSize,
                LPDWORD                         pcbBytesNeeded
    );
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusW(
                 SC_HANDLE                       hSCManager,
     
                    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
                 DWORD                           cbBufSize,
                LPDWORD                         pcbBytesNeeded
    );




#line 1504 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1506 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceObjectSecurity(
                 SC_HANDLE               hService,
                 SECURITY_INFORMATION    dwSecurityInformation,
     
                    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatus(
                 SC_HANDLE           hService,
                LPSERVICE_STATUS    lpServiceStatus
    );

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatusEx(
                 SC_HANDLE           hService,
                 SC_STATUS_TYPE      InfoLevel,
     
                    LPBYTE              lpBuffer,
                 DWORD               cbBufSize,
                LPDWORD             pcbBytesNeeded
    );

 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerA(
         LPCSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION          lpHandlerProc
    );
 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerW(
         LPCWSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION          lpHandlerProc
    );




#line 1569 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExA(
         LPCSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
      LPVOID                     lpContext
    );
 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExW(
         LPCWSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
      LPVOID                     lpContext
    );




#line 1595 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
SetServiceObjectSecurity(
             SC_HANDLE               hService,
             SECURITY_INFORMATION    dwSecurityInformation,
             PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

__declspec(dllimport)
BOOL
__stdcall
SetServiceStatus(
             SERVICE_STATUS_HANDLE   hServiceStatus,
             LPSERVICE_STATUS        lpServiceStatus
    );

__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherA(
      const  SERVICE_TABLE_ENTRYA    *lpServiceStartTable
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherW(
      const  SERVICE_TABLE_ENTRYW    *lpServiceStartTable
    );




#line 1630 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
StartServiceA(
                 SC_HANDLE            hService,
                 DWORD                dwNumServiceArgs,
     
                    LPCSTR             *lpServiceArgVectors
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceW(
                 SC_HANDLE            hService,
                 DWORD                dwNumServiceArgs,
     
                    LPCWSTR             *lpServiceArgVectors
    );




#line 1655 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1657 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UnlockServiceDatabase(
                 SC_LOCK             ScLock
    );

#line 1670 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
DWORD
__stdcall
NotifyServiceStatusChangeA (
             SC_HANDLE               hService,
             DWORD                   dwNotifyMask,
             PSERVICE_NOTIFYA        pNotifyBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
NotifyServiceStatusChangeW (
             SC_HANDLE               hService,
             DWORD                   dwNotifyMask,
             PSERVICE_NOTIFYW        pNotifyBuffer
    );




#line 1698 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ControlServiceExA(
             SC_HANDLE               hService,
             DWORD                   dwControl,
             DWORD                   dwInfoLevel,
          PVOID                   pControlParams
    );
__declspec(dllimport)
BOOL
__stdcall
ControlServiceExW(
             SC_HANDLE               hService,
             DWORD                   dwControl,
             DWORD                   dwInfoLevel,
          PVOID                   pControlParams
    );




#line 1722 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
QueryServiceDynamicInformation (
             SERVICE_STATUS_HANDLE   hServiceStatus,
             DWORD                   dwInfoLevel,
        PVOID           *       ppDynamicInfo
    );

#line 1733 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"







typedef enum _SC_EVENT_TYPE {
    SC_EVENT_DATABASE_CHANGE,
    SC_EVENT_PROPERTY_CHANGE,
    SC_EVENT_STATUS_CHANGE
} SC_EVENT_TYPE, *PSC_EVENT_TYPE;

typedef
void
__stdcall
SC_NOTIFICATION_CALLBACK (
             DWORD                   dwNotify,
         PVOID                   pCallbackContext
    );
typedef SC_NOTIFICATION_CALLBACK* PSC_NOTIFICATION_CALLBACK;

typedef struct _SC_NOTIFICATION_REGISTRATION* PSC_NOTIFICATION_REGISTRATION;

__declspec(dllimport)
DWORD
__stdcall
SubscribeServiceChangeNotifications (
           SC_HANDLE                      hService,
           SC_EVENT_TYPE                  eEventType,
           PSC_NOTIFICATION_CALLBACK      pCallback,
       PVOID                          pCallbackContext,
          PSC_NOTIFICATION_REGISTRATION* pSubscription
    );

__declspec(dllimport)
void
__stdcall
UnsubscribeServiceChangeNotifications (
           PSC_NOTIFICATION_REGISTRATION pSubscription
    );

__declspec(dllimport)
DWORD
__stdcall
WaitServiceState (
           SC_HANDLE  hService,
           DWORD      dwNotify,
       DWORD      dwTimeout,
       HANDLE     hCancelEvent
    );

#line 1786 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1788 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"
#pragma endregion


}
#line 1793 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"


#pragma warning(pop)
#line 1797 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"

#line 1799 "E:\\sdk\\include\\10.0.16299.0\\um\\winsvc.h"


#line 238 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 239 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"



#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\mcx.h"












#pragma once
#line 15 "E:\\sdk\\include\\10.0.16299.0\\um\\mcx.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 20 "E:\\sdk\\include\\10.0.16299.0\\um\\mcx.h"

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    
    DWORD   dwDialOptions;          
    DWORD   dwCallSetupFailTimer;   
    DWORD   dwInactivityTimeout;    
    DWORD   dwSpeakerVolume;        
    DWORD   dwSpeakerMode;          
    DWORD   dwModemOptions;         
    DWORD   dwMaxDTERate;           
    DWORD   dwMaxDCERate;           

    
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    
    DWORD   dwCallSetupFailTimer;       
    DWORD   dwInactivityTimeout;        
    DWORD   dwSpeakerVolume;            
    DWORD   dwSpeakerMode;              
    DWORD   dwPreferredModemOptions;    

    
    DWORD   dwNegotiatedModemOptions;   
    DWORD   dwNegotiatedDCERate;        

    
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;


















































































































































































































































































































































































































































































































































































































































































#pragma warning(pop)
#line 730 "E:\\sdk\\include\\10.0.16299.0\\um\\mcx.h"

#line 732 "E:\\sdk\\include\\10.0.16299.0\\um\\mcx.h"
#line 243 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 244 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"


#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"













extern "C" {
#line 16 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 21 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"






#pragma region Application Family



struct HIMC__{int unused;}; typedef struct HIMC__ *HIMC;
struct HIMCC__{int unused;}; typedef struct HIMCC__ *HIMCC;



#line 37 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

#line 39 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion

#pragma region Desktop Family


typedef HKL   *LPHKL;
typedef UINT  *LPUINT;

#line 48 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion

#pragma region Application Family


typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM,  *NPCOMPOSITIONFORM,  *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM,  *NPCANDIDATEFORM,  *LPCANDIDATEFORM;

#line 68 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST,  *NPCANDIDATELIST,  *LPCANDIDATELIST;

#line 86 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion


#pragma region Application Family


typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA,  *NPREGISTERWORDA,  *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW,  *NPREGISTERWORDW,  *LPREGISTERWORDW;






typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#line 111 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

#line 113 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING,  *NPRECONVERTSTRING,  *LPRECONVERTSTRING;

#line 132 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion

#line 135 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"



#pragma region Application Family


typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[32];
} STYLEBUFA, *PSTYLEBUFA,  *NPSTYLEBUFA,  *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[32];
} STYLEBUFW, *PSTYLEBUFW,  *NPSTYLEBUFW,  *LPSTYLEBUFW;






typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#line 160 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

#line 162 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[80];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA,  *NPIMEMENUITEMINFOA,  *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[80];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW,  *NPIMEMENUITEMINFOW,  *LPIMEMENUITEMINFOW;






typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#line 204 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION,  *NPIMECHARPOSITION,  *LPIMECHARPOSITION;

typedef BOOL    (__stdcall* IMCENUMPROC)(HIMC, LPARAM);

#line 216 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion

#line 219 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"





#pragma region Desktop Family


HKL  __stdcall ImmInstallIMEA(  LPCSTR lpszIMEFileName,   LPCSTR lpszLayoutText);
HKL  __stdcall ImmInstallIMEW(  LPCWSTR lpszIMEFileName,   LPCWSTR lpszLayoutText);




#line 234 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

HWND __stdcall ImmGetDefaultIMEWnd( HWND);

UINT __stdcall ImmGetDescriptionA( HKL,   LPSTR lpszDescription,  UINT uBufLen);
UINT __stdcall ImmGetDescriptionW( HKL,   LPWSTR lpszDescription,  UINT uBufLen);




#line 244 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

UINT __stdcall ImmGetIMEFileNameA( HKL,   LPSTR lpszFileName,  UINT uBufLen);
UINT __stdcall ImmGetIMEFileNameW( HKL,   LPWSTR lpszFileName,  UINT uBufLen);




#line 252 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

DWORD __stdcall ImmGetProperty( HKL,  DWORD);

BOOL __stdcall ImmIsIME( HKL);

BOOL __stdcall ImmSimulateHotKey( HWND,  DWORD);

HIMC __stdcall ImmCreateContext(void);
BOOL __stdcall ImmDestroyContext( HIMC);
HIMC __stdcall ImmGetContext( HWND);
BOOL __stdcall ImmReleaseContext( HWND,  HIMC);
HIMC __stdcall ImmAssociateContext( HWND,  HIMC);

BOOL __stdcall ImmAssociateContextEx(  HWND,   HIMC,   DWORD);
#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

LONG  __stdcall ImmGetCompositionStringA( HIMC,  DWORD,   LPVOID lpBuf,  DWORD dwBufLen);
LONG  __stdcall ImmGetCompositionStringW( HIMC,  DWORD,   LPVOID lpBuf,  DWORD dwBufLen);




#line 275 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL  __stdcall ImmSetCompositionStringA( HIMC,  DWORD dwIndex,   LPVOID lpComp,  DWORD dwCompLen,   LPVOID lpRead,  DWORD dwReadLen);
BOOL  __stdcall ImmSetCompositionStringW( HIMC,  DWORD dwIndex,   LPVOID lpComp,  DWORD dwCompLen,   LPVOID lpRead,  DWORD dwReadLen);




#line 283 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

DWORD __stdcall ImmGetCandidateListCountA( HIMC,   LPDWORD lpdwListCount);
DWORD __stdcall ImmGetCandidateListCountW( HIMC,   LPDWORD lpdwListCount);




#line 291 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

DWORD __stdcall ImmGetCandidateListA( HIMC,  DWORD deIndex,   LPCANDIDATELIST lpCandList,  DWORD dwBufLen);
DWORD __stdcall ImmGetCandidateListW( HIMC,  DWORD deIndex,   LPCANDIDATELIST lpCandList,  DWORD dwBufLen);




#line 299 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

DWORD __stdcall ImmGetGuideLineA(  HIMC,   DWORD dwIndex,   LPSTR lpBuf,   DWORD dwBufLen);
DWORD __stdcall ImmGetGuideLineW(  HIMC,   DWORD dwIndex,   LPWSTR lpBuf,   DWORD dwBufLen);




#line 307 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL __stdcall ImmGetConversionStatus( HIMC,   LPDWORD lpfdwConversion,   LPDWORD lpfdwSentence);
BOOL __stdcall ImmSetConversionStatus( HIMC,  DWORD,  DWORD);
BOOL __stdcall ImmGetOpenStatus( HIMC);
BOOL __stdcall ImmSetOpenStatus( HIMC,  BOOL);


BOOL __stdcall ImmGetCompositionFontA( HIMC,   LPLOGFONTA lplf);
BOOL __stdcall ImmGetCompositionFontW( HIMC,   LPLOGFONTW lplf);




#line 321 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL __stdcall ImmSetCompositionFontA( HIMC,   LPLOGFONTA lplf);
BOOL __stdcall ImmSetCompositionFontW( HIMC,   LPLOGFONTW lplf);




#line 329 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#line 330 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL    __stdcall ImmConfigureIMEA( HKL,  HWND,  DWORD,  LPVOID);
BOOL    __stdcall ImmConfigureIMEW( HKL,  HWND,  DWORD,  LPVOID);




#line 338 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

LRESULT __stdcall ImmEscapeA( HKL,  HIMC,  UINT,  LPVOID);
LRESULT __stdcall ImmEscapeW( HKL,  HIMC,  UINT,  LPVOID);




#line 346 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

DWORD   __stdcall ImmGetConversionListA( HKL,  HIMC,   LPCSTR lpSrc,   LPCANDIDATELIST lpDst,  DWORD dwBufLen,  UINT uFlag);
DWORD   __stdcall ImmGetConversionListW( HKL,  HIMC,   LPCWSTR lpSrc,   LPCANDIDATELIST lpDst,  DWORD dwBufLen,  UINT uFlag);




#line 354 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL    __stdcall ImmNotifyIME( HIMC,  DWORD dwAction,  DWORD dwIndex,  DWORD dwValue);

BOOL __stdcall ImmGetStatusWindowPos( HIMC,   LPPOINT lpptPos);
BOOL __stdcall ImmSetStatusWindowPos( HIMC,   LPPOINT lpptPos);
BOOL __stdcall ImmGetCompositionWindow( HIMC,   LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmSetCompositionWindow( HIMC,   LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmGetCandidateWindow( HIMC,  DWORD,   LPCANDIDATEFORM lpCandidate);
BOOL __stdcall ImmSetCandidateWindow( HIMC,   LPCANDIDATEFORM lpCandidate);

BOOL __stdcall ImmIsUIMessageA( HWND,  UINT,  WPARAM,  LPARAM);
BOOL __stdcall ImmIsUIMessageW( HWND,  UINT,  WPARAM,  LPARAM);




#line 371 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

UINT __stdcall ImmGetVirtualKey( HWND);

typedef int (__stdcall *REGISTERWORDENUMPROCA)(  LPCSTR lpszReading, DWORD,   LPCSTR lpszString, LPVOID);
typedef int (__stdcall *REGISTERWORDENUMPROCW)(  LPCWSTR lpszReading, DWORD,   LPCWSTR lpszString, LPVOID);




#line 381 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL __stdcall ImmRegisterWordA( HKL,   LPCSTR lpszReading,  DWORD,   LPCSTR lpszRegister);
BOOL __stdcall ImmRegisterWordW( HKL,   LPCWSTR lpszReading,  DWORD,   LPCWSTR lpszRegister);




#line 389 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL __stdcall ImmUnregisterWordA( HKL,   LPCSTR lpszReading,  DWORD,   LPCSTR lpszUnregister);
BOOL __stdcall ImmUnregisterWordW( HKL,   LPCWSTR lpszReading,  DWORD,   LPCWSTR lpszUnregister);




#line 397 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

UINT __stdcall ImmGetRegisterWordStyleA( HKL,  UINT nItem,   LPSTYLEBUFA lpStyleBuf);
UINT __stdcall ImmGetRegisterWordStyleW( HKL,  UINT nItem,   LPSTYLEBUFW lpStyleBuf);




#line 405 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

UINT __stdcall ImmEnumRegisterWordA( HKL,  REGISTERWORDENUMPROCA,   LPCSTR lpszReading,  DWORD,   LPCSTR lpszRegister,  LPVOID);
UINT __stdcall ImmEnumRegisterWordW( HKL,  REGISTERWORDENUMPROCW,   LPCWSTR lpszReading,  DWORD,   LPCWSTR lpszRegister,  LPVOID);




#line 413 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"


BOOL __stdcall ImmDisableIME( DWORD);
BOOL __stdcall ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD __stdcall ImmGetImeMenuItemsA( HIMC,  DWORD,  DWORD,   LPIMEMENUITEMINFOA lpImeParentMenu,   LPIMEMENUITEMINFOA lpImeMenu,  DWORD dwSize);
DWORD __stdcall ImmGetImeMenuItemsW( HIMC,  DWORD,  DWORD,   LPIMEMENUITEMINFOW lpImeParentMenu,   LPIMEMENUITEMINFOW lpImeMenu,  DWORD dwSize);




#line 424 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

BOOL __stdcall ImmDisableTextFrameService(DWORD idThread);
#line 427 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"


BOOL __stdcall ImmDisableLegacyIME(void);
#line 431 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

#line 433 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"
#pragma endregion









































































































































































































#line 1 "E:\\sdk\\include\\10.0.16299.0\\um\\ime_cmodes.h"



#pragma once


















#line 24 "E:\\sdk\\include\\10.0.16299.0\\um\\ime_cmodes.h"

#line 636 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"






















































#line 691 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"






































































#line 762 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"








#line 771 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"


#pragma warning(pop)
#line 775 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"


}
#line 779 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"

#line 781 "E:\\sdk\\include\\10.0.16299.0\\um\\imm.h"


#line 247 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 248 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 249 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 250 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"




#pragma warning(pop)





#line 261 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 262 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#line 263 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 265 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 267 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"
#pragma endregion

#line 270 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 272 "E:\\sdk\\include\\10.0.16299.0\\um\\windows.h"

#line 38 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
#line 39 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"






#line 46 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern "C" {
#line 50 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

struct gladGLversionStruct {
    int major;
    int minor;
};

typedef void* (* GLADloadproc)(const char *name);






















#line 80 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

#line 82 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
#line 83 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

extern struct gladGLversionStruct GLVersion;

extern int gladLoadGL(void);

extern int gladLoadGLLoader(GLADloadproc);


#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"











































































































#line 109 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"








    



#line 122 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"








#line 131 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"

#line 133 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"


















#line 152 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"












#line 165 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"




typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;











































#line 217 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"





typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;







typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;





#line 243 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"





typedef          float         khronos_float_t;
#line 250 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"











typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#line 264 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"






#line 271 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"







typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 0x7FFFFFFF
} khronos_boolean_enum_t;

#line 285 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\KHR/khrplatform.h"
#line 92 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"







#line 100 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"










#line 111 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

#line 113 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

#line 115 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"



#line 119 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

#line 121 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;



#line 128 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
#line 129 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLclampx;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef int GLsizei;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;



typedef unsigned int GLhandleARB;
#line 154 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef unsigned short GLhalfARB;
typedef unsigned short GLhalf;
typedef GLint GLfixed;


#line 160 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef ptrdiff_t GLintptr;
#line 162 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


#line 165 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef ptrdiff_t GLsizeiptr;
#line 167 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef int64_t GLint64;
typedef uint64_t GLuint64;


#line 172 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef ptrdiff_t GLintptrARB;
#line 174 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


#line 177 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef ptrdiff_t GLsizeiptrARB;
#line 179 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (__stdcall *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (__stdcall *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (__stdcall *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (__stdcall *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void (__stdcall *GLVULKANPROCNV)(void);




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































extern int GLAD_GL_VERSION_1_0;
typedef void (__stdcall * PFNGLCULLFACEPROC)(GLenum mode);
extern PFNGLCULLFACEPROC glad_glCullFace;

typedef void (__stdcall * PFNGLFRONTFACEPROC)(GLenum mode);
extern PFNGLFRONTFACEPROC glad_glFrontFace;

typedef void (__stdcall * PFNGLHINTPROC)(GLenum target, GLenum mode);
extern PFNGLHINTPROC glad_glHint;

typedef void (__stdcall * PFNGLLINEWIDTHPROC)(GLfloat width);
extern PFNGLLINEWIDTHPROC glad_glLineWidth;

typedef void (__stdcall * PFNGLPOINTSIZEPROC)(GLfloat size);
extern PFNGLPOINTSIZEPROC glad_glPointSize;

typedef void (__stdcall * PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
extern PFNGLPOLYGONMODEPROC glad_glPolygonMode;

typedef void (__stdcall * PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLSCISSORPROC glad_glScissor;

typedef void (__stdcall * PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
extern PFNGLTEXPARAMETERFPROC glad_glTexParameterf;

typedef void (__stdcall * PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;

typedef void (__stdcall * PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLTEXPARAMETERIPROC glad_glTexParameteri;

typedef void (__stdcall * PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;

typedef void (__stdcall * PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE1DPROC glad_glTexImage1D;

typedef void (__stdcall * PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE2DPROC glad_glTexImage2D;

typedef void (__stdcall * PFNGLDRAWBUFFERPROC)(GLenum buf);
extern PFNGLDRAWBUFFERPROC glad_glDrawBuffer;

typedef void (__stdcall * PFNGLCLEARPROC)(GLbitfield mask);
extern PFNGLCLEARPROC glad_glClear;

typedef void (__stdcall * PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLCLEARCOLORPROC glad_glClearColor;

typedef void (__stdcall * PFNGLCLEARSTENCILPROC)(GLint s);
extern PFNGLCLEARSTENCILPROC glad_glClearStencil;

typedef void (__stdcall * PFNGLCLEARDEPTHPROC)(GLdouble depth);
extern PFNGLCLEARDEPTHPROC glad_glClearDepth;

typedef void (__stdcall * PFNGLSTENCILMASKPROC)(GLuint mask);
extern PFNGLSTENCILMASKPROC glad_glStencilMask;

typedef void (__stdcall * PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern PFNGLCOLORMASKPROC glad_glColorMask;

typedef void (__stdcall * PFNGLDEPTHMASKPROC)(GLboolean flag);
extern PFNGLDEPTHMASKPROC glad_glDepthMask;

typedef void (__stdcall * PFNGLDISABLEPROC)(GLenum cap);
extern PFNGLDISABLEPROC glad_glDisable;

typedef void (__stdcall * PFNGLENABLEPROC)(GLenum cap);
extern PFNGLENABLEPROC glad_glEnable;

typedef void (__stdcall * PFNGLFINISHPROC)(void);
extern PFNGLFINISHPROC glad_glFinish;

typedef void (__stdcall * PFNGLFLUSHPROC)(void);
extern PFNGLFLUSHPROC glad_glFlush;

typedef void (__stdcall * PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
extern PFNGLBLENDFUNCPROC glad_glBlendFunc;

typedef void (__stdcall * PFNGLLOGICOPPROC)(GLenum opcode);
extern PFNGLLOGICOPPROC glad_glLogicOp;

typedef void (__stdcall * PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCPROC glad_glStencilFunc;

typedef void (__stdcall * PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
extern PFNGLSTENCILOPPROC glad_glStencilOp;

typedef void (__stdcall * PFNGLDEPTHFUNCPROC)(GLenum func);
extern PFNGLDEPTHFUNCPROC glad_glDepthFunc;

typedef void (__stdcall * PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
extern PFNGLPIXELSTOREFPROC glad_glPixelStoref;

typedef void (__stdcall * PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
extern PFNGLPIXELSTOREIPROC glad_glPixelStorei;

typedef void (__stdcall * PFNGLREADBUFFERPROC)(GLenum src);
extern PFNGLREADBUFFERPROC glad_glReadBuffer;

typedef void (__stdcall * PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
extern PFNGLREADPIXELSPROC glad_glReadPixels;

typedef void (__stdcall * PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean *data);
extern PFNGLGETBOOLEANVPROC glad_glGetBooleanv;

typedef void (__stdcall * PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble *data);
extern PFNGLGETDOUBLEVPROC glad_glGetDoublev;

typedef GLenum (__stdcall * PFNGLGETERRORPROC)(void);
extern PFNGLGETERRORPROC glad_glGetError;

typedef void (__stdcall * PFNGLGETFLOATVPROC)(GLenum pname, GLfloat *data);
extern PFNGLGETFLOATVPROC glad_glGetFloatv;

typedef void (__stdcall * PFNGLGETINTEGERVPROC)(GLenum pname, GLint *data);
extern PFNGLGETINTEGERVPROC glad_glGetIntegerv;

typedef const GLubyte * (__stdcall * PFNGLGETSTRINGPROC)(GLenum name);
extern PFNGLGETSTRINGPROC glad_glGetString;

typedef void (__stdcall * PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern PFNGLGETTEXIMAGEPROC glad_glGetTexImage;

typedef void (__stdcall * PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;

typedef void (__stdcall * PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;

typedef void (__stdcall * PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;

typedef void (__stdcall * PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint *params);
extern PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;

typedef GLboolean (__stdcall * PFNGLISENABLEDPROC)(GLenum cap);
extern PFNGLISENABLEDPROC glad_glIsEnabled;

typedef void (__stdcall * PFNGLDEPTHRANGEPROC)(GLdouble , GLdouble );
extern PFNGLDEPTHRANGEPROC glad_glDepthRange;

typedef void (__stdcall * PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLVIEWPORTPROC glad_glViewport;

typedef void (__stdcall * PFNGLNEWLISTPROC)(GLuint list, GLenum mode);
extern PFNGLNEWLISTPROC glad_glNewList;

typedef void (__stdcall * PFNGLENDLISTPROC)(void);
extern PFNGLENDLISTPROC glad_glEndList;

typedef void (__stdcall * PFNGLCALLLISTPROC)(GLuint list);
extern PFNGLCALLLISTPROC glad_glCallList;

typedef void (__stdcall * PFNGLCALLLISTSPROC)(GLsizei n, GLenum type, const void *lists);
extern PFNGLCALLLISTSPROC glad_glCallLists;

typedef void (__stdcall * PFNGLDELETELISTSPROC)(GLuint list, GLsizei range);
extern PFNGLDELETELISTSPROC glad_glDeleteLists;

typedef GLuint (__stdcall * PFNGLGENLISTSPROC)(GLsizei range);
extern PFNGLGENLISTSPROC glad_glGenLists;

typedef void (__stdcall * PFNGLLISTBASEPROC)(GLuint base);
extern PFNGLLISTBASEPROC glad_glListBase;

typedef void (__stdcall * PFNGLBEGINPROC)(GLenum mode);
extern PFNGLBEGINPROC glad_glBegin;

typedef void (__stdcall * PFNGLBITMAPPROC)(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern PFNGLBITMAPPROC glad_glBitmap;

typedef void (__stdcall * PFNGLCOLOR3BPROC)(GLbyte red, GLbyte green, GLbyte blue);
extern PFNGLCOLOR3BPROC glad_glColor3b;

typedef void (__stdcall * PFNGLCOLOR3BVPROC)(const GLbyte *v);
extern PFNGLCOLOR3BVPROC glad_glColor3bv;

typedef void (__stdcall * PFNGLCOLOR3DPROC)(GLdouble red, GLdouble green, GLdouble blue);
extern PFNGLCOLOR3DPROC glad_glColor3d;

typedef void (__stdcall * PFNGLCOLOR3DVPROC)(const GLdouble *v);
extern PFNGLCOLOR3DVPROC glad_glColor3dv;

typedef void (__stdcall * PFNGLCOLOR3FPROC)(GLfloat red, GLfloat green, GLfloat blue);
extern PFNGLCOLOR3FPROC glad_glColor3f;

typedef void (__stdcall * PFNGLCOLOR3FVPROC)(const GLfloat *v);
extern PFNGLCOLOR3FVPROC glad_glColor3fv;

typedef void (__stdcall * PFNGLCOLOR3IPROC)(GLint red, GLint green, GLint blue);
extern PFNGLCOLOR3IPROC glad_glColor3i;

typedef void (__stdcall * PFNGLCOLOR3IVPROC)(const GLint *v);
extern PFNGLCOLOR3IVPROC glad_glColor3iv;

typedef void (__stdcall * PFNGLCOLOR3SPROC)(GLshort red, GLshort green, GLshort blue);
extern PFNGLCOLOR3SPROC glad_glColor3s;

typedef void (__stdcall * PFNGLCOLOR3SVPROC)(const GLshort *v);
extern PFNGLCOLOR3SVPROC glad_glColor3sv;

typedef void (__stdcall * PFNGLCOLOR3UBPROC)(GLubyte red, GLubyte green, GLubyte blue);
extern PFNGLCOLOR3UBPROC glad_glColor3ub;

typedef void (__stdcall * PFNGLCOLOR3UBVPROC)(const GLubyte *v);
extern PFNGLCOLOR3UBVPROC glad_glColor3ubv;

typedef void (__stdcall * PFNGLCOLOR3UIPROC)(GLuint red, GLuint green, GLuint blue);
extern PFNGLCOLOR3UIPROC glad_glColor3ui;

typedef void (__stdcall * PFNGLCOLOR3UIVPROC)(const GLuint *v);
extern PFNGLCOLOR3UIVPROC glad_glColor3uiv;

typedef void (__stdcall * PFNGLCOLOR3USPROC)(GLushort red, GLushort green, GLushort blue);
extern PFNGLCOLOR3USPROC glad_glColor3us;

typedef void (__stdcall * PFNGLCOLOR3USVPROC)(const GLushort *v);
extern PFNGLCOLOR3USVPROC glad_glColor3usv;

typedef void (__stdcall * PFNGLCOLOR4BPROC)(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern PFNGLCOLOR4BPROC glad_glColor4b;

typedef void (__stdcall * PFNGLCOLOR4BVPROC)(const GLbyte *v);
extern PFNGLCOLOR4BVPROC glad_glColor4bv;

typedef void (__stdcall * PFNGLCOLOR4DPROC)(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern PFNGLCOLOR4DPROC glad_glColor4d;

typedef void (__stdcall * PFNGLCOLOR4DVPROC)(const GLdouble *v);
extern PFNGLCOLOR4DVPROC glad_glColor4dv;

typedef void (__stdcall * PFNGLCOLOR4FPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLCOLOR4FPROC glad_glColor4f;

typedef void (__stdcall * PFNGLCOLOR4FVPROC)(const GLfloat *v);
extern PFNGLCOLOR4FVPROC glad_glColor4fv;

typedef void (__stdcall * PFNGLCOLOR4IPROC)(GLint red, GLint green, GLint blue, GLint alpha);
extern PFNGLCOLOR4IPROC glad_glColor4i;

typedef void (__stdcall * PFNGLCOLOR4IVPROC)(const GLint *v);
extern PFNGLCOLOR4IVPROC glad_glColor4iv;

typedef void (__stdcall * PFNGLCOLOR4SPROC)(GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern PFNGLCOLOR4SPROC glad_glColor4s;

typedef void (__stdcall * PFNGLCOLOR4SVPROC)(const GLshort *v);
extern PFNGLCOLOR4SVPROC glad_glColor4sv;

typedef void (__stdcall * PFNGLCOLOR4UBPROC)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern PFNGLCOLOR4UBPROC glad_glColor4ub;

typedef void (__stdcall * PFNGLCOLOR4UBVPROC)(const GLubyte *v);
extern PFNGLCOLOR4UBVPROC glad_glColor4ubv;

typedef void (__stdcall * PFNGLCOLOR4UIPROC)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern PFNGLCOLOR4UIPROC glad_glColor4ui;

typedef void (__stdcall * PFNGLCOLOR4UIVPROC)(const GLuint *v);
extern PFNGLCOLOR4UIVPROC glad_glColor4uiv;

typedef void (__stdcall * PFNGLCOLOR4USPROC)(GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern PFNGLCOLOR4USPROC glad_glColor4us;

typedef void (__stdcall * PFNGLCOLOR4USVPROC)(const GLushort *v);
extern PFNGLCOLOR4USVPROC glad_glColor4usv;

typedef void (__stdcall * PFNGLEDGEFLAGPROC)(GLboolean flag);
extern PFNGLEDGEFLAGPROC glad_glEdgeFlag;

typedef void (__stdcall * PFNGLEDGEFLAGVPROC)(const GLboolean *flag);
extern PFNGLEDGEFLAGVPROC glad_glEdgeFlagv;

typedef void (__stdcall * PFNGLENDPROC)(void);
extern PFNGLENDPROC glad_glEnd;

typedef void (__stdcall * PFNGLINDEXDPROC)(GLdouble c);
extern PFNGLINDEXDPROC glad_glIndexd;

typedef void (__stdcall * PFNGLINDEXDVPROC)(const GLdouble *c);
extern PFNGLINDEXDVPROC glad_glIndexdv;

typedef void (__stdcall * PFNGLINDEXFPROC)(GLfloat c);
extern PFNGLINDEXFPROC glad_glIndexf;

typedef void (__stdcall * PFNGLINDEXFVPROC)(const GLfloat *c);
extern PFNGLINDEXFVPROC glad_glIndexfv;

typedef void (__stdcall * PFNGLINDEXIPROC)(GLint c);
extern PFNGLINDEXIPROC glad_glIndexi;

typedef void (__stdcall * PFNGLINDEXIVPROC)(const GLint *c);
extern PFNGLINDEXIVPROC glad_glIndexiv;

typedef void (__stdcall * PFNGLINDEXSPROC)(GLshort c);
extern PFNGLINDEXSPROC glad_glIndexs;

typedef void (__stdcall * PFNGLINDEXSVPROC)(const GLshort *c);
extern PFNGLINDEXSVPROC glad_glIndexsv;

typedef void (__stdcall * PFNGLNORMAL3BPROC)(GLbyte nx, GLbyte ny, GLbyte nz);
extern PFNGLNORMAL3BPROC glad_glNormal3b;

typedef void (__stdcall * PFNGLNORMAL3BVPROC)(const GLbyte *v);
extern PFNGLNORMAL3BVPROC glad_glNormal3bv;

typedef void (__stdcall * PFNGLNORMAL3DPROC)(GLdouble nx, GLdouble ny, GLdouble nz);
extern PFNGLNORMAL3DPROC glad_glNormal3d;

typedef void (__stdcall * PFNGLNORMAL3DVPROC)(const GLdouble *v);
extern PFNGLNORMAL3DVPROC glad_glNormal3dv;

typedef void (__stdcall * PFNGLNORMAL3FPROC)(GLfloat nx, GLfloat ny, GLfloat nz);
extern PFNGLNORMAL3FPROC glad_glNormal3f;

typedef void (__stdcall * PFNGLNORMAL3FVPROC)(const GLfloat *v);
extern PFNGLNORMAL3FVPROC glad_glNormal3fv;

typedef void (__stdcall * PFNGLNORMAL3IPROC)(GLint nx, GLint ny, GLint nz);
extern PFNGLNORMAL3IPROC glad_glNormal3i;

typedef void (__stdcall * PFNGLNORMAL3IVPROC)(const GLint *v);
extern PFNGLNORMAL3IVPROC glad_glNormal3iv;

typedef void (__stdcall * PFNGLNORMAL3SPROC)(GLshort nx, GLshort ny, GLshort nz);
extern PFNGLNORMAL3SPROC glad_glNormal3s;

typedef void (__stdcall * PFNGLNORMAL3SVPROC)(const GLshort *v);
extern PFNGLNORMAL3SVPROC glad_glNormal3sv;

typedef void (__stdcall * PFNGLRASTERPOS2DPROC)(GLdouble x, GLdouble y);
extern PFNGLRASTERPOS2DPROC glad_glRasterPos2d;

typedef void (__stdcall * PFNGLRASTERPOS2DVPROC)(const GLdouble *v);
extern PFNGLRASTERPOS2DVPROC glad_glRasterPos2dv;

typedef void (__stdcall * PFNGLRASTERPOS2FPROC)(GLfloat x, GLfloat y);
extern PFNGLRASTERPOS2FPROC glad_glRasterPos2f;

typedef void (__stdcall * PFNGLRASTERPOS2FVPROC)(const GLfloat *v);
extern PFNGLRASTERPOS2FVPROC glad_glRasterPos2fv;

typedef void (__stdcall * PFNGLRASTERPOS2IPROC)(GLint x, GLint y);
extern PFNGLRASTERPOS2IPROC glad_glRasterPos2i;

typedef void (__stdcall * PFNGLRASTERPOS2IVPROC)(const GLint *v);
extern PFNGLRASTERPOS2IVPROC glad_glRasterPos2iv;

typedef void (__stdcall * PFNGLRASTERPOS2SPROC)(GLshort x, GLshort y);
extern PFNGLRASTERPOS2SPROC glad_glRasterPos2s;

typedef void (__stdcall * PFNGLRASTERPOS2SVPROC)(const GLshort *v);
extern PFNGLRASTERPOS2SVPROC glad_glRasterPos2sv;

typedef void (__stdcall * PFNGLRASTERPOS3DPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLRASTERPOS3DPROC glad_glRasterPos3d;

typedef void (__stdcall * PFNGLRASTERPOS3DVPROC)(const GLdouble *v);
extern PFNGLRASTERPOS3DVPROC glad_glRasterPos3dv;

typedef void (__stdcall * PFNGLRASTERPOS3FPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLRASTERPOS3FPROC glad_glRasterPos3f;

typedef void (__stdcall * PFNGLRASTERPOS3FVPROC)(const GLfloat *v);
extern PFNGLRASTERPOS3FVPROC glad_glRasterPos3fv;

typedef void (__stdcall * PFNGLRASTERPOS3IPROC)(GLint x, GLint y, GLint z);
extern PFNGLRASTERPOS3IPROC glad_glRasterPos3i;

typedef void (__stdcall * PFNGLRASTERPOS3IVPROC)(const GLint *v);
extern PFNGLRASTERPOS3IVPROC glad_glRasterPos3iv;

typedef void (__stdcall * PFNGLRASTERPOS3SPROC)(GLshort x, GLshort y, GLshort z);
extern PFNGLRASTERPOS3SPROC glad_glRasterPos3s;

typedef void (__stdcall * PFNGLRASTERPOS3SVPROC)(const GLshort *v);
extern PFNGLRASTERPOS3SVPROC glad_glRasterPos3sv;

typedef void (__stdcall * PFNGLRASTERPOS4DPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLRASTERPOS4DPROC glad_glRasterPos4d;

typedef void (__stdcall * PFNGLRASTERPOS4DVPROC)(const GLdouble *v);
extern PFNGLRASTERPOS4DVPROC glad_glRasterPos4dv;

typedef void (__stdcall * PFNGLRASTERPOS4FPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLRASTERPOS4FPROC glad_glRasterPos4f;

typedef void (__stdcall * PFNGLRASTERPOS4FVPROC)(const GLfloat *v);
extern PFNGLRASTERPOS4FVPROC glad_glRasterPos4fv;

typedef void (__stdcall * PFNGLRASTERPOS4IPROC)(GLint x, GLint y, GLint z, GLint w);
extern PFNGLRASTERPOS4IPROC glad_glRasterPos4i;

typedef void (__stdcall * PFNGLRASTERPOS4IVPROC)(const GLint *v);
extern PFNGLRASTERPOS4IVPROC glad_glRasterPos4iv;

typedef void (__stdcall * PFNGLRASTERPOS4SPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLRASTERPOS4SPROC glad_glRasterPos4s;

typedef void (__stdcall * PFNGLRASTERPOS4SVPROC)(const GLshort *v);
extern PFNGLRASTERPOS4SVPROC glad_glRasterPos4sv;

typedef void (__stdcall * PFNGLRECTDPROC)(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern PFNGLRECTDPROC glad_glRectd;

typedef void (__stdcall * PFNGLRECTDVPROC)(const GLdouble *v1, const GLdouble *v2);
extern PFNGLRECTDVPROC glad_glRectdv;

typedef void (__stdcall * PFNGLRECTFPROC)(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern PFNGLRECTFPROC glad_glRectf;

typedef void (__stdcall * PFNGLRECTFVPROC)(const GLfloat *v1, const GLfloat *v2);
extern PFNGLRECTFVPROC glad_glRectfv;

typedef void (__stdcall * PFNGLRECTIPROC)(GLint x1, GLint y1, GLint x2, GLint y2);
extern PFNGLRECTIPROC glad_glRecti;

typedef void (__stdcall * PFNGLRECTIVPROC)(const GLint *v1, const GLint *v2);
extern PFNGLRECTIVPROC glad_glRectiv;

typedef void (__stdcall * PFNGLRECTSPROC)(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern PFNGLRECTSPROC glad_glRects;

typedef void (__stdcall * PFNGLRECTSVPROC)(const GLshort *v1, const GLshort *v2);
extern PFNGLRECTSVPROC glad_glRectsv;

typedef void (__stdcall * PFNGLTEXCOORD1DPROC)(GLdouble s);
extern PFNGLTEXCOORD1DPROC glad_glTexCoord1d;

typedef void (__stdcall * PFNGLTEXCOORD1DVPROC)(const GLdouble *v);
extern PFNGLTEXCOORD1DVPROC glad_glTexCoord1dv;

typedef void (__stdcall * PFNGLTEXCOORD1FPROC)(GLfloat s);
extern PFNGLTEXCOORD1FPROC glad_glTexCoord1f;

typedef void (__stdcall * PFNGLTEXCOORD1FVPROC)(const GLfloat *v);
extern PFNGLTEXCOORD1FVPROC glad_glTexCoord1fv;

typedef void (__stdcall * PFNGLTEXCOORD1IPROC)(GLint s);
extern PFNGLTEXCOORD1IPROC glad_glTexCoord1i;

typedef void (__stdcall * PFNGLTEXCOORD1IVPROC)(const GLint *v);
extern PFNGLTEXCOORD1IVPROC glad_glTexCoord1iv;

typedef void (__stdcall * PFNGLTEXCOORD1SPROC)(GLshort s);
extern PFNGLTEXCOORD1SPROC glad_glTexCoord1s;

typedef void (__stdcall * PFNGLTEXCOORD1SVPROC)(const GLshort *v);
extern PFNGLTEXCOORD1SVPROC glad_glTexCoord1sv;

typedef void (__stdcall * PFNGLTEXCOORD2DPROC)(GLdouble s, GLdouble t);
extern PFNGLTEXCOORD2DPROC glad_glTexCoord2d;

typedef void (__stdcall * PFNGLTEXCOORD2DVPROC)(const GLdouble *v);
extern PFNGLTEXCOORD2DVPROC glad_glTexCoord2dv;

typedef void (__stdcall * PFNGLTEXCOORD2FPROC)(GLfloat s, GLfloat t);
extern PFNGLTEXCOORD2FPROC glad_glTexCoord2f;

typedef void (__stdcall * PFNGLTEXCOORD2FVPROC)(const GLfloat *v);
extern PFNGLTEXCOORD2FVPROC glad_glTexCoord2fv;

typedef void (__stdcall * PFNGLTEXCOORD2IPROC)(GLint s, GLint t);
extern PFNGLTEXCOORD2IPROC glad_glTexCoord2i;

typedef void (__stdcall * PFNGLTEXCOORD2IVPROC)(const GLint *v);
extern PFNGLTEXCOORD2IVPROC glad_glTexCoord2iv;

typedef void (__stdcall * PFNGLTEXCOORD2SPROC)(GLshort s, GLshort t);
extern PFNGLTEXCOORD2SPROC glad_glTexCoord2s;

typedef void (__stdcall * PFNGLTEXCOORD2SVPROC)(const GLshort *v);
extern PFNGLTEXCOORD2SVPROC glad_glTexCoord2sv;

typedef void (__stdcall * PFNGLTEXCOORD3DPROC)(GLdouble s, GLdouble t, GLdouble r);
extern PFNGLTEXCOORD3DPROC glad_glTexCoord3d;

typedef void (__stdcall * PFNGLTEXCOORD3DVPROC)(const GLdouble *v);
extern PFNGLTEXCOORD3DVPROC glad_glTexCoord3dv;

typedef void (__stdcall * PFNGLTEXCOORD3FPROC)(GLfloat s, GLfloat t, GLfloat r);
extern PFNGLTEXCOORD3FPROC glad_glTexCoord3f;

typedef void (__stdcall * PFNGLTEXCOORD3FVPROC)(const GLfloat *v);
extern PFNGLTEXCOORD3FVPROC glad_glTexCoord3fv;

typedef void (__stdcall * PFNGLTEXCOORD3IPROC)(GLint s, GLint t, GLint r);
extern PFNGLTEXCOORD3IPROC glad_glTexCoord3i;

typedef void (__stdcall * PFNGLTEXCOORD3IVPROC)(const GLint *v);
extern PFNGLTEXCOORD3IVPROC glad_glTexCoord3iv;

typedef void (__stdcall * PFNGLTEXCOORD3SPROC)(GLshort s, GLshort t, GLshort r);
extern PFNGLTEXCOORD3SPROC glad_glTexCoord3s;

typedef void (__stdcall * PFNGLTEXCOORD3SVPROC)(const GLshort *v);
extern PFNGLTEXCOORD3SVPROC glad_glTexCoord3sv;

typedef void (__stdcall * PFNGLTEXCOORD4DPROC)(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern PFNGLTEXCOORD4DPROC glad_glTexCoord4d;

typedef void (__stdcall * PFNGLTEXCOORD4DVPROC)(const GLdouble *v);
extern PFNGLTEXCOORD4DVPROC glad_glTexCoord4dv;

typedef void (__stdcall * PFNGLTEXCOORD4FPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern PFNGLTEXCOORD4FPROC glad_glTexCoord4f;

typedef void (__stdcall * PFNGLTEXCOORD4FVPROC)(const GLfloat *v);
extern PFNGLTEXCOORD4FVPROC glad_glTexCoord4fv;

typedef void (__stdcall * PFNGLTEXCOORD4IPROC)(GLint s, GLint t, GLint r, GLint q);
extern PFNGLTEXCOORD4IPROC glad_glTexCoord4i;

typedef void (__stdcall * PFNGLTEXCOORD4IVPROC)(const GLint *v);
extern PFNGLTEXCOORD4IVPROC glad_glTexCoord4iv;

typedef void (__stdcall * PFNGLTEXCOORD4SPROC)(GLshort s, GLshort t, GLshort r, GLshort q);
extern PFNGLTEXCOORD4SPROC glad_glTexCoord4s;

typedef void (__stdcall * PFNGLTEXCOORD4SVPROC)(const GLshort *v);
extern PFNGLTEXCOORD4SVPROC glad_glTexCoord4sv;

typedef void (__stdcall * PFNGLVERTEX2DPROC)(GLdouble x, GLdouble y);
extern PFNGLVERTEX2DPROC glad_glVertex2d;

typedef void (__stdcall * PFNGLVERTEX2DVPROC)(const GLdouble *v);
extern PFNGLVERTEX2DVPROC glad_glVertex2dv;

typedef void (__stdcall * PFNGLVERTEX2FPROC)(GLfloat x, GLfloat y);
extern PFNGLVERTEX2FPROC glad_glVertex2f;

typedef void (__stdcall * PFNGLVERTEX2FVPROC)(const GLfloat *v);
extern PFNGLVERTEX2FVPROC glad_glVertex2fv;

typedef void (__stdcall * PFNGLVERTEX2IPROC)(GLint x, GLint y);
extern PFNGLVERTEX2IPROC glad_glVertex2i;

typedef void (__stdcall * PFNGLVERTEX2IVPROC)(const GLint *v);
extern PFNGLVERTEX2IVPROC glad_glVertex2iv;

typedef void (__stdcall * PFNGLVERTEX2SPROC)(GLshort x, GLshort y);
extern PFNGLVERTEX2SPROC glad_glVertex2s;

typedef void (__stdcall * PFNGLVERTEX2SVPROC)(const GLshort *v);
extern PFNGLVERTEX2SVPROC glad_glVertex2sv;

typedef void (__stdcall * PFNGLVERTEX3DPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEX3DPROC glad_glVertex3d;

typedef void (__stdcall * PFNGLVERTEX3DVPROC)(const GLdouble *v);
extern PFNGLVERTEX3DVPROC glad_glVertex3dv;

typedef void (__stdcall * PFNGLVERTEX3FPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEX3FPROC glad_glVertex3f;

typedef void (__stdcall * PFNGLVERTEX3FVPROC)(const GLfloat *v);
extern PFNGLVERTEX3FVPROC glad_glVertex3fv;

typedef void (__stdcall * PFNGLVERTEX3IPROC)(GLint x, GLint y, GLint z);
extern PFNGLVERTEX3IPROC glad_glVertex3i;

typedef void (__stdcall * PFNGLVERTEX3IVPROC)(const GLint *v);
extern PFNGLVERTEX3IVPROC glad_glVertex3iv;

typedef void (__stdcall * PFNGLVERTEX3SPROC)(GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEX3SPROC glad_glVertex3s;

typedef void (__stdcall * PFNGLVERTEX3SVPROC)(const GLshort *v);
extern PFNGLVERTEX3SVPROC glad_glVertex3sv;

typedef void (__stdcall * PFNGLVERTEX4DPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEX4DPROC glad_glVertex4d;

typedef void (__stdcall * PFNGLVERTEX4DVPROC)(const GLdouble *v);
extern PFNGLVERTEX4DVPROC glad_glVertex4dv;

typedef void (__stdcall * PFNGLVERTEX4FPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEX4FPROC glad_glVertex4f;

typedef void (__stdcall * PFNGLVERTEX4FVPROC)(const GLfloat *v);
extern PFNGLVERTEX4FVPROC glad_glVertex4fv;

typedef void (__stdcall * PFNGLVERTEX4IPROC)(GLint x, GLint y, GLint z, GLint w);
extern PFNGLVERTEX4IPROC glad_glVertex4i;

typedef void (__stdcall * PFNGLVERTEX4IVPROC)(const GLint *v);
extern PFNGLVERTEX4IVPROC glad_glVertex4iv;

typedef void (__stdcall * PFNGLVERTEX4SPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEX4SPROC glad_glVertex4s;

typedef void (__stdcall * PFNGLVERTEX4SVPROC)(const GLshort *v);
extern PFNGLVERTEX4SVPROC glad_glVertex4sv;

typedef void (__stdcall * PFNGLCLIPPLANEPROC)(GLenum plane, const GLdouble *equation);
extern PFNGLCLIPPLANEPROC glad_glClipPlane;

typedef void (__stdcall * PFNGLCOLORMATERIALPROC)(GLenum face, GLenum mode);
extern PFNGLCOLORMATERIALPROC glad_glColorMaterial;

typedef void (__stdcall * PFNGLFOGFPROC)(GLenum pname, GLfloat param);
extern PFNGLFOGFPROC glad_glFogf;

typedef void (__stdcall * PFNGLFOGFVPROC)(GLenum pname, const GLfloat *params);
extern PFNGLFOGFVPROC glad_glFogfv;

typedef void (__stdcall * PFNGLFOGIPROC)(GLenum pname, GLint param);
extern PFNGLFOGIPROC glad_glFogi;

typedef void (__stdcall * PFNGLFOGIVPROC)(GLenum pname, const GLint *params);
extern PFNGLFOGIVPROC glad_glFogiv;

typedef void (__stdcall * PFNGLLIGHTFPROC)(GLenum light, GLenum pname, GLfloat param);
extern PFNGLLIGHTFPROC glad_glLightf;

typedef void (__stdcall * PFNGLLIGHTFVPROC)(GLenum light, GLenum pname, const GLfloat *params);
extern PFNGLLIGHTFVPROC glad_glLightfv;

typedef void (__stdcall * PFNGLLIGHTIPROC)(GLenum light, GLenum pname, GLint param);
extern PFNGLLIGHTIPROC glad_glLighti;

typedef void (__stdcall * PFNGLLIGHTIVPROC)(GLenum light, GLenum pname, const GLint *params);
extern PFNGLLIGHTIVPROC glad_glLightiv;

typedef void (__stdcall * PFNGLLIGHTMODELFPROC)(GLenum pname, GLfloat param);
extern PFNGLLIGHTMODELFPROC glad_glLightModelf;

typedef void (__stdcall * PFNGLLIGHTMODELFVPROC)(GLenum pname, const GLfloat *params);
extern PFNGLLIGHTMODELFVPROC glad_glLightModelfv;

typedef void (__stdcall * PFNGLLIGHTMODELIPROC)(GLenum pname, GLint param);
extern PFNGLLIGHTMODELIPROC glad_glLightModeli;

typedef void (__stdcall * PFNGLLIGHTMODELIVPROC)(GLenum pname, const GLint *params);
extern PFNGLLIGHTMODELIVPROC glad_glLightModeliv;

typedef void (__stdcall * PFNGLLINESTIPPLEPROC)(GLint factor, GLushort pattern);
extern PFNGLLINESTIPPLEPROC glad_glLineStipple;

typedef void (__stdcall * PFNGLMATERIALFPROC)(GLenum face, GLenum pname, GLfloat param);
extern PFNGLMATERIALFPROC glad_glMaterialf;

typedef void (__stdcall * PFNGLMATERIALFVPROC)(GLenum face, GLenum pname, const GLfloat *params);
extern PFNGLMATERIALFVPROC glad_glMaterialfv;

typedef void (__stdcall * PFNGLMATERIALIPROC)(GLenum face, GLenum pname, GLint param);
extern PFNGLMATERIALIPROC glad_glMateriali;

typedef void (__stdcall * PFNGLMATERIALIVPROC)(GLenum face, GLenum pname, const GLint *params);
extern PFNGLMATERIALIVPROC glad_glMaterialiv;

typedef void (__stdcall * PFNGLPOLYGONSTIPPLEPROC)(const GLubyte *mask);
extern PFNGLPOLYGONSTIPPLEPROC glad_glPolygonStipple;

typedef void (__stdcall * PFNGLSHADEMODELPROC)(GLenum mode);
extern PFNGLSHADEMODELPROC glad_glShadeModel;

typedef void (__stdcall * PFNGLTEXENVFPROC)(GLenum target, GLenum pname, GLfloat param);
extern PFNGLTEXENVFPROC glad_glTexEnvf;

typedef void (__stdcall * PFNGLTEXENVFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLTEXENVFVPROC glad_glTexEnvfv;

typedef void (__stdcall * PFNGLTEXENVIPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLTEXENVIPROC glad_glTexEnvi;

typedef void (__stdcall * PFNGLTEXENVIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXENVIVPROC glad_glTexEnviv;

typedef void (__stdcall * PFNGLTEXGENDPROC)(GLenum coord, GLenum pname, GLdouble param);
extern PFNGLTEXGENDPROC glad_glTexGend;

typedef void (__stdcall * PFNGLTEXGENDVPROC)(GLenum coord, GLenum pname, const GLdouble *params);
extern PFNGLTEXGENDVPROC glad_glTexGendv;

typedef void (__stdcall * PFNGLTEXGENFPROC)(GLenum coord, GLenum pname, GLfloat param);
extern PFNGLTEXGENFPROC glad_glTexGenf;

typedef void (__stdcall * PFNGLTEXGENFVPROC)(GLenum coord, GLenum pname, const GLfloat *params);
extern PFNGLTEXGENFVPROC glad_glTexGenfv;

typedef void (__stdcall * PFNGLTEXGENIPROC)(GLenum coord, GLenum pname, GLint param);
extern PFNGLTEXGENIPROC glad_glTexGeni;

typedef void (__stdcall * PFNGLTEXGENIVPROC)(GLenum coord, GLenum pname, const GLint *params);
extern PFNGLTEXGENIVPROC glad_glTexGeniv;

typedef void (__stdcall * PFNGLFEEDBACKBUFFERPROC)(GLsizei size, GLenum type, GLfloat *buffer);
extern PFNGLFEEDBACKBUFFERPROC glad_glFeedbackBuffer;

typedef void (__stdcall * PFNGLSELECTBUFFERPROC)(GLsizei size, GLuint *buffer);
extern PFNGLSELECTBUFFERPROC glad_glSelectBuffer;

typedef GLint (__stdcall * PFNGLRENDERMODEPROC)(GLenum mode);
extern PFNGLRENDERMODEPROC glad_glRenderMode;

typedef void (__stdcall * PFNGLINITNAMESPROC)(void);
extern PFNGLINITNAMESPROC glad_glInitNames;

typedef void (__stdcall * PFNGLLOADNAMEPROC)(GLuint name);
extern PFNGLLOADNAMEPROC glad_glLoadName;

typedef void (__stdcall * PFNGLPASSTHROUGHPROC)(GLfloat token);
extern PFNGLPASSTHROUGHPROC glad_glPassThrough;

typedef void (__stdcall * PFNGLPOPNAMEPROC)(void);
extern PFNGLPOPNAMEPROC glad_glPopName;

typedef void (__stdcall * PFNGLPUSHNAMEPROC)(GLuint name);
extern PFNGLPUSHNAMEPROC glad_glPushName;

typedef void (__stdcall * PFNGLCLEARACCUMPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLCLEARACCUMPROC glad_glClearAccum;

typedef void (__stdcall * PFNGLCLEARINDEXPROC)(GLfloat c);
extern PFNGLCLEARINDEXPROC glad_glClearIndex;

typedef void (__stdcall * PFNGLINDEXMASKPROC)(GLuint mask);
extern PFNGLINDEXMASKPROC glad_glIndexMask;

typedef void (__stdcall * PFNGLACCUMPROC)(GLenum op, GLfloat value);
extern PFNGLACCUMPROC glad_glAccum;

typedef void (__stdcall * PFNGLPOPATTRIBPROC)(void);
extern PFNGLPOPATTRIBPROC glad_glPopAttrib;

typedef void (__stdcall * PFNGLPUSHATTRIBPROC)(GLbitfield mask);
extern PFNGLPUSHATTRIBPROC glad_glPushAttrib;

typedef void (__stdcall * PFNGLMAP1DPROC)(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern PFNGLMAP1DPROC glad_glMap1d;

typedef void (__stdcall * PFNGLMAP1FPROC)(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern PFNGLMAP1FPROC glad_glMap1f;

typedef void (__stdcall * PFNGLMAP2DPROC)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern PFNGLMAP2DPROC glad_glMap2d;

typedef void (__stdcall * PFNGLMAP2FPROC)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern PFNGLMAP2FPROC glad_glMap2f;

typedef void (__stdcall * PFNGLMAPGRID1DPROC)(GLint un, GLdouble u1, GLdouble u2);
extern PFNGLMAPGRID1DPROC glad_glMapGrid1d;

typedef void (__stdcall * PFNGLMAPGRID1FPROC)(GLint un, GLfloat u1, GLfloat u2);
extern PFNGLMAPGRID1FPROC glad_glMapGrid1f;

typedef void (__stdcall * PFNGLMAPGRID2DPROC)(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern PFNGLMAPGRID2DPROC glad_glMapGrid2d;

typedef void (__stdcall * PFNGLMAPGRID2FPROC)(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern PFNGLMAPGRID2FPROC glad_glMapGrid2f;

typedef void (__stdcall * PFNGLEVALCOORD1DPROC)(GLdouble u);
extern PFNGLEVALCOORD1DPROC glad_glEvalCoord1d;

typedef void (__stdcall * PFNGLEVALCOORD1DVPROC)(const GLdouble *u);
extern PFNGLEVALCOORD1DVPROC glad_glEvalCoord1dv;

typedef void (__stdcall * PFNGLEVALCOORD1FPROC)(GLfloat u);
extern PFNGLEVALCOORD1FPROC glad_glEvalCoord1f;

typedef void (__stdcall * PFNGLEVALCOORD1FVPROC)(const GLfloat *u);
extern PFNGLEVALCOORD1FVPROC glad_glEvalCoord1fv;

typedef void (__stdcall * PFNGLEVALCOORD2DPROC)(GLdouble u, GLdouble v);
extern PFNGLEVALCOORD2DPROC glad_glEvalCoord2d;

typedef void (__stdcall * PFNGLEVALCOORD2DVPROC)(const GLdouble *u);
extern PFNGLEVALCOORD2DVPROC glad_glEvalCoord2dv;

typedef void (__stdcall * PFNGLEVALCOORD2FPROC)(GLfloat u, GLfloat v);
extern PFNGLEVALCOORD2FPROC glad_glEvalCoord2f;

typedef void (__stdcall * PFNGLEVALCOORD2FVPROC)(const GLfloat *u);
extern PFNGLEVALCOORD2FVPROC glad_glEvalCoord2fv;

typedef void (__stdcall * PFNGLEVALMESH1PROC)(GLenum mode, GLint i1, GLint i2);
extern PFNGLEVALMESH1PROC glad_glEvalMesh1;

typedef void (__stdcall * PFNGLEVALPOINT1PROC)(GLint i);
extern PFNGLEVALPOINT1PROC glad_glEvalPoint1;

typedef void (__stdcall * PFNGLEVALMESH2PROC)(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern PFNGLEVALMESH2PROC glad_glEvalMesh2;

typedef void (__stdcall * PFNGLEVALPOINT2PROC)(GLint i, GLint j);
extern PFNGLEVALPOINT2PROC glad_glEvalPoint2;

typedef void (__stdcall * PFNGLALPHAFUNCPROC)(GLenum func, GLfloat ref);
extern PFNGLALPHAFUNCPROC glad_glAlphaFunc;

typedef void (__stdcall * PFNGLPIXELZOOMPROC)(GLfloat xfactor, GLfloat yfactor);
extern PFNGLPIXELZOOMPROC glad_glPixelZoom;

typedef void (__stdcall * PFNGLPIXELTRANSFERFPROC)(GLenum pname, GLfloat param);
extern PFNGLPIXELTRANSFERFPROC glad_glPixelTransferf;

typedef void (__stdcall * PFNGLPIXELTRANSFERIPROC)(GLenum pname, GLint param);
extern PFNGLPIXELTRANSFERIPROC glad_glPixelTransferi;

typedef void (__stdcall * PFNGLPIXELMAPFVPROC)(GLenum map, GLsizei mapsize, const GLfloat *values);
extern PFNGLPIXELMAPFVPROC glad_glPixelMapfv;

typedef void (__stdcall * PFNGLPIXELMAPUIVPROC)(GLenum map, GLsizei mapsize, const GLuint *values);
extern PFNGLPIXELMAPUIVPROC glad_glPixelMapuiv;

typedef void (__stdcall * PFNGLPIXELMAPUSVPROC)(GLenum map, GLsizei mapsize, const GLushort *values);
extern PFNGLPIXELMAPUSVPROC glad_glPixelMapusv;

typedef void (__stdcall * PFNGLCOPYPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern PFNGLCOPYPIXELSPROC glad_glCopyPixels;

typedef void (__stdcall * PFNGLDRAWPIXELSPROC)(GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLDRAWPIXELSPROC glad_glDrawPixels;

typedef void (__stdcall * PFNGLGETCLIPPLANEPROC)(GLenum plane, GLdouble *equation);
extern PFNGLGETCLIPPLANEPROC glad_glGetClipPlane;

typedef void (__stdcall * PFNGLGETLIGHTFVPROC)(GLenum light, GLenum pname, GLfloat *params);
extern PFNGLGETLIGHTFVPROC glad_glGetLightfv;

typedef void (__stdcall * PFNGLGETLIGHTIVPROC)(GLenum light, GLenum pname, GLint *params);
extern PFNGLGETLIGHTIVPROC glad_glGetLightiv;

typedef void (__stdcall * PFNGLGETMAPDVPROC)(GLenum target, GLenum query, GLdouble *v);
extern PFNGLGETMAPDVPROC glad_glGetMapdv;

typedef void (__stdcall * PFNGLGETMAPFVPROC)(GLenum target, GLenum query, GLfloat *v);
extern PFNGLGETMAPFVPROC glad_glGetMapfv;

typedef void (__stdcall * PFNGLGETMAPIVPROC)(GLenum target, GLenum query, GLint *v);
extern PFNGLGETMAPIVPROC glad_glGetMapiv;

typedef void (__stdcall * PFNGLGETMATERIALFVPROC)(GLenum face, GLenum pname, GLfloat *params);
extern PFNGLGETMATERIALFVPROC glad_glGetMaterialfv;

typedef void (__stdcall * PFNGLGETMATERIALIVPROC)(GLenum face, GLenum pname, GLint *params);
extern PFNGLGETMATERIALIVPROC glad_glGetMaterialiv;

typedef void (__stdcall * PFNGLGETPIXELMAPFVPROC)(GLenum map, GLfloat *values);
extern PFNGLGETPIXELMAPFVPROC glad_glGetPixelMapfv;

typedef void (__stdcall * PFNGLGETPIXELMAPUIVPROC)(GLenum map, GLuint *values);
extern PFNGLGETPIXELMAPUIVPROC glad_glGetPixelMapuiv;

typedef void (__stdcall * PFNGLGETPIXELMAPUSVPROC)(GLenum map, GLushort *values);
extern PFNGLGETPIXELMAPUSVPROC glad_glGetPixelMapusv;

typedef void (__stdcall * PFNGLGETPOLYGONSTIPPLEPROC)(GLubyte *mask);
extern PFNGLGETPOLYGONSTIPPLEPROC glad_glGetPolygonStipple;

typedef void (__stdcall * PFNGLGETTEXENVFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETTEXENVFVPROC glad_glGetTexEnvfv;

typedef void (__stdcall * PFNGLGETTEXENVIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXENVIVPROC glad_glGetTexEnviv;

typedef void (__stdcall * PFNGLGETTEXGENDVPROC)(GLenum coord, GLenum pname, GLdouble *params);
extern PFNGLGETTEXGENDVPROC glad_glGetTexGendv;

typedef void (__stdcall * PFNGLGETTEXGENFVPROC)(GLenum coord, GLenum pname, GLfloat *params);
extern PFNGLGETTEXGENFVPROC glad_glGetTexGenfv;

typedef void (__stdcall * PFNGLGETTEXGENIVPROC)(GLenum coord, GLenum pname, GLint *params);
extern PFNGLGETTEXGENIVPROC glad_glGetTexGeniv;

typedef GLboolean (__stdcall * PFNGLISLISTPROC)(GLuint list);
extern PFNGLISLISTPROC glad_glIsList;

typedef void (__stdcall * PFNGLFRUSTUMPROC)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern PFNGLFRUSTUMPROC glad_glFrustum;

typedef void (__stdcall * PFNGLLOADIDENTITYPROC)(void);
extern PFNGLLOADIDENTITYPROC glad_glLoadIdentity;

typedef void (__stdcall * PFNGLLOADMATRIXFPROC)(const GLfloat *m);
extern PFNGLLOADMATRIXFPROC glad_glLoadMatrixf;

typedef void (__stdcall * PFNGLLOADMATRIXDPROC)(const GLdouble *m);
extern PFNGLLOADMATRIXDPROC glad_glLoadMatrixd;

typedef void (__stdcall * PFNGLMATRIXMODEPROC)(GLenum mode);
extern PFNGLMATRIXMODEPROC glad_glMatrixMode;

typedef void (__stdcall * PFNGLMULTMATRIXFPROC)(const GLfloat *m);
extern PFNGLMULTMATRIXFPROC glad_glMultMatrixf;

typedef void (__stdcall * PFNGLMULTMATRIXDPROC)(const GLdouble *m);
extern PFNGLMULTMATRIXDPROC glad_glMultMatrixd;

typedef void (__stdcall * PFNGLORTHOPROC)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern PFNGLORTHOPROC glad_glOrtho;

typedef void (__stdcall * PFNGLPOPMATRIXPROC)(void);
extern PFNGLPOPMATRIXPROC glad_glPopMatrix;

typedef void (__stdcall * PFNGLPUSHMATRIXPROC)(void);
extern PFNGLPUSHMATRIXPROC glad_glPushMatrix;

typedef void (__stdcall * PFNGLROTATEDPROC)(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLROTATEDPROC glad_glRotated;

typedef void (__stdcall * PFNGLROTATEFPROC)(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLROTATEFPROC glad_glRotatef;

typedef void (__stdcall * PFNGLSCALEDPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLSCALEDPROC glad_glScaled;

typedef void (__stdcall * PFNGLSCALEFPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLSCALEFPROC glad_glScalef;

typedef void (__stdcall * PFNGLTRANSLATEDPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLTRANSLATEDPROC glad_glTranslated;

typedef void (__stdcall * PFNGLTRANSLATEFPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLTRANSLATEFPROC glad_glTranslatef;

#line 2363 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_1_1;
typedef void (__stdcall * PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
extern PFNGLDRAWARRAYSPROC glad_glDrawArrays;

typedef void (__stdcall * PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWELEMENTSPROC glad_glDrawElements;

typedef void (__stdcall * PFNGLGETPOINTERVPROC)(GLenum pname, void **params);
extern PFNGLGETPOINTERVPROC glad_glGetPointerv;

typedef void (__stdcall * PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
extern PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;

typedef void (__stdcall * PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;

typedef void (__stdcall * PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;

typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;

typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;

typedef void (__stdcall * PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;

typedef void (__stdcall * PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;

typedef void (__stdcall * PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
extern PFNGLBINDTEXTUREPROC glad_glBindTexture;

typedef void (__stdcall * PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint *textures);
extern PFNGLDELETETEXTURESPROC glad_glDeleteTextures;

typedef void (__stdcall * PFNGLGENTEXTURESPROC)(GLsizei n, GLuint *textures);
extern PFNGLGENTEXTURESPROC glad_glGenTextures;

typedef GLboolean (__stdcall * PFNGLISTEXTUREPROC)(GLuint texture);
extern PFNGLISTEXTUREPROC glad_glIsTexture;

typedef void (__stdcall * PFNGLARRAYELEMENTPROC)(GLint i);
extern PFNGLARRAYELEMENTPROC glad_glArrayElement;

typedef void (__stdcall * PFNGLCOLORPOINTERPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLCOLORPOINTERPROC glad_glColorPointer;

typedef void (__stdcall * PFNGLDISABLECLIENTSTATEPROC)(GLenum array);
extern PFNGLDISABLECLIENTSTATEPROC glad_glDisableClientState;

typedef void (__stdcall * PFNGLEDGEFLAGPOINTERPROC)(GLsizei stride, const void *pointer);
extern PFNGLEDGEFLAGPOINTERPROC glad_glEdgeFlagPointer;

typedef void (__stdcall * PFNGLENABLECLIENTSTATEPROC)(GLenum array);
extern PFNGLENABLECLIENTSTATEPROC glad_glEnableClientState;

typedef void (__stdcall * PFNGLINDEXPOINTERPROC)(GLenum type, GLsizei stride, const void *pointer);
extern PFNGLINDEXPOINTERPROC glad_glIndexPointer;

typedef void (__stdcall * PFNGLINTERLEAVEDARRAYSPROC)(GLenum format, GLsizei stride, const void *pointer);
extern PFNGLINTERLEAVEDARRAYSPROC glad_glInterleavedArrays;

typedef void (__stdcall * PFNGLNORMALPOINTERPROC)(GLenum type, GLsizei stride, const void *pointer);
extern PFNGLNORMALPOINTERPROC glad_glNormalPointer;

typedef void (__stdcall * PFNGLTEXCOORDPOINTERPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLTEXCOORDPOINTERPROC glad_glTexCoordPointer;

typedef void (__stdcall * PFNGLVERTEXPOINTERPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXPOINTERPROC glad_glVertexPointer;

typedef GLboolean (__stdcall * PFNGLARETEXTURESRESIDENTPROC)(GLsizei n, const GLuint *textures, GLboolean *residences);
extern PFNGLARETEXTURESRESIDENTPROC glad_glAreTexturesResident;

typedef void (__stdcall * PFNGLPRIORITIZETEXTURESPROC)(GLsizei n, const GLuint *textures, const GLfloat *priorities);
extern PFNGLPRIORITIZETEXTURESPROC glad_glPrioritizeTextures;

typedef void (__stdcall * PFNGLINDEXUBPROC)(GLubyte c);
extern PFNGLINDEXUBPROC glad_glIndexub;

typedef void (__stdcall * PFNGLINDEXUBVPROC)(const GLubyte *c);
extern PFNGLINDEXUBVPROC glad_glIndexubv;

typedef void (__stdcall * PFNGLPOPCLIENTATTRIBPROC)(void);
extern PFNGLPOPCLIENTATTRIBPROC glad_glPopClientAttrib;

typedef void (__stdcall * PFNGLPUSHCLIENTATTRIBPROC)(GLbitfield mask);
extern PFNGLPUSHCLIENTATTRIBPROC glad_glPushClientAttrib;

#line 2457 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_1_2;
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;

typedef void (__stdcall * PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE3DPROC glad_glTexImage3D;

typedef void (__stdcall * PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;

typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;

#line 2473 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_1_3;
typedef void (__stdcall * PFNGLACTIVETEXTUREPROC)(GLenum texture);
extern PFNGLACTIVETEXTUREPROC glad_glActiveTexture;

typedef void (__stdcall * PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
extern PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;

typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;

typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;

typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;

typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;

typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;

typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;

typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void *img);
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;

typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREPROC)(GLenum texture);
extern PFNGLCLIENTACTIVETEXTUREPROC glad_glClientActiveTexture;

typedef void (__stdcall * PFNGLMULTITEXCOORD1DPROC)(GLenum target, GLdouble s);
extern PFNGLMULTITEXCOORD1DPROC glad_glMultiTexCoord1d;

typedef void (__stdcall * PFNGLMULTITEXCOORD1DVPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD1DVPROC glad_glMultiTexCoord1dv;

typedef void (__stdcall * PFNGLMULTITEXCOORD1FPROC)(GLenum target, GLfloat s);
extern PFNGLMULTITEXCOORD1FPROC glad_glMultiTexCoord1f;

typedef void (__stdcall * PFNGLMULTITEXCOORD1FVPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD1FVPROC glad_glMultiTexCoord1fv;

typedef void (__stdcall * PFNGLMULTITEXCOORD1IPROC)(GLenum target, GLint s);
extern PFNGLMULTITEXCOORD1IPROC glad_glMultiTexCoord1i;

typedef void (__stdcall * PFNGLMULTITEXCOORD1IVPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD1IVPROC glad_glMultiTexCoord1iv;

typedef void (__stdcall * PFNGLMULTITEXCOORD1SPROC)(GLenum target, GLshort s);
extern PFNGLMULTITEXCOORD1SPROC glad_glMultiTexCoord1s;

typedef void (__stdcall * PFNGLMULTITEXCOORD1SVPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD1SVPROC glad_glMultiTexCoord1sv;

typedef void (__stdcall * PFNGLMULTITEXCOORD2DPROC)(GLenum target, GLdouble s, GLdouble t);
extern PFNGLMULTITEXCOORD2DPROC glad_glMultiTexCoord2d;

typedef void (__stdcall * PFNGLMULTITEXCOORD2DVPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD2DVPROC glad_glMultiTexCoord2dv;

typedef void (__stdcall * PFNGLMULTITEXCOORD2FPROC)(GLenum target, GLfloat s, GLfloat t);
extern PFNGLMULTITEXCOORD2FPROC glad_glMultiTexCoord2f;

typedef void (__stdcall * PFNGLMULTITEXCOORD2FVPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD2FVPROC glad_glMultiTexCoord2fv;

typedef void (__stdcall * PFNGLMULTITEXCOORD2IPROC)(GLenum target, GLint s, GLint t);
extern PFNGLMULTITEXCOORD2IPROC glad_glMultiTexCoord2i;

typedef void (__stdcall * PFNGLMULTITEXCOORD2IVPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD2IVPROC glad_glMultiTexCoord2iv;

typedef void (__stdcall * PFNGLMULTITEXCOORD2SPROC)(GLenum target, GLshort s, GLshort t);
extern PFNGLMULTITEXCOORD2SPROC glad_glMultiTexCoord2s;

typedef void (__stdcall * PFNGLMULTITEXCOORD2SVPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD2SVPROC glad_glMultiTexCoord2sv;

typedef void (__stdcall * PFNGLMULTITEXCOORD3DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern PFNGLMULTITEXCOORD3DPROC glad_glMultiTexCoord3d;

typedef void (__stdcall * PFNGLMULTITEXCOORD3DVPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD3DVPROC glad_glMultiTexCoord3dv;

typedef void (__stdcall * PFNGLMULTITEXCOORD3FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern PFNGLMULTITEXCOORD3FPROC glad_glMultiTexCoord3f;

typedef void (__stdcall * PFNGLMULTITEXCOORD3FVPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD3FVPROC glad_glMultiTexCoord3fv;

typedef void (__stdcall * PFNGLMULTITEXCOORD3IPROC)(GLenum target, GLint s, GLint t, GLint r);
extern PFNGLMULTITEXCOORD3IPROC glad_glMultiTexCoord3i;

typedef void (__stdcall * PFNGLMULTITEXCOORD3IVPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD3IVPROC glad_glMultiTexCoord3iv;

typedef void (__stdcall * PFNGLMULTITEXCOORD3SPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
extern PFNGLMULTITEXCOORD3SPROC glad_glMultiTexCoord3s;

typedef void (__stdcall * PFNGLMULTITEXCOORD3SVPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD3SVPROC glad_glMultiTexCoord3sv;

typedef void (__stdcall * PFNGLMULTITEXCOORD4DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern PFNGLMULTITEXCOORD4DPROC glad_glMultiTexCoord4d;

typedef void (__stdcall * PFNGLMULTITEXCOORD4DVPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD4DVPROC glad_glMultiTexCoord4dv;

typedef void (__stdcall * PFNGLMULTITEXCOORD4FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern PFNGLMULTITEXCOORD4FPROC glad_glMultiTexCoord4f;

typedef void (__stdcall * PFNGLMULTITEXCOORD4FVPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD4FVPROC glad_glMultiTexCoord4fv;

typedef void (__stdcall * PFNGLMULTITEXCOORD4IPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern PFNGLMULTITEXCOORD4IPROC glad_glMultiTexCoord4i;

typedef void (__stdcall * PFNGLMULTITEXCOORD4IVPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD4IVPROC glad_glMultiTexCoord4iv;

typedef void (__stdcall * PFNGLMULTITEXCOORD4SPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern PFNGLMULTITEXCOORD4SPROC glad_glMultiTexCoord4s;

typedef void (__stdcall * PFNGLMULTITEXCOORD4SVPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD4SVPROC glad_glMultiTexCoord4sv;

typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFPROC)(const GLfloat *m);
extern PFNGLLOADTRANSPOSEMATRIXFPROC glad_glLoadTransposeMatrixf;

typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDPROC)(const GLdouble *m);
extern PFNGLLOADTRANSPOSEMATRIXDPROC glad_glLoadTransposeMatrixd;

typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFPROC)(const GLfloat *m);
extern PFNGLMULTTRANSPOSEMATRIXFPROC glad_glMultTransposeMatrixf;

typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDPROC)(const GLdouble *m);
extern PFNGLMULTTRANSPOSEMATRIXDPROC glad_glMultTransposeMatrixd;

#line 2615 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_1_4;
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;

typedef void (__stdcall * PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
extern PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;

typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
extern PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;

typedef void (__stdcall * PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
extern PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;

typedef void (__stdcall * PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;

typedef void (__stdcall * PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
extern PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;

typedef void (__stdcall * PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint *params);
extern PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;

typedef void (__stdcall * PFNGLFOGCOORDFPROC)(GLfloat coord);
extern PFNGLFOGCOORDFPROC glad_glFogCoordf;

typedef void (__stdcall * PFNGLFOGCOORDFVPROC)(const GLfloat *coord);
extern PFNGLFOGCOORDFVPROC glad_glFogCoordfv;

typedef void (__stdcall * PFNGLFOGCOORDDPROC)(GLdouble coord);
extern PFNGLFOGCOORDDPROC glad_glFogCoordd;

typedef void (__stdcall * PFNGLFOGCOORDDVPROC)(const GLdouble *coord);
extern PFNGLFOGCOORDDVPROC glad_glFogCoorddv;

typedef void (__stdcall * PFNGLFOGCOORDPOINTERPROC)(GLenum type, GLsizei stride, const void *pointer);
extern PFNGLFOGCOORDPOINTERPROC glad_glFogCoordPointer;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3BPROC)(GLbyte red, GLbyte green, GLbyte blue);
extern PFNGLSECONDARYCOLOR3BPROC glad_glSecondaryColor3b;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVPROC)(const GLbyte *v);
extern PFNGLSECONDARYCOLOR3BVPROC glad_glSecondaryColor3bv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3DPROC)(GLdouble red, GLdouble green, GLdouble blue);
extern PFNGLSECONDARYCOLOR3DPROC glad_glSecondaryColor3d;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVPROC)(const GLdouble *v);
extern PFNGLSECONDARYCOLOR3DVPROC glad_glSecondaryColor3dv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3FPROC)(GLfloat red, GLfloat green, GLfloat blue);
extern PFNGLSECONDARYCOLOR3FPROC glad_glSecondaryColor3f;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVPROC)(const GLfloat *v);
extern PFNGLSECONDARYCOLOR3FVPROC glad_glSecondaryColor3fv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3IPROC)(GLint red, GLint green, GLint blue);
extern PFNGLSECONDARYCOLOR3IPROC glad_glSecondaryColor3i;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVPROC)(const GLint *v);
extern PFNGLSECONDARYCOLOR3IVPROC glad_glSecondaryColor3iv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3SPROC)(GLshort red, GLshort green, GLshort blue);
extern PFNGLSECONDARYCOLOR3SPROC glad_glSecondaryColor3s;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVPROC)(const GLshort *v);
extern PFNGLSECONDARYCOLOR3SVPROC glad_glSecondaryColor3sv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBPROC)(GLubyte red, GLubyte green, GLubyte blue);
extern PFNGLSECONDARYCOLOR3UBPROC glad_glSecondaryColor3ub;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVPROC)(const GLubyte *v);
extern PFNGLSECONDARYCOLOR3UBVPROC glad_glSecondaryColor3ubv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIPROC)(GLuint red, GLuint green, GLuint blue);
extern PFNGLSECONDARYCOLOR3UIPROC glad_glSecondaryColor3ui;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVPROC)(const GLuint *v);
extern PFNGLSECONDARYCOLOR3UIVPROC glad_glSecondaryColor3uiv;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3USPROC)(GLushort red, GLushort green, GLushort blue);
extern PFNGLSECONDARYCOLOR3USPROC glad_glSecondaryColor3us;

typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVPROC)(const GLushort *v);
extern PFNGLSECONDARYCOLOR3USVPROC glad_glSecondaryColor3usv;

typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLSECONDARYCOLORPOINTERPROC glad_glSecondaryColorPointer;

typedef void (__stdcall * PFNGLWINDOWPOS2DPROC)(GLdouble x, GLdouble y);
extern PFNGLWINDOWPOS2DPROC glad_glWindowPos2d;

typedef void (__stdcall * PFNGLWINDOWPOS2DVPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS2DVPROC glad_glWindowPos2dv;

typedef void (__stdcall * PFNGLWINDOWPOS2FPROC)(GLfloat x, GLfloat y);
extern PFNGLWINDOWPOS2FPROC glad_glWindowPos2f;

typedef void (__stdcall * PFNGLWINDOWPOS2FVPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS2FVPROC glad_glWindowPos2fv;

typedef void (__stdcall * PFNGLWINDOWPOS2IPROC)(GLint x, GLint y);
extern PFNGLWINDOWPOS2IPROC glad_glWindowPos2i;

typedef void (__stdcall * PFNGLWINDOWPOS2IVPROC)(const GLint *v);
extern PFNGLWINDOWPOS2IVPROC glad_glWindowPos2iv;

typedef void (__stdcall * PFNGLWINDOWPOS2SPROC)(GLshort x, GLshort y);
extern PFNGLWINDOWPOS2SPROC glad_glWindowPos2s;

typedef void (__stdcall * PFNGLWINDOWPOS2SVPROC)(const GLshort *v);
extern PFNGLWINDOWPOS2SVPROC glad_glWindowPos2sv;

typedef void (__stdcall * PFNGLWINDOWPOS3DPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLWINDOWPOS3DPROC glad_glWindowPos3d;

typedef void (__stdcall * PFNGLWINDOWPOS3DVPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS3DVPROC glad_glWindowPos3dv;

typedef void (__stdcall * PFNGLWINDOWPOS3FPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLWINDOWPOS3FPROC glad_glWindowPos3f;

typedef void (__stdcall * PFNGLWINDOWPOS3FVPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS3FVPROC glad_glWindowPos3fv;

typedef void (__stdcall * PFNGLWINDOWPOS3IPROC)(GLint x, GLint y, GLint z);
extern PFNGLWINDOWPOS3IPROC glad_glWindowPos3i;

typedef void (__stdcall * PFNGLWINDOWPOS3IVPROC)(const GLint *v);
extern PFNGLWINDOWPOS3IVPROC glad_glWindowPos3iv;

typedef void (__stdcall * PFNGLWINDOWPOS3SPROC)(GLshort x, GLshort y, GLshort z);
extern PFNGLWINDOWPOS3SPROC glad_glWindowPos3s;

typedef void (__stdcall * PFNGLWINDOWPOS3SVPROC)(const GLshort *v);
extern PFNGLWINDOWPOS3SVPROC glad_glWindowPos3sv;

typedef void (__stdcall * PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLBLENDCOLORPROC glad_glBlendColor;

typedef void (__stdcall * PFNGLBLENDEQUATIONPROC)(GLenum mode);
extern PFNGLBLENDEQUATIONPROC glad_glBlendEquation;

#line 2760 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_1_5;
typedef void (__stdcall * PFNGLGENQUERIESPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENQUERIESPROC glad_glGenQueries;

typedef void (__stdcall * PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETEQUERIESPROC glad_glDeleteQueries;

typedef GLboolean (__stdcall * PFNGLISQUERYPROC)(GLuint id);
extern PFNGLISQUERYPROC glad_glIsQuery;

typedef void (__stdcall * PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
extern PFNGLBEGINQUERYPROC glad_glBeginQuery;

typedef void (__stdcall * PFNGLENDQUERYPROC)(GLenum target);
extern PFNGLENDQUERYPROC glad_glEndQuery;

typedef void (__stdcall * PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETQUERYIVPROC glad_glGetQueryiv;

typedef void (__stdcall * PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;

typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint *params);
extern PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;

typedef void (__stdcall * PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
extern PFNGLBINDBUFFERPROC glad_glBindBuffer;

typedef void (__stdcall * PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint *buffers);
extern PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;

typedef void (__stdcall * PFNGLGENBUFFERSPROC)(GLsizei n, GLuint *buffers);
extern PFNGLGENBUFFERSPROC glad_glGenBuffers;

typedef GLboolean (__stdcall * PFNGLISBUFFERPROC)(GLuint buffer);
extern PFNGLISBUFFERPROC glad_glIsBuffer;

typedef void (__stdcall * PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void *data, GLenum usage);
extern PFNGLBUFFERDATAPROC glad_glBufferData;

typedef void (__stdcall * PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;

typedef void (__stdcall * PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void *data);
extern PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;

typedef void * (__stdcall * PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
extern PFNGLMAPBUFFERPROC glad_glMapBuffer;

typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERPROC)(GLenum target);
extern PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;

typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;

typedef void (__stdcall * PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void **params);
extern PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;

#line 2821 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_2_0;
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;

typedef void (__stdcall * PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum *bufs);
extern PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;

typedef void (__stdcall * PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;

typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;

typedef void (__stdcall * PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
extern PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;

typedef void (__stdcall * PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
extern PFNGLATTACHSHADERPROC glad_glAttachShader;

typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar *name);
extern PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;

typedef void (__stdcall * PFNGLCOMPILESHADERPROC)(GLuint shader);
extern PFNGLCOMPILESHADERPROC glad_glCompileShader;

typedef GLuint (__stdcall * PFNGLCREATEPROGRAMPROC)(void);
extern PFNGLCREATEPROGRAMPROC glad_glCreateProgram;

typedef GLuint (__stdcall * PFNGLCREATESHADERPROC)(GLenum type);
extern PFNGLCREATESHADERPROC glad_glCreateShader;

typedef void (__stdcall * PFNGLDELETEPROGRAMPROC)(GLuint program);
extern PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;

typedef void (__stdcall * PFNGLDELETESHADERPROC)(GLuint shader);
extern PFNGLDELETESHADERPROC glad_glDeleteShader;

typedef void (__stdcall * PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
extern PFNGLDETACHSHADERPROC glad_glDetachShader;

typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;

typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
extern PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;

typedef void (__stdcall * PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;

typedef void (__stdcall * PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;

typedef void (__stdcall * PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;

typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;

typedef void (__stdcall * PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;

typedef void (__stdcall * PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;

typedef void (__stdcall * PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint *params);
extern PFNGLGETSHADERIVPROC glad_glGetShaderiv;

typedef void (__stdcall * PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;

typedef void (__stdcall * PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;

typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;

typedef void (__stdcall * PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat *params);
extern PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;

typedef void (__stdcall * PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint *params);
extern PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;

typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;

typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;

typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;

typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void **pointer);
extern PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;

typedef GLboolean (__stdcall * PFNGLISPROGRAMPROC)(GLuint program);
extern PFNGLISPROGRAMPROC glad_glIsProgram;

typedef GLboolean (__stdcall * PFNGLISSHADERPROC)(GLuint shader);
extern PFNGLISSHADERPROC glad_glIsShader;

typedef void (__stdcall * PFNGLLINKPROGRAMPROC)(GLuint program);
extern PFNGLLINKPROGRAMPROC glad_glLinkProgram;

typedef void (__stdcall * PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
extern PFNGLSHADERSOURCEPROC glad_glShaderSource;

typedef void (__stdcall * PFNGLUSEPROGRAMPROC)(GLuint program);
extern PFNGLUSEPROGRAMPROC glad_glUseProgram;

typedef void (__stdcall * PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
extern PFNGLUNIFORM1FPROC glad_glUniform1f;

typedef void (__stdcall * PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
extern PFNGLUNIFORM2FPROC glad_glUniform2f;

typedef void (__stdcall * PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLUNIFORM3FPROC glad_glUniform3f;

typedef void (__stdcall * PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLUNIFORM4FPROC glad_glUniform4f;

typedef void (__stdcall * PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
extern PFNGLUNIFORM1IPROC glad_glUniform1i;

typedef void (__stdcall * PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
extern PFNGLUNIFORM2IPROC glad_glUniform2i;

typedef void (__stdcall * PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLUNIFORM3IPROC glad_glUniform3i;

typedef void (__stdcall * PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLUNIFORM4IPROC glad_glUniform4i;

typedef void (__stdcall * PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM1FVPROC glad_glUniform1fv;

typedef void (__stdcall * PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM2FVPROC glad_glUniform2fv;

typedef void (__stdcall * PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM3FVPROC glad_glUniform3fv;

typedef void (__stdcall * PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM4FVPROC glad_glUniform4fv;

typedef void (__stdcall * PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM1IVPROC glad_glUniform1iv;

typedef void (__stdcall * PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM2IVPROC glad_glUniform2iv;

typedef void (__stdcall * PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM3IVPROC glad_glUniform3iv;

typedef void (__stdcall * PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM4IVPROC glad_glUniform4iv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;

typedef void (__stdcall * PFNGLVALIDATEPROGRAMPROC)(GLuint program);
extern PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;

typedef void (__stdcall * PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;

typedef void (__stdcall * PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;

typedef void (__stdcall * PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
extern PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;

typedef void (__stdcall * PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;

typedef void (__stdcall * PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
extern PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;

typedef void (__stdcall * PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;

typedef void (__stdcall * PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;

typedef void (__stdcall * PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;

typedef void (__stdcall * PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
extern PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;

typedef void (__stdcall * PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;

typedef void (__stdcall * PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
extern PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;

typedef void (__stdcall * PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;

typedef void (__stdcall * PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;

typedef void (__stdcall * PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;

typedef void (__stdcall * PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;

typedef void (__stdcall * PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;

typedef void (__stdcall * PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;

typedef void (__stdcall * PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;

typedef void (__stdcall * PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;

typedef void (__stdcall * PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;

typedef void (__stdcall * PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;

typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;

#line 3104 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_2_1;
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;

typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;

#line 3126 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_3_0;
typedef void (__stdcall * PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern PFNGLCOLORMASKIPROC glad_glColorMaski;

typedef void (__stdcall * PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean *data);
extern PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;

typedef void (__stdcall * PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint *data);
extern PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;

typedef void (__stdcall * PFNGLENABLEIPROC)(GLenum target, GLuint index);
extern PFNGLENABLEIPROC glad_glEnablei;

typedef void (__stdcall * PFNGLDISABLEIPROC)(GLenum target, GLuint index);
extern PFNGLDISABLEIPROC glad_glDisablei;

typedef GLboolean (__stdcall * PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
extern PFNGLISENABLEDIPROC glad_glIsEnabledi;

typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
extern PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;

typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKPROC)(void);
extern PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;

typedef void (__stdcall * PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;

typedef void (__stdcall * PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
extern PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;

typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;

typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;

typedef void (__stdcall * PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
extern PFNGLCLAMPCOLORPROC glad_glClampColor;

typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
extern PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;

typedef void (__stdcall * PFNGLENDCONDITIONALRENDERPROC)(void);
extern PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;

typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;

typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;

typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint *params);
extern PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
extern PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;

typedef void (__stdcall * PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
extern PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;

typedef void (__stdcall * PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
extern PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;

typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
extern PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
extern PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
extern PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;

typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;

typedef void (__stdcall * PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint *params);
extern PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;

typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;

typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;

typedef void (__stdcall * PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
extern PFNGLUNIFORM1UIPROC glad_glUniform1ui;

typedef void (__stdcall * PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
extern PFNGLUNIFORM2UIPROC glad_glUniform2ui;

typedef void (__stdcall * PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLUNIFORM3UIPROC glad_glUniform3ui;

typedef void (__stdcall * PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLUNIFORM4UIPROC glad_glUniform4ui;

typedef void (__stdcall * PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;

typedef void (__stdcall * PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;

typedef void (__stdcall * PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;

typedef void (__stdcall * PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;

typedef void (__stdcall * PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;

typedef void (__stdcall * PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint *params);
extern PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;

typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;

typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint *params);
extern PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;

typedef void (__stdcall * PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint *value);
extern PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;

typedef void (__stdcall * PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint *value);
extern PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;

typedef void (__stdcall * PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat *value);
extern PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;

typedef void (__stdcall * PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;

typedef const GLubyte * (__stdcall * PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
extern PFNGLGETSTRINGIPROC glad_glGetStringi;

typedef GLboolean (__stdcall * PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
extern PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;

typedef void (__stdcall * PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
extern PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;

typedef void (__stdcall * PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint *renderbuffers);
extern PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;

typedef void (__stdcall * PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
extern PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;

typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;

typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;

typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
extern PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;

typedef void (__stdcall * PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
extern PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;

typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint *framebuffers);
extern PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;

typedef void (__stdcall * PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
extern PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;

typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;

typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;

typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;

typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;

typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;

typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;

typedef void (__stdcall * PFNGLGENERATEMIPMAPPROC)(GLenum target);
extern PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;

typedef void (__stdcall * PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;

typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;

typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;

typedef void * (__stdcall * PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;

typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;

typedef void (__stdcall * PFNGLBINDVERTEXARRAYPROC)(GLuint array);
extern PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;

typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint *arrays);
extern PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;

typedef void (__stdcall * PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
extern PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;

typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYPROC)(GLuint array);
extern PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;

#line 3382 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_3_1;
typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
extern PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;

typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
extern PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;

typedef void (__stdcall * PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLTEXBUFFERPROC glad_glTexBuffer;

typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
extern PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;

typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;

typedef void (__stdcall * PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
extern PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;

typedef void (__stdcall * PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
extern PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;

typedef void (__stdcall * PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
extern PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;

typedef GLuint (__stdcall * PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar *uniformBlockName);
extern PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;

typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;

typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;

typedef void (__stdcall * PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
extern PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;

#line 3422 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_3_2;
typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
extern PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;

typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;

typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;

typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;

typedef void (__stdcall * PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
extern PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;

typedef GLsync (__stdcall * PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
extern PFNGLFENCESYNCPROC glad_glFenceSync;

typedef GLboolean (__stdcall * PFNGLISSYNCPROC)(GLsync sync);
extern PFNGLISSYNCPROC glad_glIsSync;

typedef void (__stdcall * PFNGLDELETESYNCPROC)(GLsync sync);
extern PFNGLDELETESYNCPROC glad_glDeleteSync;

typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;

typedef void (__stdcall * PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern PFNGLWAITSYNCPROC glad_glWaitSync;

typedef void (__stdcall * PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 *data);
extern PFNGLGETINTEGER64VPROC glad_glGetInteger64v;

typedef void (__stdcall * PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
extern PFNGLGETSYNCIVPROC glad_glGetSynciv;

typedef void (__stdcall * PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 *data);
extern PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;

typedef void (__stdcall * PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 *params);
extern PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;

typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;

typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;

typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;

typedef void (__stdcall * PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat *val);
extern PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;

typedef void (__stdcall * PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
extern PFNGLSAMPLEMASKIPROC glad_glSampleMaski;

#line 3483 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


extern int GLAD_GL_VERSION_3_3;
typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;

typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;

typedef void (__stdcall * PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint *samplers);
extern PFNGLGENSAMPLERSPROC glad_glGenSamplers;

typedef void (__stdcall * PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint *samplers);
extern PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;

typedef GLboolean (__stdcall * PFNGLISSAMPLERPROC)(GLuint sampler);
extern PFNGLISSAMPLERPROC glad_glIsSampler;

typedef void (__stdcall * PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
extern PFNGLBINDSAMPLERPROC glad_glBindSampler;

typedef void (__stdcall * PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
extern PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;

typedef void (__stdcall * PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
extern PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;

typedef void (__stdcall * PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
extern PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;

typedef void (__stdcall * PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat *param);
extern PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;

typedef void (__stdcall * PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
extern PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;

typedef void (__stdcall * PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint *param);
extern PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;

typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint *params);
extern PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;

typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint *params);
extern PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;

typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat *params);
extern PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;

typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint *params);
extern PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;

typedef void (__stdcall * PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
extern PFNGLQUERYCOUNTERPROC glad_glQueryCounter;

typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 *params);
extern PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;

typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 *params);
extern PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;

typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
extern PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;

typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;

typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;

typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;

typedef void (__stdcall * PFNGLVERTEXP2UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP2UIPROC glad_glVertexP2ui;

typedef void (__stdcall * PFNGLVERTEXP2UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv;

typedef void (__stdcall * PFNGLVERTEXP3UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP3UIPROC glad_glVertexP3ui;

typedef void (__stdcall * PFNGLVERTEXP3UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv;

typedef void (__stdcall * PFNGLVERTEXP4UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP4UIPROC glad_glVertexP4ui;

typedef void (__stdcall * PFNGLVERTEXP4UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv;

typedef void (__stdcall * PFNGLTEXCOORDP1UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui;

typedef void (__stdcall * PFNGLTEXCOORDP1UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv;

typedef void (__stdcall * PFNGLTEXCOORDP2UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui;

typedef void (__stdcall * PFNGLTEXCOORDP2UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv;

typedef void (__stdcall * PFNGLTEXCOORDP3UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui;

typedef void (__stdcall * PFNGLTEXCOORDP3UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv;

typedef void (__stdcall * PFNGLTEXCOORDP4UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui;

typedef void (__stdcall * PFNGLTEXCOORDP4UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv;

typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui;

typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv;

typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui;

typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv;

typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui;

typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv;

typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui;

typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv;

typedef void (__stdcall * PFNGLNORMALP3UIPROC)(GLenum type, GLuint coords);
extern PFNGLNORMALP3UIPROC glad_glNormalP3ui;

typedef void (__stdcall * PFNGLNORMALP3UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLNORMALP3UIVPROC glad_glNormalP3uiv;

typedef void (__stdcall * PFNGLCOLORP3UIPROC)(GLenum type, GLuint color);
extern PFNGLCOLORP3UIPROC glad_glColorP3ui;

typedef void (__stdcall * PFNGLCOLORP3UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLCOLORP3UIVPROC glad_glColorP3uiv;

typedef void (__stdcall * PFNGLCOLORP4UIPROC)(GLenum type, GLuint color);
extern PFNGLCOLORP4UIPROC glad_glColorP4ui;

typedef void (__stdcall * PFNGLCOLORP4UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLCOLORP4UIVPROC glad_glColorP4uiv;

typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIPROC)(GLenum type, GLuint color);
extern PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui;

typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv;

#line 3661 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"


}
#line 3665 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

#line 3667 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glad/glad.h"

#line 9 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"
#line 10 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"





#line 1 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"





#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const char *,
	ios_base::openmode, int);
extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const wchar_t *,
	ios_base::openmode, int);

 
extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const unsigned short *,
	ios_base::openmode, int);
 #line 28 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

		
template<class _Elem> inline
	bool _Fgetc(_Elem& _Ch, FILE *_File)
	{	
	return (fread(&_Ch, sizeof (_Elem), 1, _File) == 1);
	}

template<> inline bool _Fgetc(char& _Byte, FILE *_File)
	{	
	int _Meta;
	if ((_Meta = fgetc(_File)) == (-1))
		return (false);
	else
		{	
		_Byte = (char)_Meta;
		return (true);
		}
	}

template<> inline bool _Fgetc(wchar_t& _Wchar, FILE *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF)))
		return (false);
	else
		{	
		_Wchar = (wchar_t)_Meta;
		return (true);
		}
	}

 
template<> inline bool _Fgetc(unsigned short& _Wchar, FILE *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF)))
		return (false);
	else
		{	
		_Wchar = (unsigned short)_Meta;
		return (true);
		}
	}
 #line 73 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

		
template<class _Elem> inline
	bool _Fputc(_Elem _Ch, FILE *_File)
	{	
	return (fwrite(&_Ch, 1, sizeof (_Elem), _File) == sizeof (_Elem));
	}

template<> inline bool _Fputc(char _Byte, FILE *_File)
	{	
	return (fputc(_Byte, _File) != (-1));
	}

template<> inline bool _Fputc(wchar_t _Wchar, FILE *_File)
	{	
	return (:: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}

 
template<> inline bool _Fputc(unsigned short _Wchar, FILE *_File)
	{	
	return (:: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}
 #line 97 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

		
template<class _Elem> inline
	bool _Ungetc(const _Elem& _Ch, FILE *_File)
	{	
	return (false);
	}

template<> inline bool _Ungetc(const char& _Byte, FILE *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const signed char& _Byte, FILE *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const unsigned char& _Byte, FILE *_File)
	{	
	return (ungetc(_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const wchar_t& _Wchar, FILE *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}

 
template<> inline bool _Ungetc(const unsigned short& _Wchar, FILE *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}
 #line 131 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

		
template<class _Elem,
	class _Traits>
	class basic_filebuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_filebuf<_Elem, _Traits> _Myt;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef typename _Traits::state_type _Myst;
	typedef codecvt<_Elem, char, typename _Traits::state_type> _Cvt;

	basic_filebuf(FILE *_File = 0)
		: _Mysb()
		{	
		_Init(_File, _Newfl);
		}

	virtual  ~basic_filebuf() noexcept
		{	
		if (_Myfile != 0)
			_Reset_back();	
		if (_Closef)
			close();
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_filebuf(_Uninitialized)
		: _Mysb(_Noinit)
		{	
		}

	basic_filebuf(_Myt&& _Right)
		{	
		_Init(_Right._Myfile, _Newfl);	
		_Init((FILE *)0, _Closefl);	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			
			FILE *_Myfile_sav = _Myfile;
			const _Cvt *_Pcvt_sav = _Pcvt;
			typename _Traits::state_type _State_sav = _State;
			bool _Wrotesome_sav = _Wrotesome;
			bool _Closef_sav = _Closef;
			bool _Set_eback_sav = _Mysb::eback() == &_Mychar;
			bool _Set_eback_live = _Mysb::gptr() == &_Mychar;

			_Elem *_Pfirst0 = _Mysb::pbase();
			_Elem *_Pnext0 = _Mysb::pptr();
			_Elem *_Pend = _Mysb::epptr();
			_Elem *_Gfirst0 = _Mysb::eback();
			_Elem *_Gnext0 = _Mysb::gptr();
			_Elem *_Gend = _Mysb::egptr();

			
			_Init(_Right._Myfile, _Right._Myfile != 0 ? _Openfl : _Newfl);
			_Mysb::setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			if (_Right.eback() != &_Right._Mychar)
				_Mysb::setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			else if (_Right.gptr() != &_Right._Mychar)
				_Mysb::setg(&_Mychar, &_Mychar + 1, &_Mychar + 1);
			else
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

			_Pcvt = _Right._Pcvt;
			_State = _Right._State;
			_Wrotesome = _Right._Wrotesome;
			_Closef = _Right._Closef;

			
			_Right._Init(_Myfile_sav, _Myfile_sav != 0 ? _Openfl : _Newfl);
			_Right.setp(_Pfirst0, _Pnext0, _Pend);
			if (!_Set_eback_sav)
				_Right.setg(_Gfirst0, _Gnext0, _Gend);
			else if (!_Set_eback_live)
				_Right.setg(&_Right._Mychar, &_Right._Mychar + 1,
					&_Right._Mychar + 1);
			else
				_Right.setg(&_Right._Mychar, &_Right._Mychar,
					&_Right._Mychar + 1);

			_Right._Pcvt = _Pcvt_sav;
			_Right._State = _State_sav;
			_Right._Wrotesome = _Wrotesome_sav;
			_Right._Closef = _Closef_sav;

			
			::std:: swap(_Set_eback, _Right._Set_eback);
			::std:: swap(_Set_egptr, _Right._Set_egptr);

			::std:: swap(_Mychar, _Right._Mychar);
			::std:: swap(_Mysb::_Plocale, _Right._Plocale);
			}
		}

	basic_filebuf(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	enum _Initfl
		{	
		_Newfl, _Openfl, _Closefl};

	bool is_open() const
		{	
		return (_Myfile != 0);
		}

	_Myt *open(const char *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const string& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

	_Myt *open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}

	_Myt *open(const wchar_t *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const wstring& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

	_Myt *open(const wchar_t *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}

 
	_Myt *open(const unsigned short *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 333 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	_Myt *close()
		{	
		_Myt *_Ans = this;
		if (_Myfile == 0)
			_Ans = 0;
		else
			{	
			if (!_Endwrite())
				_Ans = 0;
			if (fclose(_Myfile) != 0)
				_Ans = 0;
			}
		_Init(0, _Closefl);
		return (_Ans);
		}

	virtual void  _Lock()
		{	
		if (_Myfile)
			:: _lock_file(_Myfile);
		}

	virtual void  _Unlock()
		{	
		if (_Myfile)
			:: _unlock_file(_Myfile);
		}

protected:
	virtual int_type  overflow(int_type _Meta =
		_Traits::eof())
		{	
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	
		else if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
				? _Meta : _Traits::eof());	
		else
			{	
			const int _STRING_INC = 8;
			const _Elem _Ch = _Traits::to_char_type(_Meta);
			const _Elem *_Src;
			char *_Dest;

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->out(_State,
					&_Ch, &_Ch + 1, _Src,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (_Traits::eof());	

					_Wrotesome = true;	
					if (_Src != &_Ch)
						return (_Meta);	

					if (0 < _Count)
						;
					else if (_Str.size() < 4 * _STRING_INC)
						_Str.append(_STRING_INC, '\0');	
					else
						return (_Traits::eof());	
					break;
					}

				case codecvt_base::noconv:
					return (_Fputc(_Ch, _Myfile) ? _Meta
						: _Traits::eof());	

				default:
					return (_Traits::eof());	
				}
			}
	}

	virtual int_type  pbackfail(int_type _Meta =
		_Traits::eof())
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::eback() < _Mysb::gptr()
			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
				_Meta)))
			{	
			_Mysb::_Gndec();
			return (_Traits::not_eof(_Meta));
			}
		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::eof());	
		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
			return (_Meta);	
		else if (_Mysb::gptr() != &_Mychar)
			{	
			_Mychar = _Traits::to_char_type(_Meta);
			_Set_back();	
			return (_Meta);
			}
		else
			return (_Traits::eof());	
	}

	virtual int_type  underflow()
		{	
		int_type _Meta;
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
			return (_Meta);	
		else
			{	
			pbackfail(_Meta);
			return (_Meta);
			}
		}

	virtual int_type  uflow()
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(
				*_Mysb::_Gninc()));	
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			{	
			_Elem _Ch = 0;
			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
				: _Traits::eof());
			}
		else
			{	
			string _Str;

			for (; ; )
				{	
				_Elem _Ch, *_Dest;
				const char *_Src;
				int _Nleft;
				int _Meta = fgetc(_Myfile);

				if (_Meta == (-1))
					return (_Traits::eof());	

				_Str.append(1, (char)_Meta);	
				switch (_Pcvt->in(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
					&_Ch, &_Ch + 1, _Dest))
					{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					if (_Dest != &_Ch)
						{	
						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
						for (; 0 < _Nleft; )
							ungetc(_Src[--_Nleft], _Myfile);
						return (_Traits::to_int_type(_Ch));
						}
					else
						_Str.erase((size_t)0,	
							(size_t)(_Src - &*_Str.begin()));
					break;

				case codecvt_base::noconv:
					if (_Str.size() < sizeof (_Elem))
						break;	

					::memcpy_s((&_Ch), (sizeof (_Elem)), (&*_Str.begin()), (sizeof (_Elem)));	
#line 519 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

					return (_Traits::to_int_type(_Ch));	

				default:
					return (_Traits::eof());	
					}
				}
			}
		}

	virtual pos_type  seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition;

		if (_Mysb::gptr() == &_Mychar	
			&& _Way == ios_base::cur	
			&& _Pcvt == 0)	
			_Off -= (off_type)sizeof (_Elem);	

		if (_Myfile == 0 || !_Endwrite()
			|| ((_Off != 0 || _Way != ios_base::cur)
				&& _fseeki64(_Myfile, _Off, _Way) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 550 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"
		}

	virtual pos_type  seekpos(pos_type _Pos,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition = _Pos.seekpos();
		off_type _Off = (off_type)_Pos - (off_type)((long long)(_Fileposition));

		if (_Myfile == 0 || !_Endwrite()
			|| fsetpos(_Myfile, &_Fileposition) != 0
			|| (_Off != 0 && _fseeki64(_Myfile, _Off, 1) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_State = _Pos.state();

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 570 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"
		}

	virtual _Mysb * setbuf(_Elem *_Buffer, streamsize _Count)
		{	
		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
			_Buffer == 0 && _Count == 0 ? 0x0004 : 0x0000,
			(size_t)_Count * sizeof (_Elem)) != 0)
			return (0);	
		else
			{	
			_Init(_Myfile, _Openfl);
			return (this);
			}
		}

	virtual int  sync()
		{	
		return (_Myfile == 0
			|| _Traits::eq_int_type(_Traits::eof(), overflow())
			|| 0 <= fflush(_Myfile) ? 0 : -1);
		}

	virtual void  imbue(const locale& _Loc)
		{	
		_Initcvt(&use_facet< _Cvt >(_Loc));
		}

	void _Init(FILE *_File, _Initfl _Which)
		{	
		 static _Myst _Stinit;	

		_Closef = _Which == _Openfl;
		_Wrotesome = false;

		_Mysb::_Init();	

 
  
  
 #line 610 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

  #pragma warning(push)
  #pragma warning(disable: 6240)	
		if (_File != 0 && sizeof (_Elem) == 1)
  #pragma warning(pop)

			{	
			_Elem **_Pb = 0;
			_Elem **_Pn = 0;
			int *_Nr = 0;

			::_get_stream_buffer_pointers(
				_File,
				reinterpret_cast<char***>(&_Pb),
				reinterpret_cast<char***>(&_Pn),
				&_Nr);
			int *_Nw = _Nr;

			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}

		_Myfile = _File;
		_State = _Stinit;
		_Pcvt = 0;	
		}

	bool _Endwrite()
		{	
		if (_Pcvt == 0 || !_Wrotesome)
			return (true);
		else
			{	
			const int _STRING_INC = 8;
			char *_Dest;
			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
				return (false);

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->unshift(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::ok:
					_Wrotesome = false;	

				case codecvt_base::partial:	
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (false);	
					if (!_Wrotesome)
						return (true);
					if (_Count == 0)
						_Str.append(_STRING_INC, '\0');	
					break;
					}

				case codecvt_base::noconv:
					return (true);	

				default:
					return (false);	
				}
			}
		}

	void _Initcvt(const _Cvt *_Newpcvt)
		{	
		if (_Newpcvt->always_noconv())
			_Pcvt = 0;	
		else
			{	
			_Pcvt = _Newpcvt;
			_Mysb::_Init();	
			}
		}

private:
	const _Cvt *_Pcvt;	
	_Elem _Mychar;	
	bool _Wrotesome;	
	typename _Traits::state_type _State;	
	bool _Closef;	
	FILE *_Myfile;	

	void _Reset_back()
		{	
		if (_Mysb::eback() == &_Mychar)
			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
		}

	void _Set_back()
		{	
		if (_Mysb::eback() != &_Mychar)
			{	
			_Set_eback = _Mysb::eback();
			_Set_egptr = _Mysb::egptr();
			}
		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
		}

	_Elem *_Set_eback;	
	_Elem *_Set_egptr;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_filebuf<_Elem, _Traits>& _Left,
		basic_filebuf<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ifstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_ifstream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ifstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ifstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ifstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 788 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	explicit basic_ifstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ifstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ifstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 867 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	virtual  ~basic_ifstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ifstream<_Elem, _Traits>& _Left,
		basic_ifstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ofstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ofstream<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ofstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ofstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ofstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 986 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	explicit basic_ofstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ofstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ofstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1065 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	virtual  ~basic_ofstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ofstream<_Elem, _Traits>& _Left,
		basic_ofstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_fstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_fstream<_Elem, _Traits> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_fstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_fstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_fstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 1189 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	explicit basic_fstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_fstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_fstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1268 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"

	virtual  ~basic_fstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
	}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_fstream<_Elem, _Traits>& _Left,
		basic_fstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1329 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"
#line 1330 "H:\\Visual Studio\\VC\\INCLUDE\\fstream"






#line 7 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"


#line 10 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"










#line 21 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"




namespace engine
{
	namespace io
	{

		char* ReadEntireFile(const char* path)
		{
			char *result = 0;
			FILE *file = fopen(path, "r");
			if (file)
			{
				fseek(file, 0, 2);
				size_t fileSize = ftell(file);
				fseek(file, 0, 0);

				result = (char *)malloc(fileSize + 1);
				fread(result, fileSize, 1, file);
				result[fileSize] = '\0';

				fclose(file);
			}
			else
			{

				printf("failed  %s path \n", path);
				if (false) { } else { __debugbreak();; };
				
			}
			printf("%s\n", result);
			return result;

			
		}

		char* ReadEntireFile(const char* path, int* size)
		{
			char *result = 0;
			FILE *file = fopen(path, "r");
			if (file)
			{
				fseek(file, 0, 2);
				size_t fileSize = ftell(file);
				fseek(file, 0, 0);

				result = (char *)malloc(fileSize + 1);
				fread(result, fileSize, 1, file);
				result[fileSize] = '\0';

				*size = (int)fileSize;
				fclose(file);
			}
			else
			{
				printf("failed  %s path \n", path);
				if (false) { } else { __debugbreak();; };
				
			}
			
			return result;
		}




		std::string ReadEntireFileToString(const char* path)
		{


























#line 118 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"
			std::ifstream ifile(path);
			
			
			
			
			
			

			std::FILE *fp = std::fopen(path, "rb");
			if (fp)
			{
				std::string contents;
				std::fseek(fp, 0, 2);
				contents.resize(std::ftell(fp));
				std::rewind(fp);
				std::fread(&contents[0], 1, contents.size(), fp);
				std::fclose(fp);
				return(contents);
			}
			else
			{
				printf("CAN'T read file %s \n", path);
				if (false) { } else { __debugbreak();; };
			}
			return { "lol" };
#line 144 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"
		}
#line 146 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"


		void WriteBufferToFile(const char* path, const char* buffer, size_t bufferSize)
		{
			char *result = 0;
			FILE *file = fopen(path, "w");
			if (file)
			{
				fwrite(buffer, bufferSize, 1, file);
				fclose(file);
			}
			else
			{
				if (false) { } else { __debugbreak();; };
			}

			
		}






































































#line 235 "I:\\Dev\\Motors\\pikkumoottori\\inc\\../src/IO.cpp"
		}
	}
#line 16 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"

#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"



















































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/_fixes.hpp"






























#line 53 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"

#pragma once





#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cassert"



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"









#line 11 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 5 "H:\\Visual Studio\\VC\\INCLUDE\\cassert"





#line 61 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#pragma once



#line 9 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"














#line 24 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"


#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cassert"



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"









#line 11 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 5 "H:\\Visual Studio\\VC\\INCLUDE\\cassert"





#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"



#pragma once




















#line 26 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 28 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 30 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 32 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"











#line 44 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"



























#line 72 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"
































































































#line 169 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"










#line 180 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

















































#line 230 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"


#line 233 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 235 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 237 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 239 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"





#line 245 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

















































#line 295 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"









































#line 337 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 339 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 341 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 343 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 345 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 347 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 349 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 351 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 353 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 355 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 357 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 359 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"






























#line 390 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"


#line 393 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 395 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 397 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"











#line 409 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"


#line 412 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"






#line 419 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"



#line 423 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 425 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"




#line 430 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 432 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 434 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 436 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"

#line 438 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"


	typedef __m128		glm_vec4;
	typedef __m128i		glm_ivec4;
	typedef __m128i		glm_uvec4;
#line 444 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"



#line 448 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"




#line 453 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/platform.h"
#line 31 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"













#line 45 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

















#line 63 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"










#line 74 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 78 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"








#line 87 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"






























#line 118 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




































#line 155 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"









#line 165 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 167 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 169 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"














#line 184 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"









#line 194 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 200 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 202 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 208 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"












#line 221 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"









































#line 263 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"
#line 264 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

























#line 290 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"











#line 302 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 308 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 313 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 318 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 320 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 325 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 330 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 336 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 342 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"


#line 345 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 350 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 355 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 357 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 362 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 367 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"






#line 374 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 379 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 381 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 383 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 389 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 394 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 396 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 401 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 406 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 408 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 414 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 419 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 421 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 427 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 432 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 434 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 440 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 445 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 447 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 453 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 458 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




#line 463 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 467 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"







#line 475 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 479 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 483 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 487 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"






















































#line 542 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"







#line 550 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"


#line 553 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 557 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 559 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"















#line 575 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"


#line 578 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



















#line 598 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"


#line 601 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"








#line 610 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"










#line 621 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"






#line 628 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"















#line 644 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"








#line 653 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"
















#line 670 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"








#line 679 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"















#line 695 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"
































#line 728 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"







#line 736 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 740 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"







#line 748 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 752 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 756 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 758 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"



#line 762 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"

#line 764 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"





#line 770 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"










namespace glm
{
	using std::size_t;


#line 786 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"
		typedef int length_t;
#line 788 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"
}








#line 798 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"






#line 805 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"


	namespace glm
	{
		template <typename T, std::size_t N>
		constexpr std::size_t countof(T const (&)[N])
		{
			return N;
		}
	}





#line 821 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\setup.hpp"




namespace glm
{
	enum ctor{uninitialize};
}

#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"


#line 10 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"



#line 14 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"

namespace glm{
namespace detail
{

		typedef std::int8_t					int8;
		typedef std::int16_t				int16;
		typedef std::int32_t				int32;
		typedef std::int64_t				int64;
	
		typedef std::uint8_t				uint8;
		typedef std::uint16_t				uint16;
		typedef std::uint32_t				uint32;
		typedef std::uint64_t				uint64;

































#line 62 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"
	
	typedef signed int						lowp_int_t;
	typedef signed int						mediump_int_t;
	typedef signed int						highp_int_t;
	
	typedef unsigned int					lowp_uint_t;
	typedef unsigned int					mediump_uint_t;
	typedef unsigned int					highp_uint_t;


		using std::make_signed;
		using std::make_unsigned;

































































































































#line 204 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"
}

	typedef detail::int8					int8;
	typedef detail::int16					int16;
	typedef detail::int32					int32;
	typedef detail::int64					int64;
	
	typedef detail::uint8					uint8;
	typedef detail::uint16					uint16;
	typedef detail::uint32					uint32;
	typedef detail::uint64					uint64;

	
	

	
	
	
	
	
	typedef detail::lowp_int_t				lowp_int;

	
	
	
	
	
	typedef detail::mediump_int_t			mediump_int;

	
	
	
	
	
	typedef detail::highp_int_t				highp_int;

	
	
	
	
	
	typedef detail::lowp_uint_t				lowp_uint;

	
	
	
	
	
	typedef detail::mediump_uint_t			mediump_uint;

	
	
	
	
	
	typedef detail::highp_uint_t			highp_uint;


	typedef mediump_int					int_t;








#line 272 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"


	typedef mediump_uint				uint_t;








#line 284 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"

	
	
	
	typedef unsigned int				uint;

	




	static_assert(sizeof(glm::int8) == 1, "int8 size isn't 1 byte on this platform");
	static_assert(sizeof(glm::int16) == 2, "int16 size isn't 2 bytes on this platform");
	static_assert(sizeof(glm::int32) == 4, "int32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::int64) == 8, "int64 size isn't 8 bytes on this platform");

	static_assert(sizeof(glm::uint8) == 1, "uint8 size isn't 1 byte on this platform");
	static_assert(sizeof(glm::uint16) == 2, "uint16 size isn't 2 bytes on this platform");
	static_assert(sizeof(glm::uint32) == 4, "uint32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::uint64) == 8, "uint64 size isn't 8 bytes on this platform");
#line 305 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_int.hpp"

}
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_float.hpp"



#pragma once



namespace glm{
namespace detail
{
	typedef float				float32;
	typedef double				float64;
}
	
	typedef float				lowp_float_t;
	typedef float				mediump_float_t;
	typedef double				highp_float_t;

	
	

	
	
	
	
	
	typedef lowp_float_t		lowp_float;

	
	
	
	
	
	typedef mediump_float_t		mediump_float;

	
	
	
	
	
	typedef highp_float_t		highp_float;


	typedef mediump_float		float_t;








#line 54 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_float.hpp"

	typedef float				float32;
	typedef double				float64;




	static_assert(sizeof(glm::float32) == 4, "float32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::float64) == 8, "float64 size isn't 8 bytes on this platform");
#line 64 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_float.hpp"

	

}
#line 8 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\precision.hpp"



#pragma once



namespace glm
{
	enum precision
	{
		packed_highp,
		packed_mediump,
		packed_lowp,


			aligned_highp,
			aligned_mediump,
			aligned_lowp,
			aligned = aligned_highp,
#line 22 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\precision.hpp"

		highp = packed_highp,
		mediump = packed_mediump,
		lowp = packed_lowp,
		packed = packed_highp,



#line 31 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\precision.hpp"
			defaultp = highp
#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\precision.hpp"
	};
	
namespace detail
{
	template <glm::precision P>
	struct is_aligned
	{
		static const bool value = false;
	};


		template<>
		struct is_aligned<glm::aligned_lowp>
		{
			static const bool value = true;
		};

		template<>
		struct is_aligned<glm::aligned_mediump>
		{
			static const bool value = true;
		};

		template<>
		struct is_aligned<glm::aligned_highp>
		{
			static const bool value = true;
		};
#line 62 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\precision.hpp"
}
}
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"


namespace glm{
namespace detail
{
	template <typename T, std::size_t size, bool aligned>
	struct storage
	{
		typedef struct type {
			uint8 data[size];
		} type;
	};

	







	template <typename T> struct storage<T, 1, true> { struct __declspec(align(1)) type { uint8 data[1]; }; };
	template <typename T> struct storage<T, 2, true> { struct __declspec(align(2)) type { uint8 data[2]; }; };
	template <typename T> struct storage<T, 4, true> { struct __declspec(align(4)) type { uint8 data[4]; }; };
	template <typename T> struct storage<T, 8, true> { struct __declspec(align(8)) type { uint8 data[8]; }; };
	template <typename T> struct storage<T, 16, true> { struct __declspec(align(16)) type { uint8 data[16]; }; };
	template <typename T> struct storage<T, 32, true> { struct __declspec(align(32)) type { uint8 data[32]; }; };
	template <typename T> struct storage<T, 64, true> { struct __declspec(align(64)) type { uint8 data[64]; }; };
		

		template <>
		struct storage<float, 16, true>
		{
			typedef glm_vec4 type;
		};

		template <>
		struct storage<int, 16, true>
		{
			typedef glm_ivec4 type;
		};

		template <>
		struct storage<unsigned int, 16, true>
		{
			typedef glm_uvec4 type;
		};

























#line 80 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"







#line 88 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"













#line 102 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"
}

	template <typename T, precision P> struct tvec1;
	template <typename T, precision P> struct tvec2;
	template <typename T, precision P> struct tvec3;
	template <typename T, precision P> struct tvec4;

	typedef tvec1<float, highp>		highp_vec1_t;
	typedef tvec1<float, mediump>	mediump_vec1_t;
	typedef tvec1<float, lowp>		lowp_vec1_t;
	typedef tvec1<double, highp>	highp_dvec1_t;
	typedef tvec1<double, mediump>	mediump_dvec1_t;
	typedef tvec1<double, lowp>		lowp_dvec1_t;
	typedef tvec1<int, highp>		highp_ivec1_t;
	typedef tvec1<int, mediump>		mediump_ivec1_t;
	typedef tvec1<int, lowp>		lowp_ivec1_t;
	typedef tvec1<uint, highp>		highp_uvec1_t;
	typedef tvec1<uint, mediump>	mediump_uvec1_t;
	typedef tvec1<uint, lowp>		lowp_uvec1_t;
	typedef tvec1<bool, highp>		highp_bvec1_t;
	typedef tvec1<bool, mediump>	mediump_bvec1_t;
	typedef tvec1<bool, lowp>		lowp_bvec1_t;

	
	

	
	
	
	
	
	typedef tvec2<float, highp>		highp_vec2;

	
	
	
	
	
	typedef tvec2<float, mediump>	mediump_vec2;

	
	
	
	
	
	typedef tvec2<float, lowp>		lowp_vec2;

	
	
	
	
	
	typedef tvec2<double, highp>	highp_dvec2;

	
	
	
	
	
	typedef tvec2<double, mediump>	mediump_dvec2;

	
	
	
	
	
	typedef tvec2<double, lowp>		lowp_dvec2;

	
	
	
	
	
	typedef tvec2<int, highp>		highp_ivec2;

	
	
	
	
	
	typedef tvec2<int, mediump>		mediump_ivec2;

	
	
	
	
	
	typedef tvec2<int, lowp>		lowp_ivec2;

	
	
	
	
	
	typedef tvec2<uint, highp>		highp_uvec2;

	
	
	
	
	
	typedef tvec2<uint, mediump>	mediump_uvec2;

	
	
	
	
	
	typedef tvec2<uint, lowp>		lowp_uvec2;

	
	
	
	
	
	typedef tvec2<bool, highp>		highp_bvec2;

	
	
	
	
	
	typedef tvec2<bool, mediump>	mediump_bvec2;

	
	
	
	
	
	typedef tvec2<bool, lowp>		lowp_bvec2;

	

	
	

	
	
	
	
	
	typedef tvec3<float, highp>		highp_vec3;

	
	
	
	
	
	typedef tvec3<float, mediump>	mediump_vec3;

	
	
	
	
	
	typedef tvec3<float, lowp>		lowp_vec3;

	
	
	
	
	
	typedef tvec3<double, highp>	highp_dvec3;

	
	
	
	
	
	typedef tvec3<double, mediump>	mediump_dvec3;

	
	
	
	
	
	typedef tvec3<double, lowp>		lowp_dvec3;

	
	
	
	
	
	typedef tvec3<int, highp>		highp_ivec3;

	
	
	
	
	
	typedef tvec3<int, mediump>		mediump_ivec3;

	
	
	
	
	
	typedef tvec3<int, lowp>		lowp_ivec3;

	
	
	
	
	
	typedef tvec3<uint, highp>		highp_uvec3;

	
	
	
	
	
	typedef tvec3<uint, mediump>	mediump_uvec3;

	
	
	
	
	
	typedef tvec3<uint, lowp>		lowp_uvec3;

	
	
	
	
	typedef tvec3<bool, highp>		highp_bvec3;

	
	
	
	
	typedef tvec3<bool, mediump>	mediump_bvec3;

	
	
	
	
	typedef tvec3<bool, lowp>		lowp_bvec3;

	

	
	

	
	
	
	
	typedef tvec4<float, highp>		highp_vec4;

	
	
	
	
	typedef tvec4<float, mediump>	mediump_vec4;

	
	
	
	
	typedef tvec4<float, lowp>		lowp_vec4;

	
	
	
	
	typedef tvec4<double, highp>	highp_dvec4;

	
	
	
	
	typedef tvec4<double, mediump>	mediump_dvec4;

	
	
	
	
	typedef tvec4<double, lowp>		lowp_dvec4;

	
	
	
	
	typedef tvec4<int, highp>		highp_ivec4;

	
	
	
	
	typedef tvec4<int, mediump>		mediump_ivec4;

	
	
	
	
	typedef tvec4<int, lowp>		lowp_ivec4;

	
	
	
	
	typedef tvec4<uint, highp>		highp_uvec4;

	
	
	
	
	typedef tvec4<uint, mediump>	mediump_uvec4;

	
	
	
	
	typedef tvec4<uint, lowp>		lowp_uvec4;

	
	
	
	
	typedef tvec4<bool, highp>		highp_bvec4;

	
	
	
	
	typedef tvec4<bool, mediump>	mediump_bvec4;

	
	
	
	
	typedef tvec4<bool, lowp>		lowp_bvec4;

	

	
	

	





#line 447 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"



#line 451 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"
	
	
	
	typedef highp_vec2			vec2;

	
	
	
	typedef highp_vec3			vec3;

	
	
	
	typedef highp_vec4			vec4;
#line 466 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"

	





#line 474 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"



#line 478 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"
	
	
	
	typedef highp_dvec2			dvec2;

	
	
	
	typedef highp_dvec3			dvec3;

	
	
	
	typedef highp_dvec4			dvec4;
#line 493 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"

	





#line 501 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"



#line 505 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"
	
	
	
	typedef highp_ivec2			ivec2;

	
	
	
	typedef highp_ivec3			ivec3;

	
	
	
	typedef highp_ivec4			ivec4;
#line 520 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"

	





#line 528 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"



#line 532 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"
	
	
	
	typedef highp_uvec2			uvec2;

	
	
	
	typedef highp_uvec3			uvec3;

	
	
	
	typedef highp_uvec4			uvec4;
#line 547 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"

	





#line 555 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"



#line 559 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"
	
	
	
	typedef highp_bvec2			bvec2;

	
	
	
	typedef highp_bvec3			bvec3;

	
	
	
	typedef highp_bvec4			bvec4;
#line 574 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec.hpp"

	
}
#line 9 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"



#pragma once



namespace glm{
namespace detail
{
	template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
	struct outerProduct_trait{};
}

	template <typename T, precision P> struct tvec2;
	template <typename T, precision P> struct tvec3;
	template <typename T, precision P> struct tvec4;
	template <typename T, precision P> struct tmat2x2;
	template <typename T, precision P> struct tmat2x3;
	template <typename T, precision P> struct tmat2x4;
	template <typename T, precision P> struct tmat3x2;
	template <typename T, precision P> struct tmat3x3;
	template <typename T, precision P> struct tmat3x4;
	template <typename T, precision P> struct tmat4x2;
	template <typename T, precision P> struct tmat4x3;
	template <typename T, precision P> struct tmat4x4;

	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> inverse(matType<T, P> const & m);

	
	
	
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2x2;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x3<float, lowp>		lowp_mat2x3;
	
	
	
	
	
	
	typedef tmat2x3<float, mediump>		mediump_mat2x3;
	
	
	
	
	
	
	typedef tmat2x3<float, highp>		highp_mat2x3;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x4<float, lowp>		lowp_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, mediump>		mediump_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, highp>		highp_mat2x4;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x2<float, lowp>		lowp_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, mediump>		mediump_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, highp>		highp_mat3x2;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3x3;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x4<float, lowp>		lowp_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, mediump>		mediump_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, highp>		highp_mat3x4;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x2<float, lowp>		lowp_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, mediump>		mediump_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, highp>		highp_mat4x2;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x3<float, lowp>		lowp_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, mediump>		mediump_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, highp>		highp_mat4x3;
	
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4x4;
	
	
	
	
	
	
	
	
	










#line 346 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"









#line 356 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"
	
	
	
	typedef highp_mat2x2			mat2x2;
	
	
	
	
	typedef highp_mat2x3			mat2x3;
	
	
	
	
	typedef highp_mat2x4			mat2x4;
	
	
	
	
	typedef highp_mat3x2			mat3x2;
	
	
	
	
	typedef highp_mat3x3			mat3x3;
	
	
	
	
	typedef highp_mat3x4			mat3x4;
	
	
	
	
	typedef highp_mat4x2			mat4x2;
	
	
	
	
	typedef highp_mat4x3			mat4x3;
	
	
	
	
	typedef highp_mat4x4			mat4x4;
	
#line 402 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"
	
	
	
	
	typedef mat2x2					mat2;
	
	
	
	
	typedef mat3x3					mat3;
	
	
	
	
	typedef mat4x4					mat4;
		
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x2<double, lowp>		lowp_dmat2;
	
	
	
	
	
	typedef tmat2x2<double, mediump>	mediump_dmat2;
	
	
	
	
	
	typedef tmat2x2<double, highp>		highp_dmat2;
	
	
	
	
	
	typedef tmat2x2<double, lowp>		lowp_dmat2x2;
	
	
	
	
	
	typedef tmat2x2<double, mediump>	mediump_dmat2x2;
	
	
	
	
	
	typedef tmat2x2<double, highp>		highp_dmat2x2;
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x3<double, lowp>		lowp_dmat2x3;
	
	
	
	
	
	typedef tmat2x3<double, mediump>	mediump_dmat2x3;
	
	
	
	
	
	typedef tmat2x3<double, highp>		highp_dmat2x3;
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x4<double, lowp>		lowp_dmat2x4;
	
	
	
	
	
	typedef tmat2x4<double, mediump>	mediump_dmat2x4;
	
	
	
	
	
	typedef tmat2x4<double, highp>		highp_dmat2x4;
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x2<double, lowp>		lowp_dmat3x2;
	
	
	
	
	
	typedef tmat3x2<double, mediump>	mediump_dmat3x2;
	
	
	
	
	
	typedef tmat3x2<double, highp>		highp_dmat3x2;
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_dmat3;
	
	
	
	
	
	typedef tmat3x3<double, mediump>	mediump_dmat3;
	
	
	
	
	
	typedef tmat3x3<double, highp>		highp_dmat3;
	
	
	
	
	
	typedef tmat3x3<double, lowp>		lowp_dmat3x3;
	
	
	
	
	
	typedef tmat3x3<double, mediump>	mediump_dmat3x3;
	
	
	
	
	
	typedef tmat3x3<double, highp>		highp_dmat3x3;
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x4<double, lowp>		lowp_dmat3x4;
	
	
	
	
	
	typedef tmat3x4<double, mediump>	mediump_dmat3x4;
	
	
	
	
	
	typedef tmat3x4<double, highp>		highp_dmat3x4;
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x2<double, lowp>		lowp_dmat4x2;
	
	
	
	
	
	typedef tmat4x2<double, mediump>	mediump_dmat4x2;
	
	
	
	
	
	typedef tmat4x2<double, highp>		highp_dmat4x2;
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x3<double, lowp>		lowp_dmat4x3;
	
	
	
	
	
	typedef tmat4x3<double, mediump>	mediump_dmat4x3;
	
	
	
	
	
	typedef tmat4x3<double, highp>		highp_dmat4x3;
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x4<double, lowp>		lowp_dmat4;
	
	
	
	
	
	typedef tmat4x4<double, mediump>	mediump_dmat4;
	
	
	
	
	
	typedef tmat4x4<double, highp>		highp_dmat4;
	
	
	
	
	
	typedef tmat4x4<double, lowp>		lowp_dmat4x4;
	
	
	
	
	
	typedef tmat4x4<double, mediump>	mediump_dmat4x4;
	
	
	
	
	
	typedef tmat4x4<double, highp>		highp_dmat4x4;
	
	
	










#line 693 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"









#line 703 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"
	
	
	
	
	typedef highp_dmat2x2		dmat2;
	
	
	
	
	typedef highp_dmat3x3		dmat3;
	
	
	
	
	typedef highp_dmat4x4		dmat4;
	
	
	
	
	typedef highp_dmat2x2		dmat2x2;
	
	
	
	
	typedef highp_dmat2x3		dmat2x3;
	
	
	
	
	typedef highp_dmat2x4		dmat2x4;
	
	
	
	
	typedef highp_dmat3x2		dmat3x2;
	
	
	
	
	typedef highp_dmat3x3		dmat3x3;
	
	
	
	
	typedef highp_dmat3x4		dmat3x4;
	
	
	
	
	typedef highp_dmat4x2		dmat4x2;
	
	
	
	
	typedef highp_dmat4x3		dmat4x3;
	
	
	
	
	typedef highp_dmat4x4		dmat4x4;

#line 765 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat.hpp"
	
	
}

#line 10 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"



namespace glm
{
	template <typename T, precision P> struct tquat;

	
	
	
	typedef tquat<float, lowp>		lowp_quat;

	
	
	
	typedef tquat<float, mediump>	mediump_quat;

	
	
	
	typedef tquat<float, highp>		highp_quat;



#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	typedef highp_quat			quat;
#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

	
	
	
	typedef lowp_quat			lowp_fquat;

	
	
	
	typedef mediump_quat		mediump_fquat;

	
	
	
	typedef highp_quat			highp_fquat;

	
	
	
	typedef quat				fquat;


	
	
	
	typedef tquat<double, lowp>		lowp_dquat;
	
	
	
	
	typedef tquat<double, mediump>	mediump_dquat;
	
	
	
	
	typedef tquat<double, highp>	highp_dquat;
	


#line 82 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

#line 84 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

#line 86 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	
	typedef highp_dquat			dquat;
#line 91 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

}



namespace glm
{
	
	
	typedef detail::int8 lowp_int8;
	
	
	
	typedef detail::int16 lowp_int16;

	
	
	typedef detail::int32 lowp_int32;

	
	
	typedef detail::int64 lowp_int64;

	
	
	typedef detail::int8 lowp_int8_t;
	
	
	
	typedef detail::int16 lowp_int16_t;

	
	
	typedef detail::int32 lowp_int32_t;

	
	
	typedef detail::int64 lowp_int64_t;

	
	
	typedef detail::int8 lowp_i8;
	
	
	
	typedef detail::int16 lowp_i16;

	
	
	typedef detail::int32 lowp_i32;

	
	
	typedef detail::int64 lowp_i64;

	
	
	typedef detail::int8 mediump_int8;
	
	
	
	typedef detail::int16 mediump_int16;

	
	
	typedef detail::int32 mediump_int32;

	
	
	typedef detail::int64 mediump_int64;

	
	
	typedef detail::int8 mediump_int8_t;
	
	
	
	typedef detail::int16 mediump_int16_t;

	
	
	typedef detail::int32 mediump_int32_t;

	
	
	typedef detail::int64 mediump_int64_t;

	
	
	typedef detail::int8 mediump_i8;
	
	
	
	typedef detail::int16 mediump_i16;

	
	
	typedef detail::int32 mediump_i32;

	
	
	typedef detail::int64 mediump_i64;

	
	
	typedef detail::int8 highp_int8;
	
	
	
	typedef detail::int16 highp_int16;

	
	
	typedef detail::int32 highp_int32;

	
	
	typedef detail::int64 highp_int64;

	
	
	typedef detail::int8 highp_int8_t;
	
	
	
	typedef detail::int16 highp_int16_t;

	
	
	typedef detail::int32 highp_int32_t;

	
	
	typedef detail::int64 highp_int64_t;

	
	
	typedef detail::int8 highp_i8;
	
	
	
	typedef detail::int16 highp_i16;

	
	
	typedef detail::int32 highp_i32;

	
	
	typedef detail::int64 highp_i64;
	

	
	
	typedef detail::int8 int8;
	
	
	
	typedef detail::int16 int16;

	
	
	typedef detail::int32 int32;

	
	
	typedef detail::int64 int64;



	using std::int8_t;
	using std::int16_t;
	using std::int32_t;
	using std::int64_t;
















#line 282 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

	
	
	typedef detail::int8 i8;
	
	
	
	typedef detail::int16 i16;

	
	
	typedef detail::int32 i32;

	
	
	typedef detail::int64 i64;
	
	
	
	
	
	typedef tvec1<i8, lowp> lowp_i8vec1;
	
	
	
	typedef tvec2<i8, lowp> lowp_i8vec2;
	
	
	
	typedef tvec3<i8, lowp> lowp_i8vec3;
	
	
	
	typedef tvec4<i8, lowp> lowp_i8vec4;
	

	
	
	typedef tvec1<i8, mediump> mediump_i8vec1;
	
	
	
	typedef tvec2<i8, mediump> mediump_i8vec2;
	
	
	
	typedef tvec3<i8, mediump> mediump_i8vec3;
	
	
	
	typedef tvec4<i8, mediump> mediump_i8vec4;
	
	
	
	
	typedef tvec1<i8, highp> highp_i8vec1;
	
	
	
	typedef tvec2<i8, highp> highp_i8vec2;
	
	
	
	typedef tvec3<i8, highp> highp_i8vec3;
	
	
	
	typedef tvec4<i8, highp> highp_i8vec4;
	





#line 357 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 362 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_i8vec1			i8vec1;
	
	
	
	typedef highp_i8vec2			i8vec2;
	
	
	
	typedef highp_i8vec3			i8vec3;
	
	
	
	typedef highp_i8vec4			i8vec4;
#line 378 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	
	
	typedef tvec1<i16, lowp>		lowp_i16vec1;
	
	
	
	typedef tvec2<i16, lowp>		lowp_i16vec2;
	
	
	
	typedef tvec3<i16, lowp>		lowp_i16vec3;
	
	
	
	typedef tvec4<i16, lowp>		lowp_i16vec4;
	
	
	
	
	typedef tvec1<i16, mediump>		mediump_i16vec1;
	
	
	
	typedef tvec2<i16, mediump>		mediump_i16vec2;
	
	
	
	typedef tvec3<i16, mediump>		mediump_i16vec3;
	
	
	
	typedef tvec4<i16, mediump>		mediump_i16vec4;
	
	
	
	
	typedef tvec1<i16, highp>		highp_i16vec1;
	
	
	
	typedef tvec2<i16, highp>		highp_i16vec2;
	
	
	
	typedef tvec3<i16, highp>		highp_i16vec3;
	
	
	
	typedef tvec4<i16, highp>		highp_i16vec4;
	
	





#line 437 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 442 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_i16vec1			i16vec1;
	
	
	
	typedef highp_i16vec2			i16vec2;
	
	
	
	typedef highp_i16vec3			i16vec3;
	
	
	
	typedef highp_i16vec4			i16vec4;
#line 458 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	typedef tvec1<i32, lowp>		lowp_i32vec1;
	
	
	
	typedef tvec2<i32, lowp>		lowp_i32vec2;
	
	
	
	typedef tvec3<i32, lowp>		lowp_i32vec3;
	
	
	
	typedef tvec4<i32, lowp>		lowp_i32vec4;
	
	
	
	
	typedef tvec1<i32, mediump>		mediump_i32vec1;
	
	
	
	typedef tvec2<i32, mediump>		mediump_i32vec2;
	
	
	
	typedef tvec3<i32, mediump>		mediump_i32vec3;
	
	
	
	typedef tvec4<i32, mediump>		mediump_i32vec4;
	
	
	
	
	typedef tvec1<i32, highp>		highp_i32vec1;
	
	
	
	typedef tvec2<i32, highp>		highp_i32vec2;
	
	
	
	typedef tvec3<i32, highp>		highp_i32vec3;
	
	
	
	typedef tvec4<i32, highp>		highp_i32vec4;
	





#line 516 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 521 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_i32vec1			i32vec1;
	
	
	
	typedef highp_i32vec2			i32vec2;
	
	
	
	typedef highp_i32vec3			i32vec3;
	
	
	
	typedef highp_i32vec4			i32vec4;
#line 537 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	typedef tvec1<i32, lowp>		lowp_i32vec1;
	
	
	
	typedef tvec2<i32, lowp>		lowp_i32vec2;
	
	
	
	typedef tvec3<i32, lowp>		lowp_i32vec3;
	
	
	
	typedef tvec4<i32, lowp>		lowp_i32vec4;
	
	
	
	
	typedef tvec1<i32, mediump>		mediump_i32vec1;
	
	
	
	typedef tvec2<i32, mediump>		mediump_i32vec2;
	
	
	
	typedef tvec3<i32, mediump>		mediump_i32vec3;
	
	
	
	typedef tvec4<i32, mediump>		mediump_i32vec4;
	
	
	
	
	typedef tvec1<i32, highp>		highp_i32vec1;
	
	
	
	typedef tvec2<i32, highp>		highp_i32vec2;
	
	
	
	typedef tvec3<i32, highp>		highp_i32vec3;
	
	
	
	typedef tvec4<i32, highp>		highp_i32vec4;
	





#line 595 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 600 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_i32vec1			i32vec1;

	
	
	typedef highp_i32vec2			i32vec2;
	
	
	
	typedef highp_i32vec3			i32vec3;
	
	
	
	typedef highp_i32vec4			i32vec4;
#line 616 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	
	typedef tvec1<i64, lowp>		lowp_i64vec1;
	
	
	
	typedef tvec2<i64, lowp>		lowp_i64vec2;
	
	
	
	typedef tvec3<i64, lowp>		lowp_i64vec3;
	
	
	
	typedef tvec4<i64, lowp>		lowp_i64vec4;
	
	
	
	
	typedef tvec1<i64, mediump>		mediump_i64vec1;
	
	
	
	typedef tvec2<i64, mediump>		mediump_i64vec2;
	
	
	
	typedef tvec3<i64, mediump>		mediump_i64vec3;
	
	
	
	typedef tvec4<i64, mediump>		mediump_i64vec4;
	
	
	
	
	typedef tvec1<i64, highp>		highp_i64vec1;
	
	
	
	typedef tvec2<i64, highp>		highp_i64vec2;
	
	
	
	typedef tvec3<i64, highp>		highp_i64vec3;
	
	
	
	typedef tvec4<i64, highp>		highp_i64vec4;
	





#line 675 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 680 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_i64vec1			i64vec1;

	
	
	typedef highp_i64vec2			i64vec2;
	
	
	
	typedef highp_i64vec3			i64vec3;
	
	
	
	typedef highp_i64vec4			i64vec4;
#line 696 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	
	
	
	
	
	typedef detail::uint8 lowp_uint8;
	
	
	
	typedef detail::uint16 lowp_uint16;
	
	
	
	typedef detail::uint32 lowp_uint32;
	
	
	
	typedef detail::uint64 lowp_uint64;
	
	
	
	
	typedef detail::uint8 lowp_uint8_t;
	
	
	
	typedef detail::uint16 lowp_uint16_t;
	
	
	
	typedef detail::uint32 lowp_uint32_t;
	
	
	
	typedef detail::uint64 lowp_uint64_t;
	
	
	
	
	typedef detail::uint8 lowp_u8;
	
	
	
	typedef detail::uint16 lowp_u16;
	
	
	
	typedef detail::uint32 lowp_u32;
	
	
	
	typedef detail::uint64 lowp_u64;
	
	
	
	
	
	typedef detail::uint8 mediump_uint8;
	
	
	
	typedef detail::uint16 mediump_uint16;
	
	
	
	typedef detail::uint32 mediump_uint32;
	
	
	
	typedef detail::uint64 mediump_uint64;
	
	
	
	typedef detail::uint8 mediump_uint8_t;
	
	
	
	typedef detail::uint16 mediump_uint16_t;
	
	
	
	typedef detail::uint32 mediump_uint32_t;
	
	
	
	typedef detail::uint64 mediump_uint64_t;
	
	
	
	typedef detail::uint8 mediump_u8;
	
	
	
	typedef detail::uint16 mediump_u16;
	
	
	
	typedef detail::uint32 mediump_u32;
	
	
	
	typedef detail::uint64 mediump_u64;
		
	
	
	
	
	typedef detail::uint8 highp_uint8;
	
	
	
	typedef detail::uint16 highp_uint16;
	
	
	
	typedef detail::uint32 highp_uint32;
	
	
	
	typedef detail::uint64 highp_uint64;
	
	
	
	typedef detail::uint8 highp_uint8_t;
	
	
	
	typedef detail::uint16 highp_uint16_t;
	
	
	
	typedef detail::uint32 highp_uint32_t;
	
	
	
	typedef detail::uint64 highp_uint64_t;
	
	
	
	typedef detail::uint8 highp_u8;
	
	
	
	typedef detail::uint16 highp_u16;
	
	
	
	typedef detail::uint32 highp_u32;
	
	
	
	typedef detail::uint64 highp_u64;
	
	
	
	
	
	typedef detail::uint8 uint8;
	
	
	
	typedef detail::uint16 uint16;
	
	
	
	typedef detail::uint32 uint32;
	
	
	
	typedef detail::uint64 uint64;
	

	using std::uint8_t;
	using std::uint16_t;
	using std::uint32_t;
	using std::uint64_t;
















#line 891 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

	
	
	typedef detail::uint8 u8;

	
	
	typedef detail::uint16 u16;

	
	
	typedef detail::uint32 u32;

	
	
	typedef detail::uint64 u64;



	
	
	typedef tvec1<u8, lowp> lowp_u8vec1;
	
	
	
	typedef tvec2<u8, lowp> lowp_u8vec2;
	
	
	
	typedef tvec3<u8, lowp> lowp_u8vec3;
	
	
	
	typedef tvec4<u8, lowp> lowp_u8vec4;
	

	
	
	typedef tvec1<u8, mediump> mediump_u8vec1;

	
	
	typedef tvec2<u8, mediump> mediump_u8vec2;

	
	
	typedef tvec3<u8, mediump> mediump_u8vec3;

	
	
	typedef tvec4<u8, mediump> mediump_u8vec4;


	
	
	typedef tvec1<u8, highp> highp_u8vec1;

	
	
	typedef tvec2<u8, highp> highp_u8vec2;

	
	
	typedef tvec3<u8, highp> highp_u8vec3;

	
	
	typedef tvec4<u8, highp> highp_u8vec4;






#line 966 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 971 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_u8vec1			u8vec1;

	
	
	typedef highp_u8vec2			u8vec2;

	
	
	typedef highp_u8vec3			u8vec3;

	
	
	typedef highp_u8vec4			u8vec4;
#line 987 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	typedef tvec1<u16, lowp>		lowp_u16vec1;

	
	
	typedef tvec2<u16, lowp>		lowp_u16vec2;

	
	
	typedef tvec3<u16, lowp>		lowp_u16vec3;

	
	
	typedef tvec4<u16, lowp>		lowp_u16vec4;


	
	
	typedef tvec1<u16, mediump>		mediump_u16vec1;

	
	
	typedef tvec2<u16, mediump>		mediump_u16vec2;

	
	
	typedef tvec3<u16, mediump>		mediump_u16vec3;

	
	
	typedef tvec4<u16, mediump>		mediump_u16vec4;


	
	
	typedef tvec1<u16, highp>		highp_u16vec1;

	
	
	typedef tvec2<u16, highp>		highp_u16vec2;

	
	
	typedef tvec3<u16, highp>		highp_u16vec3;

	
	
	typedef tvec4<u16, highp>		highp_u16vec4;







#line 1046 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 1051 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_u16vec1			u16vec1;

	
	
	typedef highp_u16vec2			u16vec2;

	
	
	typedef highp_u16vec3			u16vec3;

	
	
	typedef highp_u16vec4			u16vec4;
#line 1067 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	typedef tvec1<u32, lowp>		lowp_u32vec1;

	
	
	typedef tvec2<u32, lowp>		lowp_u32vec2;

	
	
	typedef tvec3<u32, lowp>		lowp_u32vec3;

	
	
	typedef tvec4<u32, lowp>		lowp_u32vec4;


	
	
	typedef tvec1<u32, mediump>		mediump_u32vec1;

	
	
	typedef tvec2<u32, mediump>		mediump_u32vec2;

	
	
	typedef tvec3<u32, mediump>		mediump_u32vec3;

	
	
	typedef tvec4<u32, mediump>		mediump_u32vec4;


	
	
	typedef tvec1<u32, highp>		highp_u32vec1;

	
	
	typedef tvec2<u32, highp>		highp_u32vec2;

	
	
	typedef tvec3<u32, highp>		highp_u32vec3;

	
	
	typedef tvec4<u32, highp>		highp_u32vec4;






#line 1125 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 1130 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_u32vec1			u32vec1;

	
	
	typedef highp_u32vec2			u32vec2;

	
	
	typedef highp_u32vec3			u32vec3;

	
	
	typedef highp_u32vec4			u32vec4;
#line 1146 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	typedef tvec1<u32, lowp>		lowp_u32vec1;

	
	
	typedef tvec2<u32, lowp>		lowp_u32vec2;

	
	
	typedef tvec3<u32, lowp>		lowp_u32vec3;

	
	
	typedef tvec4<u32, lowp>		lowp_u32vec4;


	
	
	typedef tvec1<u32, mediump>		mediump_u32vec1;

	
	
	typedef tvec2<u32, mediump>		mediump_u32vec2;

	
	
	typedef tvec3<u32, mediump>		mediump_u32vec3;

	
	
	typedef tvec4<u32, mediump>		mediump_u32vec4;


	
	
	typedef tvec1<u32, highp>		highp_u32vec1;

	
	
	typedef tvec2<u32, highp>		highp_u32vec2;

	
	
	typedef tvec3<u32, highp>		highp_u32vec3;

	
	
	typedef tvec4<u32, highp>		highp_u32vec4;






#line 1204 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 1209 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_u32vec1			u32vec1;

	
	
	typedef highp_u32vec2			u32vec2;
	
	
	
	typedef highp_u32vec3			u32vec3;
	
	
	
	typedef highp_u32vec4			u32vec4;
#line 1225 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	
	typedef tvec1<u64, lowp>		lowp_u64vec1;

	
	
	typedef tvec2<u64, lowp>		lowp_u64vec2;

	
	
	typedef tvec3<u64, lowp>		lowp_u64vec3;

	
	
	typedef tvec4<u64, lowp>		lowp_u64vec4;


	
	
	typedef tvec1<u64, mediump>		mediump_u64vec1;

	
	
	typedef tvec2<u64, mediump>		mediump_u64vec2;

	
	
	typedef tvec3<u64, mediump>		mediump_u64vec3;

	
	
	typedef tvec4<u64, mediump>		mediump_u64vec4;


	
	
	typedef tvec1<u64, highp>		highp_u64vec1;

	
	
	typedef tvec2<u64, highp>		highp_u64vec2;

	
	
	typedef tvec3<u64, highp>		highp_u64vec3;

	
	
	typedef tvec4<u64, highp>		highp_u64vec4;






#line 1284 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"




#line 1289 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_u64vec1			u64vec1;

	
	
	typedef highp_u64vec2			u64vec2;
	
	
	
	typedef highp_u64vec3			u64vec3;
	
	
	
	typedef highp_u64vec4			u64vec4;
#line 1305 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	
	

	
	
	typedef detail::float32 lowp_float32;

	
	
	typedef detail::float64 lowp_float64;

	
	
	typedef detail::float32 lowp_float32_t;

	
	
	typedef detail::float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;

	
	
	typedef detail::float32 lowp_float32;

	
	
	typedef detail::float64 lowp_float64;

	
	
	typedef detail::float32 lowp_float32_t;

	
	
	typedef detail::float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;


	
	
	typedef detail::float32 lowp_float32;

	
	
	typedef detail::float64 lowp_float64;

	
	
	typedef detail::float32 lowp_float32_t;
	
	
	
	typedef detail::float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;


	
	
	typedef detail::float32 mediump_float32;

	
	
	typedef detail::float64 mediump_float64;

	
	
	typedef detail::float32 mediump_float32_t;

	
	
	typedef detail::float64 mediump_float64_t;

	
	
	typedef float32 mediump_f32;

	
	
	typedef float64 mediump_f64;


	
	
	typedef detail::float32 highp_float32;

	
	
	typedef detail::float64 highp_float64;

	
	
	typedef detail::float32 highp_float32_t;

	
	
	typedef detail::float64 highp_float64_t;

	
	
	typedef float32 highp_f32;

	
	
	typedef float64 highp_f64;



























#line 1460 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

























#line 1486 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

	
	
	typedef highp_float32 float32;

	
	
	typedef highp_float64 float64;

	
	
	typedef highp_float32_t float32_t;

	
	
	typedef highp_float64_t float64_t;

	
	
	typedef highp_float32_t f32;

	
	
	typedef highp_float64_t f64;
#line 1511 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"


	
	
	typedef tvec1<float, lowp> lowp_vec1;

	
	
	typedef tvec2<float, lowp> lowp_vec2;

	
	
	typedef tvec3<float, lowp> lowp_vec3;

	
	
	typedef tvec4<float, lowp> lowp_vec4;

	
	
	typedef tvec1<float, lowp> lowp_fvec1;

	
	
	typedef tvec2<float, lowp> lowp_fvec2;

	
	
	typedef tvec3<float, lowp> lowp_fvec3;

	
	
	typedef tvec4<float, lowp> lowp_fvec4;


	
	
	typedef tvec1<float, mediump> mediump_vec1;

	
	
	typedef tvec2<float, mediump> mediump_vec2;

	
	
	typedef tvec3<float, mediump> mediump_vec3;

	
	
	typedef tvec4<float, mediump> mediump_vec4;

	
	
	typedef tvec1<float, mediump> mediump_fvec1;

	
	
	typedef tvec2<float, mediump> mediump_fvec2;

	
	
	typedef tvec3<float, mediump> mediump_fvec3;

	
	
	typedef tvec4<float, mediump> mediump_fvec4;


	
	
	typedef tvec1<float, highp> highp_vec1;

	
	
	typedef tvec2<float, highp> highp_vec2;

	
	
	typedef tvec3<float, highp> highp_vec3;

	
	
	typedef tvec4<float, highp> highp_vec4;

	
	
	typedef tvec1<float, highp> highp_fvec1;

	
	
	typedef tvec2<float, highp> highp_fvec2;

	
	
	typedef tvec3<float, highp> highp_fvec3;

	
	
	typedef tvec4<float, highp> highp_fvec4;


	
	
	typedef tvec1<f32, lowp> lowp_f32vec1;

	
	
	typedef tvec2<f32, lowp> lowp_f32vec2;

	
	
	typedef tvec3<f32, lowp> lowp_f32vec3;

	
	
	typedef tvec4<f32, lowp> lowp_f32vec4;

	
	
	typedef tvec1<f32, mediump> mediump_f32vec1;

	
	
	typedef tvec2<f32, mediump> mediump_f32vec2;

	
	
	typedef tvec3<f32, mediump> mediump_f32vec3;

	
	
	typedef tvec4<f32, mediump> mediump_f32vec4;

	
	
	typedef tvec1<f32, highp> highp_f32vec1;

	
	
	typedef tvec2<f32, highp> highp_f32vec2;

	
	
	typedef tvec3<f32, highp> highp_f32vec3;

	
	
	typedef tvec4<f32, highp> highp_f32vec4;


	
	
	typedef tvec1<f64, lowp> lowp_f64vec1;

	
	
	typedef tvec2<f64, lowp> lowp_f64vec2;

	
	
	typedef tvec3<f64, lowp> lowp_f64vec3;

	
	
	typedef tvec4<f64, lowp> lowp_f64vec4;

	
	
	typedef tvec1<f64, mediump> mediump_f64vec1;

	
	
	typedef tvec2<f64, mediump> mediump_f64vec2;

	
	
	typedef tvec3<f64, mediump> mediump_f64vec3;

	
	
	typedef tvec4<f64, mediump> mediump_f64vec4;

	
	
	typedef tvec1<f64, highp> highp_f64vec1;

	
	
	typedef tvec2<f64, highp> highp_f64vec2;

	
	
	typedef tvec3<f64, highp> highp_f64vec3;

	
	
	typedef tvec4<f64, highp> highp_f64vec4;


	
	

	
	
	

	
	
	typedef tmat2x2<f32, lowp> lowp_fmat2x2;

	
	
	typedef tmat2x3<f32, lowp> lowp_fmat2x3;

	
	
	typedef tmat2x4<f32, lowp> lowp_fmat2x4;

	
	
	typedef tmat3x2<f32, lowp> lowp_fmat3x2;

	
	
	typedef tmat3x3<f32, lowp> lowp_fmat3x3;

	
	
	typedef tmat3x4<f32, lowp> lowp_fmat3x4;

	
	
	typedef tmat4x2<f32, lowp> lowp_fmat4x2;

	
	
	typedef tmat4x3<f32, lowp> lowp_fmat4x3;

	
	
	typedef tmat4x4<f32, lowp> lowp_fmat4x4;

	
	
	

	
	
	typedef lowp_fmat2x2 lowp_fmat2;

	
	
	typedef lowp_fmat3x3 lowp_fmat3;

	
	
	typedef lowp_fmat4x4 lowp_fmat4;


	
	
	

	
	
	typedef tmat2x2<f32, mediump> mediump_fmat2x2;

	
	
	typedef tmat2x3<f32, mediump> mediump_fmat2x3;

	
	
	typedef tmat2x4<f32, mediump> mediump_fmat2x4;

	
	
	typedef tmat3x2<f32, mediump> mediump_fmat3x2;

	
	
	typedef tmat3x3<f32, mediump> mediump_fmat3x3;

	
	
	typedef tmat3x4<f32, mediump> mediump_fmat3x4;

	
	
	typedef tmat4x2<f32, mediump> mediump_fmat4x2;

	
	
	typedef tmat4x3<f32, mediump> mediump_fmat4x3;

	
	
	typedef tmat4x4<f32, mediump> mediump_fmat4x4;

	
	
	

	
	
	typedef mediump_fmat2x2 mediump_fmat2;

	
	
	typedef mediump_fmat3x3 mediump_fmat3;

	
	
	typedef mediump_fmat4x4 mediump_fmat4;


	
	
	

	
	
	typedef tmat2x2<f32, highp> highp_fmat2x2;

	
	
	typedef tmat2x3<f32, highp> highp_fmat2x3;

	
	
	typedef tmat2x4<f32, highp> highp_fmat2x4;

	
	
	typedef tmat3x2<f32, highp> highp_fmat3x2;

	
	
	typedef tmat3x3<f32, highp> highp_fmat3x3;

	
	
	typedef tmat3x4<f32, highp> highp_fmat3x4;

	
	
	typedef tmat4x2<f32, highp> highp_fmat4x2;

	
	
	typedef tmat4x3<f32, highp> highp_fmat4x3;

	
	
	typedef tmat4x4<f32, highp> highp_fmat4x4;

	
	
	

	
	
	typedef highp_fmat2x2 highp_fmat2;

	
	
	typedef highp_fmat3x3 highp_fmat3;
	
	
	
	typedef highp_fmat4x4 highp_fmat4;


	
	
	

	
	
	typedef tmat2x2<f32, lowp> lowp_f32mat2x2;

	
	
	typedef tmat2x3<f32, lowp> lowp_f32mat2x3;

	
	
	typedef tmat2x4<f32, lowp> lowp_f32mat2x4;

	
	
	typedef tmat3x2<f32, lowp> lowp_f32mat3x2;

	
	
	typedef tmat3x3<f32, lowp> lowp_f32mat3x3;

	
	
	typedef tmat3x4<f32, lowp> lowp_f32mat3x4;

	
	
	typedef tmat4x2<f32, lowp> lowp_f32mat4x2;

	
	
	typedef tmat4x3<f32, lowp> lowp_f32mat4x3;

	
	
	typedef tmat4x4<f32, lowp> lowp_f32mat4x4;

	
	
	

	
	
	typedef lowp_f32mat2x2 lowp_f32mat2;

	
	
	typedef lowp_f32mat3x3 lowp_f32mat3;

	
	
	typedef lowp_f32mat4x4 lowp_f32mat4;


	
	
	

	
	
	typedef tmat2x2<f32, mediump> mediump_f32mat2x2;

	
	
	typedef tmat2x3<f32, mediump> mediump_f32mat2x3;

	
	
	typedef tmat2x4<f32, mediump> mediump_f32mat2x4;

	
	
	typedef tmat3x2<f32, mediump> mediump_f32mat3x2;

	
	
	typedef tmat3x3<f32, mediump> mediump_f32mat3x3;

	
	
	typedef tmat3x4<f32, mediump> mediump_f32mat3x4;

	
	
	typedef tmat4x2<f32, mediump> mediump_f32mat4x2;

	
	
	typedef tmat4x3<f32, mediump> mediump_f32mat4x3;

	
	
	typedef tmat4x4<f32, mediump> mediump_f32mat4x4;

	
	
	

	
	
	typedef mediump_f32mat2x2 mediump_f32mat2;

	
	
	typedef mediump_f32mat3x3 mediump_f32mat3;

	
	
	typedef mediump_f32mat4x4 mediump_f32mat4;


	
	
	

	
	
	typedef tmat2x2<f32, highp> highp_f32mat2x2;

	
	
	typedef tmat2x3<f32, highp> highp_f32mat2x3;

	
	
	typedef tmat2x4<f32, highp> highp_f32mat2x4;

	
	
	typedef tmat3x2<f32, highp> highp_f32mat3x2;

	
	
	typedef tmat3x3<f32, highp> highp_f32mat3x3;

	
	
	typedef tmat3x4<f32, highp> highp_f32mat3x4;

	
	
	typedef tmat4x2<f32, highp> highp_f32mat4x2;

	
	
	typedef tmat4x3<f32, highp> highp_f32mat4x3;

	
	
	typedef tmat4x4<f32, highp> highp_f32mat4x4;

	
	
	

	
	
	typedef highp_f32mat2x2 highp_f32mat2;

	
	
	typedef highp_f32mat3x3 highp_f32mat3;

	
	
	typedef highp_f32mat4x4 highp_f32mat4;


	
	
	

	
	
	typedef tmat2x2<f64, lowp> lowp_f64mat2x2;

	
	
	typedef tmat2x3<f64, lowp> lowp_f64mat2x3;

	
	
	typedef tmat2x4<f64, lowp> lowp_f64mat2x4;

	
	
	typedef tmat3x2<f64, lowp> lowp_f64mat3x2;

	
	
	typedef tmat3x3<f64, lowp> lowp_f64mat3x3;

	
	
	typedef tmat3x4<f64, lowp> lowp_f64mat3x4;

	
	
	typedef tmat4x2<f64, lowp> lowp_f64mat4x2;

	
	
	typedef tmat4x3<f64, lowp> lowp_f64mat4x3;
	
	
	
	typedef tmat4x4<f64, lowp> lowp_f64mat4x4;

	
	
	

	
	
	typedef lowp_f64mat2x2 lowp_f64mat2;

	
	
	typedef lowp_f64mat3x3 lowp_f64mat3;

	
	
	typedef lowp_f64mat4x4 lowp_f64mat4;


	
	
	

	
	
	typedef tmat2x2<f64, mediump> mediump_f64mat2x2;

	
	
	typedef tmat2x3<f64, mediump> mediump_f64mat2x3;

	
	
	typedef tmat2x4<f64, mediump> mediump_f64mat2x4;

	
	
	typedef tmat3x2<f64, mediump> mediump_f64mat3x2;

	
	
	typedef tmat3x3<f64, mediump> mediump_f64mat3x3;

	
	
	typedef tmat3x4<f64, mediump> mediump_f64mat3x4;

	
	
	typedef tmat4x2<f64, mediump> mediump_f64mat4x2;

	
	
	typedef tmat4x3<f64, mediump> mediump_f64mat4x3;

	
	
	typedef tmat4x4<f64, mediump> mediump_f64mat4x4;

	
	
	

	
	
	typedef mediump_f64mat2x2 mediump_f64mat2;

	
	
	typedef mediump_f64mat3x3 mediump_f64mat3;

	
	
	typedef mediump_f64mat4x4 mediump_f64mat4;

	
	
	

	
	
	typedef tmat2x2<f64, highp> highp_f64mat2x2;

	
	
	typedef tmat2x3<f64, highp> highp_f64mat2x3;

	
	
	typedef tmat2x4<f64, highp> highp_f64mat2x4;

	
	
	typedef tmat3x2<f64, highp> highp_f64mat3x2;

	
	
	typedef tmat3x3<f64, highp> highp_f64mat3x3;

	
	
	typedef tmat3x4<f64, highp> highp_f64mat3x4;

	
	
	typedef tmat4x2<f64, highp> highp_f64mat4x2;

	
	
	typedef tmat4x3<f64, highp> highp_f64mat4x3;

	
	
	typedef tmat4x4<f64, highp> highp_f64mat4x4;

	
	
	

	
	
	typedef highp_f64mat2x2 highp_f64mat2;

	
	
	typedef highp_f64mat3x3 highp_f64mat3;

	
	
	typedef highp_f64mat4x4 highp_f64mat4;

	
	

	
	
	typedef tquat<f32, lowp> lowp_f32quat;

	
	
	typedef tquat<f64, lowp> lowp_f64quat;

	
	
	typedef tquat<f32, mediump> mediump_f32quat;

	
	
	typedef tquat<f64, mediump> mediump_f64quat;

	
	
	typedef tquat<f32, highp> highp_f32quat;

	
	
	typedef tquat<f64, highp> highp_f64quat;






































#line 2289 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"



































#line 2325 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_f32vec1			fvec1;

	
	
	typedef highp_f32vec2			fvec2;

	
	
	typedef highp_f32vec3			fvec3;

	
	
	typedef highp_f32vec4			fvec4;

	
	
	typedef highp_f32mat2x2			fmat2x2;

	
	
	typedef highp_f32mat2x3			fmat2x3;

	
	
	typedef highp_f32mat2x4			fmat2x4;

	
	
	typedef highp_f32mat3x2			fmat3x2;

	
	
	typedef highp_f32mat3x3			fmat3x3;

	
	
	typedef highp_f32mat3x4			fmat3x4;

	
	
	typedef highp_f32mat4x2			fmat4x2;

	
	
	typedef highp_f32mat4x3			fmat4x3;

	
	
	typedef highp_f32mat4x4			fmat4x4;
	
	
	
	typedef fmat2x2					fmat2;

	
	
	typedef fmat3x3					fmat3;

	
	
	typedef fmat4x4					fmat4;

	
	
	typedef highp_fquat				fquat;
	


	
	
	typedef highp_f32vec1			f32vec1;

	
	
	typedef highp_f32vec2			f32vec2;

	
	
	typedef highp_f32vec3			f32vec3;

	
	
	typedef highp_f32vec4			f32vec4;

	
	
	typedef highp_f32mat2x2			f32mat2x2;

	
	
	typedef highp_f32mat2x3			f32mat2x3;

	
	
	typedef highp_f32mat2x4			f32mat2x4;

	
	
	typedef highp_f32mat3x2			f32mat3x2;

	
	
	typedef highp_f32mat3x3			f32mat3x3;

	
	
	typedef highp_f32mat3x4			f32mat3x4;

	
	
	typedef highp_f32mat4x2			f32mat4x2;

	
	
	typedef highp_f32mat4x3			f32mat4x3;

	
	
	typedef highp_f32mat4x4			f32mat4x4;

	
	
	typedef f32mat2x2				f32mat2;

	
	
	typedef f32mat3x3				f32mat3;

	
	
	typedef f32mat4x4				f32mat4;

	
	
	typedef highp_f32quat			f32quat;
#line 2463 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"



















#line 2483 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

















#line 2501 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"
	
	
	typedef highp_f64vec1			f64vec1;

	
	
	typedef highp_f64vec2			f64vec2;

	
	
	typedef highp_f64vec3			f64vec3;

	
	
	typedef highp_f64vec4			f64vec4;

	
	
	typedef highp_f64mat2x2			f64mat2x2;

	
	
	typedef highp_f64mat2x3			f64mat2x3;

	
	
	typedef highp_f64mat2x4			f64mat2x4;

	
	
	typedef highp_f64mat3x2			f64mat3x2;

	
	
	typedef highp_f64mat3x3			f64mat3x3;

	
	
	typedef highp_f64mat3x4			f64mat3x4;

	
	
	typedef highp_f64mat4x2			f64mat4x2;

	
	
	typedef highp_f64mat4x3			f64mat4x3;

	
	
	typedef highp_f64mat4x4			f64mat4x4;

	
	
	typedef f64mat2x2				f64mat2;

	
	
	typedef f64mat3x3				f64mat3;

	
	
	typedef f64mat4x4				f64mat4;

	
	
	typedef highp_f64quat			f64quat;
#line 2569 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\fwd.hpp"

}

#line 62 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"




#line 67 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vec2.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"



#pragma once








#line 14 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec2
	{
		

		typedef T value_type;
		typedef tvec2<T, P> type;
		typedef tvec2<bool, P> bool_type;

		




#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"



#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"




#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"
		
			union
			{
				struct{ T x, y; };
				struct{ T r, g; };
				struct{ T s, t; };











#line 60 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"

			};
		


#line 66 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"


#line 69 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"







#line 77 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"

		

		
		typedef length_t length_type;
		 static length_type length(){return 2;}

		 T & operator[](length_type i);
		 T const & operator[](length_type i) const;

		

		  tvec2() ;
		  tvec2(tvec2<T, P> const& v) = default;
		template <precision Q>
		  tvec2(tvec2<T, Q> const& v);

		

		  explicit tvec2(ctor);
		  explicit tvec2(T scalar);
		  tvec2(T s1, T s2);

		

		
		template <typename A, typename B>
		  tvec2(A x, B y);
		template <typename A, typename B>
		  tvec2(tvec1<A, P> const & v1, tvec1<B, P> const & v2);

		

		
		template <typename U, precision Q>
		   tvec2(tvec3<U, Q> const & v);
		
		template <typename U, precision Q>
		   tvec2(tvec4<U, Q> const & v);

		
		template <typename U, precision Q>
		   tvec2(tvec2<U, Q> const & v);

		






#line 129 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"

		

		 tvec2<T, P>& operator=(tvec2<T, P> const & v) = default;

		template <typename U>
		 tvec2<T, P>& operator=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator+=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator+=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator-=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator-=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator*=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator*=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator*=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator/=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator/=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator/=(tvec2<U, P> const & v);

		

		 tvec2<T, P> & operator++();
		 tvec2<T, P> & operator--();
		 tvec2<T, P> operator++(int);
		 tvec2<T, P> operator--(int);

		

		template <typename U> 
		 tvec2<T, P> & operator%=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator%=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator&=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator&=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator|=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator|=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator^=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator^=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator<<=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator<<=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator>>=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator>>=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator>>=(tvec2<U, P> const & v);
	};

	

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v);

	

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator~(tvec2<T, P> const & v);

	

	template <typename T, precision P>
	 bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <precision P>
	 tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2);

	template <precision P>
	 tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl"



namespace glm
{













	


		template <typename T, precision P>
		 inline  tvec2<T, P>::tvec2()

				: x(0), y(0)
#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl"
		{}
#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl"






#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline  tvec2<T, P>::tvec2(tvec2<T, Q> const & v)
		: x(v.x), y(v.y)
	{}

	

	template <typename T, precision P>
	 inline  tvec2<T, P>::tvec2(ctor)
	{}

	template <typename T, precision P>
	 inline  tvec2<T, P>::tvec2(T scalar)
		: x(scalar), y(scalar)
	{}

	template <typename T, precision P>
	 inline  tvec2<T, P>::tvec2(T s1, T s2)
		: x(s1), y(s2)
	{}

	

	template <typename T, precision P>
	template <typename A, typename B>
	 inline  tvec2<T, P>::tvec2(A a, B b)
		: x(static_cast<T>(a))
		, y(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B>
	 inline  tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)
		: x(static_cast<T>(a.x))
		, y(static_cast<T>(b.x))
	{}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec2<T, P>::tvec2(tvec2<U, Q> const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec2<T, P>::tvec2(tvec3<U, Q> const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec2<T, P>::tvec2(tvec4<U, Q> const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	

	template <typename T, precision P>
	 inline T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl", (unsigned)(103)), 0) );
		return (&x)[i];
	}

	template <typename T, precision P>
	 inline T const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl", (unsigned)(110)), 0) );
		return (&x)[i];
	}

	









#line 125 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec2.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		this->y /= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}

	

	template <typename T, precision P>
	 inline tvec2<T, P> & tvec2<T, P>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec2<T, P> & tvec2<T, P>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec2<T, P> tvec2<T, P>::operator++(int)
	{
		tvec2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec2<T, P> tvec2<T, P>::operator--(int)
	{
		tvec2<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		this->y %= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		this->y &= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		this->y |= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		this->y ^= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		this->y <<= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		return *this;
	}

	

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			-v.x, 
			-v.y);
	}

	

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x + scalar,
			v.y + scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.y + v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar + v.x,
			scalar + v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.x + v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.y + v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x - scalar,
			v.y - scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.y - v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar - v.x,
			scalar - v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.x - v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.y - v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x * scalar,
			v.y * scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.y * v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar * v.x,
			scalar * v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.x * v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.y * v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x / scalar,
			v.y / scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.y / v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar / v.x,
			scalar / v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.x / v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.y / v2.y);
	}

	

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x % scalar,
			v.y % scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.y % v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar % v.x,
			scalar % v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.x % v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.y % v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x & scalar,
			v.y & scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.y & v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar & v.x,
			scalar & v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.x & v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.y & v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x | scalar,
			v.y | scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.y | v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar | v.x,
			scalar | v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.x | v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.y | v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x ^ scalar,
			v.y ^ scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar ^ v.x,
			scalar ^ v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.x ^ v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x << scalar,
			v.y << scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.y << v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar << v.x,
			scalar << v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.x << v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.y << v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x >> scalar,
			v.y >> scalar);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			scalar >> v.x,
			scalar >> v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.x >> v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator~(tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			~v.x,
			~v.y);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y);
	}

	template <typename T, precision P>
	 inline bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y);
	}

	template <precision P>
	 inline tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)
	{
		return tvec2<bool, P>(v1.x && v2.x, v1.y && v2.y);
	}

	template <precision P>
	 inline tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)
	{
		return tvec2<bool, P>(v1.x || v2.x, v1.y || v2.y);
	}
}
#line 388 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"
#line 389 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec2.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vec2.hpp"
#line 69 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vec3.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"



#pragma once








#line 14 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec3
	{
		

		typedef T value_type;
		typedef tvec3<T, P> type;
		typedef tvec3<bool, P> bool_type;

		




#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"



#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"




#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"

			union
			{
				struct{ T x, y, z; };
				struct{ T r, g, b; };
				struct{ T s, t, p; };











#line 60 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"
			};
		


#line 65 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"


#line 68 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"








#line 77 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"

		

		
		typedef length_t length_type;
		 static length_type length(){return 3;}

		 T & operator[](length_type i);
		 T const & operator[](length_type i) const;

		

		  tvec3() ;
		  tvec3(tvec3<T, P> const & v) = default;
		template <precision Q>
		  tvec3(tvec3<T, Q> const & v);

		

		  explicit tvec3(ctor);
		  explicit tvec3(T scalar);
		  tvec3(T a, T b, T c);

		

		
		template <typename A, typename B, typename C>
		  tvec3(A a, B b, C c);
		template <typename A, typename B, typename C>
		  tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);

		

		
		template <typename A, typename B, precision Q>
		  tvec3(tvec2<A, Q> const & a, B b);
		
		template <typename A, typename B, precision Q>
		  tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		  tvec3(A a, tvec2<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		  tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);
		
		template <typename U, precision Q>
		   tvec3(tvec4<U, Q> const & v);

		
		template <typename U, precision Q>
		   tvec3(tvec3<U, Q> const & v);

		


















#line 150 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"

		

		 tvec3<T, P> & operator=(tvec3<T, P> const & v) = default;

		template <typename U>
		 tvec3<T, P> & operator=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator+=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator-=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator*=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator*=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator/=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator/=(tvec3<U, P> const & v);

		

		 tvec3<T, P> & operator++();
		 tvec3<T, P> & operator--();
		 tvec3<T, P> operator++(int);
		 tvec3<T, P> operator--(int);

		

		template <typename U>
		 tvec3<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator%=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator&=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator|=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator^=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator<<=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator>>=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator>>=(tvec3<U, P> const & v);
	};

	

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v);

	

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> const & v1, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P> 
	 tvec3<T, P> operator~(tvec3<T, P> const & v);

	

	template <typename T, precision P>
	 bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <precision P>
	 tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);

	template <precision P>
	 tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl"



namespace glm
{


























	


		template <typename T, precision P>
		 inline  tvec3<T, P>::tvec3()

				: x(0), y(0), z(0)
#line 40 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl"
		{}
#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl"






#line 49 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline  tvec3<T, P>::tvec3(tvec3<T, Q> const & v)
		: x(v.x), y(v.y), z(v.z)
	{}

	

	template <typename T, precision P>
	 inline  tvec3<T, P>::tvec3(ctor)
	{}

	template <typename T, precision P>
	 inline  tvec3<T, P>::tvec3(T scalar)
		: x(scalar), y(scalar), z(scalar)
	{}

	template <typename T, precision P>
	 inline  tvec3<T, P>::tvec3(T a, T b, T c)
		: x(a), y(b), z(c)
	{}

	

	template <typename T, precision P>
	template <typename A, typename B, typename C>
	 inline  tvec3<T, P>::tvec3(A a, B b, C c) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C>
	 inline  tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c))
	{}

	

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec3<T, P>::tvec3(A a, tvec2<B, Q> const & b) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z))
	{}

	

	template <typename T, precision P>
	 inline T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl", (unsigned)(145)), 0) );
		return (&x)[i];
	}

	template <typename T, precision P>
	 inline T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl", (unsigned)(152)), 0) );
		return (&x)[i];
	}

	










#line 168 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec3.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		this->z += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		this->z -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		this->z *= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator/=(U v)
	{
		this->x /= static_cast<T>(v);
		this->y /= static_cast<T>(v);
		this->z /= static_cast<T>(v);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}

	

	template <typename T, precision P>
	 inline tvec3<T, P> & tvec3<T, P>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec3<T, P> & tvec3<T, P>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> tvec3<T, P>::operator++(int)
	{
		tvec3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> tvec3<T, P>::operator--(int)
	{
		tvec3<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)
	{
		this->x %= scalar;
		this->y %= scalar;
		this->z %= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= v.x;
		this->y %= v.x;
		this->z %= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)
	{
		this->x &= scalar;
		this->y &= scalar;
		this->z &= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= v.x;
		this->y &= v.x;
		this->z &= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)
	{
		this->x |= scalar;
		this->y |= scalar;
		this->z |= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= v.x;
		this->y |= v.x;
		this->z |= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)
	{
		this->x ^= scalar;
		this->y ^= scalar;
		this->z ^= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= v.x;
		this->y ^= v.x;
		this->z ^= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)
	{
		this->x <<= scalar;
		this->y <<= scalar;
		this->z <<= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		this->z >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		this->z >>= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		return *this;
	}

	

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			-v.x, 
			-v.y, 
			-v.z);
	}

	

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x + scalar.x,
			v.y + scalar.x,
			v.z + scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x + v.x,
			scalar.x + v.y,
			scalar.x + v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x - scalar.x,
			v.y - scalar.x,
			v.z - scalar.x);
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z);
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x - v.x,
			scalar.x - v.y,
			scalar.x - v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x * scalar.x,
			v.y * scalar.x,
			v.z * scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x * v.x,
			scalar.x * v.y,
			scalar.x * v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x / scalar.x,
			v.y / scalar.x,
			v.z / scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x / v.x,
			scalar.x / v.y,
			scalar.x / v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}

	

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x % scalar,
			v.y % scalar,
			v.z % scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x % scalar.x,
			v.y % scalar.x,
			v.z % scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar % v.x,
			scalar % v.y,
			scalar % v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x % v.x,
			scalar.x % v.y,
			scalar.x % v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x & scalar,
			v.y & scalar,
			v.z & scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x & scalar.x,
			v.y & scalar.x,
			v.z & scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar & v.x,
			scalar & v.y,
			scalar & v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x & v.x,
			scalar.x & v.y,
			scalar.x & v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x | scalar,
			v.y | scalar,
			v.z | scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x | scalar.x,
			v.y | scalar.x,
			v.z | scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar | v.x,
			scalar | v.y,
			scalar | v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x | v.x,
			scalar.x | v.y,
			scalar.x | v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x ^ scalar,
			v.y ^ scalar,
			v.z ^ scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x ^ scalar.x,
			v.y ^ scalar.x,
			v.z ^ scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x ^ v.x,
			scalar.x ^ v.y,
			scalar.x ^ v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x << scalar.x,
			v.y << scalar.x,
			v.z << scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x << v.x,
			scalar.x << v.y,
			scalar.x << v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec3<T, P>(
			v.x >> scalar.x,
			v.y >> scalar.x,
			v.z >> scalar.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			scalar.x >> v.x,
			scalar.x >> v.y,
			scalar.x >> v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> operator~(tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			~v.x,
			~v.y,
			~v.z);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
	}

	template <typename T, precision P>
	 inline bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
	}

	template <precision P>
	 inline tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)
	{
		return tvec3<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
	}

	template <precision P>
	 inline tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)
	{
		return tvec3<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
	}
}
#line 409 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"
#line 410 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec3.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vec3.hpp"
#line 70 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vec4.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"



#pragma once








#line 14 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec4
	{
		

		typedef T value_type;
		typedef tvec4<T, P> type;
		typedef tvec4<bool, P> bool_type;

		




#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"



#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"




#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"

			union
			{
				struct { T x, y, z, w;};
				struct { T r, g, b, a; };
				struct { T s, t, p, q; };

				typename detail::storage<T, sizeof(T) * 4, detail::is_aligned<P>::value>::type data;











#line 62 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"
			};



#line 67 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"


#line 70 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"









#line 80 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"

		

		
		typedef length_t length_type;
		 static length_type length(){return 4;}

		 T & operator[](length_type i);
		 T const & operator[](length_type i) const;

		

		  tvec4() ;
		  tvec4(tvec4<T, P> const& v) = default;
		template <precision Q>
		  tvec4(tvec4<T, Q> const& v);

		

		  explicit tvec4(ctor);
		  explicit tvec4(T scalar);
		  tvec4(T a, T b, T c, T d);

		

		
		template <typename A, typename B, typename C, typename D>
		  tvec4(A a, B b, C c, D d);
		template <typename A, typename B, typename C, typename D>
		  tvec4(tvec1<A, P> const& a, tvec1<B, P> const& b, tvec1<C, P> const& c, tvec1<D, P> const& d);

		

		
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec2<A, Q> const & a, B b, C c);
		
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);
		
		template <typename A, typename B, typename C, precision Q>
		  tvec4(A a, tvec2<B, Q> const & b, C c);
		
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);
		
		template <typename A, typename B, typename C, precision Q>
		  tvec4(A a, B b, tvec2<C, Q> const & c);
		
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);
		
		template <typename A, typename B, precision Q>
		  tvec4(tvec3<A, Q> const & a, B b);
		
		template <typename A, typename B, precision Q>
		  tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		  tvec4(A a, tvec3<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		  tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		  tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);

		
		template <typename U, precision Q>
		   tvec4(tvec4<U, Q> const& v);

		










































#line 195 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"

		

		 tvec4<T, P> & operator=(tvec4<T, P> const & v) = default;

		template <typename U>
		 tvec4<T, P> & operator=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator+=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator-=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator*=(tvec1<U, P> const& v);
		template <typename U>
		 tvec4<T, P> & operator*=(tvec4<U, P> const& v);
		template <typename U>
		 tvec4<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator/=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator/=(tvec4<U, P> const & v);

		

		 tvec4<T, P> & operator++();
		 tvec4<T, P> & operator--();
		 tvec4<T, P> operator++(int);
		 tvec4<T, P> operator--(int);

		

		template <typename U>
		 tvec4<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator%=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator&=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator|=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator^=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator<<=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator>>=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator>>=(tvec4<U, P> const & v);
	};

	

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v);

	

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P> 
	 tvec4<T, P> operator~(tvec4<T, P> const & v);

	

	template <typename T, precision P>
	 bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <precision P>
	 tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);

	template <precision P>
	 tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"



namespace glm{
namespace detail
{
	template <typename T>
	struct is_int
	{
		enum test {value = 0};
	};

	template <>
	struct is_int<uint32>
	{
		enum test {value = ~0};
	};

	template <>
	struct is_int<int32>
	{
		enum test {value = ~0};
	};

	template <>
	struct is_int<uint64>
	{
		enum test {value = ~0};
	};

	template <>
	struct is_int<int64>
	{
		enum test {value = ~0};
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_add
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_sub
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_mul
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_div
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_mod
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_and
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_or
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_xor
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_left
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_right
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_equal
	{
		 inline static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
		{
			return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_nequal
	{
		 inline static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
		{
			return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_bitwise_not
	{
		 inline static tvec4<T, P> call(tvec4<T, P> const & v)
		{
			return tvec4<T, P>(~v.x, ~v.y, ~v.z, ~v.w);
		}
	};
}

	


		template <typename T, precision P>
		 inline  tvec4<T, P>::tvec4()

				: x(0), y(0), z(0), w(0)
#line 163 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"
		{}
#line 165 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"






#line 172 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline  tvec4<T, P>::tvec4(tvec4<T, Q> const & v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}

	

	template <typename T, precision P>
	 inline  tvec4<T, P>::tvec4(ctor)
	{}

	template <typename T, precision P>
	 inline  tvec4<T, P>::tvec4(T scalar)
		: x(scalar), y(scalar), z(scalar), w(scalar)
	{}

	template <typename T, precision P>
	 inline  tvec4<T, P>::tvec4(T a, T b, T c, T d)
		: x(a), y(b), z(c), w(d)
	{}

	

	template <typename T, precision P>
	template <typename A, typename B, typename C, typename D>
	 inline  tvec4<T, P>::tvec4(A a, B b, C c, D d) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c)),
		w(static_cast<T>(d))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, typename D>
	 inline  tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(c.x)),
		w(static_cast<T>(d.x))
	{}

	

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b)),
		w(static_cast<T>(c))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x)),
		w(static_cast<T>(c.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline  tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :
		x(static_cast<T>(s1)),
		y(static_cast<T>(v.x)),
		z(static_cast<T>(v.y)),
		w(static_cast<T>(s2))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(c.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline  tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :
		x(static_cast<T>(s1)),
		y(static_cast<T>(s2)),
		z(static_cast<T>(v.x)),
		w(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(c.x)),
		w(static_cast<T>(c.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(a.z)),
		w(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(a.z)),
		w(static_cast<T>(b.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(b.z))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(b.z))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x)),
		w(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z)),
		w(static_cast<T>(v.w))
	{}

	

	template <typename T, precision P>
	 inline T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl", (unsigned)(330)), 0) );
		return (&x)[i];
	}

	template <typename T, precision P>
	 inline T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl", (unsigned)(337)), 0) );
		return (&x)[i];
	}

	











#line 354 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P>& tvec4<T, P>::operator=(tvec4<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		this->w = static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)
	{
		return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)
	{
		return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator*=(U scalar)
	{
		return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator/=(U scalar)
	{
		return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	

	template <typename T, precision P>
	 inline tvec4<T, P> & tvec4<T, P>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> & tvec4<T, P>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> tvec4<T, P>::operator++(int)
	{
		tvec4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> tvec4<T, P>::operator--(int)
	{
		tvec4<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)
	{
		return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)
	{
		return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)
	{
		return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)
	{
		return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)
	{
		return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	

	template <typename T, precision P>
	 inline tvec4<T, P> operator+(tvec4<T, P> const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v)
	{
		return tvec4<T, P>(0) -= v;
	}

	

	template <typename T, precision P>
	 inline tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) += scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) += v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(v) += scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v2) += v1;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) += v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) -= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) -= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) -= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) -= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) -= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) *= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) *= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(v) *= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v2) *= v1;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) *= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) /= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) /= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) /= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) /= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) /= v2;
	}

	

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) %= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) %= v2.x;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) %= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar.x) %= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) %= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) &= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar)
	{
		return tvec4<T, P>(v) &= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) &= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) &= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) &= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) |= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) |= v2.x;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) |= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) |= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) |= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) ^= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) ^= v2.x;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) ^= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) ^= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) ^= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) <<= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) <<= v2.x;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) <<= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) <<= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) <<= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(v) >>= scalar;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec4<T, P>(v1) >>= v2.x;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(scalar) >>= v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1.x) >>= v2;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(v1) >>= v2;
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator~(tvec4<T, P> const & v)
	{
		return detail::compute_vec4_bitwise_not<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return detail::compute_vec4_equal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
	}

	template <typename T, precision P>
	 inline bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return detail::compute_vec4_nequal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
	}

	template <precision P>
	 inline tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)
	{
		return tvec4<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
	}

	template <precision P>
	 inline tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)
	{
		return tvec4<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"





namespace glm{
namespace detail
{











































#line 53 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <precision P>
	struct compute_vec4_add<float, P, true>
	{
		static tvec4<float, P> call(tvec4<float, P> const & a, tvec4<float, P> const & b)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_add_ps(a.data, b.data);
			return Result;
		}
	};












#line 77 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <precision P>
	struct compute_vec4_sub<float, P, true>
	{
		static tvec4<float, P> call(tvec4<float, P> const & a, tvec4<float, P> const & b)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_sub_ps(a.data, b.data);
			return Result;
		}
	};












#line 101 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <precision P>
	struct compute_vec4_mul<float, P, true>
	{
		static tvec4<float, P> call(tvec4<float, P> const & a, tvec4<float, P> const & b)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_mul_ps(a.data, b.data);
			return Result;
		}
	};












#line 125 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <precision P>
	struct compute_vec4_div<float, P, true>
	{
		static tvec4<float, P> call(tvec4<float, P> const & a, tvec4<float, P> const & b)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_div_ps(a.data, b.data);
			return Result;
		}
	};

	










#line 149 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <>
	struct compute_vec4_div<float, aligned_lowp, true>
	{
		static tvec4<float, aligned_lowp> call(tvec4<float, aligned_lowp> const & a, tvec4<float, aligned_lowp> const & b)
		{
			tvec4<float, aligned_lowp> Result(uninitialize);
			Result.data = _mm_mul_ps(a.data, _mm_rcp_ps(b.data));
			return Result;
		}
	};

	template <typename T, precision P>
	struct compute_vec4_and<T, P, true, 32, true>
	{
		static tvec4<T, P> call(tvec4<T, P> const& a, tvec4<T, P> const& b)
		{
			tvec4<T, P> Result(uninitialize);
			Result.data = _mm_and_si128(a.data, b.data);
			return Result;
		}
	};












#line 184 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <typename T, precision P>
	struct compute_vec4_or<T, P, true, 32, true>
	{
		static tvec4<T, P> call(tvec4<T, P> const& a, tvec4<T, P> const& b)
		{
			tvec4<T, P> Result(uninitialize);
			Result.data = _mm_or_si128(a.data, b.data);
			return Result;
		}
	};












#line 208 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <typename T, precision P>
	struct compute_vec4_xor<T, P, true, 32, true>
	{
		static tvec4<T, P> call(tvec4<T, P> const& a, tvec4<T, P> const& b)
		{
			tvec4<T, P> Result(uninitialize);
			Result.data = _mm_xor_si128(a.data, b.data);
			return Result;
		}
	};












#line 232 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <typename T, precision P>
	struct compute_vec4_shift_left<T, P, true, 32, true>
	{
		static tvec4<T, P> call(tvec4<T, P> const& a, tvec4<T, P> const& b)
		{
			tvec4<T, P> Result(uninitialize);
			Result.data = _mm_sll_epi32(a.data, b.data);
			return Result;
		}
	};












#line 256 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <typename T, precision P>
	struct compute_vec4_shift_right<T, P, true, 32, true>
	{
		static tvec4<T, P> call(tvec4<T, P> const& a, tvec4<T, P> const& b)
		{
			tvec4<T, P> Result(uninitialize);
			Result.data = _mm_srl_epi32(a.data, b.data);
			return Result;
		}
	};












#line 280 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <typename T, precision P>
	struct compute_vec4_bitwise_not<T, P, true, 32, true>
	{
		static tvec4<T, P> call(tvec4<T, P> const & v)
		{
			tvec4<T, P> Result(uninitialize);
			Result.data = _mm_xor_si128(v.data, _mm_set1_epi32(-1));
			return Result;
		}
	};












#line 304 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <precision P>
	struct compute_vec4_equal<float, P, false, 32, true>
	{
		static bool call(tvec4<float, P> const & v1, tvec4<float, P> const & v2)
		{
			return _mm_movemask_ps(_mm_cmpeq_ps(v1.data, v2.data)) != 0;
		}
	};

	template <precision P>
	struct compute_vec4_equal<int32, P, true, 32, true>
	{
		static bool call(tvec4<int32, P> const & v1, tvec4<int32, P> const & v2)
		{
			return _mm_movemask_epi8(_mm_cmpeq_epi32(v1.data, v2.data)) != 0;
		}
	};

	template <precision P>
	struct compute_vec4_nequal<float, P, false, 32, true>
	{
		static bool call(tvec4<float, P> const & v1, tvec4<float, P> const & v2)
		{
			return _mm_movemask_ps(_mm_cmpneq_ps(v1.data, v2.data)) != 0;
		}
	};

	template <precision P>
	struct compute_vec4_nequal<int32, P, true, 32, true>
	{
		static bool call(tvec4<int32, P> const & v1, tvec4<int32, P> const & v2)
		{
			return _mm_movemask_epi8(_mm_cmpneq_epi32(v1.data, v2.data)) != 0;
		}
	};
}






















#line 364 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <>
	 inline  tvec4<float, aligned_lowp>::tvec4(float s) :
		data(_mm_set_ps1(s))
	{}

	template <>
	 inline  tvec4<float, aligned_mediump>::tvec4(float s) :
		data(_mm_set_ps1(s))
	{}

	template <>
	 inline  tvec4<float, aligned_highp>::tvec4(float s) :
		data(_mm_set_ps1(s))
	{}
















#line 396 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <>
	 inline  tvec4<int32, aligned_lowp>::tvec4(int32 s) :
		data(_mm_set1_epi32(s))
	{}

	template <>
	 inline  tvec4<int32, aligned_mediump>::tvec4(int32 s) :
		data(_mm_set1_epi32(s))
	{}

	template <>
	 inline  tvec4<int32, aligned_highp>::tvec4(int32 s) :
		data(_mm_set1_epi32(s))
	{}
















#line 428 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"

	template <>
	 inline  tvec4<float, aligned_lowp>::tvec4(float a, float b, float c, float d) :
		data(_mm_set_ps(d, c, b, a))
	{}

	template <>
	 inline  tvec4<float, aligned_mediump>::tvec4(float a, float b, float c, float d) :
		data(_mm_set_ps(d, c, b, a))
	{}

	template <>
	 inline  tvec4<float, aligned_highp>::tvec4(float a, float b, float c, float d) :
		data(_mm_set_ps(d, c, b, a))
	{}

	template <>
	template <>
	 inline  tvec4<int32, aligned_lowp>::tvec4(int32 a, int32 b, int32 c, int32 d) :
		data(_mm_set_epi32(d, c, b, a))
	{}

	template <>
	template <>
	 inline  tvec4<int32, aligned_mediump>::tvec4(int32 a, int32 b, int32 c, int32 d) :
		data(_mm_set_epi32(d, c, b, a))
	{}

	template <>
	template <>
	 inline  tvec4<int32, aligned_highp>::tvec4(int32 a, int32 b, int32 c, int32 d) :
		data(_mm_set_epi32(d, c, b, a))
	{}

	template <>
	template <>
	 inline  tvec4<float, aligned_lowp>::tvec4(int32 a, int32 b, int32 c, int32 d) :
		data(_mm_castsi128_ps(_mm_set_epi32(d, c, b, a)))
	{}

	template <>
	template <>
	 inline  tvec4<float, aligned_mediump>::tvec4(int32 a, int32 b, int32 c, int32 d) :
		data(_mm_castsi128_ps(_mm_set_epi32(d, c, b, a)))
	{}

	template <>
	template <>
	 inline  tvec4<float, aligned_highp>::tvec4(int32 a, int32 b, int32 c, int32 d) :
		data(_mm_castsi128_ps(_mm_set_epi32(d, c, b, a)))
	{}
}

#line 482 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4_simd.inl"
#line 969 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"
#line 970 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec4.inl"

#line 454 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"
#line 455 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_vec4.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vec4.hpp"
#line 71 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\mat2x2.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x2.hpp"



#pragma once







namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x2<T, P> type;
		typedef tmat2x2<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		 tmat2x2() ;
		 tmat2x2(tmat2x2<T, P> const & m) = default;
		template <precision Q>
		 tmat2x2(tmat2x2<T, Q> const & m);

		  explicit tmat2x2(ctor);
		 explicit tmat2x2(T scalar);
		 tmat2x2(
			T const & x1, T const & y1,
			T const & x2, T const & y2);
		 tmat2x2(
			col_type const & v1,
			col_type const & v2);

		

		template <typename U, typename V, typename M, typename N>
		 tmat2x2(
			U const & x1, V const & y1,
			M const & x2, N const & y2);

		template <typename U, typename V>
		 tmat2x2(
			tvec2<U, P> const & v1,
			tvec2<V, P> const & v2);

		

		template <typename U, precision Q>
		  tmat2x2(tmat2x2<U, Q> const & m);

		  tmat2x2(tmat3x3<T, P> const & x);
		  tmat2x2(tmat4x4<T, P> const & x);
		  tmat2x2(tmat2x3<T, P> const & x);
		  tmat2x2(tmat3x2<T, P> const & x);
		  tmat2x2(tmat2x4<T, P> const & x);
		  tmat2x2(tmat4x2<T, P> const & x);
		  tmat2x2(tmat3x4<T, P> const & x);
		  tmat2x2(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 2;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat2x2<T, P> & operator=(tmat2x2<T, P> const & v) = default;

		template <typename U>
		 tmat2x2<T, P> & operator=(tmat2x2<U, P> const & m);
		template <typename U>
		 tmat2x2<T, P> & operator+=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator+=(tmat2x2<U, P> const & m);
		template <typename U>
		 tmat2x2<T, P> & operator-=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator-=(tmat2x2<U, P> const & m);
		template <typename U>
		 tmat2x2<T, P> & operator*=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator*=(tmat2x2<U, P> const & m);
		template <typename U>
		 tmat2x2<T, P> & operator/=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator/=(tmat2x2<U, P> const & m);

		

		 tmat2x2<T, P> & operator++ ();
		 tmat2x2<T, P> & operator-- ();
		 tmat2x2<T, P> operator++(int);
		 tmat2x2<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m);

	

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::col_type operator*(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::row_type operator*(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

	

	template <typename T, precision P>
	 bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);
} 


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"














#pragma once









#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat2x3.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x3.hpp"



#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x3<T, P> type;
		typedef tmat3x2<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		 tmat2x3() ;
		 tmat2x3(tmat2x3<T, P> const & m) = default;
		template <precision Q>
		 tmat2x3(tmat2x3<T, Q> const & m);

		  explicit tmat2x3(ctor);
		 explicit tmat2x3(T scalar);
		 tmat2x3(
			T x0, T y0, T z0,
			T x1, T y1, T z1);
		 tmat2x3(
			col_type const & v0,
			col_type const & v1);

		

		template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		 tmat2x3(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2);

		template <typename U, typename V>
		 tmat2x3(
			tvec3<U, P> const & v1,
			tvec3<V, P> const & v2);

		

		template <typename U, precision Q>
		  tmat2x3(tmat2x3<U, Q> const & m);

		  tmat2x3(tmat2x2<T, P> const & x);
		  tmat2x3(tmat3x3<T, P> const & x);
		  tmat2x3(tmat4x4<T, P> const & x);
		  tmat2x3(tmat2x4<T, P> const & x);
		  tmat2x3(tmat3x2<T, P> const & x);
		  tmat2x3(tmat3x4<T, P> const & x);
		  tmat2x3(tmat4x2<T, P> const & x);
		  tmat2x3(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 2;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat2x3<T, P> & operator=(tmat2x3<T, P> const & m) = default;

		template <typename U>
		 tmat2x3<T, P> & operator=(tmat2x3<U, P> const & m);
		template <typename U>
		 tmat2x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat2x3<T, P> & operator+=(tmat2x3<U, P> const & m);
		template <typename U>
		 tmat2x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat2x3<T, P> & operator-=(tmat2x3<U, P> const & m);
		template <typename U>
		 tmat2x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat2x3<T, P> & operator/=(U s);

		

		 tmat2x3<T, P> & operator++ ();
		 tmat2x3<T, P> & operator-- ();
		 tmat2x3<T, P> operator++(int);
		 tmat2x3<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> const & m);

	

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x3<T, P>::col_type operator*(tmat2x3<T, P> const & m, typename tmat2x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x3<T, P>::row_type operator*(typename tmat2x3<T, P>::col_type const & v, tmat2x3<T, P> const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> const & m);

	

	template <typename T, precision P>
	 bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl"



namespace glm
{
	


		template <typename T, precision P> 
		 inline tmat2x3<T, P>::tmat2x3()
		{

				this->value[0] = col_type(1, 0, 0);
				this->value[1] = col_type(0, 1, 0);
#line 16 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl"
		}
#line 18 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl"








#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat2x3<T, P>::tmat2x3(tmat2x3<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P> 
	 inline  tmat2x3<T, P>::tmat2x3(ctor)
	{}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0);
		this->value[1] = col_type(0, scalar, 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(col_type const & v0, col_type const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	 inline tmat2x3<T, P>::tmat2x3
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 inline tmat2x3<T, P>::tmat2x3(tvec3<V1, P> const & v1, tvec3<V2, P> const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat2x3<T, P>::tmat2x3(tmat2x3<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 inline  tmat2x3<T, P>::tmat2x3(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat4x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	

	template <typename T, precision P>
	 inline typename tmat2x3<T, P>::col_type & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl", (unsigned)(160)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat2x3<T, P>::col_type const & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl", (unsigned)(167)), 0) );
		return this->value[i];
	}

	









#line 182 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x3.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator+=(tmat2x3<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(tmat2x3<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template <typename T, precision P>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
	{
		tmat2x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
	{
		tmat2x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m)
	{
		return tmat2x3<T, P>(
			-m[0],
			-m[1]);
	}

	

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> const & m)
	{
		return tmat2x3<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 inline typename tmat2x3<T, P>::col_type operator*
	(
		tmat2x3<T, P> const & m,
		typename tmat2x3<T, P>::row_type const & v)
	{
		return typename tmat2x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template <typename T, precision P>
	 inline typename tmat2x3<T, P>::row_type operator*
	(
		typename tmat2x3<T, P>::col_type const & v,
		tmat2x3<T, P> const & m)
	{
		return typename tmat2x3<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> const & m)
	{
		return tmat2x3<T, P>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 165 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x3.hpp"
#line 166 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x3.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat2x3.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat2x3<float, lowp>		lowp_mat2x3;

	
	
	
	
	
	typedef tmat2x3<float, mediump>		mediump_mat2x3;

	
	
	
	
	
	typedef tmat2x3<float, highp>		highp_mat2x3;

}

#line 26 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat2x4.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x4.hpp"



#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x4<T, P> type;
		typedef tmat4x2<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		 tmat2x4() ;
		 tmat2x4(tmat2x4<T, P> const & m) = default;
		template <precision Q>
		 tmat2x4(tmat2x4<T, Q> const & m);

		  explicit tmat2x4(ctor);
		 explicit tmat2x4(T scalar);
		 tmat2x4(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1);
		 tmat2x4(
			col_type const & v0,
			col_type const & v1);

		

		template <
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		 tmat2x4(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2);

		template <typename U, typename V>
		 tmat2x4(
			tvec4<U, P> const & v1,
			tvec4<V, P> const & v2);

		

		template <typename U, precision Q>
		  tmat2x4(tmat2x4<U, Q> const & m);

		  tmat2x4(tmat2x2<T, P> const & x);
		  tmat2x4(tmat3x3<T, P> const & x);
		  tmat2x4(tmat4x4<T, P> const & x);
		  tmat2x4(tmat2x3<T, P> const & x);
		  tmat2x4(tmat3x2<T, P> const & x);
		  tmat2x4(tmat3x4<T, P> const & x);
		  tmat2x4(tmat4x2<T, P> const & x);
		  tmat2x4(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 2;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat2x4<T, P> & operator=(tmat2x4<T, P> const & m) = default;

		template <typename U>
		 tmat2x4<T, P> & operator=(tmat2x4<U, P> const & m);
		template <typename U>
		 tmat2x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat2x4<T, P> & operator+=(tmat2x4<U, P> const & m);
		template <typename U>
		 tmat2x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat2x4<T, P> & operator-=(tmat2x4<U, P> const & m);
		template <typename U>
		 tmat2x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat2x4<T, P> & operator/=(U s);

		

		 tmat2x4<T, P> & operator++ ();
		 tmat2x4<T, P> & operator-- ();
		 tmat2x4<T, P> operator++(int);
		 tmat2x4<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> const & m);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> const & m);

	

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> const & m);

	

	template <typename T, precision P>
	 bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl"



namespace glm
{
	


		template <typename T, precision P>
		 inline tmat2x4<T, P>::tmat2x4()
		{

				this->value[0] = col_type(1, 0, 0, 0);
				this->value[1] = col_type(0, 1, 0, 0);
#line 16 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl"
		}
#line 18 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl"








#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x4<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	 inline  tmat2x4<T, P>::tmat2x4(ctor)
	{}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(T scalar)
	{
		value_type const Zero(0);
		this->value[0] = col_type(scalar, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, scalar, Zero, Zero);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(col_type const & v0, col_type const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline tmat2x4<T, P>::tmat2x4
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 inline tmat2x4<T, P>::tmat2x4(tvec4<V1, P> const & v1, tvec4<V2, P> const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x4<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat3x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	

	template <typename T, precision P>
	 inline typename tmat2x4<T, P>::col_type & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl", (unsigned)(161)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat2x4<T, P>::col_type const & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl", (unsigned)(168)), 0) );
		return this->value[i];
	}

	









#line 183 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x4.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(tmat2x4<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(tmat2x4<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P> & tmat2x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template <typename T, precision P>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
	{
		tmat2x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
	{
		tmat2x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m)
	{
		return tmat2x4<T, P>(
			-m[0], 
			-m[1]);
	}

	

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> const & m)
	{
		return tmat2x4<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 inline typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v)
	{
		return typename tmat2x4<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template <typename T, precision P>
	 inline typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m)
	{
		return typename tmat2x4<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];

		tmat4x4<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> const & m)
	{
		return tmat2x4<T, P>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 167 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x4.hpp"
#line 168 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x4.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat2x4.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat2x4<float, lowp>		lowp_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, mediump>		mediump_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, highp>		highp_mat2x4;

}
#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat3x2.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x2.hpp"



#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x2<T, P> type;
		typedef tmat2x3<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		 tmat3x2() ;
		 tmat3x2(tmat3x2<T, P> const & m) = default;
		template <precision Q>
		 tmat3x2(tmat3x2<T, Q> const & m);

		  explicit tmat3x2(ctor);
		 explicit tmat3x2(T scalar);
		 tmat3x2(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2);
		 tmat3x2(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2);

		

		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 tmat3x2(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template <typename V1, typename V2, typename V3>
		 tmat3x2(
			tvec2<V1, P> const & v1,
			tvec2<V2, P> const & v2,
			tvec2<V3, P> const & v3);

		

		template <typename U, precision Q>
		  tmat3x2(tmat3x2<U, Q> const & m);

		  tmat3x2(tmat2x2<T, P> const & x);
		  tmat3x2(tmat3x3<T, P> const & x);
		  tmat3x2(tmat4x4<T, P> const & x);
		  tmat3x2(tmat2x3<T, P> const & x);
		  tmat3x2(tmat2x4<T, P> const & x);
		  tmat3x2(tmat3x4<T, P> const & x);
		  tmat3x2(tmat4x2<T, P> const & x);
		  tmat3x2(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 3;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat3x2<T, P> & operator=(tmat3x2<T, P> const & m) = default;

		template <typename U>
		 tmat3x2<T, P> & operator=(tmat3x2<U, P> const & m);
		template <typename U>
		 tmat3x2<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x2<T, P> & operator+=(tmat3x2<U, P> const & m);
		template <typename U>
		 tmat3x2<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x2<T, P> & operator-=(tmat3x2<U, P> const & m);
		template <typename U>
		 tmat3x2<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x2<T, P> & operator/=(U s);

		

		 tmat3x2<T, P> & operator++ ();
		 tmat3x2<T, P> & operator-- ();
		 tmat3x2<T, P> operator++(int);
		 tmat3x2<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> const & m);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> const & m);

	

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> const & m);

	

	template <typename T, precision P>
	 bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl"



namespace glm
{
	


		template <typename T, precision P> 
		 inline tmat3x2<T, P>::tmat3x2()
		{

				this->value[0] = col_type(1, 0);
				this->value[1] = col_type(0, 1);
				this->value[2] = col_type(0, 0);
#line 17 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl"
		}
#line 19 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl"









#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x2<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 inline  tmat3x2<T, P>::tmat3x2(ctor)
	{}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
		this->value[2] = col_type(0, 0);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	 inline tmat3x2<T, P>::tmat3x2
	(
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
	}

	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 inline tmat3x2<T, P>::tmat3x2
	(
		tvec2<V1, P> const & v1,
		tvec2<V2, P> const & v2,
		tvec2<V3, P> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x2<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat2x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat4x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	

	template <typename T, precision P>
	 inline typename tmat3x2<T, P>::col_type & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl", (unsigned)(190)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat3x2<T, P>::col_type const & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl", (unsigned)(197)), 0) );
		return this->value[i];
	}

	










#line 213 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x2.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(tmat3x2<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(tmat3x2<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P> & tmat3x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template <typename T, precision P>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
	{
		tmat3x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
	{
		tmat3x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m)
	{
		return tmat3x2<T, P>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> const & m)
	{
		return tmat3x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
   
	template <typename T, precision P>
	 inline typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v)
	{
		return typename tmat3x2<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template <typename T, precision P>
	 inline typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m)
	{
		return typename tmat3x2<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];

		tmat2x2<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> const & m)
	{
		return tmat3x2<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P> 
	 inline bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 173 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x2.hpp"
#line 174 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x2.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat3x2.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat3x2<float, lowp>		lowp_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, mediump>		mediump_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, highp>		highp_mat3x2;

}
#line 28 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat3x3.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x3.hpp"



#pragma once







namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x3<T, P> type;
		typedef tmat3x3<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		 tmat3x3() ;
		 tmat3x3(tmat3x3<T, P> const & m) = default;
		template <precision Q>
		 tmat3x3(tmat3x3<T, Q> const & m);

		  explicit tmat3x3(ctor);
		 explicit tmat3x3(T scalar);
		 tmat3x3(
			T x0, T y0, T z0,
			T x1, T y1, T z1,
			T x2, T y2, T z2);
		 tmat3x3(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		 tmat3x3(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2,
			X3 x3, Y3 y3, Z3 z3);

		template <typename V1, typename V2, typename V3>
		 tmat3x3(
			tvec3<V1, P> const & v1,
			tvec3<V2, P> const & v2,
			tvec3<V3, P> const & v3);

		

		template <typename U, precision Q>
		  tmat3x3(tmat3x3<U, Q> const & m);

		  tmat3x3(tmat2x2<T, P> const & x);
		  tmat3x3(tmat4x4<T, P> const & x);
		  tmat3x3(tmat2x3<T, P> const & x);
		  tmat3x3(tmat3x2<T, P> const & x);
		  tmat3x3(tmat2x4<T, P> const & x);
		  tmat3x3(tmat4x2<T, P> const & x);
		  tmat3x3(tmat3x4<T, P> const & x);
		  tmat3x3(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 3;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat3x3<T, P> & operator=(tmat3x3<T, P> const & m) = default;

		template <typename U>
		 tmat3x3<T, P> & operator=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator+=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator-=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator*=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator/=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator/=(tmat3x3<U, P> const & m);

		

		 tmat3x3<T, P> & operator++();
		 tmat3x3<T, P> & operator--();
		 tmat3x3<T, P> operator++(int);
		 tmat3x3<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> const & m);

	

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	

	template <typename T, precision P>
	 bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl"





namespace glm
{
	


		template <typename T, precision P>
		 inline tmat3x3<T, P>::tmat3x3()
		{

				this->value[0] = col_type(1, 0, 0);
				this->value[1] = col_type(0, 1, 0);
				this->value[2] = col_type(0, 0, 1);
#line 19 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl"
		}
#line 21 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl"









#line 31 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x3<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 inline  tmat3x3<T, P>::tmat3x3(ctor)
	{}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0);
		this->value[1] = col_type(0, scalar, 0);
		this->value[2] = col_type(0, 0, scalar);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1,
		T x2, T y2, T z2
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline tmat3x3<T, P>::tmat3x3
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2,
		X3 x3, Y3 y3, Z3 z3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 inline tmat3x3<T, P>::tmat3x3
	(
		tvec3<V1, P> const & v1,
		tvec3<V2, P> const & v2,
		tvec3<V3, P> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x3<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat2x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat4x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	

	template <typename T, precision P>
	 inline typename tmat3x3<T, P>::col_type & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl", (unsigned)(192)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat3x3<T, P>::col_type const & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl", (unsigned)(199)), 0) );
		return this->value[i];
	}

	










#line 215 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x3.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(tmat3x3<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(tmat3x3<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(tmat3x3<U, P> const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(tmat3x3<U, P> const & m)
	{
		return *this *= inverse(m);
	}

	

	template <typename T, precision P>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
	{
		tmat3x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
	{
		tmat3x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			-m[0], 
			-m[1],
			-m[2]);
	}

	

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T scalar)
	{
		return tmat3x3<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T scalar)
	{
		return tmat3x3<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T scalar)
	{
		return tmat3x3<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P> 
	 inline typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
	{
		return typename tmat3x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template <typename T, precision P> 
	 inline typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
	{
		return typename tmat3x3<T, P>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator/(tmat3x3<T, P> const & m,	T scalar)
	{
		return tmat3x3<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	template <typename T, precision P>
	 inline typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
	{
		return  inverse(m) * v;
	}

	template <typename T, precision P>
	 inline typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
	{
		return v * inverse(m);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		tmat3x3<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 190 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x3.hpp"
#line 191 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x3.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat3x3.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3x3;

}
#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat3x4.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x4.hpp"



#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x4<T, P> type;
		typedef tmat4x3<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		 tmat3x4() ;
		 tmat3x4(tmat3x4<T, P> const & m) = default;
		template <precision Q>
		 tmat3x4(tmat3x4<T, Q> const & m);

		  explicit tmat3x4(ctor);
		 explicit tmat3x4(T scalar);
		 tmat3x4(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1,
			T x2, T y2, T z2, T w2);
		 tmat3x4(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		 tmat3x4(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2,
			X3 x3, Y3 y3, Z3 z3, W3 w3);

		template <typename V1, typename V2, typename V3>
		 tmat3x4(
			tvec4<V1, P> const & v1,
			tvec4<V2, P> const & v2,
			tvec4<V3, P> const & v3);

		

		template <typename U, precision Q>
		  tmat3x4(tmat3x4<U, Q> const & m);

		  tmat3x4(tmat2x2<T, P> const & x);
		  tmat3x4(tmat3x3<T, P> const & x);
		  tmat3x4(tmat4x4<T, P> const & x);
		  tmat3x4(tmat2x3<T, P> const & x);
		  tmat3x4(tmat3x2<T, P> const & x);
		  tmat3x4(tmat2x4<T, P> const & x);
		  tmat3x4(tmat4x2<T, P> const & x);
		  tmat3x4(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 3;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat3x4<T, P> & operator=(tmat3x4<T, P> const & m) = default;

		template <typename U>
		 tmat3x4<T, P> & operator=(tmat3x4<U, P> const & m);
		template <typename U>
		 tmat3x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x4<T, P> & operator+=(tmat3x4<U, P> const & m);
		template <typename U>
		 tmat3x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x4<T, P> & operator-=(tmat3x4<U, P> const & m);
		template <typename U>
		 tmat3x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x4<T, P> & operator/=(U s);

		

		 tmat3x4<T, P> & operator++();
		 tmat3x4<T, P> & operator--();
		 tmat3x4<T, P> operator++(int);
		 tmat3x4<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m);

	

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x4<T, P>::col_type operator*(tmat3x4<T, P> const & m, typename tmat3x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x4<T, P>::row_type operator*(typename tmat3x4<T, P>::col_type const & v, tmat3x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1,	tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1,	tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> const & m);

	

	template <typename T, precision P>
	 bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl"



namespace glm
{
	


		template <typename T, precision P>
		 inline tmat3x4<T, P>::tmat3x4()
		{

				this->value[0] = col_type(1, 0, 0, 0);
				this->value[1] = col_type(0, 1, 0, 0);
				this->value[2] = col_type(0, 0, 1, 0);
#line 17 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl"
		}
#line 19 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl"









#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x4<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 inline  tmat3x4<T, P>::tmat3x4(ctor)
	{}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0, 0);
		this->value[1] = col_type(0, scalar, 0, 0);
		this->value[2] = col_type(0, 0, scalar, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1,
		T x2, T y2, T z2, T w2
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3>
	 inline tmat3x4<T, P>::tmat3x4
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2,
		X3 x3, Y3 y3, Z3 z3, W3 w3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 inline tmat3x4<T, P>::tmat3x4
	(
		tvec4<V1, P> const & v1,
		tvec4<V2, P> const & v2,
		tvec4<V3, P> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}
	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x4<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}

	

	template <typename T, precision P>
	 inline typename tmat3x4<T, P>::col_type & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl", (unsigned)(190)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat3x4<T, P>::col_type const & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl", (unsigned)(197)), 0) );
		return this->value[i];
	}

	










#line 213 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat3x4.inl"

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(tmat3x4<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(tmat3x4<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P> & tmat3x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template <typename T, precision P>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
	{
		tmat3x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
	{
		tmat3x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m)
	{
		return tmat3x4<T, P>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T scalar)
	{
		return tmat3x4<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m,	T scalar)
	{
		return tmat3x4<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T scalar)
	{
		return tmat3x4<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> const & m)
	{
		return tmat3x4<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P>
	 inline typename tmat3x4<T, P>::col_type operator*
	(
		tmat3x4<T, P> const & m,
		typename tmat3x4<T, P>::row_type const & v
	)
	{
		return typename tmat3x4<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template <typename T, precision P>
	 inline typename tmat3x4<T, P>::row_type operator*
	(
		typename tmat3x4<T, P>::col_type const & v,
		tmat3x4<T, P> const & m
	)
	{
		return typename tmat3x4<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];

		tmat4x4<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator/(tmat3x4<T, P> const & m,	T scalar)
	{
		return tmat3x4<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> const & m)
	{
		return tmat3x4<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 172 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x4.hpp"
#line 173 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat3x4.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat3x4.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat3x4<float, lowp>		lowp_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, mediump>		mediump_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, highp>		highp_mat3x4;

}
#line 30 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat4x2.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x2.hpp"



#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x2<T, P> type;
		typedef tmat2x4<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		 tmat4x2() ;
		 tmat4x2(tmat4x2<T, P> const & m) = default;
		template <precision Q>
		 tmat4x2(tmat4x2<T, Q> const & m);

		  explicit tmat4x2(ctor);
		 explicit tmat4x2(T scalar);
		 tmat4x2(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2,
			T x3, T y3);
		 tmat4x2(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		

		template <
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3,
			typename X4, typename Y4>
		 tmat4x2(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3,
			X4 x4, Y4 y4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x2(
			tvec2<V1, P> const & v1,
			tvec2<V2, P> const & v2,
			tvec2<V3, P> const & v3,
			tvec2<V4, P> const & v4);

		

		template <typename U, precision Q>
		  tmat4x2(tmat4x2<U, Q> const & m);

		  tmat4x2(tmat2x2<T, P> const & x);
		  tmat4x2(tmat3x3<T, P> const & x);
		  tmat4x2(tmat4x4<T, P> const & x);
		  tmat4x2(tmat2x3<T, P> const & x);
		  tmat4x2(tmat3x2<T, P> const & x);
		  tmat4x2(tmat2x4<T, P> const & x);
		  tmat4x2(tmat4x3<T, P> const & x);
		  tmat4x2(tmat3x4<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat4x2<T, P> & operator=(tmat4x2<T, P> const & m) = default;

		template <typename U>
		 tmat4x2<T, P> & operator=(tmat4x2<U, P> const & m);
		template <typename U>
		 tmat4x2<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x2<T, P> & operator+=(tmat4x2<U, P> const & m);
		template <typename U>
		 tmat4x2<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x2<T, P> & operator-=(tmat4x2<U, P> const & m);
		template <typename U>
		 tmat4x2<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x2<T, P> & operator/=(U s);

		

		 tmat4x2<T, P> & operator++ ();
		 tmat4x2<T, P> & operator-- ();
		 tmat4x2<T, P> operator++(int);
		 tmat4x2<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m);

	

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1,	tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> const & m);

	

	template <typename T, precision P>
	 bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl"



namespace glm
{







	


		template <typename T, precision P> 
		 inline tmat4x2<T, P>::tmat4x2()
		{

				this->value[0] = col_type(1, 0);
				this->value[1] = col_type(0, 1);
				this->value[2] = col_type(0, 0);
				this->value[3] = col_type(0, 0);
#line 25 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl"
		}
#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl"










#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x2<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	 inline  tmat4x2<T, P>::tmat4x2(ctor)
	{}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
		this->value[2] = col_type(0, 0);
		this->value[3] = col_type(0, 0);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2,
		T x3, T y3
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
		this->value[3] = col_type(x3, y3);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3,
		typename X4, typename Y4>
	 inline tmat4x2<T, P>::tmat4x2
	(
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3,
		X4 x4, Y4 y4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 inline tmat4x2<T, P>::tmat4x2
	(
		tvec2<V1, P> const & v1,
		tvec2<V2, P> const & v2,
		tvec2<V3, P> const & v3,
		tvec2<V4, P> const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x2<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	

	template <typename T, precision P>
	 inline typename tmat4x2<T, P>::col_type & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl", (unsigned)(219)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat4x2<T, P>::col_type const & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl", (unsigned)(226)), 0) );
		return this->value[i];
	}

	











#line 243 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x2.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(tmat4x2<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(tmat4x2<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template <typename T, precision P>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
	{
		tmat4x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
	{
		tmat4x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m)
	{
		return tmat4x2<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> const & m)
	{
		return tmat4x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template <typename T, precision P>
	 inline typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v)
	{
		return typename tmat4x2<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template <typename T, precision P>
	 inline typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m)
	{
		return typename tmat4x2<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];

		tmat2x2<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> const & m)
	{
		return tmat4x2<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 177 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x2.hpp"
#line 178 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x2.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat4x2.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat4x2<float, lowp>		lowp_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, mediump>		mediump_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, highp>		highp_mat4x2;

}
#line 31 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat4x3.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x3.hpp"



#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x3<T, P> type;
		typedef tmat3x4<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		 tmat4x3() ;
		 tmat4x3(tmat4x3<T, P> const & m) = default;
		template <precision Q>
		 tmat4x3(tmat4x3<T, Q> const & m);

		  explicit tmat4x3(ctor);
		 explicit tmat4x3(T const & x);
		 tmat4x3(
			T const & x0, T const & y0, T const & z0,
			T const & x1, T const & y1, T const & z1,
			T const & x2, T const & y2, T const & z2,
			T const & x3, T const & y3, T const & z3);
		 tmat4x3(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		

		template <
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		 tmat4x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1,
			X2 const & x2, Y2 const & y2, Z2 const & z2,
			X3 const & x3, Y3 const & y3, Z3 const & z3,
			X4 const & x4, Y4 const & y4, Z4 const & z4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x3(
			tvec3<V1, P> const & v1,
			tvec3<V2, P> const & v2,
			tvec3<V3, P> const & v3,
			tvec3<V4, P> const & v4);

		

		template <typename U, precision Q>
		  tmat4x3(tmat4x3<U, Q> const & m);

		  tmat4x3(tmat2x2<T, P> const & x);
		  tmat4x3(tmat3x3<T, P> const & x);
		  tmat4x3(tmat4x4<T, P> const & x);
		  tmat4x3(tmat2x3<T, P> const & x);
		  tmat4x3(tmat3x2<T, P> const & x);
		  tmat4x3(tmat2x4<T, P> const & x);
		  tmat4x3(tmat4x2<T, P> const & x);
		  tmat4x3(tmat3x4<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat4x3<T, P> & operator=(tmat4x3<T, P> const & m) = default;

		template <typename U>
		 tmat4x3<T, P> & operator=(tmat4x3<U, P> const & m);
		template <typename U>
		 tmat4x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator+=(tmat4x3<U, P> const & m);
		template <typename U>
		 tmat4x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator-=(tmat4x3<U, P> const & m);
		template <typename U>
		 tmat4x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator/=(U s);

		

		 tmat4x3<T, P> & operator++();
		 tmat4x3<T, P> & operator--();
		 tmat4x3<T, P> operator++(int);
		 tmat4x3<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m);

	

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x3<T, P>::col_type operator*(tmat4x3<T, P> const & m, typename tmat4x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x3<T, P>::row_type operator*(typename tmat4x3<T, P>::col_type const & v, tmat4x3<T, P> const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1,	tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m);

	

	template <typename T, precision P>
	 bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl"



namespace glm
{
	


		template <typename T, precision P>
		 inline tmat4x3<T, P>::tmat4x3()
		{

				this->value[0] = col_type(1, 0, 0);
				this->value[1] = col_type(0, 1, 0);
				this->value[2] = col_type(0, 0, 1);
				this->value[3] = col_type(0, 0, 0);
#line 18 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl"
		}
#line 20 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl"










#line 31 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x3<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	 inline  tmat4x3<T, P>::tmat4x3(ctor)
	{}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(T const & s)
	{
		this->value[0] = col_type(s, 0, 0);
		this->value[1] = col_type(0, s, 0);
		this->value[2] = col_type(0, 0, s);
		this->value[3] = col_type(0, 0, 0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3
	(
		T const & x0, T const & y0, T const & z0,
		T const & x1, T const & y1, T const & z1,
		T const & x2, T const & y2, T const & z2,
		T const & x3, T const & y3, T const & z3
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
		this->value[3] = col_type(x3, y3, z3);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3,
		typename X4, typename Y4, typename Z4>
	 inline tmat4x3<T, P>::tmat4x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1,
		X2 const & x2, Y2 const & y2, Z2 const & z2,
		X3 const & x3, Y3 const & y3, Z3 const & z3,
		X4 const & x4, Y4 const & y4, Z4 const & z4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 inline tmat4x3<T, P>::tmat4x3
	(
		tvec3<V1, P> const & v1,
		tvec3<V2, P> const & v2,
		tvec3<V3, P> const & v3,
		tvec3<V4, P> const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x3<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(m[3], 0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	

	template <typename T, precision P>
	 inline typename tmat4x3<T, P>::col_type & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl", (unsigned)(212)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat4x3<T, P>::col_type const & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl", (unsigned)(219)), 0) );
		return this->value[i];
	}

	











#line 236 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x3.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(tmat4x3<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(tmat4x3<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template <typename T, precision P>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
	{
		tmat4x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
	{
		tmat4x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m)
	{
		return tmat4x3<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m)
	{
		return tmat4x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline typename tmat4x3<T, P>::col_type operator*
	(
		tmat4x3<T, P> const & m,
		typename tmat4x3<T, P>::row_type const & v)
	{
		return typename tmat4x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template <typename T, precision P>
	 inline typename tmat4x3<T, P>::row_type operator*
	(
		typename tmat4x3<T, P>::col_type const & v,
		tmat4x3<T, P> const & m)
	{
		return typename tmat4x3<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m)
	{
		return tmat4x3<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 177 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x3.hpp"
#line 178 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x3.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat4x3.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat4x3<float, lowp>		lowp_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, mediump>		mediump_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, highp>		highp_mat4x3;

}
#line 32 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat4x4.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x4.hpp"



#pragma once







namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x4<T, P> type;
		typedef tmat4x4<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		 tmat4x4() ;
		 tmat4x4(tmat4x4<T, P> const & m) = default;
		template <precision Q>
		 tmat4x4(tmat4x4<T, Q> const & m);

		 explicit tmat4x4(ctor);
		 explicit tmat4x4(T const & x);
		 tmat4x4(
			T const & x0, T const & y0, T const & z0, T const & w0,
			T const & x1, T const & y1, T const & z1, T const & w1,
			T const & x2, T const & y2, T const & z2, T const & w2,
			T const & x3, T const & y3, T const & z3, T const & w3);
		 tmat4x4(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		

		template <
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		 tmat4x4(
			X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
			X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
			X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
			X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x4(
			tvec4<V1, P> const & v1,
			tvec4<V2, P> const & v2,
			tvec4<V3, P> const & v3,
			tvec4<V4, P> const & v4);

		

		template <typename U, precision Q>
		  tmat4x4(tmat4x4<U, Q> const & m);

		  tmat4x4(tmat2x2<T, P> const & x);
		  tmat4x4(tmat3x3<T, P> const & x);
		  tmat4x4(tmat2x3<T, P> const & x);
		  tmat4x4(tmat3x2<T, P> const & x);
		  tmat4x4(tmat2x4<T, P> const & x);
		  tmat4x4(tmat4x2<T, P> const & x);
		  tmat4x4(tmat3x4<T, P> const & x);
		  tmat4x4(tmat4x3<T, P> const & x);

		

		typedef length_t length_type;
		 static length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 col_type const & operator[](length_type i) const;

		

		 tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m) = default;

		template <typename U>
		 tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator/=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);

		

		 tmat4x4<T, P> & operator++();
		 tmat4x4<T, P> & operator--();
		 tmat4x4<T, P> operator++(int);
		 tmat4x4<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m);

	

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1,	tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1,	tmat4x4<T, P> const & m2);

	

	template <typename T, precision P>
	 bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"





namespace glm
{
	


		template <typename T, precision P>
		 inline tmat4x4<T, P>::tmat4x4()
		{

				this->value[0] = col_type(1, 0, 0, 0);
				this->value[1] = col_type(0, 1, 0, 0);
				this->value[2] = col_type(0, 0, 1, 0);
				this->value[3] = col_type(0, 0, 0, 1);
#line 20 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"
		}
#line 22 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"










#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(ctor)
	{}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(T const & s)
	{
		this->value[0] = col_type(s, 0, 0, 0);
		this->value[1] = col_type(0, s, 0, 0);
		this->value[2] = col_type(0, 0, s, 0);
		this->value[3] = col_type(0, 0, 0, s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4
	(
		T const & x0, T const & y0, T const & z0, T const & w0,
		T const & x1, T const & y1, T const & z1, T const & w1,
		T const & x2, T const & y2, T const & z2, T const & w2,
		T const & x3, T const & y3, T const & z3, T const & w3
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
		this->value[3] = col_type(x3, y3, z3, w3);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat4x4<T, P>::tmat4x4
	(
		tmat4x4<U, Q> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	

	template <typename T, precision P> 
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	 inline tmat4x4<T, P>::tmat4x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
		X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
		X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
	)
	{
		static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

		static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
		static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
		static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
		static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

		static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
		static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
		static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
		static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

		static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
		static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
		static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
		static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");

		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 inline tmat4x4<T, P>::tmat4x4
	(
		tvec4<V1, P> const & v1,
		tvec4<V2, P> const & v2,
		tvec4<V3, P> const & v3,
		tvec4<V4, P> const & v4
	)		
	{
		static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(m[3], 1);
	}

	

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl", (unsigned)(242)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl", (unsigned)(249)), 0) );
		return this->value[i];
	}

	













#line 268 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)
	{
		return *this *= inverse(m);
	}

	

	template <typename T, precision P>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
	{
		tmat4x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
	{
		tmat4x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)
	{
		return tmat4x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)
	{
		return tmat4x4<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			s - m[0],
			s - m[1],
			s - m[2],
			s - m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const  & s)
	{
		return tmat4x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::col_type operator*
	(
		tmat4x4<T, P> const & m,
		typename tmat4x4<T, P>::row_type const & v
	)
	{



















		typename tmat4x4<T, P>::col_type const Mov0(v[0]);
		typename tmat4x4<T, P>::col_type const Mov1(v[1]);
		typename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;
		typename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;
		typename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;
		typename tmat4x4<T, P>::col_type const Mov2(v[2]);
		typename tmat4x4<T, P>::col_type const Mov3(v[3]);
		typename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;
		typename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;
		typename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;
		typename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;
		return Add2;








	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::row_type operator*
	(
		typename tmat4x4<T, P>::col_type const & v,
		tmat4x4<T, P> const & m
	)
	{
		return typename tmat4x4<T, P>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		typename tmat4x4<T, P>::col_type const SrcA0 = m1[0];
		typename tmat4x4<T, P>::col_type const SrcA1 = m1[1];
		typename tmat4x4<T, P>::col_type const SrcA2 = m1[2];
		typename tmat4x4<T, P>::col_type const SrcA3 = m1[3];

		typename tmat4x4<T, P>::col_type const SrcB0 = m2[0];
		typename tmat4x4<T, P>::col_type const SrcB1 = m2[1];
		typename tmat4x4<T, P>::col_type const SrcB2 = m2[2];
		typename tmat4x4<T, P>::col_type const SrcB3 = m2[3];

		tmat4x4<T, P> Result(uninitialize);
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)
	{
		return tmat4x4<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator/(T const & s,	tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)
	{
		return inverse(m) * v;
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)
	{
		return v * inverse(m);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		tmat4x4<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4_simd.inl"



namespace glm
{

}
#line 671 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"
#line 672 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat4x4.inl"
#line 195 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x4.hpp"
#line 196 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat4x4.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../mat4x4.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4x4;

}
#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"

namespace glm{
namespace detail
{
	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec2>
	{
		typedef tmat2x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec3>
	{
		typedef tmat3x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec4>
	{
		typedef tmat4x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec2>
	{
		typedef tmat2x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec3>
	{
		typedef tmat3x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec4>
	{
		typedef tmat4x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec2>
	{
		typedef tmat2x4<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec3>
	{
		typedef tmat3x4<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec4>
	{
		typedef tmat4x4<T, P> type;
	};

}

	
	

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
	 typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);

	
	
	
	
	
	

		template <typename T, precision P, template <typename, precision> class matType>
		 typename matType<T, P>::transpose_type transpose(matType<T, P> const & x);
#line 127 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class matType>
	 T determinant(matType<T, P> const & m);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> inverse(matType<T, P> const & m);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../geometric.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_geometric.hpp"










#pragma once



namespace glm
{
	
	

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 T length(
		vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 T distance(
		vecType<T, P> const & p0,
		vecType<T, P> const & p1);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 T dot(
		vecType<T, P> const & x,
		vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P>
	 tvec3<T, P> cross(
		tvec3<T, P> const & x,
		tvec3<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> normalize(
		vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> faceforward(
		vecType<T, P> const & N,
		vecType<T, P> const & I,
		vecType<T, P> const & Nref);

	
	
	
	
	
	
	
	template <typename genType>
	 genType reflect(
		genType const & I,
		genType const & N);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> refract(
		vecType<T, P> const & I,
		vecType<T, P> const & N,
		T eta);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.hpp"










#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"



#pragma once









#line 15 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec1
	{
		

		typedef T value_type;
		typedef tvec1<T, P> type;
		typedef tvec1<bool, P> bool_type;

		




#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"



#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"




#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"
		
			union
			{
				T x;
				T r;
				T s;












			};
		


#line 66 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"


#line 69 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"






#line 76 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"

		

		
		typedef length_t length_type;
		 static length_type length(){return 1;}

		 T & operator[](length_type i);
		 T const & operator[](length_type i) const;

		

		  tvec1() ;
		  tvec1(tvec1<T, P> const & v) = default;
		template <precision Q>
		  tvec1(tvec1<T, Q> const & v);

		

		  explicit tvec1(ctor);
		  explicit tvec1(T scalar);

		

		
		template <typename U, precision Q>
		   tvec1(tvec2<U, Q> const & v);
		
		template <typename U, precision Q>
		   tvec1(tvec3<U, Q> const & v);
		
		template <typename U, precision Q>
		   tvec1(tvec4<U, Q> const & v);

		
		template <typename U, precision Q>
		   tvec1(tvec1<U, Q> const & v);

		









		

		 tvec1<T, P> & operator=(tvec1<T, P> const & v) = default;

		template <typename U>
		 tvec1<T, P> & operator=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator*=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator/=(tvec1<U, P> const & v);

		

		 tvec1<T, P> & operator++();
		 tvec1<T, P> & operator--();
		 tvec1<T, P> operator++(int);
		 tvec1<T, P> operator--(int);

		

		template <typename U>
		 tvec1<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U>
		 tvec1<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator>>=(tvec1<U, P> const & v);
	};

	

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator-(tvec1<T, P> const & v);

	

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator+(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator-(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator-(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator-	(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator*(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator*(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator/(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator/(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator%(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator%(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator&(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator&(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator|(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator|(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator^(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator^(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(tvec1<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(T scalar, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator~(tvec1<T, P> const & v);

	

	template <typename T, precision P>
	 bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <precision P>
	 tvec1<bool, P> operator&&(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2);

	template <precision P>
	 tvec1<bool, P> operator||(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2);
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl"



namespace glm
{
	


		template <typename T, precision P>
		 inline  tvec1<T, P>::tvec1()

				: x(0)
#line 14 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl"
		{}
#line 16 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl"






#line 23 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline  tvec1<T, P>::tvec1(tvec1<T, Q> const & v)
		: x(v.x)
	{}

	

	template <typename T, precision P>
	 inline  tvec1<T, P>::tvec1(ctor)
	{}

	template <typename T, precision P>
	 inline  tvec1<T, P>::tvec1(T scalar)
		: x(scalar)
	{}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec1<T, P>::tvec1(tvec1<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec1<T, P>::tvec1(tvec2<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec1<T, P>::tvec1(tvec3<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline  tvec1<T, P>::tvec1(tvec4<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	

	template <typename T, precision P>
	 inline T & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl", (unsigned)(72)), 0) );
		return (&x)[i];
	}

	template <typename T, precision P>
	 inline T const & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl", (unsigned)(79)), 0) );
		return (&x)[i];
	}

	








#line 93 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.inl"

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator=(tvec1<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator+=(tvec1<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator-=(tvec1<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		return *this;
	}

	

	template <typename T, precision P>
	 inline tvec1<T, P> & tvec1<T, P>::operator++()
	{
		++this->x;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec1<T, P> & tvec1<T, P>::operator--()
	{
		--this->x;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec1<T, P> tvec1<T, P>::operator++(int)
	{
		tvec1<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec1<T, P> tvec1<T, P>::operator--(int)
	{
		tvec1<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= U(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		return *this;
	}

	

	template <typename T, precision P>
	 inline tvec1<T, P> operator+(tvec1<T, P> const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator-(tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			-v.x);
	}

	

	template <typename T, precision P> 
	 inline tvec1<T, P> operator+(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x + scalar);
	}

	template <typename T, precision P> 
	 inline tvec1<T, P> operator+(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar + v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x + v2.x);
	}

	
	template <typename T, precision P> 
	 inline tvec1<T, P> operator-(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x - scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator-(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar - v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator-(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x - v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator*(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x * scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator*(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar * v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x * v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator/(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x / scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator/(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar / v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x / v2.x);
	}

	

	template <typename T, precision P>
	 inline tvec1<T, P> operator%(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x % scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator%(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar % v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x % v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator&(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x & scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator&(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar & v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x & v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator|(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x | scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator|(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar | v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x | v2.x);
	}
		
	template <typename T, precision P>
	 inline tvec1<T, P> operator^(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x ^ scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator^(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar ^ v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x ^ v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator<<(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x << scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator<<(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar << v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x << v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator>>(tvec1<T, P> const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x >> scalar);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator>>(T scalar, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			scalar >> v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x >> v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator~(tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			~v.x);
	}

	

	template <typename T, precision P> 
	 inline bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return (v1.x == v2.x);
	}

	template <typename T, precision P> 
	 inline bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return (v1.x != v2.x);
	}

	template <precision P>
	 inline tvec1<bool, P> operator&&(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2)
	{
		return tvec1<bool, P>(v1.x && v2.x);
	}

	template <precision P>
	 inline tvec1<bool, P> operator||(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2)
	{
		return tvec1<bool, P>(v1.x || v2.x);
	}
}
#line 302 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"
#line 303 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_vec1.hpp"
#line 14 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.hpp"





namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> exp(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> log(vecType<T, P> const & v);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> exp2(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> log2(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sqrt(vecType<T, P> const & v);
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> inversesqrt(vecType<T, P> const & v);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.hpp"















#pragma once




namespace glm
{
	
	

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 bool any(vecType<bool, P> const & v);

	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 bool all(vecType<bool, P> const & v);

	
	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 vecType<bool, P> not_(vecType<bool, P> const & v);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl"





namespace glm
{
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl", (unsigned)(11)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];

		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl", (unsigned)(23)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl", (unsigned)(34)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl", (unsigned)(45)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl", (unsigned)(56)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl", (unsigned)(67)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 inline bool any(vecType<bool, P> const & v)
	{
		bool Result = false;
		for(length_t i = 0; i < v.length(); ++i)
			Result = Result || v[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 inline bool all(vecType<bool, P> const & v)
	{
		bool Result = true;
		for(length_t i = 0; i < v.length(); ++i)
			Result = Result && v[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> not_(vecType<bool, P> const & v)
	{
		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < v.length(); ++i)
			Result[i] = !v[i];
		return Result;
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational_simd.inl"



namespace glm{
namespace detail
{

}
}
#line 105 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl"
#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.inl"
#line 112 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_vector_relational.hpp"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\_vectorize.hpp"



#pragma once






namespace glm{
namespace detail
{
	template <typename R, typename T, precision P, template <typename, precision> class vecType>
	struct functor1{};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec1>
	{
		 inline static tvec1<R, P> call(R (*Func) (T x), tvec1<T, P> const & v)
		{
			return tvec1<R, P>(Func(v.x));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec2>
	{
		 inline static tvec2<R, P> call(R (*Func) (T x), tvec2<T, P> const & v)
		{
			return tvec2<R, P>(Func(v.x), Func(v.y));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec3>
	{
		 inline static tvec3<R, P> call(R (*Func) (T x), tvec3<T, P> const & v)
		{
			return tvec3<R, P>(Func(v.x), Func(v.y), Func(v.z));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec4>
	{
		 inline static tvec4<R, P> call(R (*Func) (T x), tvec4<T, P> const & v)
		{
			return tvec4<R, P>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct functor2{};

	template <typename T, precision P>
	struct functor2<T, P, tvec1>
	{
		 inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, tvec1<T, P> const & b)
		{
			return tvec1<T, P>(Func(a.x, b.x));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec2>
	{
		 inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, tvec2<T, P> const & b)
		{
			return tvec2<T, P>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec3>
	{
		 inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, tvec3<T, P> const & b)
		{
			return tvec3<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec4>
	{
		 inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct functor2_vec_sca{};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec1>
	{
		 inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, T b)
		{
			return tvec1<T, P>(Func(a.x, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec2>
	{
		 inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, T b)
		{
			return tvec2<T, P>(Func(a.x, b), Func(a.y, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec3>
	{
		 inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, T b)
		{
			return tvec3<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec4>
	{
		 inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, T b)
		{
			return tvec4<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};
}
}
#line 6 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"


#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\cassert"



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"









#line 11 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 5 "H:\\Visual Studio\\VC\\INCLUDE\\cassert"





#line 9 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"

namespace glm{
namespace detail
{

		using std::log2;






#line 22 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"

	template <typename T, precision P, template <class, precision> class vecType, bool isFloat, bool Aligned>
	struct compute_log2
	{
		 inline static vecType<T, P> call(vecType<T, P> const & vec)
		{
			return detail::functor1<T, T, P, vecType>::call(log2, vec);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_sqrt
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(std::sqrt, x);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_inversesqrt
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return static_cast<T>(1) / sqrt(x);
		}
	};
		
	template <template <class, precision> class vecType, bool Aligned>
	struct compute_inversesqrt<vecType, float, lowp, Aligned>
	{
		 inline static vecType<float, lowp> call(vecType<float, lowp> const & x)
		{
			vecType<float, lowp> tmp(x);
			vecType<float, lowp> xhalf(tmp * 0.5f);
			vecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
			vecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));
			vecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);
			tmp = *ptmp;
			tmp = tmp * (1.5f - xhalf * tmp * tmp);
			return tmp;
		}
	};
}

	
	using std::pow;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)
	{
		return detail::functor2<T, P, vecType>::call(pow, base, exponent);
	}

	
	using std::exp;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> exp(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(exp, x);
	}

	
	using std::log;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> log(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(log, x);
	}

	
	template <typename genType>
	 inline genType exp2(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'exp2' only accept floating-point inputs");

		return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> exp2(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(exp2, x);
	}

	
	template <typename genType>
	 inline genType log2(genType x)
	{
		return log2(tvec1<genType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> log2(vecType<T, P> const & x)
	{
		return detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
	}

	
	using std::sqrt;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sqrt(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'sqrt' only accept floating-point inputs");
		return detail::compute_sqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
	}

	
	template <typename genType>
	 inline genType inversesqrt(genType x)
	{
		return static_cast<genType>(1) / sqrt(x);
	}
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> inversesqrt(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
		return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential_simd.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/exponential.h"



#pragma once





 inline glm_vec4 glm_vec1_sqrt_lowp(glm_vec4 x)
{
	return _mm_mul_ss(_mm_rsqrt_ss(x), x);
}

 inline glm_vec4 glm_vec4_sqrt_lowp(glm_vec4 x)
{
	return _mm_mul_ps(_mm_rsqrt_ps(x), x);
}

#line 21 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/exponential.h"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential_simd.inl"



namespace glm{
namespace detail
{
	template <precision P>
	struct compute_sqrt<tvec4, float, P, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = _mm_sqrt_ps(v.data);
			return result;
		}
	};

	template <>
	struct compute_sqrt<tvec4, float, aligned_lowp, true>
	{
		 inline static tvec4<float, aligned_lowp> call(tvec4<float, aligned_lowp> const & v)
		{
			tvec4<float, aligned_lowp> result(uninitialize);
			result.data = glm_vec4_sqrt_lowp(v.data);
			return result;
		}
	};
}
}

#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential_simd.inl"
#line 145 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"
#line 146 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.inl"

#line 104 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_exponential.hpp"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric.inl"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.hpp"










#pragma once




#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\_fixes.hpp"






























#line 17 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template <typename genType>
	 genType abs(genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> abs(vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sign(vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> floor(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> trunc(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> round(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> roundEven(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> ceil(vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename genType>
	 genType fract(genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fract(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename genType>
	 genType mod(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	
	
	
	template <typename genType>
	 genType modf(genType x, genType & i);

	
	
	
	
	
	
	template <typename genType>
	 genType min(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> min(vecType<T, P> const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> min(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename genType>
	 genType max(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> max(vecType<T, P> const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> max(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	
	template <typename genType>
	 genType clamp(genType x, genType minVal, genType maxVal);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a);

	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a);

	template <typename genTypeT, typename genTypeU>
	 genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

	
	
	
	
	template <typename genType>
	 genType step(genType edge, genType x);

	
	
	
	
	template <template <typename, precision> class vecType, typename T, precision P>
	 vecType<T, P> step(T edge, vecType<T, P> const & x);

	
	
	
	
	template <template <typename, precision> class vecType, typename T, precision P>
	 vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType>
	 genType smoothstep(genType edge0, genType edge1, genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isnan(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isinf(vecType<T, P> const & x);

	
	
	
	
	
	
	 int floatBitsToInt(float const & v);

	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<int, P> floatBitsToInt(vecType<float, P> const & v);

	
	
	
	
	
	
	 uint floatBitsToUint(float const & v);

	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<uint, P> floatBitsToUint(vecType<float, P> const & v);

	
	
	
	
	
	
	
	
	 float intBitsToFloat(int const & v);

	
	
	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<float, P> intBitsToFloat(vecType<int, P> const & v);

	
	
	
	
	
	
	
	
	 float uintBitsToFloat(uint const & v);

	
	
	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v);

	
	
	
	
	
	
	template <typename genType>
	 genType fma(genType const & a, genType const & b, genType const & c);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType frexp(genType const & x, genIType & exp);

	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType ldexp(genType const & x, genIType const & exp);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"










namespace glm
{
	
	template <typename genType>
	 inline genType min(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer || 0, "'min' only accept floating-point or integer inputs");
		return x < y ? x : y;
	}

	
	template <typename genType>
	 inline genType max(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer || 0, "'max' only accept floating-point or integer inputs");

		return x > y ? x : y;
	}

	
	template <>
	 inline int32 abs(int32 x)
	{
		int32 const y = x >> 31;
		return (x ^ y) - y;
	}

	

		using ::std::round;








#line 50 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

	

		using ::std::trunc;








#line 63 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

}

namespace glm{
namespace detail
{
	template <typename genFIType, bool >
	struct compute_abs
	{};

	template <typename genFIType>
	struct compute_abs<genFIType, true>
	{
		 inline static genFIType call(genFIType x)
		{
			static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed || 0, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 81 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

			return x >= genFIType(0) ? x : -x;
			
		}
	};

	








#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

	template <typename genFIType>
	struct compute_abs<genFIType, false>
	{
		 inline static genFIType call(genFIType x)
		{
			static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer) || 0, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"
			return x;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_abs_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(abs, x);
		}
	};

	template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_vector<T, bool, P, vecType, Aligned>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<bool, P> const & a)
		{
			vecType<T, P> Result(uninitialize);
			for(length_t i = 0; i < x.length(); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};

	template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_scalar
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, U const & a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_scalar<T, bool, P, vecType, Aligned>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, bool const & a)
		{
			return a ? y : x;
		}
	};

	template <typename T, typename U>
	struct compute_mix
	{
		 inline static T call(T const & x, T const & y, U const & a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
		}
	};

	template <typename T>
	struct compute_mix<T, bool>
	{
		 inline static T call(T const & x, T const & y, bool const & a)
		{
			return a ? y : x;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool isFloat, bool Aligned>
	struct compute_sign
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));
		}
	};













#line 204 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_floor
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(std::floor, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_ceil
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(std::ceil, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_fract
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return x - floor(x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_trunc
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(trunc, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_round
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(round, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mod
	{
		 inline static vecType<T, P> call(vecType<T, P> const & a, vecType<T, P> const & b)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
			return a - b * floor(a / b);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_min_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y)
		{
			return detail::functor2<T, P, vecType>::call(min, x, y);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_max_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y)
		{
			return detail::functor2<T, P, vecType>::call(max, x, y);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_clamp_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
		{
			return min(max(x, minVal), maxVal);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_step_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & edge, vecType<T, P> const & x)
		{
			return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_smoothstep_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'step' only accept floating-point inputs");
			vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
			return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
		}
	};
}

	template <typename genFIType>
	 inline genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> abs(vecType<T, P> const & x)
	{
		return detail::compute_abs_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	
	
	template <typename genFIType> 
	 inline genFIType sign(genFIType x)
	{
		static_assert(std::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs");
#line 328 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"
		
		return detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559, highp>::call(tvec1<genFIType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sign(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs");
#line 338 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

		return detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
	}

	
	using ::std::floor;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> floor(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'floor' only accept floating-point inputs.");
		return detail::compute_floor<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> trunc(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'trunc' only accept floating-point inputs");
		return detail::compute_trunc<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> round(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'round' only accept floating-point inputs");
		return detail::compute_round<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}












	
	template <typename genType>
	 inline genType roundEven(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs");
		
		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
		
		
		
		
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> roundEven(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'roundEven' only accept floating-point inputs");
		return detail::functor1<T, T, P, vecType>::call(roundEven, x);
	}

	
	using ::std::ceil;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> ceil(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ceil' only accept floating-point inputs");
		return detail::compute_ceil<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	
	template <typename genType>
	 inline genType fract(genType x)
	{
		return fract(tvec1<genType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> fract(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fract' only accept floating-point inputs");
		return detail::compute_fract<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	
	template <typename genType>
	 inline genType mod(genType x, genType y)
	{




#line 447 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"
			return mod(tvec1<genType, defaultp>(x), y).x;
#line 449 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mod(vecType<T, P> const & x, T y)
	{
		return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(y));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, y);
	}

	
	template <typename genType>
	 inline genType modf(genType x, genType & i)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs");
		return std::modf(x, &i);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> modf(tvec1<T, P> const & x, tvec1<T, P> & i)
	{
		return tvec1<T, P>(
			modf(x.x, i.x));
	}

	template <typename T, precision P>
	 inline tvec2<T, P> modf(tvec2<T, P> const & x, tvec2<T, P> & i)
	{
		return tvec2<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template <typename T, precision P>
	 inline tvec3<T, P> modf(tvec3<T, P> const & x, tvec3<T, P> & i)
	{
		return tvec3<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template <typename T, precision P>
	 inline tvec4<T, P> modf(tvec4<T, P> const & x, tvec4<T, P> & i)
	{
		return tvec4<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	
	
	
	
	
	
	

	
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> min(vecType<T, P> const & a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'min' only accept floating-point or integer inputs");
		return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> min(vecType<T, P> const & a, vecType<T, P> const & b)
	{
		return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
	}

	
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> max(vecType<T, P> const & a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'max' only accept floating-point or integer inputs");
		return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> max(vecType<T, P> const & a, vecType<T, P> const & b)
	{
		return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
	}

	
	template <typename genType>
	 inline genType clamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer || 0, "'clamp' only accept floating-point or integer inputs");
		return min(max(x, minVal), maxVal);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(minVal), vecType<T, P>(maxVal));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, minVal, maxVal);
	}

	template <typename genTypeT, typename genTypeU>
	 inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}

	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a)
	{
		return detail::compute_mix_scalar<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
	}
	
	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
	{
		return detail::compute_mix_vector<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
	}

	
	template <typename genType>
	 inline genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));
	}

	template <template <typename, precision> class vecType, typename T, precision P>
	 inline vecType<T, P> step(T edge, vecType<T, P> const & x)
	{
		return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge), x);
	}

	template <template <typename, precision> class vecType, typename T, precision P>
	 inline vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x)
	{
		return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge, x);
	}

	
	template <typename genType>
	 inline genType smoothstep(genType edge0, genType edge1, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'smoothstep' only accept floating-point inputs");

		genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x)
	{
		return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge0), vecType<T, P>(edge1), x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
	{
		return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge0, edge1, x);
	}


		using std::isnan;
























#line 649 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> isnan(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

		return detail::functor1<bool, T, P, vecType>::call(isnan, x);
	}


		using std::isinf;



























#line 688 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> isinf(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

		return detail::functor1<bool, T, P, vecType>::call(isinf, x);
	}

	 inline int floatBitsToInt(float const & v)
	{
		return reinterpret_cast<int&>(const_cast<float&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<int, P> floatBitsToInt(vecType<float, P> const & v)
	{
		return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
	}

	 inline uint floatBitsToUint(float const & v)
	{
		return reinterpret_cast<uint&>(const_cast<float&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)
	{
		return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
	}

	 inline float intBitsToFloat(int const & v)
	{
		return reinterpret_cast<float&>(const_cast<int&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<float, P> intBitsToFloat(vecType<int, P> const & v)
	{
		return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
	}

	 inline float uintBitsToFloat(uint const & v)
	{
		return reinterpret_cast<float&>(const_cast<uint&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)
	{
		return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
	}
	
	template <typename genType>
	 inline genType fma(genType const & a, genType const & b, genType const & c)
	{
		return a * b + c;
	}

	template <typename genType>
	 inline genType frexp(genType x, int & exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		return std::frexp(x, &exp);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> frexp(tvec1<T, P> const & x, tvec1<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		return tvec1<T, P>(std::frexp(x.x, &exp.x));
	}

	template <typename T, precision P>
	 inline tvec2<T, P> frexp(tvec2<T, P> const & x, tvec2<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		return tvec2<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y));
	}

	template <typename T, precision P>
	 inline tvec3<T, P> frexp(tvec3<T, P> const & x, tvec3<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		return tvec3<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y),
			frexp(x.z, exp.z));
	}

	template <typename T, precision P>
	 inline tvec4<T, P> frexp(tvec4<T, P> const & x, tvec4<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		return tvec4<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y),
			frexp(x.z, exp.z),
			frexp(x.w, exp.w));
	}

	template <typename genType>
	 inline genType ldexp(genType const & x, int const & exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		return std::ldexp(x, exp);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> ldexp(tvec1<T, P> const & x, tvec1<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		return tvec1<T, P>(
			ldexp(x.x, exp.x));
	}

	template <typename T, precision P>
	 inline tvec2<T, P> ldexp(tvec2<T, P> const & x, tvec2<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		return tvec2<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y));
	}

	template <typename T, precision P>
	 inline tvec3<T, P> ldexp(tvec3<T, P> const & x, tvec3<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		return tvec3<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y),
			ldexp(x.z, exp.z));
	}

	template <typename T, precision P>
	 inline tvec4<T, P> ldexp(tvec4<T, P> const & x, tvec4<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		return tvec4<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y),
			ldexp(x.z, exp.z),
			ldexp(x.w, exp.w));
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common_simd.inl"





#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"



#pragma once





 inline glm_vec4 glm_vec4_add(glm_vec4 a, glm_vec4 b)
{
	return _mm_add_ps(a, b);
}

 inline glm_vec4 glm_vec1_add(glm_vec4 a, glm_vec4 b)
{
	return _mm_add_ss(a, b);
}

 inline glm_vec4 glm_vec4_sub(glm_vec4 a, glm_vec4 b)
{
	return _mm_sub_ps(a, b);
}

 inline glm_vec4 glm_vec1_sub(glm_vec4 a, glm_vec4 b)
{
	return _mm_sub_ss(a, b);
}

 inline glm_vec4 glm_vec4_mul(glm_vec4 a, glm_vec4 b)
{
	return _mm_mul_ps(a, b);
}

 inline glm_vec4 glm_vec1_mul(glm_vec4 a, glm_vec4 b)
{
	return _mm_mul_ss(a, b);
}

 inline glm_vec4 glm_vec4_div(glm_vec4 a, glm_vec4 b)
{
	return _mm_div_ps(a, b);
}

 inline glm_vec4 glm_vec1_div(glm_vec4 a, glm_vec4 b)
{
	return _mm_div_ss(a, b);
}

 inline glm_vec4 glm_vec4_div_lowp(glm_vec4 a, glm_vec4 b)
{
	return glm_vec4_mul(a, _mm_rcp_ps(b));
}

 inline glm_vec4 glm_vec4_swizzle_xyzw(glm_vec4 a)
{


#line 60 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		return _mm_shuffle_ps(a, a, (((3) << 6) | ((2) << 4) | ((1) << 2) | ((0))));
#line 62 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}

 inline glm_vec4 glm_vec1_fma(glm_vec4 a, glm_vec4 b, glm_vec4 c)
{


#line 69 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		return _mm_add_ss(_mm_mul_ss(a, b), c);
#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}

 inline glm_vec4 glm_vec4_fma(glm_vec4 a, glm_vec4 b, glm_vec4 c)
{


#line 78 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		return glm_vec4_add(glm_vec4_mul(a, b), c);
#line 80 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}

 inline glm_vec4 glm_vec4_abs(glm_vec4 x)
{
	return _mm_and_ps(x, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));
}

 inline glm_ivec4 glm_ivec4_abs(glm_ivec4 x)
{


#line 92 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		glm_ivec4 const sgn0 = _mm_srai_epi32(x, 31);
		glm_ivec4 const inv0 = _mm_xor_si128(x, sgn0);
		glm_ivec4 const sub0 = _mm_sub_epi32(inv0, sgn0);
		return sub0;
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}

 inline glm_vec4 glm_vec4_sign(glm_vec4 x)
{
	glm_vec4 const zro0 = _mm_setzero_ps();
	glm_vec4 const cmp0 = _mm_cmplt_ps(x, zro0);
	glm_vec4 const cmp1 = _mm_cmpgt_ps(x, zro0);
	glm_vec4 const and0 = _mm_and_ps(cmp0, _mm_set_ps1(-1.0f));
	glm_vec4 const and1 = _mm_and_ps(cmp1, _mm_set_ps1(1.0f));
	glm_vec4 const or0 = _mm_or_ps(and0, and1);;
	return or0;
}

 inline glm_vec4 glm_vec4_round(glm_vec4 x)
{


#line 115 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		glm_vec4 const sgn0 = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
		glm_vec4 const and0 = _mm_and_ps(sgn0, x);
		glm_vec4 const or0 = _mm_or_ps(and0, _mm_set_ps1(8388608.0f));
		glm_vec4 const add0 = glm_vec4_add(x, or0);
		glm_vec4 const sub0 = glm_vec4_sub(add0, or0);
		return sub0;
#line 122 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}

 inline glm_vec4 glm_vec4_floor(glm_vec4 x)
{


#line 129 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		glm_vec4 const rnd0 = glm_vec4_round(x);
		glm_vec4 const cmp0 = _mm_cmplt_ps(x, rnd0);
		glm_vec4 const and0 = _mm_and_ps(cmp0, _mm_set_ps1(1.0f));
		glm_vec4 const sub0 = glm_vec4_sub(rnd0, and0);
		return sub0;
#line 135 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}









 inline glm_vec4 glm_vec4_roundEven(glm_vec4 x)
{
	glm_vec4 const sgn0 = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
	glm_vec4 const and0 = _mm_and_ps(sgn0, x);
	glm_vec4 const or0 = _mm_or_ps(and0, _mm_set_ps1(8388608.0f));
	glm_vec4 const add0 = glm_vec4_add(x, or0);
	glm_vec4 const sub0 = glm_vec4_sub(add0, or0);
	return sub0;
}

 inline glm_vec4 glm_vec4_ceil(glm_vec4 x)
{


#line 160 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
		glm_vec4 const rnd0 = glm_vec4_round(x);
		glm_vec4 const cmp0 = _mm_cmpgt_ps(x, rnd0);
		glm_vec4 const and0 = _mm_and_ps(cmp0, _mm_set_ps1(1.0f));
		glm_vec4 const add0 = glm_vec4_add(rnd0, and0);
		return add0;
#line 166 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
}

 inline glm_vec4 glm_vec4_fract(glm_vec4 x)
{
	glm_vec4 const flr0 = glm_vec4_floor(x);
	glm_vec4 const sub0 = glm_vec4_sub(x, flr0);
	return sub0;
}

 inline glm_vec4 glm_vec4_mod(glm_vec4 x, glm_vec4 y)
{
	glm_vec4 const div0 = glm_vec4_div(x, y);
	glm_vec4 const flr0 = glm_vec4_floor(div0);
	glm_vec4 const mul0 = glm_vec4_mul(y, flr0);
	glm_vec4 const sub0 = glm_vec4_sub(x, mul0);
	return sub0;
}

 inline glm_vec4 glm_vec4_clamp(glm_vec4 v, glm_vec4 minVal, glm_vec4 maxVal)
{
	glm_vec4 const min0 = _mm_min_ps(v, maxVal);
	glm_vec4 const max0 = _mm_max_ps(min0, minVal);
	return max0;
}

 inline glm_vec4 glm_vec4_mix(glm_vec4 v1, glm_vec4 v2, glm_vec4 a)
{
	glm_vec4 const sub0 = glm_vec4_sub(_mm_set_ps1(1.0f), a);
	glm_vec4 const mul0 = glm_vec4_mul(v1, sub0);
	glm_vec4 const mad0 = glm_vec4_fma(v2, a, mul0);
	return mad0;
}

 inline glm_vec4 glm_vec4_step(glm_vec4 edge, glm_vec4 x)
{
	glm_vec4 const cmp = _mm_cmple_ps(x, edge);
	return _mm_movemask_ps(cmp) == 0 ? _mm_set_ps1(1.0f) : _mm_setzero_ps();
}

 inline glm_vec4 glm_vec4_smoothstep(glm_vec4 edge0, glm_vec4 edge1, glm_vec4 x)
{
	glm_vec4 const sub0 = glm_vec4_sub(x, edge0);
	glm_vec4 const sub1 = glm_vec4_sub(edge1, edge0);
	glm_vec4 const div0 = glm_vec4_sub(sub0, sub1);
	glm_vec4 const clp0 = glm_vec4_clamp(div0, _mm_setzero_ps(), _mm_set_ps1(1.0f));
	glm_vec4 const mul0 = glm_vec4_mul(_mm_set_ps1(2.0f), clp0);
	glm_vec4 const sub2 = glm_vec4_sub(_mm_set_ps1(3.0f), mul0);
	glm_vec4 const mul1 = glm_vec4_mul(clp0, clp0);
	glm_vec4 const mul2 = glm_vec4_mul(mul1, sub2);
	return mul2;
}


 inline glm_vec4 glm_vec4_nan(glm_vec4 x)
{
	glm_ivec4 const t1 = _mm_castps_si128(x);						
	glm_ivec4 const t2 = _mm_sll_epi32(t1, _mm_cvtsi32_si128(1));	
	glm_ivec4 const t3 = _mm_set1_epi32(0xFF000000);				
	glm_ivec4 const t4 = _mm_and_si128(t2, t3);						
	glm_ivec4 const t5 = _mm_andnot_si128(t3, t2);					
	glm_ivec4 const Equal = _mm_cmpeq_epi32(t3, t4);
	glm_ivec4 const Nequal = _mm_cmpeq_epi32(t5, _mm_setzero_si128());
	glm_ivec4 const And = _mm_and_si128(Equal, Nequal);
	return _mm_castsi128_ps(And);									
}


 inline glm_vec4 glm_vec4_inf(glm_vec4 x)
{
	glm_ivec4 const t1 = _mm_castps_si128(x);										
	glm_ivec4 const t2 = _mm_sll_epi32(t1, _mm_cvtsi32_si128(1));					
	return _mm_castsi128_ps(_mm_cmpeq_epi32(t2, _mm_set1_epi32(0xFF000000)));		
}

#line 241 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/common.h"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common_simd.inl"



namespace glm{
namespace detail
{
	template <precision P>
	struct compute_abs_vector<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_abs(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_abs_vector<int, P, tvec4, true>
	{
		 inline static tvec4<int, P> call(tvec4<int, P> const & v)
		{
			tvec4<int, P> result(uninitialize);
			result.data = glm_ivec4_abs(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_floor<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_floor(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_ceil<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_ceil(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_fract<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_fract(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_round<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_round(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_mod<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & x, tvec4<float, P> const & y)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_mod(x.data, y.data);
			return result;
		}
	};

	template <precision P>
	struct compute_min_vector<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v1, tvec4<float, P> const & v2)
		{
			tvec4<float, P> result(uninitialize);
			result.data = _mm_min_ps(v1.data, v2.data);
			return result;
		}
	};

	template <precision P>
	struct compute_min_vector<int32, P, tvec4, true>
	{
		 inline static tvec4<int32, P> call(tvec4<int32, P> const & v1, tvec4<int32, P> const & v2)
		{
			tvec4<int32, P> result(uninitialize);
			result.data = _mm_min_epi32(v1.data, v2.data);
			return result;
		}
	};

	template <precision P>
	struct compute_min_vector<uint32, P, tvec4, true>
	{
		 inline static tvec4<int32, P> call(tvec4<uint32, P> const & v1, tvec4<uint32, P> const & v2)
		{
			tvec4<uint32, P> result(uninitialize);
			result.data = _mm_min_epu32(v1.data, v2.data);
			return result;
		}
	};

	template <precision P>
	struct compute_max_vector<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v1, tvec4<float, P> const & v2)
		{
			tvec4<float, P> result(uninitialize);
			result.data = _mm_max_ps(v1.data, v2.data);
			return result;
		}
	};

	template <precision P>
	struct compute_max_vector<int32, P, tvec4, true>
	{
		 inline static tvec4<int32, P> call(tvec4<int32, P> const & v1, tvec4<int32, P> const & v2)
		{
			tvec4<int32, P> result(uninitialize);
			result.data = _mm_max_epi32(v1.data, v2.data);
			return result;
		}
	};

	template <precision P>
	struct compute_max_vector<uint32, P, tvec4, true>
	{
		 inline static tvec4<uint32, P> call(tvec4<uint32, P> const & v1, tvec4<uint32, P> const & v2)
		{
			tvec4<uint32, P> result(uninitialize);
			result.data = _mm_max_epu32(v1.data, v2.data);
			return result;
		}
	};

	template <precision P>
	struct compute_clamp_vector<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & x, tvec4<float, P> const & minVal, tvec4<float, P> const & maxVal)
		{
			tvec4<float, P> result(uninitialize);
			result.data = _mm_min_ps(_mm_max_ps(x.data, minVal.data), maxVal.data);
			return result;
		}
	};

	template <precision P>
	struct compute_clamp_vector<int32, P, tvec4, true>
	{
		 inline static tvec4<int32, P> call(tvec4<int32, P> const & x, tvec4<int32, P> const & minVal, tvec4<int32, P> const & maxVal)
		{
			tvec4<int32, P> result(uninitialize);
			result.data = _mm_min_epi32(_mm_max_epi32(x.data, minVal.data), maxVal.data);
			return result;
		}
	};

	template <precision P>
	struct compute_clamp_vector<uint32, P, tvec4, true>
	{
		 inline static tvec4<uint32, P> call(tvec4<uint32, P> const & x, tvec4<uint32, P> const & minVal, tvec4<uint32, P> const & maxVal)
		{
			tvec4<uint32, P> result(uninitialize);
			result.data = _mm_min_epu32(_mm_max_epu32(x.data, minVal.data), maxVal.data);
			return result;
		}
	};

	template <precision P>
	struct compute_mix_vector<float, bool, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & x, tvec4<float, P> const & y, tvec4<bool, P> const & a)
		{
			__m128i const Load = _mm_set_epi32(-(int)a.w, -(int)a.z, -(int)a.y, -(int)a.x);
			__m128 const Mask = _mm_castsi128_ps(Load);

			tvec4<float, P> Result(uninitialize);


#line 201 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common_simd.inl"
				Result.data = _mm_or_ps(_mm_and_ps(Mask, y.data), _mm_andnot_ps(Mask, x.data));
#line 203 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common_simd.inl"
			return Result;
		}
	};












	template <precision P>
	struct compute_smoothstep_vector<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const& edge0, tvec4<float, P> const& edge1, tvec4<float, P> const& x)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_smoothstep(edge0.data, edge1.data, x.data);
			return result;
		}
	};
}
}

#line 232 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common_simd.inl"
#line 849 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"
#line 850 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.inl"

#line 427 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_common.hpp"

#line 6 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric.inl"




namespace glm{
namespace detail
{
	template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_length
	{
		 inline static T call(vecType<T, P> const & v)
		{
			return sqrt(dot(v, v));
		}
	};

	template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_distance
	{
		 inline static T call(vecType<T, P> const & p0, vecType<T, P> const & p1)
		{
			return length(p1 - p0);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_dot{};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec1, T, P, Aligned>
	{
		 inline static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)
		{
			return a.x * b.x;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec2, T, P, Aligned>
	{
		 inline static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)
		{
			tvec2<T, P> tmp(x * y);
			return tmp.x + tmp.y;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec3, T, P, Aligned>
	{
		 inline static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)
		{
			tvec3<T, P> tmp(x * y);
			return tmp.x + tmp.y + tmp.z;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec4, T, P, Aligned>
	{
		 inline static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)
		{
			tvec4<T, P> tmp(x * y);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_cross
	{
		 inline static tvec3<T, P> call(tvec3<T, P> const & x, tvec3<T, P> const & y)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

			return tvec3<T, P>(
				x.y * y.z - y.y * x.z,
				x.z * y.x - y.z * x.x,
				x.x * y.y - y.x * x.y);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_normalize
	{
		 inline static vecType<T, P> call(vecType<T, P> const & v)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

			return v * inversesqrt(dot(v, v));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_faceforward
	{
		 inline static vecType<T, P> call(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

			return dot(Nref, I) < static_cast<T>(0) ? N : -N;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_reflect
	{
		 inline static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N)
		{
			return I - N * dot(N, I) * static_cast<T>(2);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_refract
	{
		 inline static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
		{
			T const dotValue(dot(N, I));
			T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
			return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
		}
	};
}

	
	template <typename genType>
	 inline genType length(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

		return abs(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline T length(vecType<T, P> const & v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

		return detail::compute_length<vecType, T, P, detail::is_aligned<P>::value>::call(v);
	}

	
	template <typename genType>
	 inline genType distance(genType const & p0, genType const & p1)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

		return length(p1 - p0);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)
	{
		return detail::compute_distance<vecType, T, P, detail::is_aligned<P>::value>::call(p0, p1);
	}

	
	template <typename T>
	 inline T dot(T x, T y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return x * y;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline T dot(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return detail::compute_dot<vecType, T, P, detail::is_aligned<P>::value>::call(x, y);
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)
	{
		return detail::compute_cross<T, P, detail::is_aligned<P>::value>::call(x, y);
	}

	
	template <typename genType>
	 inline genType normalize(genType const & x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'normalize' accepts only floating-point inputs");

		return x < genType(0) ? genType(-1) : genType(1);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> normalize(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

		return detail::compute_normalize<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	
	template <typename genType>
	 inline genType faceforward(genType const & N, genType const & I, genType const & Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
	{
		return detail::compute_faceforward<T, P, vecType, detail::is_aligned<P>::value>::call(N, I, Nref);
	}

	
	template <typename genType>
	 inline genType reflect(genType const & I, genType const & N)
	{
		return I - N * dot(N, I) * genType(2);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> reflect(vecType<T, P> const & I, vecType<T, P> const & N)
	{
		return detail::compute_reflect<T, P, vecType, detail::is_aligned<P>::value>::call(I, N);
	}

	
	template <typename genType>
	 inline genType refract(genType const & I, genType const & N, genType eta)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
		genType const dotValue(dot(N, I));
		genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
		return detail::compute_refract<T, P, vecType, detail::is_aligned<P>::value>::call(I, N, eta);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric_simd.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"



#pragma once





 glm_vec4 glm_vec4_dot(glm_vec4 v1, glm_vec4 v2);
 glm_vec4 glm_vec1_dot(glm_vec4 v1, glm_vec4 v2);

 inline glm_vec4 glm_vec4_length(glm_vec4 x)
{
	glm_vec4 const dot0 = glm_vec4_dot(x, x);
	glm_vec4 const sqt0 = _mm_sqrt_ps(dot0);
	return sqt0;
}

 inline glm_vec4 glm_vec4_distance(glm_vec4 p0, glm_vec4 p1)
{
	glm_vec4 const sub0 = _mm_sub_ps(p0, p1);
	glm_vec4 const len0 = glm_vec4_length(sub0);
	return len0;
}

 inline glm_vec4 glm_vec4_dot(glm_vec4 v1, glm_vec4 v2)
{


#line 32 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"




#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"
		glm_vec4 const mul0 = _mm_mul_ps(v1, v2);
		glm_vec4 const swp0 = _mm_shuffle_ps(mul0, mul0, (((2) << 6) | ((3) << 4) | ((0) << 2) | ((1))));
		glm_vec4 const add0 = _mm_add_ps(mul0, swp0);
		glm_vec4 const swp1 = _mm_shuffle_ps(add0, add0, (((0) << 6) | ((1) << 4) | ((2) << 2) | ((3))));
		glm_vec4 const add1 = _mm_add_ps(add0, swp1);
		return add1;
#line 44 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"
}

 inline glm_vec4 glm_vec1_dot(glm_vec4 v1, glm_vec4 v2)
{


#line 51 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"




#line 56 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"
		glm_vec4 const mul0 = _mm_mul_ps(v1, v2);
		glm_vec4 const mov0 = _mm_movehl_ps(mul0, mul0);
		glm_vec4 const add0 = _mm_add_ps(mov0, mul0);
		glm_vec4 const swp1 = _mm_shuffle_ps(add0, add0, 1);
		glm_vec4 const add1 = _mm_add_ss(add0, swp1);
		return add1;
#line 63 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"
}

 inline glm_vec4 glm_vec4_cross(glm_vec4 v1, glm_vec4 v2)
{
	glm_vec4 const swp0 = _mm_shuffle_ps(v1, v1, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
	glm_vec4 const swp1 = _mm_shuffle_ps(v1, v1, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
	glm_vec4 const swp2 = _mm_shuffle_ps(v2, v2, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
	glm_vec4 const swp3 = _mm_shuffle_ps(v2, v2, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
	glm_vec4 const mul0 = _mm_mul_ps(swp0, swp3);
	glm_vec4 const mul1 = _mm_mul_ps(swp1, swp2);
	glm_vec4 const sub0 = _mm_sub_ps(mul0, mul1);
	return sub0;
}

 inline glm_vec4 glm_vec4_normalize(glm_vec4 v)
{
	glm_vec4 const dot0 = glm_vec4_dot(v, v);
	glm_vec4 const isr0 = _mm_rsqrt_ps(dot0);
	glm_vec4 const mul0 = _mm_mul_ps(v, isr0);
	return mul0;
}

 inline glm_vec4 glm_vec4_faceforward(glm_vec4 N, glm_vec4 I, glm_vec4 Nref)
{
	glm_vec4 const dot0 = glm_vec4_dot(Nref, I);
	glm_vec4 const sgn0 = glm_vec4_sign(dot0);
	glm_vec4 const mul0 = _mm_mul_ps(sgn0, _mm_set_ps1(-1.0f));
	glm_vec4 const mul1 = _mm_mul_ps(N, mul0);
	return mul1;
}

 inline glm_vec4 glm_vec4_reflect(glm_vec4 I, glm_vec4 N)
{
	glm_vec4 const dot0 = glm_vec4_dot(N, I);
	glm_vec4 const mul0 = _mm_mul_ps(N, dot0);
	glm_vec4 const mul1 = _mm_mul_ps(mul0, _mm_set_ps1(2.0f));
	glm_vec4 const sub0 = _mm_sub_ps(I, mul1);
	return sub0;
}

 inline __m128 glm_vec4_refract(glm_vec4 I, glm_vec4 N, glm_vec4 eta)
{
	glm_vec4 const dot0 = glm_vec4_dot(N, I);
	glm_vec4 const mul0 = _mm_mul_ps(eta, eta);
	glm_vec4 const mul1 = _mm_mul_ps(dot0, dot0);
	glm_vec4 const sub0 = _mm_sub_ps(_mm_set_ps1(1.0f), mul0);
	glm_vec4 const sub1 = _mm_sub_ps(_mm_set_ps1(1.0f), mul1);
	glm_vec4 const mul2 = _mm_mul_ps(sub0, sub1);
	
	if(_mm_movemask_ps(_mm_cmplt_ss(mul2, _mm_set_ps1(0.0f))) == 0)
		return _mm_set_ps1(0.0f);

	glm_vec4 const sqt0 = _mm_sqrt_ps(mul2);
	glm_vec4 const mad0 = glm_vec4_fma(eta, dot0, sqt0);
	glm_vec4 const mul4 = _mm_mul_ps(mad0, N);
	glm_vec4 const mul5 = _mm_mul_ps(eta, I);
	glm_vec4 const sub2 = _mm_sub_ps(mul5, mul4);

	return sub2;
}

#line 125 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/geometric.h"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric_simd.inl"



namespace glm{
namespace detail
{
	template <precision P>
	struct compute_length<tvec4, float, P, true>
	{
		 inline static float call(tvec4<float, P> const & v)
		{
			return _mm_cvtss_f32(glm_vec4_length(v.data));
		}
	};

	template <precision P>
	struct compute_distance<tvec4, float, P, true>
	{
		 inline static float call(tvec4<float, P> const & p0, tvec4<float, P> const & p1)
		{
			return _mm_cvtss_f32(glm_vec4_distance(p0.data, p1.data));
		}
	};

	template <precision P>
	struct compute_dot<tvec4, float, P, true>
	{
		 inline static float call(tvec4<float, P> const& x, tvec4<float, P> const& y)
		{
			return _mm_cvtss_f32(glm_vec1_dot(x.data, y.data));
		}
	};

	template <precision P>
	struct compute_cross<float, P, true>
	{
		 inline static tvec3<float, P> call(tvec3<float, P> const & a, tvec3<float, P> const & b)
		{
			__m128 const set0 = _mm_set_ps(0.0f, a.z, a.y, a.x);
			__m128 const set1 = _mm_set_ps(0.0f, b.z, b.y, b.x);
			__m128 const xpd0 = glm_vec4_cross(set0, set1);

			tvec4<float, P> result(uninitialize);
			result.data = xpd0;
			return tvec3<float, P>(result);
		}
	};

	template <precision P>
	struct compute_normalize<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const & v)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_normalize(v.data);
			return result;
		}
	};

	template <precision P>
	struct compute_faceforward<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const& N, tvec4<float, P> const& I, tvec4<float, P> const& Nref)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_faceforward(N.data, I.data, Nref.data);
			return result;
		}
	};

	template <precision P>
	struct compute_reflect<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const& I, tvec4<float, P> const& N)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_reflect(I.data, N.data);
			return result;
		}
	};

	template <precision P>
	struct compute_refract<float, P, tvec4, true>
	{
		 inline static tvec4<float, P> call(tvec4<float, P> const& I, tvec4<float, P> const& N, float eta)
		{
			tvec4<float, P> result(uninitialize);
			result.data = glm_vec4_refract(I.data, N.data, _mm_set_ps1(eta));
			return result;
		}
	};
}
}

#line 100 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric_simd.inl"
#line 247 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric.inl"
#line 248 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_geometric.inl"
#line 114 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_geometric.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../geometric.hpp"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.inl"


namespace glm{
namespace detail
{
	template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_matrixCompMult
	{
		 inline static matType<T, P> call(matType<T, P> const& x, matType<T, P> const& y)
		{
			matType<T, P> result(uninitialize);
			for(length_t i = 0; i < result.length(); ++i)
				result[i] = x[i] * y[i];
			return result;
		}
	};

	template <template <class, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_transpose{};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat2x2, T, P, Aligned>
	{
		 inline static tmat2x2<T, P> call(tmat2x2<T, P> const & m)
		{
			tmat2x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat2x3, T, P, Aligned>
	{
		 inline static tmat3x2<T, P> call(tmat2x3<T, P> const & m)
		{
			tmat3x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat2x4, T, P, Aligned>
	{
		 inline static tmat4x2<T, P> call(tmat2x4<T, P> const & m)
		{
			tmat4x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat3x2, T, P, Aligned>
	{
		 inline static tmat2x3<T, P> call(tmat3x2<T, P> const & m)
		{
			tmat2x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat3x3, T, P, Aligned>
	{
		 inline static tmat3x3<T, P> call(tmat3x3<T, P> const & m)
		{
			tmat3x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];

			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];

			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat3x4, T, P, Aligned>
	{
		 inline static tmat4x3<T, P> call(tmat3x4<T, P> const & m)
		{
			tmat4x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			result[3][2] = m[2][3];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat4x2, T, P, Aligned>
	{
		 inline static tmat2x4<T, P> call(tmat4x2<T, P> const & m)
		{
			tmat2x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat4x3, T, P, Aligned>
	{
		 inline static tmat3x4<T, P> call(tmat4x3<T, P> const & m)
		{
			tmat3x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[2][3] = m[3][2];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat4x4, T, P, Aligned>
	{
		 inline static tmat4x4<T, P> call(tmat4x4<T, P> const & m)
		{
			tmat4x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];

			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];

			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[2][3] = m[3][2];

			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			result[3][2] = m[2][3];
			result[3][3] = m[3][3];
			return result;
		}
	};

	template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_determinant{};

	template <typename T, precision P, bool Aligned>
	struct compute_determinant<tmat2x2, T, P, Aligned>
	{
		 inline static T call(tmat2x2<T, P> const & m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_determinant<tmat3x3, T, P, Aligned>
	{
		 inline static T call(tmat3x3<T, P> const & m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_determinant<tmat4x4, T, P, Aligned>
	{
		 inline static T call(tmat4x4<T, P> const & m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

			tvec4<T, P> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};

	template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_inverse{};

	template <typename T, precision P, bool Aligned>
	struct compute_inverse<tmat2x2, T, P, Aligned>
	{
		 inline static tmat2x2<T, P> call(tmat2x2<T, P> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * m[1][1]
				- m[1][0] * m[0][1]);

			tmat2x2<T, P> Inverse(
				+ m[1][1] * OneOverDeterminant,
				- m[0][1] * OneOverDeterminant,
				- m[1][0] * OneOverDeterminant,
				+ m[0][0] * OneOverDeterminant);

			return Inverse;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_inverse<tmat3x3, T, P, Aligned>
	{
		 inline static tmat3x3<T, P> call(tmat3x3<T, P> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

			tmat3x3<T, P> Inverse(uninitialize);
			Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
			Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
			Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
			Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
			Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

			return Inverse;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_inverse<tmat4x4, T, P, Aligned>
	{
		 inline static tmat4x4<T, P> call(tmat4x4<T, P> const& m)
		{
			T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
			T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

			T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
			T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

			T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
			T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

			T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
			T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

			T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
			T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

			T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
			T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

			tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
			tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
			tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
			tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
			tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
			tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

			tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
			tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
			tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
			tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

			tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
			tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
			tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
			tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

			tvec4<T, P> SignA(+1, -1, +1, -1);
			tvec4<T, P> SignB(-1, +1, -1, +1);
			tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

			tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

			tvec4<T, P> Dot0(m[0] * Row0);
			T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

			T OneOverDeterminant = static_cast<T>(1) / Dot1;

			return Inverse * OneOverDeterminant;
		}
	};
}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs");
		return detail::compute_matrixCompMult<matType, T, P, detail::is_aligned<P>::value>::call(x, y);
	}

	template<typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
	 inline typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs");

		typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type m(uninitialize);
		for(length_t i = 0; i < m.length(); ++i)
			m[i] = c * r[i];
		return m;
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline typename matType<T, P>::transpose_type transpose(matType<T, P> const & m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs");
		return detail::compute_transpose<matType, T, P, detail::is_aligned<P>::value>::call(m);
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline T determinant(matType<T, P> const & m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs");
		return detail::compute_determinant<matType, T, P, detail::is_aligned<P>::value>::call(m);
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline matType<T, P> inverse(matType<T, P> const & m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
		return detail::compute_inverse<matType, T, P, detail::is_aligned<P>::value>::call(m);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix_simd.inl"







#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/matrix.h"



#pragma once





 inline void glm_mat4_matrixCompMult(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	out[0] = _mm_mul_ps(in1[0], in2[0]);
	out[1] = _mm_mul_ps(in1[1], in2[1]);
	out[2] = _mm_mul_ps(in1[2], in2[2]);
	out[3] = _mm_mul_ps(in1[3], in2[3]);
}

 inline void glm_mat4_add(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	out[0] = _mm_add_ps(in1[0], in2[0]);
	out[1] = _mm_add_ps(in1[1], in2[1]);
	out[2] = _mm_add_ps(in1[2], in2[2]);
	out[3] = _mm_add_ps(in1[3], in2[3]);
}

 inline void glm_mat4_sub(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	out[0] = _mm_sub_ps(in1[0], in2[0]);
	out[1] = _mm_sub_ps(in1[1], in2[1]);
	out[2] = _mm_sub_ps(in1[2], in2[2]);
	out[3] = _mm_sub_ps(in1[3], in2[3]);
}

 inline glm_vec4 glm_mat4_mul_vec4(glm_vec4 const m[4], glm_vec4 v)
{
	__m128 v0 = _mm_shuffle_ps(v, v, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 v1 = _mm_shuffle_ps(v, v, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 v2 = _mm_shuffle_ps(v, v, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 v3 = _mm_shuffle_ps(v, v, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

	__m128 m0 = _mm_mul_ps(m[0], v0);
	__m128 m1 = _mm_mul_ps(m[1], v1);
	__m128 m2 = _mm_mul_ps(m[2], v2);
	__m128 m3 = _mm_mul_ps(m[3], v3);

	__m128 a0 = _mm_add_ps(m0, m1);
	__m128 a1 = _mm_add_ps(m2, m3);
	__m128 a2 = _mm_add_ps(a0, a1);

	return a2;
}

 inline __m128 glm_vec4_mul_mat4(glm_vec4 v, glm_vec4 const m[4])
{
	__m128 i0 = m[0];
	__m128 i1 = m[1];
	__m128 i2 = m[2];
	__m128 i3 = m[3];

	__m128 m0 = _mm_mul_ps(v, i0);
	__m128 m1 = _mm_mul_ps(v, i1);
	__m128 m2 = _mm_mul_ps(v, i2);
	__m128 m3 = _mm_mul_ps(v, i3);

	__m128 u0 = _mm_unpacklo_ps(m0, m1);
	__m128 u1 = _mm_unpackhi_ps(m0, m1);
	__m128 a0 = _mm_add_ps(u0, u1);

	__m128 u2 = _mm_unpacklo_ps(m2, m3);
	__m128 u3 = _mm_unpackhi_ps(m2, m3);
	__m128 a1 = _mm_add_ps(u2, u3);

	__m128 f0 = _mm_movelh_ps(a0, a1);
	__m128 f1 = _mm_movehl_ps(a1, a0);
	__m128 f2 = _mm_add_ps(f0, f1);

	return f2;
}

 inline void glm_mat4_mul(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	{
		__m128 e0 = _mm_shuffle_ps(in2[0], in2[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[0], in2[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[0], in2[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[0], in2[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);

		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);

		out[0] = a2;
	}

	{
		__m128 e0 = _mm_shuffle_ps(in2[1], in2[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[1], in2[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[1], in2[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[1], in2[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);

		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);

		out[1] = a2;
	}

	{
		__m128 e0 = _mm_shuffle_ps(in2[2], in2[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[2], in2[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[2], in2[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[2], in2[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);

		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);

		out[2] = a2;
	}

	{
		
		__m128 e0 = _mm_shuffle_ps(in2[3], in2[3], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[3], in2[3], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[3], in2[3], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[3], in2[3], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);

		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);

		out[3] = a2;
	}
}

 inline void glm_mat4_transpose(glm_vec4 const in[4], glm_vec4 out[4])
{
	__m128 tmp0 = _mm_shuffle_ps(in[0], in[1], 0x44);
	__m128 tmp2 = _mm_shuffle_ps(in[0], in[1], 0xEE);
	__m128 tmp1 = _mm_shuffle_ps(in[2], in[3], 0x44);
	__m128 tmp3 = _mm_shuffle_ps(in[2], in[3], 0xEE);

	out[0] = _mm_shuffle_ps(tmp0, tmp1, 0x88);
	out[1] = _mm_shuffle_ps(tmp0, tmp1, 0xDD);
	out[2] = _mm_shuffle_ps(tmp2, tmp3, 0x88);
	out[3] = _mm_shuffle_ps(tmp2, tmp3, 0xDD);
}

 inline glm_vec4 glm_mat4_determinant_highp(glm_vec4 const in[4])
{
	__m128 Fac0;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac0 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac1;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac1 = _mm_sub_ps(Mul00, Mul01);
	}


	__m128 Fac2;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac2 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac3;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac3 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac4;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac4 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac5;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac5 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
	__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);

	
	
	
	
	__m128 Temp0 = _mm_shuffle_ps(in[1], in[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp1 = _mm_shuffle_ps(in[1], in[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp2 = _mm_shuffle_ps(in[1], in[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp3 = _mm_shuffle_ps(in[1], in[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	
	__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
	__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
	__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
	__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
	__m128 Add00 = _mm_add_ps(Sub00, Mul02);
	__m128 Inv0 = _mm_mul_ps(SignB, Add00);

	
	
	
	
	
	__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
	__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
	__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
	__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
	__m128 Add01 = _mm_add_ps(Sub01, Mul05);
	__m128 Inv1 = _mm_mul_ps(SignA, Add01);

	
	
	
	
	
	__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
	__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
	__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
	__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
	__m128 Add02 = _mm_add_ps(Sub02, Mul08);
	__m128 Inv2 = _mm_mul_ps(SignB, Add02);

	
	
	
	
	
	__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
	__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
	__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
	__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
	__m128 Add03 = _mm_add_ps(Sub03, Mul11);
	__m128 Inv3 = _mm_mul_ps(SignA, Add03);

	__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row2 = _mm_shuffle_ps(Row0, Row1, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Det0 = glm_vec4_dot(in[0], Row2);
	return Det0;
}

 inline glm_vec4 glm_mat4_determinant_lowp(glm_vec4 const m[4])
{
	

	
	
	
	
	
	

	
 	__m128 Swp2A = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[2]), (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2)))));
 	__m128 Swp3A = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[3]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3)))));
	__m128 MulA = _mm_mul_ps(Swp2A, Swp3A);

	
	__m128 Swp2B = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[2]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3)))));
	__m128 Swp3B = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[3]), (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2)))));
	__m128 MulB = _mm_mul_ps(Swp2B, Swp3B);

	
	__m128 SubE = _mm_sub_ps(MulA, MulB);

	
	__m128 Swp2C = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[2]), (((0) << 6) | ((0) << 4) | ((1) << 2) | ((2)))));
	__m128 Swp3C = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[3]), (((1) << 6) | ((2) << 4) | ((0) << 2) | ((0)))));
	__m128 MulC = _mm_mul_ps(Swp2C, Swp3C);
	__m128 SubF = _mm_sub_ps(_mm_movehl_ps(MulC, MulC), MulC);

	
	
	
	
	

	__m128 SubFacA = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubE), (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0)))));
	__m128 SwpFacA = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[1]), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((1)))));
	__m128 MulFacA = _mm_mul_ps(SwpFacA, SubFacA);

	__m128 SubTmpB = _mm_shuffle_ps(SubE, SubF, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((1))));
	__m128 SubFacB = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubTmpB), (((3) << 6) | ((1) << 4) | ((1) << 2) | ((0)))));
	__m128 SwpFacB = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[1]), (((1) << 6) | ((1) << 4) | ((2) << 2) | ((2)))));
	__m128 MulFacB = _mm_mul_ps(SwpFacB, SubFacB);

	__m128 SubRes = _mm_sub_ps(MulFacA, MulFacB);

	__m128 SubTmpC = _mm_shuffle_ps(SubE, SubF, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
	__m128 SubFacC = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubTmpC), (((3) << 6) | ((3) << 4) | ((2) << 2) | ((0)))));
	__m128 SwpFacC = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[1]), (((2) << 6) | ((3) << 4) | ((3) << 2) | ((3)))));
	__m128 MulFacC = _mm_mul_ps(SwpFacC, SubFacC);

	__m128 AddRes = _mm_add_ps(SubRes, MulFacC);
	__m128 DetCof = _mm_mul_ps(AddRes, _mm_setr_ps( 1.0f,-1.0f, 1.0f,-1.0f));

	
	
	
	

	return glm_vec4_dot(m[0], DetCof);
}

 inline glm_vec4 glm_mat4_determinant(glm_vec4 const m[4])
{
	

	
	
	
	
	
	

	
 	__m128 Swp2A = _mm_shuffle_ps(m[2], m[2], (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2))));
 	__m128 Swp3A = _mm_shuffle_ps(m[3], m[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3))));
	__m128 MulA = _mm_mul_ps(Swp2A, Swp3A);

	
	__m128 Swp2B = _mm_shuffle_ps(m[2], m[2], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3))));
	__m128 Swp3B = _mm_shuffle_ps(m[3], m[3], (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2))));
	__m128 MulB = _mm_mul_ps(Swp2B, Swp3B);

	
	__m128 SubE = _mm_sub_ps(MulA, MulB);

	
	__m128 Swp2C = _mm_shuffle_ps(m[2], m[2], (((0) << 6) | ((0) << 4) | ((1) << 2) | ((2))));
	__m128 Swp3C = _mm_shuffle_ps(m[3], m[3], (((1) << 6) | ((2) << 4) | ((0) << 2) | ((0))));
	__m128 MulC = _mm_mul_ps(Swp2C, Swp3C);
	__m128 SubF = _mm_sub_ps(_mm_movehl_ps(MulC, MulC), MulC);

	
	
	
	
	

	__m128 SubFacA = _mm_shuffle_ps(SubE, SubE, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
	__m128 SwpFacA = _mm_shuffle_ps(m[1], m[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((1))));
	__m128 MulFacA = _mm_mul_ps(SwpFacA, SubFacA);

	__m128 SubTmpB = _mm_shuffle_ps(SubE, SubF, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((1))));
	__m128 SubFacB = _mm_shuffle_ps(SubTmpB, SubTmpB, (((3) << 6) | ((1) << 4) | ((1) << 2) | ((0))));
	__m128 SwpFacB = _mm_shuffle_ps(m[1], m[1], (((1) << 6) | ((1) << 4) | ((2) << 2) | ((2))));
	__m128 MulFacB = _mm_mul_ps(SwpFacB, SubFacB);

	__m128 SubRes = _mm_sub_ps(MulFacA, MulFacB);

	__m128 SubTmpC = _mm_shuffle_ps(SubE, SubF, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
	__m128 SubFacC = _mm_shuffle_ps(SubTmpC, SubTmpC, (((3) << 6) | ((3) << 4) | ((2) << 2) | ((0))));
	__m128 SwpFacC = _mm_shuffle_ps(m[1], m[1], (((2) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 MulFacC = _mm_mul_ps(SwpFacC, SubFacC);

	__m128 AddRes = _mm_add_ps(SubRes, MulFacC);
	__m128 DetCof = _mm_mul_ps(AddRes, _mm_setr_ps( 1.0f,-1.0f, 1.0f,-1.0f));

	
	
	
	

	return glm_vec4_dot(m[0], DetCof);
}

 inline void glm_mat4_inverse(glm_vec4 const in[4], glm_vec4 out[4])
{
	__m128 Fac0;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac0 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac1;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac1 = _mm_sub_ps(Mul00, Mul01);
	}


	__m128 Fac2;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac2 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac3;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac3 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac4;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac4 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac5;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac5 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
	__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);

	
	
	
	
	__m128 Temp0 = _mm_shuffle_ps(in[1], in[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp1 = _mm_shuffle_ps(in[1], in[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp2 = _mm_shuffle_ps(in[1], in[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp3 = _mm_shuffle_ps(in[1], in[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	
	__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
	__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
	__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
	__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
	__m128 Add00 = _mm_add_ps(Sub00, Mul02);
	__m128 Inv0 = _mm_mul_ps(SignB, Add00);

	
	
	
	
	
	__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
	__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
	__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
	__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
	__m128 Add01 = _mm_add_ps(Sub01, Mul05);
	__m128 Inv1 = _mm_mul_ps(SignA, Add01);

	
	
	
	
	
	__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
	__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
	__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
	__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
	__m128 Add02 = _mm_add_ps(Sub02, Mul08);
	__m128 Inv2 = _mm_mul_ps(SignB, Add02);

	
	
	
	
	
	__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
	__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
	__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
	__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
	__m128 Add03 = _mm_add_ps(Sub03, Mul11);
	__m128 Inv3 = _mm_mul_ps(SignA, Add03);

	__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row2 = _mm_shuffle_ps(Row0, Row1, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Det0 = glm_vec4_dot(in[0], Row2);
	__m128 Rcp0 = _mm_div_ps(_mm_set_ps1(1.0f), Det0);
	

	
	out[0] = _mm_mul_ps(Inv0, Rcp0);
	out[1] = _mm_mul_ps(Inv1, Rcp0);
	out[2] = _mm_mul_ps(Inv2, Rcp0);
	out[3] = _mm_mul_ps(Inv3, Rcp0);
}

 inline void glm_mat4_inverse_lowp(glm_vec4 const in[4], glm_vec4 out[4])
{
	__m128 Fac0;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac0 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac1;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac1 = _mm_sub_ps(Mul00, Mul01);
	}


	__m128 Fac2;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac2 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac3;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac3 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac4;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac4 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 Fac5;
	{
		
		
		
		

		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));

		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));

		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac5 = _mm_sub_ps(Mul00, Mul01);
	}

	__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
	__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);

	
	
	
	
	__m128 Temp0 = _mm_shuffle_ps(in[1], in[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp1 = _mm_shuffle_ps(in[1], in[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp2 = _mm_shuffle_ps(in[1], in[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Temp3 = _mm_shuffle_ps(in[1], in[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	
	__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
	__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
	__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
	__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
	__m128 Add00 = _mm_add_ps(Sub00, Mul02);
	__m128 Inv0 = _mm_mul_ps(SignB, Add00);

	
	
	
	
	
	__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
	__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
	__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
	__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
	__m128 Add01 = _mm_add_ps(Sub01, Mul05);
	__m128 Inv1 = _mm_mul_ps(SignA, Add01);

	
	
	
	
	
	__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
	__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
	__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
	__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
	__m128 Add02 = _mm_add_ps(Sub02, Mul08);
	__m128 Inv2 = _mm_mul_ps(SignB, Add02);

	
	
	
	
	
	__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
	__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
	__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
	__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
	__m128 Add03 = _mm_add_ps(Sub03, Mul11);
	__m128 Inv3 = _mm_mul_ps(SignA, Add03);

	__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row2 = _mm_shuffle_ps(Row0, Row1, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));

	
	
	
	
	__m128 Det0 = glm_vec4_dot(in[0], Row2);
	__m128 Rcp0 = _mm_rcp_ps(Det0);
	
	
	out[0] = _mm_mul_ps(Inv0, Rcp0);
	out[1] = _mm_mul_ps(Inv1, Rcp0);
	out[2] = _mm_mul_ps(Inv2, Rcp0);
	out[3] = _mm_mul_ps(Inv3, Rcp0);
}







































































 inline void glm_mat4_outerProduct(__m128 const & c, __m128 const & r, __m128 out[4])
{
	out[0] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0)))));
	out[1] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1)))));
	out[2] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2)))));
	out[3] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3)))));
}

#line 1029 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/matrix.h"

#line 9 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix_simd.inl"

namespace glm{
namespace detail
{
	template <precision P>
	struct compute_matrixCompMult<tmat4x4, float, P, true>
	{
		static_assert(detail::is_aligned<P>::value, "Specialization requires aligned");

		 inline static tmat4x4<float, P> call(tmat4x4<float, P> const & x, tmat4x4<float, P> const & y)
		{
			tmat4x4<float, P> result(uninitialize);
			glm_mat4_matrixCompMult(
				*(glm_vec4 const (*)[4])&x[0].data,
				*(glm_vec4 const (*)[4])&y[0].data,
				*(glm_vec4(*)[4])&result[0].data);
			return result;
		}
	};

	template <precision P>
	struct compute_transpose<tmat4x4, float, P, true>
	{
		 inline static tmat4x4<float, P> call(tmat4x4<float, P> const & m)
		{
			tmat4x4<float, P> result(uninitialize);
			glm_mat4_transpose(
				*(glm_vec4 const (*)[4])&m[0].data,
				*(glm_vec4(*)[4])&result[0].data);
			return result;
		}
	};

	template <precision P>
	struct compute_determinant<tmat4x4, float, P, true>
	{
		 inline static float call(tmat4x4<float, P> const& m)
		{
			return _mm_cvtss_f32(glm_mat4_determinant(*reinterpret_cast<__m128 const(*)[4]>(&m[0].data)));
		}
	};

	template <precision P>
	struct compute_inverse<tmat4x4, float, P, true>
	{
		 inline static tmat4x4<float, P> call(tmat4x4<float, P> const& m)
		{
			tmat4x4<float, P> Result(uninitialize);
			glm_mat4_inverse(*reinterpret_cast<__m128 const(*)[4]>(&m[0].data), *reinterpret_cast<__m128(*)[4]>(&Result[0].data));
			return Result;
		}
	};
}

	template<>
	 inline tmat4x4<float, aligned_lowp> outerProduct<float, aligned_lowp, tvec4, tvec4>(tvec4<float, aligned_lowp> const & c, tvec4<float, aligned_lowp> const & r)
	{
		tmat4x4<float, aligned_lowp> m(uninitialize);
		glm_mat4_outerProduct(c.data, r.data, *reinterpret_cast<__m128(*)[4]>(&m[0].data));
		return m;
	}

	template<>
	 inline tmat4x4<float, aligned_mediump> outerProduct<float, aligned_mediump, tvec4, tvec4>(tvec4<float, aligned_mediump> const & c, tvec4<float, aligned_mediump> const & r)
	{
		tmat4x4<float, aligned_mediump> m(uninitialize);
		glm_mat4_outerProduct(c.data, r.data, *reinterpret_cast<__m128(*)[4]>(&m[0].data));
		return m;
	}

	template<>
	 inline tmat4x4<float, aligned_highp> outerProduct<float, aligned_highp, tvec4, tvec4>(tvec4<float, aligned_highp> const & c, tvec4<float, aligned_highp> const & r)
	{
		tmat4x4<float, aligned_highp> m(uninitialize);
		glm_mat4_outerProduct(c.data, r.data, *reinterpret_cast<__m128(*)[4]>(&m[0].data));
		return m;
	}
}

#line 89 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix_simd.inl"
#line 400 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.inl"
#line 401 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.inl"

#line 150 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_matrix.hpp"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl"

namespace glm
{
	


		template <typename T, precision P>
		 inline tmat2x2<T, P>::tmat2x2()
		{

				this->value[0] = col_type(1, 0);
				this->value[1] = col_type(0, 1);
#line 18 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl"
		}
#line 20 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl"








#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x2<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	 inline  tmat2x2<T, P>::tmat2x2(ctor)
	{}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2
	(
		T const & x0, T const & y0,
		T const & x1, T const & y1
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(col_type const & v0, col_type const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	

	template <typename T, precision P>
	template <typename X1, typename Y1, typename X2, typename Y2>
	 inline tmat2x2<T, P>::tmat2x2
	(
		X1 const & x1, Y1 const & y1,
		X2 const & x2, Y2 const & y2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 inline tmat2x2<T, P>::tmat2x2(tvec2<V1, P> const & v1, tvec2<V2, P> const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x2<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x2<T, P>::tmat2x2(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat3x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat4x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::col_type & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl", (unsigned)(160)), 0) );
		return this->value[i];
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::col_type const & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl", (unsigned)(167)), 0) );
		return this->value[i];
	}

	









#line 182 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_mat2x2.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(U scalar)
	{
		this->value[0] += scalar;
		this->value[1] += scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(tmat2x2<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(U scalar)
	{
		this->value[0] -= scalar;
		this->value[1] -= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(tmat2x2<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(U scalar)
	{
		this->value[0] *= scalar;
		this->value[1] *= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(tmat2x2<U, P> const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(U scalar)
	{
		this->value[0] /= scalar;
		this->value[1] /= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(tmat2x2<U, P> const & m)
	{
		return *this *= inverse(m);
	}

	

	template <typename T, precision P>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
	{
		tmat2x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
	{
		tmat2x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			-m[0], 
			-m[1]);
	}

	

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			scalar - m[0],
			scalar - m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::col_type operator*
	(
		tmat2x2<T, P> const & m,
		typename tmat2x2<T, P>::row_type const & v
	)
	{
		return tvec2<T, P>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::row_type operator*
	(
		typename tmat2x2<T, P>::col_type const & v,
		tmat2x2<T, P> const & m
	)
	{
		return tvec2<T, P>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template <typename T, precision P> 
	 inline tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template <typename T, precision P> 
	 inline tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			scalar / m[0],
			scalar / m[1]);
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v)
	{
		return inverse(m) * v;
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m)
	{
		return v *  inverse(m);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{	
		tmat2x2<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template <typename T, precision P>
	 inline bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 183 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x2.hpp"
#line 184 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/type_mat2x2.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\mat2x2.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2x2;

}
#line 72 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"









#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\trigonometric.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_trigonometric.hpp"














#pragma once




namespace glm
{
	
	

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 constexpr vecType<T, P> radians(vecType<T, P> const & degrees);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 constexpr vecType<T, P> degrees(vecType<T, P> const & radians);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sin(vecType<T, P> const & angle);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> cos(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> tan(vecType<T, P> const & angle); 

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> asin(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> acos(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atan(vecType<T, P> const & y, vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atan(vecType<T, P> const & y_over_x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sinh(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> cosh(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> tanh(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> asinh(vecType<T, P> const & x);
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> acosh(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atanh(vecType<T, P> const & x);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric.inl"







namespace glm
{
	
	template <typename genType>
	 inline constexpr genType radians(genType degrees)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'radians' only accept floating-point input");

		return degrees * static_cast<genType>(0.01745329251994329576923690768489);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline constexpr vecType<T, P> radians(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(radians, v);
	}
	
	
	template <typename genType>
	 inline constexpr genType degrees(genType radians)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'degrees' only accept floating-point input");

		return radians * static_cast<genType>(57.295779513082320876798154814105);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline constexpr vecType<T, P> degrees(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(degrees, v);
	}

	
	using ::std::sin;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sin(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(sin, v);
	}

	
	using std::cos;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> cos(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(cos, v);
	}

	
	using std::tan;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> tan(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(tan, v);
	}

	
	using std::asin;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> asin(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(asin, v);
	}

	
	using std::acos;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> acos(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(acos, v);
	}

	
	template <typename genType>
	 inline genType atan(genType y, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");

		return ::std::atan2(y, x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> atan(vecType<T, P> const & a, vecType<T, P> const & b)
	{
		return detail::functor2<T, P, vecType>::call(::std::atan2, a, b);
	}

	using std::atan;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> atan(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(atan, v);
	}

	
	using std::sinh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sinh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(sinh, v);
	}

	
	using std::cosh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> cosh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(cosh, v);
	}

	
	using std::tanh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> tanh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(tanh, v);
	}

	

		using std::asinh;








#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> asinh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(asinh, v);
	}

	

		using std::acosh;










#line 168 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> acosh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(acosh, v);
	}

	

		using std::atanh;










#line 189 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> atanh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(atanh, v);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric_simd.inl"
#line 199 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric.inl"
#line 200 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_trigonometric.inl"

#line 177 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_trigonometric.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\trigonometric.hpp"
#line 82 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\exponential.hpp"



#pragma once


#line 83 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\common.hpp"



#pragma once


#line 84 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\packing.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_packing.hpp"











#pragma once




namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	 uint packUnorm2x16(vec2 const & v);

	
	
	
	
	
	
	
	
	
	
	
	 uint packSnorm2x16(vec2 const & v);

	
	
	
	
	
	
	
	
	
	
	
	 uint packUnorm4x8(vec4 const & v);

	
	
	
	
	
	
	
	
	
	
	
	 uint packSnorm4x8(vec4 const & v);

	
	
	
	
	
	
	
	
	
	
	
	 vec2 unpackUnorm2x16(uint p);

	
	
	
	
	
	
	
	
	
	
	
	 vec2 unpackSnorm2x16(uint p);

	
	
	
	
	
	
	
	
	
	
	
	 vec4 unpackUnorm4x8(uint p);

	
	
	
	
	
	
	
	
	
	
	
	 vec4 unpackSnorm4x8(uint p);

	
	
	
	
	
	
	
	
	 double packDouble2x32(uvec2 const & v);

	
	
	
	
	
	
	
	 uvec2 unpackDouble2x32(double v);

	
	
	
	
	
	
	
	
	 uint packHalf2x16(vec2 const & v);
	
	
	
	
	
	
	
	
	
	 vec2 unpackHalf2x16(uint v);
	
	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_packing.inl"




#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_half.hpp"



#pragma once



namespace glm{
namespace detail
{
	typedef short hdata;

	 float toFloat32(hdata value);
	 hdata toFloat16(float const & value);

}
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_half.inl"



namespace glm{
namespace detail
{
	 inline float overflow()
	{
		volatile float f = 1e10;

		for(int i = 0; i < 10; ++i)	
			f *= f; 
		return f;
	}

	union uif32
	{
		 inline uif32() :
			i(0)
		{}

		 inline uif32(float f_) :
			f(f_)
		{}

		 inline uif32(uint32 i_) :
			i(i_)
		{}

		float f;
		uint32 i;
	};

	 inline float toFloat32(hdata value)
	{
		int s = (value >> 15) & 0x00000001;
		int e = (value >> 10) & 0x0000001f;
		int m =  value        & 0x000003ff;

		if(e == 0)
		{
			if(m == 0)
			{
				
				
				

				detail::uif32 result;
				result.i = (unsigned int)(s << 31);
				return result.f;
			}
			else
			{
				
				
				

				while(!(m & 0x00000400))
				{
					m <<= 1;
					e -=  1;
				}

				e += 1;
				m &= ~0x00000400;
			}
		}
		else if(e == 31)
		{
			if(m == 0)
			{
				
				
				

				uif32 result;
				result.i = (unsigned int)((s << 31) | 0x7f800000);
				return result.f;
			}
			else
			{
				
				
				

				uif32 result;
				result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
				return result.f;
			}
		}

		
		
		

		e = e + (127 - 15);
		m = m << 13;

		
		
		

		uif32 Result;
		Result.i = (unsigned int)((s << 31) | (e << 23) | m);
		return Result.f;
	}

	 inline hdata toFloat16(float const & f)
	{
		uif32 Entry;
		Entry.f = f;
		int i = (int)Entry.i;

		
		
		
		
		
		
		
		
		

		int s =  (i >> 16) & 0x00008000;
		int e = ((i >> 23) & 0x000000ff) - (127 - 15);
		int m =   i        & 0x007fffff;

		
		
		

		if(e <= 0)
		{
			if(e < -10)
			{
				
				
				
				
				
				
				

				return hdata(s);
			}

			
			
			
			
			
			

			m = (m | 0x00800000) >> (1 - e);

			
			
			
			
			
			
			
			

			if(m & 0x00001000) 
				m += 0x00002000;

			
			
			

			return hdata(s | (m >> 13));
		}
		else if(e == 0xff - (127 - 15))
		{
			if(m == 0)
			{
				
				
				
				

				return hdata(s | 0x7c00);
			}
			else
			{
				
				
				
				
				
				
				
				

				m >>= 13;

				return hdata(s | 0x7c00 | m | (m == 0));
			}
		}
		else
		{
			
			
			
			

			
			
			

			if(m &  0x00001000)
			{
				m += 0x00002000;

				if(m & 0x00800000)
				{
					m =  0;     
					e += 1;     
				}
			}

			
			
			

			if (e > 30)
			{
				overflow();        

				return hdata(s | 0x7c00);
				
			}   

			
			
			

			return hdata(s | (e << 10) | (m >> 13));
		}
	}

}
}
#line 20 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\type_half.hpp"
#line 6 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_packing.inl"


namespace glm
{
	 inline uint packUnorm2x16(vec2 const & v)
	{
		union
		{
			u16  in[2];
			uint out;
		} u;

		u16vec2 result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	 inline vec2 unpackUnorm2x16(uint p)
	{
		union
		{
			uint in;
			u16  out[2];
		} u;

		u.in = p;

		return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
	}

	 inline uint packSnorm2x16(vec2 const & v)
	{
		union
		{
			i16  in[2];
			uint out;
		} u;

		i16vec2 result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	 inline vec2 unpackSnorm2x16(uint p)
	{
		union
		{
			uint in;
			i16  out[2];
		} u;

		u.in = p;

		return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
	}

	 inline uint packUnorm4x8(vec4 const & v)
	{
		union
		{
			u8   in[4];
			uint out;
		} u;

		u8vec4 result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}

	 inline vec4 unpackUnorm4x8(uint p)
	{
		union
		{
			uint in;
			u8   out[4];
		} u;

		u.in = p;

		return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
	}
	
	 inline uint packSnorm4x8(vec4 const & v)
	{
		union
		{
			i8   in[4];
			uint out;
		} u;

		i8vec4 result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}
	
	 inline glm::vec4 unpackSnorm4x8(uint p)
	{
		union
		{
			uint in;
			i8   out[4];
		} u;

		u.in = p;

		return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
	}

	 inline double packDouble2x32(uvec2 const & v)
	{
		union
		{
			uint   in[2];
			double out;
		} u;

		u.in[0] = v[0];
		u.in[1] = v[1];

		return u.out;
	}

	 inline uvec2 unpackDouble2x32(double v)
	{
		union
		{
			double in;
			uint   out[2];
		} u;

		u.in = v;

		return uvec2(u.out[0], u.out[1]);
	}

	 inline uint packHalf2x16(vec2 const & v)
	{
		union
		{
			i16  in[2];
			uint out;
		} u;

		u.in[0] = detail::toFloat16(v.x);
		u.in[1] = detail::toFloat16(v.y);

		return u.out;
	}

	 inline vec2 unpackHalf2x16(uint v)
	{
		union
		{
			uint in;
			i16  out[2];
		} u;

		u.in = v;

		return vec2(
			detail::toFloat32(u.out[0]),
			detail::toFloat32(u.out[1]));
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_packing_simd.inl"



namespace glm{
namespace detail
{

}
}
#line 189 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_packing.inl"
#line 190 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_packing.inl"

#line 169 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_packing.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\packing.hpp"
#line 85 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\matrix.hpp"



#pragma once


#line 87 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\vector_relational.hpp"



#pragma once


#line 88 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\integer.hpp"



#pragma once

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_integer.hpp"












#pragma once






namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 vecType<uint, P> uaddCarry(
		vecType<uint, P> const & x,
		vecType<uint, P> const & y,
		vecType<uint, P> & carry);

	
	
	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 vecType<uint, P> usubBorrow(
		vecType<uint, P> const & x,
		vecType<uint, P> const & y,
		vecType<uint, P> & borrow);

	
	
	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 void umulExtended(
		vecType<uint, P> const & x,
		vecType<uint, P> const & y,
		vecType<uint, P> & msb,
		vecType<uint, P> & lsb);
		
	
	
	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 void imulExtended(
		vecType<int, P> const & x,
		vecType<int, P> const & y,
		vecType<int, P> & msb,
		vecType<int, P> & lsb);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldExtract(
		vecType<T, P> const & Value,
		int Offset,
		int Bits);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldInsert(
		vecType<T, P> const & Base,
		vecType<T, P> const & Insert,
		int Offset,
		int Bits);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldReverse(vecType<T, P> const & v);

	
	
	
	
	
	
	template <typename genType>
	 int bitCount(genType v);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> bitCount(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	template <typename genIUType>
	 int findLSB(genIUType x);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> findLSB(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	
	template <typename genIUType>
	 int findMSB(genIUType x);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> findMSB(vecType<T, P> const & v);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"










#pragma intrinsic(_BitScanReverse)
#line 13 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"









#line 23 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"

namespace glm{
namespace detail
{
	template <typename T>
	 inline T mask(T Bits)
	{
		return Bits >= sizeof(T) * 8 ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
	}

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
	struct compute_bitfieldReverseStep
	{
		 inline static vecType<T, P> call(vecType<T, P> const & v, T, T)
		{
			return v;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
	struct compute_bitfieldReverseStep<T, P, vecType, Aligned, true>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
		{
			return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
	struct compute_bitfieldBitCountStep
	{
		 inline static vecType<T, P> call(vecType<T, P> const & v, T, T)
		{
			return v;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
	struct compute_bitfieldBitCountStep<T, P, vecType, Aligned, true>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
		{
			return (v & Mask) + ((v >> Shift) & Mask);
		}
	};

	template <typename genIUType, size_t Bits>
	struct compute_findLSB
	{
		 inline static int call(genIUType Value)
		{
			if(Value == 0)
				return -1;

			return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
		}
	};


		template <typename genIUType>
		struct compute_findLSB<genIUType, 32>
		{
			 inline static int call(genIUType Value)
			{
				unsigned long Result(0);
				unsigned char IsNotNull = _BitScanForward(&Result, *reinterpret_cast<unsigned long*>(&Value));
				return IsNotNull ? int(Result) : -1;
			}
		};


		template <typename genIUType>
		struct compute_findLSB<genIUType, 64>
		{
			 inline static int call(genIUType Value)
			{
				unsigned long Result(0);
				unsigned char IsNotNull = _BitScanForward64(&Result, *reinterpret_cast<unsigned __int64*>(&Value));
				return IsNotNull ? int(Result) : -1;
			}
		};
#line 105 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"
#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"

	template <typename T, glm::precision P, template <class, glm::precision> class vecType, bool EXEC = true>
	struct compute_findMSB_step_vec
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, T Shift)
		{
			return x | (x >> Shift);
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
	struct compute_findMSB_step_vec<T, P, vecType, false>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, T)
		{
			return x;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, int>
	struct compute_findMSB_vec
	{
		 inline static vecType<int, P> call(vecType<T, P> const & vec)
		{
			vecType<T, P> x(vec);
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 1));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 2));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 4));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
			return vecType<int, P>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
		}
	};


		template <typename genIUType>
		 inline int compute_findMSB_32(genIUType Value)
		{
			unsigned long Result(0);
			unsigned char IsNotNull = _BitScanReverse(&Result, *reinterpret_cast<unsigned long*>(&Value));
			return IsNotNull ? int(Result) : -1;
		}

		template <typename T, glm::precision P, template<typename, glm::precision> class vecType>
		struct compute_findMSB_vec<T, P, vecType, 32>
		{
			 inline static vecType<int, P> call(vecType<T, P> const & x)
			{
				return detail::functor1<int, T, P, vecType>::call(compute_findMSB_32, x);
			}
		};


		template <typename genIUType>
		 inline int compute_findMSB_64(genIUType Value)
		{
			unsigned long Result(0);
			unsigned char IsNotNull = _BitScanReverse64(&Result, *reinterpret_cast<unsigned __int64*>(&Value));
			return IsNotNull ? int(Result) : -1;
		}

		template <typename T, glm::precision P, template <class, glm::precision> class vecType>
		struct compute_findMSB_vec<T, P, vecType, 64>
		{
			 inline static vecType<int, P> call(vecType<T, P> const & x)
			{
				return detail::functor1<int, T, P, vecType>::call(compute_findMSB_64, x);
			}
		};
#line 177 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"
#line 178 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"
}

	
	 inline uint uaddCarry(uint const & x, uint const & y, uint & Carry)
	{
		uint64 const Value64(static_cast<uint64>(x) + static_cast<uint64>(y));
		uint64 const Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
		Carry = Value64 > Max32 ? 1u : 0u;
		return static_cast<uint32>(Value64 % (Max32 + static_cast<uint64>(1)));
	}

	template <precision P, template <typename, precision> class vecType>
	 inline vecType<uint, P> uaddCarry(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Carry)
	{
		vecType<uint64, P> Value64(vecType<uint64, P>(x) + vecType<uint64, P>(y));
		vecType<uint64, P> Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
		Carry = mix(vecType<uint32, P>(0), vecType<uint32, P>(1), greaterThan(Value64, Max32));
		return vecType<uint32,P>(Value64 % (Max32 + static_cast<uint64>(1)));
	}

	
	 inline uint usubBorrow(uint const & x, uint const & y, uint & Borrow)
	{
		static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

		Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
		if(y >= x)
			return y - x;
		else
			return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + (static_cast<int64>(y) - static_cast<int64>(x)));
	}

	template <precision P, template <typename, precision> class vecType>
	 inline vecType<uint, P> usubBorrow(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Borrow)
	{
		Borrow = mix(vecType<uint, P>(1), vecType<uint, P>(0), greaterThanEqual(x, y));
		vecType<uint, P> const YgeX(y - x);
		vecType<uint, P> const XgeY(vecType<uint32, P>((static_cast<int64>(1) << static_cast<int64>(32)) + (vecType<int64, P>(y) - vecType<int64, P>(x))));
		return mix(XgeY, YgeX, greaterThanEqual(y, x));
	}

	
	 inline void umulExtended(uint const & x, uint const & y, uint & msb, uint & lsb)
	{
		static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

		uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
		msb = static_cast<uint>(Value64 >> static_cast<uint64>(32));
		lsb = static_cast<uint>(Value64);
	}

	template <precision P, template <typename, precision> class vecType>
	 inline void umulExtended(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & msb, vecType<uint, P> & lsb)
	{
		static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

		vecType<uint64, P> Value64(vecType<uint64, P>(x) * vecType<uint64, P>(y));
		msb = vecType<uint32, P>(Value64 >> static_cast<uint64>(32));
		lsb = vecType<uint32, P>(Value64);
	}

	
	 inline void imulExtended(int x, int y, int & msb, int & lsb)
	{
		static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");

		int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
		msb = static_cast<int>(Value64 >> static_cast<int64>(32));
		lsb = static_cast<int>(Value64);
	}

	template <precision P, template <typename, precision> class vecType>
	 inline void imulExtended(vecType<int, P> const & x, vecType<int, P> const & y, vecType<int, P> & msb, vecType<int, P> & lsb)
	{
		static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");

		vecType<int64, P> Value64(vecType<int64, P>(x) * vecType<int64, P>(y));
		lsb = vecType<int32, P>(Value64 & static_cast<int64>(0xFFFFFFFF));
		msb = vecType<int32, P>((Value64 >> static_cast<int64>(32)) & static_cast<int64>(0xFFFFFFFF));
	}

	
	template <typename genIUType>
	 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
	{
		return bitfieldExtract(tvec1<genIUType>(Value), Offset, Bits).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> bitfieldExtract(vecType<T, P> const & Value, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

		return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
	}

	
	template <typename genIUType>
	 inline genIUType bitfieldInsert(genIUType const & Base, genIUType const & Insert, int Offset, int Bits)
	{
		return bitfieldInsert(tvec1<genIUType>(Base), tvec1<genIUType>(Insert), Offset, Bits).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> bitfieldInsert(vecType<T, P> const & Base, vecType<T, P> const & Insert, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

		T const Mask = static_cast<T>(detail::mask(Bits) << Offset);
		return (Base & ~Mask) | (Insert & Mask);
	}

	
	template <typename genType>
	 inline genType bitfieldReverse(genType x)
	{
		return bitfieldReverse(glm::tvec1<genType, glm::defaultp>(x)).x;
	}

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
	 inline vecType<T, P> bitfieldReverse(vecType<T, P> const & v)
	{
		vecType<T, P> x(v);
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  2>::call(x, T(0x5555555555555555ull), static_cast<T>( 1));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  4>::call(x, T(0x3333333333333333ull), static_cast<T>( 2));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  8>::call(x, T(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, T(0x00FF00FF00FF00FFull), static_cast<T>( 8));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, T(0x0000FFFF0000FFFFull), static_cast<T>(16));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, T(0x00000000FFFFFFFFull), static_cast<T>(32));
		return x;
	}

	
	template <typename genType>
	 inline int bitCount(genType x)
	{
		return bitCount(glm::tvec1<genType, glm::defaultp>(x)).x;
	}

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
	 inline vecType<int, P> bitCount(vecType<T, P> const & v)
	{
		vecType<typename detail::make_unsigned<T>::type, P> x(*reinterpret_cast<vecType<typename detail::make_unsigned<T>::type, P> const *>(&v));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
		return vecType<int, P>(x);
	}

	
	template <typename genIUType>
	 inline int findLSB(genIUType Value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

		return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<int, P> findLSB(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

		return detail::functor1<int, T, P, vecType>::call(findLSB, x);
	}

	
	template <typename genIUType>
	 inline int findMSB(genIUType x)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

		return findMSB(tvec1<genIUType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<int, P> findMSB(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

		return detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(x);
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer_simd.inl"



#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/integer.h"



#pragma once



 inline glm_uvec4 glm_i128_interleave(glm_uvec4 x)
{
	glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
	glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
	glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
	glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
	glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);

	glm_uvec4 Reg1;
	glm_uvec4 Reg2;

	
	
	
	Reg1 = x;

	
	
	Reg2 = _mm_slli_si128(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask4);

	
	
	Reg2 = _mm_slli_si128(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask3);

	
	
	Reg2 = _mm_slli_epi32(Reg1, 4);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask2);

	
	
	Reg2 = _mm_slli_epi32(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask1);

	
	
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask0);

	
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg2 = _mm_srli_si128(Reg2, 8);
	Reg1 = _mm_or_si128(Reg1, Reg2);
	
	return Reg1;
}

 inline glm_uvec4 glm_i128_interleave2(glm_uvec4 x, glm_uvec4 y)
{
	glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
	glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
	glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
	glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
	glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);

	glm_uvec4 Reg1;
	glm_uvec4 Reg2;

	
	
	Reg1 = _mm_unpacklo_epi64(x, y);

	
	
	Reg2 = _mm_slli_si128(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask4);

	
	
	Reg2 = _mm_slli_si128(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask3);

	
	
	Reg2 = _mm_slli_epi32(Reg1, 4);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask2);

	
	
	Reg2 = _mm_slli_epi32(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask1);

	
	
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask0);

	
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg2 = _mm_srli_si128(Reg2, 8);
	Reg1 = _mm_or_si128(Reg1, Reg2);
	
	return Reg1;
}

#line 116 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\../simd/integer.h"
#line 5 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer_simd.inl"



namespace glm{
namespace detail
{
	template <glm::precision P>
	struct compute_bitfieldReverseStep<uint32, P, tvec4, true, true>
	{
		 inline static tvec4<uint32, P> call(tvec4<uint32, P> const & v, uint32 Mask, uint32 Shift)
		{
			__m128i const set0 = v.data;

			__m128i const set1 = _mm_set1_epi32(Mask);
			__m128i const and1 = _mm_and_si128(set0, set1);
			__m128i const sft1 = _mm_slli_epi32(and1, Shift);

			__m128i const set2 = _mm_andnot_si128(set0, _mm_set1_epi32(-1));
			__m128i const and2 = _mm_and_si128(set0, set2);
			__m128i const sft2 = _mm_srai_epi32(and2, Shift);
		
			__m128i const or0 = _mm_or_si128(sft1, sft2);
		
			return or0;
		}
	};

	template <glm::precision P>
	struct compute_bitfieldBitCountStep<uint32, P, tvec4, true, true>
	{
		 inline static tvec4<uint32, P> call(tvec4<uint32, P> const & v, uint32 Mask, uint32 Shift)
		{
			__m128i const set0 = v.data;

			__m128i const set1 = _mm_set1_epi32(Mask);
			__m128i const and0 = _mm_and_si128(set0, set1);
			__m128i const sft0 = _mm_slli_epi32(set0, Shift);
			__m128i const and1 = _mm_and_si128(sft0, set1);
			__m128i const add0 = _mm_add_epi32(and0, and1);
		
			return add0;
		}
	};
}















#line 65 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer_simd.inl"

}

#line 69 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer_simd.inl"
#line 367 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"
#line 368 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail\\func_integer.inl"

#line 204 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\detail/func_integer.hpp"
#line 7 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\integer.hpp"
#line 89 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/glm.hpp"
#line 18 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"
#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/type_ptr.hpp"

































#pragma once


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"














#pragma once






#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/constants.hpp"













#pragma once






#line 22 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/constants.hpp"

namespace glm
{
	
	

	
	
	template <typename genType>
	 constexpr genType epsilon();

	
	
	template <typename genType>
	 constexpr genType zero();

	
	
	template <typename genType>
	 constexpr genType one();

	
	
	template <typename genType>
	 constexpr genType pi();

	
	
	template <typename genType>
	 constexpr genType two_pi();

	
	
	template <typename genType>
	 constexpr genType root_pi();

	
	
	template <typename genType>
	 constexpr genType half_pi();

	
	
	template <typename genType>
	 constexpr genType three_over_two_pi();

	
	
	template <typename genType>
	 constexpr genType quarter_pi();

	
	
	template <typename genType>
	 constexpr genType one_over_pi();

	
	
	template <typename genType>
	 constexpr genType one_over_two_pi();

	
	
	template <typename genType>
	 constexpr genType two_over_pi();

	
	
	template <typename genType>
	 constexpr genType four_over_pi();

	
	
	template <typename genType>
	 constexpr genType two_over_root_pi();

	
	
	template <typename genType>
	 constexpr genType one_over_root_two();

	
	
	template <typename genType>
	 constexpr genType root_half_pi();

	
	
	template <typename genType>
	 constexpr genType root_two_pi();

	
	
	template <typename genType>
	 constexpr genType root_ln_four();

	
	
	template <typename genType>
	 constexpr genType e();

	
	
	template <typename genType>
	 constexpr genType euler();

	
	
	template <typename genType>
	 constexpr genType root_two();

	
	
	template <typename genType>
	 constexpr genType root_three();

	
	
	template <typename genType>
	 constexpr genType root_five();

	
	
	template <typename genType>
	 constexpr genType ln_two();

	
	
	template <typename genType>
	 constexpr genType ln_ten();

	
	
	template <typename genType>
	 constexpr genType ln_ln_two();

	
	
	template <typename genType>
	 constexpr genType third();

	
	
	template <typename genType>
	 constexpr genType two_thirds();

	
	
	template <typename genType>
	 constexpr genType golden_ratio();

	
} 

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\constants.inl"





namespace glm
{
	template <typename genType>
	 inline constexpr genType epsilon()
	{
		return std::numeric_limits<genType>::epsilon();
	}

	template <typename genType>
	 inline constexpr genType zero()
	{
		return genType(0);
	}

	template <typename genType>
	 inline constexpr genType one()
	{
		return genType(1);
	}

	template <typename genType>
	 inline constexpr genType pi()
	{
		return genType(3.14159265358979323846264338327950288);
	}

	template <typename genType>
	 inline constexpr genType two_pi()
	{
		return genType(6.28318530717958647692528676655900576);
	}

	template <typename genType>
	 inline constexpr genType root_pi()
	{
		return genType(1.772453850905516027);
	}

	template <typename genType>
	 inline constexpr genType half_pi()
	{
		return genType(1.57079632679489661923132169163975144);
	}

	template <typename genType>
	 inline constexpr genType three_over_two_pi()
	{
		return genType(4.71238898038468985769396507491925432);           
	}

	template <typename genType>
	 inline constexpr genType quarter_pi()
	{
		return genType(0.785398163397448309615660845819875721);
	}

	template <typename genType>
	 inline constexpr genType one_over_pi()
	{
		return genType(0.318309886183790671537767526745028724);
	}

	template <typename genType>
	 inline constexpr genType one_over_two_pi()
	{
		return genType(0.159154943091895335768883763372514362);
	}

	template <typename genType>
	 inline constexpr genType two_over_pi()
	{
		return genType(0.636619772367581343075535053490057448);
	}

	template <typename genType>
	 inline constexpr genType four_over_pi()
	{
		return genType(1.273239544735162686151070106980114898);
	}

	template <typename genType>
	 inline constexpr genType two_over_root_pi()
	{
		return genType(1.12837916709551257389615890312154517);
	}

	template <typename genType>
	 inline constexpr genType one_over_root_two()
	{
		return genType(0.707106781186547524400844362104849039);
	}

	template <typename genType>
	 inline constexpr genType root_half_pi()
	{
		return genType(1.253314137315500251);
	}

	template <typename genType>
	 inline constexpr genType root_two_pi()
	{
		return genType(2.506628274631000502);
	}

	template <typename genType>
	 inline constexpr genType root_ln_four()
	{
		return genType(1.17741002251547469);
	}

	template <typename genType>
	 inline constexpr genType e()
	{
		return genType(2.71828182845904523536);
	}

	template <typename genType>
	 inline constexpr genType euler()
	{
		return genType(0.577215664901532860606);
	}

	template <typename genType>
	 inline constexpr genType root_two()
	{
		return genType(1.41421356237309504880168872420969808);
	}

	template <typename genType>
	 inline constexpr genType root_three()
	{
		return genType(1.73205080756887729352744634150587236);
	}

	template <typename genType>
	 inline constexpr genType root_five()
	{
		return genType(2.23606797749978969640917366873127623);
	}

	template <typename genType>
	 inline constexpr genType ln_two()
	{
		return genType(0.693147180559945309417232121458176568);
	}

	template <typename genType>
	 inline constexpr genType ln_ten()
	{
		return genType(2.30258509299404568401799145468436421);
	}

	template <typename genType>
	 inline constexpr genType ln_ln_two()
	{
		return genType(-0.3665129205816643);
	}

	template <typename genType>
	 inline constexpr genType third()
	{
		return genType(0.3333333333333333333333333333333333333333);
	}

	template <typename genType>
	 inline constexpr genType two_thirds()
	{
		return genType(0.666666666666666666666666666666666666667);
	}

	template <typename genType>
	 inline constexpr genType golden_ratio()
	{
		return genType(1.61803398874989484820458683436563811);
	}
} 
#line 177 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/constants.hpp"
#line 23 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"



#line 27 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"

namespace glm
{
	
	

	template <typename T, precision P = defaultp>
	struct tquat
	{
		

		typedef tquat<T, P> type;
		typedef T value_type;

		





#line 48 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"




#line 53 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"
		
			union
			{
				struct { T x, y, z, w;};
				typename detail::storage<T, sizeof(T) * 4, detail::is_aligned<P>::value>::type data;
			};
		


#line 63 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"


#line 66 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"


#line 69 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"

		

		typedef length_t length_type;
		
		 static length_type length(){return 4;}

		 T & operator[](length_type i);
		 T const & operator[](length_type i) const;

		

		 constexpr tquat() ;
		 constexpr tquat(tquat<T, P> const & q) = default;
		template <precision Q>
		 constexpr tquat(tquat<T, Q> const & q);

		

		  explicit tquat(ctor);
		 constexpr tquat(T const & s, tvec3<T, P> const & v);
		 constexpr tquat(T const & w, T const & x, T const & y, T const & z);

		

		template <typename U, precision Q>
		 constexpr  tquat(tquat<U, Q> const & q);

		

			 explicit operator tmat3x3<T, P>();
			 explicit operator tmat4x4<T, P>();
#line 102 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"

		
		
		
		
		
		
		 tquat(tvec3<T, P> const & u, tvec3<T, P> const & v);

		
		  tquat(tvec3<T, P> const & eulerAngles);
		  tquat(tmat3x3<T, P> const & m);
		  tquat(tmat4x4<T, P> const & m);

		

		 tquat<T, P> & operator=(tquat<T, P> const & m) = default;

		template <typename U>
		 tquat<T, P> & operator=(tquat<U, P> const & m);
		template <typename U>
		 tquat<T, P> & operator+=(tquat<U, P> const & q);
		template <typename U>
		 tquat<T, P> & operator-=(tquat<U, P> const & q);
		template <typename U>
		 tquat<T, P> & operator*=(tquat<U, P> const & q);
		template <typename U>
		 tquat<T, P> & operator*=(U s);
		template <typename U>
		 tquat<T, P> & operator/=(U s);
	};

	

	template <typename T, precision P>
	 tquat<T, P> operator+(tquat<T, P> const & q);

	template <typename T, precision P>
	 tquat<T, P> operator-(tquat<T, P> const & q);

	

	template <typename T, precision P>
	 tquat<T, P> operator+(tquat<T, P> const & q, tquat<T, P> const & p);

	template <typename T, precision P>
	 tquat<T, P> operator*(tquat<T, P> const & q, tquat<T, P> const & p);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tquat<T, P> const & q, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tquat<T, P> const & q, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q);

	template <typename T, precision P>
	 tquat<T, P> operator*(tquat<T, P> const & q, T const & s);

	template <typename T, precision P>
	 tquat<T, P> operator*(T const & s, tquat<T, P> const & q);

	template <typename T, precision P>
	 tquat<T, P> operator/(tquat<T, P> const & q, T const & s);

	

	template <typename T, precision P>
	 bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2);

	template <typename T, precision P>
	 bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2);

	
	
	
	template <typename T, precision P>
	 T length(tquat<T, P> const & q);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> normalize(tquat<T, P> const & q);
		
	
	
	
	template <typename T, precision P, template <typename, precision> class quatType>
	 T dot(quatType<T, P> const & x, quatType<T, P> const & y);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a);

	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);

	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> slerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> conjugate(tquat<T, P> const & q);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> inverse(tquat<T, P> const & q);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & axis);

	
	
	
	
	template <typename T, precision P>
	 tvec3<T, P> eulerAngles(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T roll(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T pitch(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T yaw(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tmat3x3<T, P> mat3_cast(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> mat4_cast(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> quat_cast(tmat3x3<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> quat_cast(tmat4x4<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T angle(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tvec3<T, P> axis(tquat<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & axis);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> isnan(tquat<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> isinf(tquat<T, P> const & x);

	
} 

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"








namespace glm{
namespace detail
{
	template <typename T, precision P, bool Aligned>
	struct compute_dot<tquat, T, P, Aligned>
	{
		static  inline T call(tquat<T, P> const& x, tquat<T, P> const& y)
		{
			tvec4<T, P> tmp(x.x * y.x, x.y * y.y, x.z * y.z, x.w * y.w);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_add
	{
		static tquat<T, P> call(tquat<T, P> const& q, tquat<T, P> const& p)
		{
			return tquat<T, P>(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_sub
	{
		static tquat<T, P> call(tquat<T, P> const& q, tquat<T, P> const& p)
		{
			return tquat<T, P>(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_mul_scalar
	{
		static tquat<T, P> call(tquat<T, P> const& q, T s)
		{
			return tquat<T, P>(q.w * s, q.x * s, q.y * s, q.z * s);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_div_scalar
	{
		static tquat<T, P> call(tquat<T, P> const& q, T s)
		{
			return tquat<T, P>(q.w / s, q.x / s, q.y / s, q.z / s);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_mul_vec4
	{
		static tvec4<T, P> call(tquat<T, P> const & q, tvec4<T, P> const & v)
		{
			return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
		}
	};
}

	

	template <typename T, precision P>
	 inline T & tquat<T, P>::operator[](typename tquat<T, P>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl", (unsigned)(73)), 0) );
		return (&x)[i];
	}

	template <typename T, precision P>
	 inline T const & tquat<T, P>::operator[](typename tquat<T, P>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl", (unsigned)(80)), 0) );
		return (&x)[i];
	}

	


		template <typename T, precision P>
		 inline constexpr tquat<T, P>::tquat()

				: x(0), y(0), z(0), w(1)
#line 92 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"
		{}
#line 94 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"






#line 101 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"

	template <typename T, precision P>
	template <precision Q>
	 inline constexpr tquat<T, P>::tquat(tquat<T, Q> const & q)
		: x(q.x), y(q.y), z(q.z), w(q.w)
	{}

	

	template <typename T, precision P>
	 inline  tquat<T, P>::tquat(ctor)
	{}

	template <typename T, precision P>
	 inline constexpr tquat<T, P>::tquat(T const & s, tvec3<T, P> const & v)
		: x(v.x), y(v.y), z(v.z), w(s)
	{}

	template <typename T, precision P>
	 inline constexpr tquat<T, P>::tquat(T const & w, T const & x, T const & y, T const & z)
		: x(x), y(y), z(z), w(w)
	{}

	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline constexpr tquat<T, P>::tquat(tquat<U, Q> const & q)
		: x(static_cast<T>(q.x))
		, y(static_cast<T>(q.y))
		, z(static_cast<T>(q.z))
		, w(static_cast<T>(q.w))
	{}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tvec3<T, P> const & u, tvec3<T, P> const & v)
	{
		tvec3<T, P> const LocalW(cross(u, v));
		T Dot = detail::compute_dot<tvec3, T, P, detail::is_aligned<P>::value>::call(u, v);
		tquat<T, P> q(T(1) + Dot, LocalW.x, LocalW.y, LocalW.z);

		*this = normalize(q);
	}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tvec3<T, P> const & eulerAngle)
	{
		tvec3<T, P> c = glm::cos(eulerAngle * T(0.5));
		tvec3<T, P> s = glm::sin(eulerAngle * T(0.5));
		
		this->w = c.x * c.y * c.z + s.x * s.y * s.z;
		this->x = s.x * c.y * c.z - c.x * s.y * s.z;
		this->y = c.x * s.y * c.z + s.x * c.y * s.z;
		this->z = c.x * c.y * s.z - s.x * s.y * c.z;
	}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tmat3x3<T, P> const & m)
	{
		*this = quat_cast(m);
	}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tmat4x4<T, P> const & m)
	{
		*this = quat_cast(m);
	}


	template <typename T, precision P>
	 inline tquat<T, P>::operator tmat3x3<T, P>()
	{
		return mat3_cast(*this);
	}
	
	template <typename T, precision P>	
	 inline tquat<T, P>::operator tmat4x4<T, P>()
	{
		return mat4_cast(*this);
	}
#line 200 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"

	template <typename T, precision P>
	 inline tquat<T, P> conjugate(tquat<T, P> const & q)
	{
		return tquat<T, P>(q.w, -q.x, -q.y, -q.z);
	}

	template <typename T, precision P>
	 inline tquat<T, P> inverse(tquat<T, P> const & q)
	{
		return conjugate(q) / dot(q, q);
	}

	











#line 226 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator=(tquat<U, P> const & q)
	{
		this->w = static_cast<T>(q.w);
		this->x = static_cast<T>(q.x);
		this->y = static_cast<T>(q.y);
		this->z = static_cast<T>(q.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator+=(tquat<U, P> const& q)
	{
		return (*this = detail::compute_quat_add<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator-=(tquat<U, P> const& q)
	{
		return (*this = detail::compute_quat_sub<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator*=(tquat<U, P> const & r)
	{
		tquat<T, P> const p(*this);
		tquat<T, P> const q(r);

		this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
		this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
		this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
		this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator*=(U s)
	{
		return (*this = detail::compute_quat_mul_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator/=(U s)
	{
		return (*this = detail::compute_quat_div_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
	}

	

	template <typename T, precision P>
	 inline tquat<T, P> operator+(tquat<T, P> const & q)
	{
		return q;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator-(tquat<T, P> const & q)
	{
		return tquat<T, P>(-q.w, -q.x, -q.y, -q.z);
	}

	

	template <typename T, precision P>
	 inline tquat<T, P> operator+(tquat<T, P> const & q,	tquat<T, P> const & p)
	{
		return tquat<T, P>(q) += p;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator*(tquat<T, P> const & q,	tquat<T, P> const & p)
	{
		return tquat<T, P>(q) *= p;
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tquat<T, P> const & q,	tvec3<T, P> const & v)
	{
		tvec3<T, P> const QuatVector(q.x, q.y, q.z);
		tvec3<T, P> const uv(glm::cross(QuatVector, v));
		tvec3<T, P> const uuv(glm::cross(QuatVector, uv));

		return v + ((uv * q.w) + uuv) * static_cast<T>(2);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tquat<T, P> const& q, tvec4<T, P> const& v)
	{
		return detail::compute_quat_mul_vec4<T, P, detail::is_aligned<P>::value>::call(q, v);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator*(tquat<T, P> const & q, T const & s)
	{
		return tquat<T, P>(
			q.w * s, q.x * s, q.y * s, q.z * s);
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator*(T const & s, tquat<T, P> const & q)
	{
		return q * s;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator/(tquat<T, P> const & q, T const & s)
	{
		return tquat<T, P>(
			q.w / s, q.x / s, q.y / s, q.z / s);
	}

	

	template <typename T, precision P>
	 inline bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2)
	{
		return (q1.x == q2.x) && (q1.y == q2.y) && (q1.z == q2.z) && (q1.w == q2.w);
	}

	template <typename T, precision P>
	 inline bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2)
	{
		return (q1.x != q2.x) || (q1.y != q2.y) || (q1.z != q2.z) || (q1.w != q2.w);
	}

	

	template <typename T, precision P>
	 inline T length(tquat<T, P> const & q)
	{
		return glm::sqrt(dot(q, q));
	}

	template <typename T, precision P>
	 inline tquat<T, P> normalize(tquat<T, P> const & q)
	{
		T len = length(q);
		if(len <= T(0)) 
			return tquat<T, P>(1, 0, 0, 0);
		T oneOverLen = T(1) / len;
		return tquat<T, P>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
	}

	template <typename T, precision P>
	 inline tquat<T, P> cross(tquat<T, P> const & q1, tquat<T, P> const & q2)
	{
		return tquat<T, P>(
			q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
			q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
			q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
			q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
	}













































































	template <typename T, precision P>
	 inline tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a)
	{
		T cosTheta = dot(x, y);

		
		if(cosTheta > T(1) - epsilon<T>())
		{
			
			return tquat<T, P>(
				mix(x.w, y.w, a),
				mix(x.x, y.x, a),
				mix(x.y, y.y, a),
				mix(x.z, y.z, a));
		}
		else
		{
			
			T angle = acos(cosTheta);
			return (sin((T(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
		}
	}

	template <typename T, precision P>
	 inline tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a)
	{
		
		(void)( (!!(a >= static_cast<T>(0))) || (_wassert(L"a >= static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl", (unsigned)(501)), 0) );
		(void)( (!!(a <= static_cast<T>(1))) || (_wassert(L"a <= static_cast<T>(1)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl", (unsigned)(502)), 0) );

		return x * (T(1) - a) + (y * a);
	}

	template <typename T, precision P>
	 inline tquat<T, P> slerp(tquat<T, P> const & x,	tquat<T, P> const & y, T a)
	{
		tquat<T, P> z = y;

		T cosTheta = dot(x, y);

		
		
		if (cosTheta < T(0))
		{
			z        = -y;
			cosTheta = -cosTheta;
		}

		
		if(cosTheta > T(1) - epsilon<T>())
		{
			
			return tquat<T, P>(
				mix(x.w, z.w, a),
				mix(x.x, z.x, a),
				mix(x.y, z.y, a),
				mix(x.z, z.z, a));
		}
		else
		{
			
			T angle = acos(cosTheta);
			return (sin((T(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
		}
	}

	template <typename T, precision P>
	 inline tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & v)
	{
		tvec3<T, P> Tmp = v;

		
		T len = glm::length(Tmp);
		if(abs(len - T(1)) > T(0.001))
		{
			T oneOverLen = static_cast<T>(1) / len;
			Tmp.x *= oneOverLen;
			Tmp.y *= oneOverLen;
			Tmp.z *= oneOverLen;
		}

		T const AngleRad(angle);
		T const Sin = sin(AngleRad * T(0.5));

		return q * tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
		
	}

	template <typename T, precision P>
	 inline tvec3<T, P> eulerAngles(tquat<T, P> const & x)
	{
		return tvec3<T, P>(pitch(x), yaw(x), roll(x));
	}

	template <typename T, precision P>
	 inline T roll(tquat<T, P> const & q)
	{
		return T(atan(T(2) * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z));
	}

	template <typename T, precision P>
	 inline T pitch(tquat<T, P> const & q)
	{
		return T(atan(T(2) * (q.y * q.z + q.w * q.x), q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z));
	}

	template <typename T, precision P>
	 inline T yaw(tquat<T, P> const & q)
	{
		return asin(clamp(T(-2) * (q.x * q.z - q.w * q.y), T(-1), T(1)));
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> mat3_cast(tquat<T, P> const & q)
	{
		tmat3x3<T, P> Result(T(1));
		T qxx(q.x * q.x);
		T qyy(q.y * q.y);
		T qzz(q.z * q.z);
		T qxz(q.x * q.z);
		T qxy(q.x * q.y);
		T qyz(q.y * q.z);
		T qwx(q.w * q.x);
		T qwy(q.w * q.y);
		T qwz(q.w * q.z);

		Result[0][0] = T(1) - T(2) * (qyy +  qzz);
		Result[0][1] = T(2) * (qxy + qwz);
		Result[0][2] = T(2) * (qxz - qwy);

		Result[1][0] = T(2) * (qxy - qwz);
		Result[1][1] = T(1) - T(2) * (qxx +  qzz);
		Result[1][2] = T(2) * (qyz + qwx);

		Result[2][0] = T(2) * (qxz + qwy);
		Result[2][1] = T(2) * (qyz - qwx);
		Result[2][2] = T(1) - T(2) * (qxx +  qyy);
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> mat4_cast(tquat<T, P> const & q)
	{
		return tmat4x4<T, P>(mat3_cast(q));
	}

	template <typename T, precision P>
	 inline tquat<T, P> quat_cast(tmat3x3<T, P> const & m)
	{
		T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
		T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
		T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
		T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

		int biggestIndex = 0;
		T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
		if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourXSquaredMinus1;
			biggestIndex = 1;
		}
		if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourYSquaredMinus1;
			biggestIndex = 2;
		}
		if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourZSquaredMinus1;
			biggestIndex = 3;
		}

		T biggestVal = sqrt(fourBiggestSquaredMinus1 + T(1)) * T(0.5);
		T mult = static_cast<T>(0.25) / biggestVal;

		tquat<T, P> Result(uninitialize);
		switch(biggestIndex)
		{
		case 0:
			Result.w = biggestVal;
			Result.x = (m[1][2] - m[2][1]) * mult;
			Result.y = (m[2][0] - m[0][2]) * mult;
			Result.z = (m[0][1] - m[1][0]) * mult;
			break;
		case 1:
			Result.w = (m[1][2] - m[2][1]) * mult;
			Result.x = biggestVal;
			Result.y = (m[0][1] + m[1][0]) * mult;
			Result.z = (m[2][0] + m[0][2]) * mult;
			break;
		case 2:
			Result.w = (m[2][0] - m[0][2]) * mult;
			Result.x = (m[0][1] + m[1][0]) * mult;
			Result.y = biggestVal;
			Result.z = (m[1][2] + m[2][1]) * mult;
			break;
		case 3:
			Result.w = (m[0][1] - m[1][0]) * mult;
			Result.x = (m[2][0] + m[0][2]) * mult;
			Result.y = (m[1][2] + m[2][1]) * mult;
			Result.z = biggestVal;
			break;
			
		default:					
			(void)( (!!(false)) || (_wassert(L"false", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl", (unsigned)(678)), 0) );
			break;
		}
		return Result;
	}

	template <typename T, precision P>
	 inline tquat<T, P> quat_cast(tmat4x4<T, P> const & m4)
	{
		return quat_cast(tmat3x3<T, P>(m4));
	}

	template <typename T, precision P>
	 inline T angle(tquat<T, P> const & x)
	{
		return acos(x.w) * T(2);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> axis(tquat<T, P> const & x)
	{
		T tmp1 = static_cast<T>(1) - x.w * x.w;
		if(tmp1 <= static_cast<T>(0))
			return tvec3<T, P>(0, 0, 1);
		T tmp2 = static_cast<T>(1) / sqrt(tmp1);
		return tvec3<T, P>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
	}

	template <typename T, precision P>
	 inline tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & v)
	{
		tquat<T, P> Result(uninitialize);

		T const a(angle);
		T const s = glm::sin(a * static_cast<T>(0.5));

		Result.w = glm::cos(a * static_cast<T>(0.5));
		Result.x = v.x * s;
		Result.y = v.y * s;
		Result.z = v.z * s;
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> isnan(tquat<T, P> const& q)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

		return tvec4<bool, P>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> isinf(tquat<T, P> const& q)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs");

		return tvec4<bool, P>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
	}
}


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion_simd.inl"





namespace glm{
namespace detail
{























































	template <precision P>
	struct compute_dot<tquat, float, P, true>
	{
		static  inline float call(tquat<float, P> const& x, tquat<float, P> const& y)
		{
			return _mm_cvtss_f32(glm_vec1_dot(x.data, y.data));
		}
	};

	template <precision P>
	struct compute_quat_add<float, P, true>
	{
		static tquat<float, P> call(tquat<float, P> const& q, tquat<float, P> const& p)
		{
			tquat<float, P> Result(uninitialize);
			Result.data = _mm_add_ps(q.data, p.data);
			return Result;
		}
	};












#line 96 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion_simd.inl"

	template <precision P>
	struct compute_quat_sub<float, P, true>
	{
		static tquat<float, P> call(tquat<float, P> const& q, tquat<float, P> const& p)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_sub_ps(q.data, p.data);
			return Result;
		}
	};












#line 120 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion_simd.inl"

	template <precision P>
	struct compute_quat_mul_scalar<float, P, true>
	{
		static tquat<float, P> call(tquat<float, P> const& q, float s)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_mul_ps(q.data, _mm_set_ps1(s));
			return Result;
		}
	};












#line 144 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion_simd.inl"

	template <precision P>
	struct compute_quat_div_scalar<float, P, true>
	{
		static tquat<float, P> call(tquat<float, P> const& q, float s)
		{
			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_div_ps(q.data, _mm_set_ps1(s));
			return Result;
		}
	};












#line 168 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion_simd.inl"

	template <precision P>
	struct compute_quat_mul_vec4<float, P, true>
	{
		static tvec4<float, P> call(tquat<float, P> const& q, tvec4<float, P> const& v)
		{
			__m128 const q_wwww = _mm_shuffle_ps(q.data, q.data, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
			__m128 const q_swp0 = _mm_shuffle_ps(q.data, q.data, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
			__m128 const q_swp1 = _mm_shuffle_ps(q.data, q.data, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
			__m128 const v_swp0 = _mm_shuffle_ps(v.data, v.data, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
			__m128 const v_swp1 = _mm_shuffle_ps(v.data, v.data, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
	
			__m128 uv      = _mm_sub_ps(_mm_mul_ps(q_swp0, v_swp1), _mm_mul_ps(q_swp1, v_swp0));
			__m128 uv_swp0 = _mm_shuffle_ps(uv, uv, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
			__m128 uv_swp1 = _mm_shuffle_ps(uv, uv, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
			__m128 uuv     = _mm_sub_ps(_mm_mul_ps(q_swp0, uv_swp1), _mm_mul_ps(q_swp1, uv_swp0));

			__m128 const two = _mm_set_ps1(2.0f);
			uv  = _mm_mul_ps(uv, _mm_mul_ps(q_wwww, two));
			uuv = _mm_mul_ps(uuv, two);

			tvec4<float, P> Result(uninitialize);
			Result.data = _mm_add_ps(v.Data, _mm_add_ps(uv, uuv));
			return Result;
		}
	};
}
}

#line 198 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion_simd.inl"

#line 794 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"
#line 795 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\quaternion.inl"

#line 398 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\../gtc/quaternion.hpp"
#line 38 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/type_ptr.hpp"
















#line 55 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/type_ptr.hpp"

namespace glm
{
	
	

	
	
	template<typename genType>
	 typename genType::value_type const * value_ptr(genType const & vec);

	
	
	template<typename T>
	 tvec2<T, defaultp> make_vec2(T const * const ptr);

	
	
	template<typename T>
	 tvec3<T, defaultp> make_vec3(T const * const ptr);

	
	
	template<typename T>
	 tvec4<T, defaultp> make_vec4(T const * const ptr);

	
	
	template<typename T>
	 tmat2x2<T, defaultp> make_mat2x2(T const * const ptr);

	
	
	template<typename T>
	 tmat2x3<T, defaultp> make_mat2x3(T const * const ptr);

	
	
	template<typename T>
	 tmat2x4<T, defaultp> make_mat2x4(T const * const ptr);

	
	
	template<typename T>
	 tmat3x2<T, defaultp> make_mat3x2(T const * const ptr);

	
	
	template<typename T>
	 tmat3x3<T, defaultp> make_mat3x3(T const * const ptr);

	
	
	template<typename T>
	 tmat3x4<T, defaultp> make_mat3x4(T const * const ptr);

	
	
	template<typename T>
	 tmat4x2<T, defaultp> make_mat4x2(T const * const ptr);

	
	
	template<typename T>
	 tmat4x3<T, defaultp> make_mat4x3(T const * const ptr);

	
	
	template<typename T>
	 tmat4x4<T, defaultp> make_mat4x4(T const * const ptr);
	
	
	
	template<typename T>
	 tmat2x2<T, defaultp> make_mat2(T const * const ptr);

	
	
	template<typename T>
	 tmat3x3<T, defaultp> make_mat3(T const * const ptr);
		
	
	
	template<typename T>
	 tmat4x4<T, defaultp> make_mat4(T const * const ptr);

	
	
	template<typename T>
	 tquat<T, defaultp> make_quat(T const * const ptr);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\type_ptr.inl"





namespace glm
{
	
	

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tvec2<T, P> const & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tvec2<T, P> & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tvec3<T, P> const & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tvec3<T, P> & vec
	)
	{
		return &(vec.x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(	
		tvec4<T, P> const & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(	
		tvec4<T, P> & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat2x2<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat2x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat3x3<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat3x3<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat4x4<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat4x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat2x3<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat2x3<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat3x2<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat3x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat2x4<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat2x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat4x2<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(	
		tmat4x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat3x4<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat3x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat4x3<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr(tmat4x3<T, P> & mat)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tquat<T, P> const & q
	)
	{
		return &(q[0]);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tquat<T, P> & q
	)
	{
		return &(q[0]);
	}

	
	
	template <typename T>
	 inline tvec2<T, defaultp> make_vec2(T const * const ptr)
	{
		tvec2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tvec3<T, defaultp> make_vec3(T const * const ptr)
	{
		tvec3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tvec4<T, defaultp> make_vec4(T const * const ptr)
	{
		tvec4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)
	{
		tmat2x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)
	{
		tmat2x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)
	{
		tmat2x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)
	{
		tmat3x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)
	{
		tmat3x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)
	{
		tmat3x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)
	{
		tmat4x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)
	{
		tmat4x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)
	{
		tmat4x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x2<T, defaultp> make_mat2(T const * const ptr)
	{
		return make_mat2x2(ptr);
	}

	
	
	template <typename T>
	 inline tmat3x3<T, defaultp> make_mat3(T const * const ptr)
	{
		return make_mat3x3(ptr);
	}
		
	
	
	template <typename T>
	 inline tmat4x4<T, defaultp> make_mat4(T const * const ptr)
	{
		return make_mat4x4(ptr);
	}

	
	
	template <typename T>
	 inline tquat<T, defaultp> make_quat(T const * const ptr)
	{
		tquat<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));
		return Result;
	}

	
}

#line 150 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/type_ptr.hpp"
#line 19 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"

void checkCompileErrors(unsigned int shader, std::string type, const char* shaderName);

namespace engine {

	class Shader
	{
	public:
		unsigned int ID;

		Shader() = default;

		Shader(const char* vertexPath, const char* fragmentPath)
		{
			if (vertexPath == 0 && fragmentPath == 0)
			{
				return;
			}

			
		}

		void SetVector3f(const char* name, const glm::vec3 &value)
		{
			glad_glUniform3f(glad_glGetUniformLocation(this->ID, name), value.x, value.y, value.z);
		}

		void SetVector4f(const char* name, const vec4 &value)
		{
			glad_glUniform4f(glad_glGetUniformLocation(this->ID, name), value.x, value.y, value.w, value.h);
		}

		void compileShaderFromFile(const char* vertexFilepath, const char* fragmentFilepath, bool modernVersion = false)
		{
			std::string vertexCode;
			std::string fragmentCode;


            if (modernVersion)
            {
                const int additionalLen = 20;
                if (strlen(vertexFilepath) + additionalLen < 256) { } else { __debugbreak();; }; 
                if (strlen(fragmentFilepath) + additionalLen < 256) { } else { __debugbreak();; };
                char fragbuf[256];
                char verbuf[256];

                sprintf(verbuf, "%s_43", vertexFilepath);
                sprintf(fragbuf, "%s_43", fragmentFilepath);

                vertexCode = engine::io::ReadEntireFileToString(verbuf);
                fragmentCode = engine::io::ReadEntireFileToString(fragbuf);
            }
            else
#line 73 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"
            {
                vertexCode = engine::io::ReadEntireFileToString(vertexFilepath);
                fragmentCode = engine::io::ReadEntireFileToString(fragmentFilepath);
            }


			const char* vShaderCode = vertexCode.c_str();
			const char* fShaderCode = fragmentCode.c_str();

			compileShadersFromSource(vShaderCode, fShaderCode, vertexFilepath, fragmentFilepath);
		}
#line 85 "I:\\Dev\\Motors\\pikkumoottori\\inc\\graphics/Shader.h"

		void compileShadersFromSource(const char * vertexSrc, const char * fragmentSrc,
                const char* vertexName, const char* fragmentName)
		{
			unsigned int vertex, fragment;

			vertex = glad_glCreateShader(0x8B31);
			glad_glShaderSource(vertex, 1, &vertexSrc, 0);
			glad_glCompileShader(vertex);
			checkCompileErrors(vertex, "VERTEX", vertexName);

			
			fragment = glad_glCreateShader(0x8B30);
			glad_glShaderSource(fragment, 1, &fragmentSrc, 0);
			glad_glCompileShader(fragment);
			checkCompileErrors(fragment, "FRAGMENT", fragmentName);

			
			ID = glad_glCreateProgram();
			glad_glAttachShader(ID, vertex);
			glad_glAttachShader(ID, fragment);
			glad_glLinkProgram(ID);
			checkCompileErrors(ID, "PROGRAM", fragmentName);

			
			glad_glDeleteShader(vertex);
			glad_glDeleteShader(fragment);


		}

		
		
		void use()
		{
			glad_glUseProgram(ID);
		}
		
		
		void setBool(const std::string &name, bool value) const
		{
			glad_glUniform1i(glad_glGetUniformLocation(ID, name.c_str()), (int)value);
		}
		
		void setInt(const std::string &name, int value) const
		{
			glad_glUniform1i(glad_glGetUniformLocation(ID, name.c_str()), value);
		}

		void setInts(const std::string &name, int count, int* values) const
		{
			glad_glUniform1iv(glad_glGetUniformLocation(ID, name.c_str()), count, values);
		}

		
		void setFloat(const std::string &name, float value) const
		{
			glad_glUniform1f(glad_glGetUniformLocation(ID, name.c_str()), value);
		}

		void setFloat2(const std::string &name, glm::vec2& value) const
		{
			glad_glUniform2f(glad_glGetUniformLocation(ID, name.c_str()), value.x, value.y);
		}

		void setMat4(const std::string &name, glm::mat4 value) const
		{
            float* ptr = glm::value_ptr(value);
            GLuint id = glad_glGetUniformLocation(ID, name.c_str());
			glad_glUniformMatrix4fv(id, 1, 0, ptr);
		}

		void setMat4(const unsigned int ID, glm::mat4 value) const
		{
			glad_glUniformMatrix4fv(ID, 1, 0, glm::value_ptr(value));
		}


		unsigned int getLocation(const char* name)
		{
			return glad_glGetUniformLocation(ID, name);
		}

		void setFloat4(const char* name, const glm::vec4& vec4)
		{
			glad_glUniform4f(glad_glGetUniformLocation(ID, name), vec4.x, vec4.y, vec4.z, vec4.w);
		}

	private:
		
		
	};
}
#line 2 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\shader.cpp"



namespace engine {
}

void checkCompileErrors(unsigned shader, std::string type, const char* shaderName)
{
	int success;
	char infoLog[1024];
	if (type != "PROGRAM")
	{
		glad_glGetShaderiv(shader, 0x8B81, &success);
		if (!success)
		{
			glad_glGetShaderInfoLog(shader, 1024, 0, infoLog);
			printf("ERROR::SHADER_COMPILATION_ERROR of type: %s \n %s \n", type.c_str(), infoLog);
            printf("In shader %s\n", shaderName);
			if (false) { } else { __debugbreak();; };
		}
	}
	else
	{
		glad_glGetProgramiv(shader, 0x8B82, &success);
		if (!success)
		{
			glad_glGetProgramInfoLog(shader, 1024, 0, infoLog);
			printf("ERROR::PROGRAM_LINKING_ERROR of type: %s \n %s \n", type.c_str(), infoLog);
            printf("In shader %s\n", shaderName);
			if (false) { } else { __debugbreak();; };
		}
	}
}
#line 7 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\graphics.h"

constexpr int MAX_SPRITES = 300001;
struct VertexData
{
	float pos[MAX_SPRITES * 16];
	float uvs[MAX_SPRITES * 8];
	float ids[MAX_SPRITES * 4];
	float rot[MAX_SPRITES * 4];
	unsigned int colors[MAX_SPRITES * 4];
	int textureSlots[32];
	unsigned int slotCount;
	unsigned int indicesCount;
};

struct SpriteBatch
{
	unsigned int VAO;
	unsigned int buffers[6];
	engine::Shader shader;
	VertexData vertexData;
};

struct Camera2D
{
	glm::mat4 cameraMatrix;
	glm::mat4 orthoMatrix;
};

extern "C" __declspec(dllexport) void initGraphics(EngineContext* engine);
extern "C" __declspec(dllexport) void updateGraphics(EngineContext* engine);
extern "C" __declspec(dllexport) void drawGraphics(EngineContext* engine);







#line 46 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\graphics.h"

GLenum glCheckError__(const char *file, int line)
{
	GLenum errorCode;
	while ((errorCode = glad_glGetError()) != 0)
	{
		std::string error;
		switch (errorCode)
		{
		case 0x0500:                  error = "INVALID_ENUM"; break;
		case 0x0501:                 error = "INVALID_VALUE"; break;
		case 0x0502:             error = "INVALID_OPERATION"; break;
			
			
		case 0x0505:                 error = "OUT_OF_MEMORY"; break;
		case 0x0506: error = "INVALID_FRAMEBUFFER_OPERATION"; break;
		}
		printf("%s | %s (%i)\n", error.c_str(), file, line);
	}
	return errorCode;
}
#line 3 "..\\src\\graphics\\graphics.cpp"



#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"

























static void* get_proc(const char *namez);



static HMODULE libGL;

typedef void* (__stdcall * PFNWGLGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNWGLGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;

static
int open_gl(void) {
    libGL = LoadLibraryW(L"opengl32.dll");
    if(libGL != 0) {
        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE)GetProcAddress(
                libGL, "wglGetProcAddress");
        return gladGetProcAddressPtr != 0;
    }

    return 0;
}

static
void close_gl(void) {
    if(libGL != 0) {
        FreeLibrary(libGL);
        libGL = 0;
    }
}















































#line 102 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"

static
void* get_proc(const char *namez) {
    void* result = 0;
    if(libGL == 0) return 0;


    if(gladGetProcAddressPtr != 0) {
        result = gladGetProcAddressPtr(namez);
    }
#line 113 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"
    if(result == 0) {

        result = (void*)GetProcAddress(libGL, namez);


#line 119 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"
    }

    return result;
}

int gladLoadGL(void) {
    int status = 0;

    if(open_gl()) {
        status = gladLoadGLLoader(&get_proc);
        close_gl();
    }

    return status;
}

struct gladGLversionStruct GLVersion;



#line 140 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"

static int max_loaded_major;
static int max_loaded_minor;

static const char *exts = 0;
static int num_exts_i = 0;
static const char **exts_i = 0;

static int get_exts(void) {

    if(max_loaded_major < 3) {
#line 152 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"
        exts = (const char *)glad_glGetString(0x1F03);

    } else {
        unsigned int index;

        num_exts_i = 0;
        glad_glGetIntegerv(0x821D, &num_exts_i);
        if (num_exts_i > 0) {
            exts_i = (const char **)realloc((void *)exts_i, (size_t)num_exts_i * (sizeof *exts_i));
        }

        if (exts_i == 0) {
            return 0;
        }

        for(index = 0; index < (unsigned)num_exts_i; index++) {
            const char *gl_str_tmp = (const char*)glad_glGetStringi(0x1F03, index);
            size_t len = strlen(gl_str_tmp);

            char *local_str = (char*)malloc((len+1) * sizeof(*exts_i));
            if(local_str != 0) {

                strncpy_s(local_str, len+1, gl_str_tmp, len);


#line 178 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"
            }
            exts_i[index] = local_str;
        }
    }
#line 183 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"
    return 1;
}

static void free_exts(void) {
    if (exts_i != 0) {
        int index;
        for(index = 0; index < num_exts_i; index++) {
            free((char *)exts_i[index]);
        }
        free((void *)exts_i);
        exts_i = 0;
    }
}

static int has_ext(const char *ext) {

    if(max_loaded_major < 3) {
#line 201 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"
        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == 0 || ext == 0) {
            return 0;
        }

        while(1) {
            loc = strstr(extensions, ext);
            if(loc == 0) {
                return 0;
            }

            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }

    } else {
        int index;
        if(exts_i == 0) return 0;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];

            if(exts_i[index] != 0 && strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }
#line 235 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"

    return 0;
}
int GLAD_GL_VERSION_1_0;
int GLAD_GL_VERSION_1_1;
int GLAD_GL_VERSION_1_2;
int GLAD_GL_VERSION_1_3;
int GLAD_GL_VERSION_1_4;
int GLAD_GL_VERSION_1_5;
int GLAD_GL_VERSION_2_0;
int GLAD_GL_VERSION_2_1;
int GLAD_GL_VERSION_3_0;
int GLAD_GL_VERSION_3_1;
int GLAD_GL_VERSION_3_2;
int GLAD_GL_VERSION_3_3;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
PFNGLWINDOWPOS2SPROC glad_glWindowPos2s;
PFNGLWINDOWPOS2IPROC glad_glWindowPos2i;
PFNGLWINDOWPOS2FPROC glad_glWindowPos2f;
PFNGLWINDOWPOS2DPROC glad_glWindowPos2d;
PFNGLVERTEX2FVPROC glad_glVertex2fv;
PFNGLINDEXIPROC glad_glIndexi;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
PFNGLRECTDVPROC glad_glRectdv;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
PFNGLEVALCOORD2DPROC glad_glEvalCoord2d;
PFNGLEVALCOORD2FPROC glad_glEvalCoord2f;
PFNGLINDEXDPROC glad_glIndexd;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
PFNGLINDEXFPROC glad_glIndexf;
PFNGLBINDSAMPLERPROC glad_glBindSampler;
PFNGLLINEWIDTHPROC glad_glLineWidth;
PFNGLCOLORP3UIVPROC glad_glColorP3uiv;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
PFNGLGETMAPFVPROC glad_glGetMapfv;
PFNGLINDEXSPROC glad_glIndexs;
PFNGLCOMPILESHADERPROC glad_glCompileShader;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
PFNGLWINDOWPOS2IVPROC glad_glWindowPos2iv;
PFNGLINDEXFVPROC glad_glIndexfv;
PFNGLFOGIVPROC glad_glFogiv;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
PFNGLRASTERPOS2FVPROC glad_glRasterPos2fv;
PFNGLLIGHTMODELIVPROC glad_glLightModeliv;
PFNGLCOLOR4UIPROC glad_glColor4ui;
PFNGLSECONDARYCOLOR3FVPROC glad_glSecondaryColor3fv;
PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui;
PFNGLFOGFVPROC glad_glFogfv;
PFNGLVERTEXP4UIPROC glad_glVertexP4ui;
PFNGLENABLEIPROC glad_glEnablei;
PFNGLVERTEX4IVPROC glad_glVertex4iv;
PFNGLEVALCOORD1FVPROC glad_glEvalCoord1fv;
PFNGLWINDOWPOS2SVPROC glad_glWindowPos2sv;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
PFNGLCREATESHADERPROC glad_glCreateShader;
PFNGLISBUFFERPROC glad_glIsBuffer;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
PFNGLVERTEX4FVPROC glad_glVertex4fv;
PFNGLBINDTEXTUREPROC glad_glBindTexture;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
PFNGLTEXCOORD2FVPROC glad_glTexCoord2fv;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
PFNGLVERTEXP2UIPROC glad_glVertexP2ui;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
PFNGLTEXCOORD4FVPROC glad_glTexCoord4fv;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
PFNGLPOINTSIZEPROC glad_glPointSize;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
PFNGLCOLOR4BVPROC glad_glColor4bv;
PFNGLRASTERPOS2FPROC glad_glRasterPos2f;
PFNGLRASTERPOS2DPROC glad_glRasterPos2d;
PFNGLLOADIDENTITYPROC glad_glLoadIdentity;
PFNGLRASTERPOS2IPROC glad_glRasterPos2i;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
PFNGLCOLOR3BPROC glad_glColor3b;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
PFNGLEDGEFLAGPROC glad_glEdgeFlag;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
PFNGLVERTEX3DPROC glad_glVertex3d;
PFNGLVERTEX3FPROC glad_glVertex3f;
PFNGLVERTEX3IPROC glad_glVertex3i;
PFNGLCOLOR3IPROC glad_glColor3i;
PFNGLUNIFORM3FPROC glad_glUniform3f;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
PFNGLCOLOR3SPROC glad_glColor3s;
PFNGLVERTEX3SPROC glad_glVertex3s;
PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui;
PFNGLCOLORMASKIPROC glad_glColorMaski;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
PFNGLTEXCOORD1IVPROC glad_glTexCoord1iv;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
PFNGLVERTEX2IVPROC glad_glVertex2iv;
PFNGLCOLOR3SVPROC glad_glColor3sv;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
PFNGLNORMALPOINTERPROC glad_glNormalPointer;
PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv;
PFNGLVERTEX4SVPROC glad_glVertex4sv;
PFNGLPASSTHROUGHPROC glad_glPassThrough;
PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui;
PFNGLFOGIPROC glad_glFogi;
PFNGLBEGINPROC glad_glBegin;
PFNGLEVALCOORD2DVPROC glad_glEvalCoord2dv;
PFNGLCOLOR3UBVPROC glad_glColor3ubv;
PFNGLVERTEXPOINTERPROC glad_glVertexPointer;
PFNGLSECONDARYCOLOR3UIVPROC glad_glSecondaryColor3uiv;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
PFNGLDRAWARRAYSPROC glad_glDrawArrays;
PFNGLUNIFORM1UIPROC glad_glUniform1ui;
PFNGLMULTITEXCOORD1DPROC glad_glMultiTexCoord1d;
PFNGLMULTITEXCOORD1FPROC glad_glMultiTexCoord1f;
PFNGLLIGHTFVPROC glad_glLightfv;
PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
PFNGLCLEARPROC glad_glClear;
PFNGLMULTITEXCOORD1IPROC glad_glMultiTexCoord1i;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
PFNGLMULTITEXCOORD1SPROC glad_glMultiTexCoord1s;
PFNGLISENABLEDPROC glad_glIsEnabled;
PFNGLSTENCILOPPROC glad_glStencilOp;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;
PFNGLTRANSLATEFPROC glad_glTranslatef;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
PFNGLTRANSLATEDPROC glad_glTranslated;
PFNGLTEXCOORD3SVPROC glad_glTexCoord3sv;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
PFNGLSECONDARYCOLOR3BVPROC glad_glSecondaryColor3bv;
PFNGLGETMATERIALFVPROC glad_glGetMaterialfv;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
PFNGLFOGCOORDFVPROC glad_glFogCoordfv;
PFNGLPIXELMAPUIVPROC glad_glPixelMapuiv;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
PFNGLINDEXSVPROC glad_glIndexsv;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
PFNGLVERTEX3IVPROC glad_glVertex3iv;
PFNGLBITMAPPROC glad_glBitmap;
PFNGLMATERIALIPROC glad_glMateriali;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
PFNGLGETQUERYIVPROC glad_glGetQueryiv;
PFNGLTEXCOORD4FPROC glad_glTexCoord4f;
PFNGLTEXCOORD4DPROC glad_glTexCoord4d;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
PFNGLTEXCOORD4IPROC glad_glTexCoord4i;
PFNGLMATERIALFPROC glad_glMaterialf;
PFNGLTEXCOORD4SPROC glad_glTexCoord4s;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
PFNGLISSHADERPROC glad_glIsShader;
PFNGLMULTITEXCOORD2SPROC glad_glMultiTexCoord2s;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
PFNGLVERTEX3DVPROC glad_glVertex3dv;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
PFNGLENABLEPROC glad_glEnable;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
PFNGLCOLOR4FVPROC glad_glColor4fv;
PFNGLTEXCOORD1FVPROC glad_glTexCoord1fv;
PFNGLTEXCOORD2SVPROC glad_glTexCoord2sv;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
PFNGLMULTITEXCOORD1DVPROC glad_glMultiTexCoord1dv;
PFNGLMULTITEXCOORD2IPROC glad_glMultiTexCoord2i;
PFNGLTEXCOORD3FVPROC glad_glTexCoord3fv;
PFNGLSECONDARYCOLOR3USVPROC glad_glSecondaryColor3usv;
PFNGLTEXGENFPROC glad_glTexGenf;
PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui;
PFNGLGETPOINTERVPROC glad_glGetPointerv;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
PFNGLNORMAL3FVPROC glad_glNormal3fv;
PFNGLSECONDARYCOLOR3SPROC glad_glSecondaryColor3s;
PFNGLDEPTHRANGEPROC glad_glDepthRange;
PFNGLFRUSTUMPROC glad_glFrustum;
PFNGLMULTITEXCOORD4SVPROC glad_glMultiTexCoord4sv;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
PFNGLPUSHMATRIXPROC glad_glPushMatrix;
PFNGLRASTERPOS3FVPROC glad_glRasterPos3fv;
PFNGLORTHOPROC glad_glOrtho;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
PFNGLWINDOWPOS3SVPROC glad_glWindowPos3sv;
PFNGLCLEARINDEXPROC glad_glClearIndex;
PFNGLMAP1DPROC glad_glMap1d;
PFNGLMAP1FPROC glad_glMap1f;
PFNGLFLUSHPROC glad_glFlush;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
PFNGLINDEXIVPROC glad_glIndexiv;
PFNGLRASTERPOS3SVPROC glad_glRasterPos3sv;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
PFNGLPIXELZOOMPROC glad_glPixelZoom;
PFNGLFENCESYNCPROC glad_glFenceSync;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
PFNGLCOLORP3UIPROC glad_glColorP3ui;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
PFNGLLIGHTIPROC glad_glLighti;
PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv;
PFNGLLIGHTFPROC glad_glLightf;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
PFNGLGENSAMPLERSPROC glad_glGenSamplers;
PFNGLCLAMPCOLORPROC glad_glClampColor;
PFNGLUNIFORM4IVPROC glad_glUniform4iv;
PFNGLCLEARSTENCILPROC glad_glClearStencil;
PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv;
PFNGLMULTITEXCOORD3FVPROC glad_glMultiTexCoord3fv;
PFNGLGETPIXELMAPUIVPROC glad_glGetPixelMapuiv;
PFNGLGENTEXTURESPROC glad_glGenTextures;
PFNGLTEXCOORD4IVPROC glad_glTexCoord4iv;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
PFNGLINDEXPOINTERPROC glad_glIndexPointer;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
PFNGLISSYNCPROC glad_glIsSync;
PFNGLVERTEX2FPROC glad_glVertex2f;
PFNGLVERTEX2DPROC glad_glVertex2d;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
PFNGLUNIFORM2IPROC glad_glUniform2i;
PFNGLMAPGRID2DPROC glad_glMapGrid2d;
PFNGLMAPGRID2FPROC glad_glMapGrid2f;
PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui;
PFNGLVERTEX2IPROC glad_glVertex2i;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
PFNGLVERTEX2SPROC glad_glVertex2s;
PFNGLNORMAL3BVPROC glad_glNormal3bv;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
PFNGLSECONDARYCOLOR3SVPROC glad_glSecondaryColor3sv;
PFNGLVERTEX3SVPROC glad_glVertex3sv;
PFNGLGENQUERIESPROC glad_glGenQueries;
PFNGLGETPIXELMAPFVPROC glad_glGetPixelMapfv;
PFNGLTEXENVFPROC glad_glTexEnvf;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
PFNGLFOGCOORDDPROC glad_glFogCoordd;
PFNGLFOGCOORDFPROC glad_glFogCoordf;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
PFNGLTEXENVIPROC glad_glTexEnvi;
PFNGLMULTITEXCOORD1IVPROC glad_glMultiTexCoord1iv;
PFNGLISENABLEDIPROC glad_glIsEnabledi;
PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
PFNGLMULTITEXCOORD2DVPROC glad_glMultiTexCoord2dv;
PFNGLUNIFORM2IVPROC glad_glUniform2iv;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
PFNGLMATRIXMODEPROC glad_glMatrixMode;
PFNGLFEEDBACKBUFFERPROC glad_glFeedbackBuffer;
PFNGLGETMAPIVPROC glad_glGetMapiv;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
PFNGLGETSHADERIVPROC glad_glGetShaderiv;
PFNGLMULTITEXCOORD2DPROC glad_glMultiTexCoord2d;
PFNGLMULTITEXCOORD2FPROC glad_glMultiTexCoord2f;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
PFNGLPRIORITIZETEXTURESPROC glad_glPrioritizeTextures;
PFNGLCALLLISTPROC glad_glCallList;
PFNGLSECONDARYCOLOR3UBVPROC glad_glSecondaryColor3ubv;
PFNGLGETDOUBLEVPROC glad_glGetDoublev;
PFNGLMULTITEXCOORD3IVPROC glad_glMultiTexCoord3iv;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
PFNGLLIGHTMODELFPROC glad_glLightModelf;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
PFNGLVERTEX2SVPROC glad_glVertex2sv;
PFNGLLIGHTMODELIPROC glad_glLightModeli;
PFNGLWINDOWPOS3IVPROC glad_glWindowPos3iv;
PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv;
PFNGLUNIFORM3FVPROC glad_glUniform3fv;
PFNGLPIXELSTOREIPROC glad_glPixelStorei;
PFNGLCALLLISTSPROC glad_glCallLists;
PFNGLMAPBUFFERPROC glad_glMapBuffer;
PFNGLSECONDARYCOLOR3DPROC glad_glSecondaryColor3d;
PFNGLTEXCOORD3IPROC glad_glTexCoord3i;
PFNGLMULTITEXCOORD4FVPROC glad_glMultiTexCoord4fv;
PFNGLRASTERPOS3IPROC glad_glRasterPos3i;
PFNGLSECONDARYCOLOR3BPROC glad_glSecondaryColor3b;
PFNGLRASTERPOS3DPROC glad_glRasterPos3d;
PFNGLRASTERPOS3FPROC glad_glRasterPos3f;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
PFNGLTEXCOORD3FPROC glad_glTexCoord3f;
PFNGLDELETESYNCPROC glad_glDeleteSync;
PFNGLTEXCOORD3DPROC glad_glTexCoord3d;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
PFNGLTEXCOORD3SPROC glad_glTexCoord3s;
PFNGLUNIFORM3IVPROC glad_glUniform3iv;
PFNGLRASTERPOS3SPROC glad_glRasterPos3s;
PFNGLPOLYGONMODEPROC glad_glPolygonMode;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
PFNGLARETEXTURESRESIDENTPROC glad_glAreTexturesResident;
PFNGLISLISTPROC glad_glIsList;
PFNGLRASTERPOS2SVPROC glad_glRasterPos2sv;
PFNGLRASTERPOS4SVPROC glad_glRasterPos4sv;
PFNGLCOLOR4SPROC glad_glColor4s;
PFNGLUSEPROGRAMPROC glad_glUseProgram;
PFNGLLINESTIPPLEPROC glad_glLineStipple;
PFNGLMULTITEXCOORD1SVPROC glad_glMultiTexCoord1sv;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
PFNGLMULTITEXCOORD2IVPROC glad_glMultiTexCoord2iv;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
PFNGLCOLOR4BPROC glad_glColor4b;
PFNGLSECONDARYCOLOR3FPROC glad_glSecondaryColor3f;
PFNGLCOLOR4FPROC glad_glColor4f;
PFNGLCOLOR4DPROC glad_glColor4d;
PFNGLCOLOR4IPROC glad_glColor4i;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
PFNGLRASTERPOS3IVPROC glad_glRasterPos3iv;
PFNGLVERTEX2DVPROC glad_glVertex2dv;
PFNGLTEXCOORD4SVPROC glad_glTexCoord4sv;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
PFNGLFINISHPROC glad_glFinish;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
PFNGLDELETESHADERPROC glad_glDeleteShader;
PFNGLDRAWELEMENTSPROC glad_glDrawElements;
PFNGLRASTERPOS2SPROC glad_glRasterPos2s;
PFNGLGETMAPDVPROC glad_glGetMapdv;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
PFNGLMATERIALFVPROC glad_glMaterialfv;
PFNGLVIEWPORTPROC glad_glViewport;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
PFNGLINDEXDVPROC glad_glIndexdv;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
PFNGLTEXCOORD3IVPROC glad_glTexCoord3iv;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
PFNGLCLEARDEPTHPROC glad_glClearDepth;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
PFNGLTEXBUFFERPROC glad_glTexBuffer;
PFNGLPOPNAMEPROC glad_glPopName;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
PFNGLPIXELSTOREFPROC glad_glPixelStoref;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
PFNGLRASTERPOS4FVPROC glad_glRasterPos4fv;
PFNGLEVALCOORD1DVPROC glad_glEvalCoord1dv;
PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv;
PFNGLRECTIPROC glad_glRecti;
PFNGLCOLOR4UBPROC glad_glColor4ub;
PFNGLMULTTRANSPOSEMATRIXFPROC glad_glMultTransposeMatrixf;
PFNGLRECTFPROC glad_glRectf;
PFNGLRECTDPROC glad_glRectd;
PFNGLNORMAL3SVPROC glad_glNormal3sv;
PFNGLNEWLISTPROC glad_glNewList;
PFNGLCOLOR4USPROC glad_glColor4us;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
PFNGLLINKPROGRAMPROC glad_glLinkProgram;
PFNGLHINTPROC glad_glHint;
PFNGLRECTSPROC glad_glRects;
PFNGLTEXCOORD2DVPROC glad_glTexCoord2dv;
PFNGLRASTERPOS4IVPROC glad_glRasterPos4iv;
PFNGLGETSTRINGPROC glad_glGetString;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
PFNGLEDGEFLAGVPROC glad_glEdgeFlagv;
PFNGLDETACHSHADERPROC glad_glDetachShader;
PFNGLSCALEFPROC glad_glScalef;
PFNGLENDQUERYPROC glad_glEndQuery;
PFNGLSCALEDPROC glad_glScaled;
PFNGLEDGEFLAGPOINTERPROC glad_glEdgeFlagPointer;
PFNGLCOPYPIXELSPROC glad_glCopyPixels;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
PFNGLPOPATTRIBPROC glad_glPopAttrib;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
PFNGLNORMALP3UIVPROC glad_glNormalP3uiv;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
PFNGLINITNAMESPROC glad_glInitNames;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
PFNGLCOLOR3DVPROC glad_glColor3dv;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
PFNGLWAITSYNCPROC glad_glWaitSync;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
PFNGLCOLORMATERIALPROC glad_glColorMaterial;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
PFNGLUNIFORM1FPROC glad_glUniform1f;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
PFNGLRENDERMODEPROC glad_glRenderMode;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
PFNGLWINDOWPOS2DVPROC glad_glWindowPos2dv;
PFNGLUNIFORM1IPROC glad_glUniform1i;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
PFNGLUNIFORM3IPROC glad_glUniform3i;
PFNGLPIXELTRANSFERIPROC glad_glPixelTransferi;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
PFNGLDISABLEPROC glad_glDisable;
PFNGLLOGICOPPROC glad_glLogicOp;
PFNGLEVALPOINT2PROC glad_glEvalPoint2;
PFNGLPIXELTRANSFERFPROC glad_glPixelTransferf;
PFNGLSECONDARYCOLOR3IPROC glad_glSecondaryColor3i;
PFNGLUNIFORM4UIPROC glad_glUniform4ui;
PFNGLCOLOR3FPROC glad_glColor3f;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
PFNGLGETTEXENVFVPROC glad_glGetTexEnvfv;
PFNGLRECTFVPROC glad_glRectfv;
PFNGLCULLFACEPROC glad_glCullFace;
PFNGLGETLIGHTFVPROC glad_glGetLightfv;
PFNGLCOLOR3DPROC glad_glColor3d;
PFNGLTEXGENDPROC glad_glTexGend;
PFNGLTEXGENIPROC glad_glTexGeni;
PFNGLMULTITEXCOORD3SPROC glad_glMultiTexCoord3s;
PFNGLGETSTRINGIPROC glad_glGetStringi;
PFNGLMULTITEXCOORD3IPROC glad_glMultiTexCoord3i;
PFNGLMULTITEXCOORD3FPROC glad_glMultiTexCoord3f;
PFNGLMULTITEXCOORD3DPROC glad_glMultiTexCoord3d;
PFNGLATTACHSHADERPROC glad_glAttachShader;
PFNGLFOGCOORDDVPROC glad_glFogCoorddv;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
PFNGLGETTEXGENFVPROC glad_glGetTexGenfv;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
PFNGLFOGCOORDPOINTERPROC glad_glFogCoordPointer;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
PFNGLTEXGENIVPROC glad_glTexGeniv;
PFNGLRASTERPOS2DVPROC glad_glRasterPos2dv;
PFNGLSECONDARYCOLOR3DVPROC glad_glSecondaryColor3dv;
PFNGLCLIENTACTIVETEXTUREPROC glad_glClientActiveTexture;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
PFNGLSECONDARYCOLOR3USPROC glad_glSecondaryColor3us;
PFNGLNORMALP3UIPROC glad_glNormalP3ui;
PFNGLTEXENVFVPROC glad_glTexEnvfv;
PFNGLREADBUFFERPROC glad_glReadBuffer;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
PFNGLWINDOWPOS3FVPROC glad_glWindowPos3fv;
PFNGLLIGHTMODELFVPROC glad_glLightModelfv;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
PFNGLDELETELISTSPROC glad_glDeleteLists;
PFNGLGETCLIPPLANEPROC glad_glGetClipPlane;
PFNGLVERTEX4DVPROC glad_glVertex4dv;
PFNGLTEXCOORD2DPROC glad_glTexCoord2d;
PFNGLPOPMATRIXPROC glad_glPopMatrix;
PFNGLTEXCOORD2FPROC glad_glTexCoord2f;
PFNGLCOLOR4IVPROC glad_glColor4iv;
PFNGLINDEXUBVPROC glad_glIndexubv;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
PFNGLTEXCOORD2IPROC glad_glTexCoord2i;
PFNGLRASTERPOS4DPROC glad_glRasterPos4d;
PFNGLRASTERPOS4FPROC glad_glRasterPos4f;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
PFNGLTEXCOORD2SPROC glad_glTexCoord2s;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
PFNGLVERTEX3FVPROC glad_glVertex3fv;
PFNGLTEXCOORD4DVPROC glad_glTexCoord4dv;
PFNGLMATERIALIVPROC glad_glMaterialiv;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
PFNGLISPROGRAMPROC glad_glIsProgram;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
PFNGLVERTEX4SPROC glad_glVertex4s;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
PFNGLNORMAL3DVPROC glad_glNormal3dv;
PFNGLUNIFORM4IPROC glad_glUniform4i;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
PFNGLROTATEDPROC glad_glRotated;
PFNGLROTATEFPROC glad_glRotatef;
PFNGLVERTEX4IPROC glad_glVertex4i;
PFNGLREADPIXELSPROC glad_glReadPixels;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
PFNGLLOADNAMEPROC glad_glLoadName;
PFNGLUNIFORM4FPROC glad_glUniform4f;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
PFNGLSHADEMODELPROC glad_glShadeModel;
PFNGLMAPGRID1DPROC glad_glMapGrid1d;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
PFNGLMAPGRID1FPROC glad_glMapGrid1f;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
PFNGLDISABLECLIENTSTATEPROC glad_glDisableClientState;
PFNGLMULTITEXCOORD3SVPROC glad_glMultiTexCoord3sv;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
PFNGLSECONDARYCOLORPOINTERPROC glad_glSecondaryColorPointer;
PFNGLALPHAFUNCPROC glad_glAlphaFunc;
PFNGLUNIFORM1IVPROC glad_glUniform1iv;
PFNGLMULTITEXCOORD4IVPROC glad_glMultiTexCoord4iv;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
PFNGLSTENCILFUNCPROC glad_glStencilFunc;
PFNGLMULTITEXCOORD1FVPROC glad_glMultiTexCoord1fv;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
PFNGLCOLOR4UIVPROC glad_glColor4uiv;
PFNGLRECTIVPROC glad_glRectiv;
PFNGLCOLORP4UIPROC glad_glColorP4ui;
PFNGLRASTERPOS3DVPROC glad_glRasterPos3dv;
PFNGLEVALMESH2PROC glad_glEvalMesh2;
PFNGLEVALMESH1PROC glad_glEvalMesh1;
PFNGLTEXCOORDPOINTERPROC glad_glTexCoordPointer;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
PFNGLEVALCOORD2FVPROC glad_glEvalCoord2fv;
PFNGLCOLOR4UBVPROC glad_glColor4ubv;
PFNGLLOADTRANSPOSEMATRIXDPROC glad_glLoadTransposeMatrixd;
PFNGLLOADTRANSPOSEMATRIXFPROC glad_glLoadTransposeMatrixf;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
PFNGLRASTERPOS2IVPROC glad_glRasterPos2iv;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
PFNGLTEXENVIVPROC glad_glTexEnviv;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
PFNGLGENBUFFERSPROC glad_glGenBuffers;
PFNGLSELECTBUFFERPROC glad_glSelectBuffer;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
PFNGLPUSHATTRIBPROC glad_glPushAttrib;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
PFNGLBLENDFUNCPROC glad_glBlendFunc;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
PFNGLLIGHTIVPROC glad_glLightiv;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
PFNGLTEXGENFVPROC glad_glTexGenfv;
PFNGLENDPROC glad_glEnd;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
PFNGLSCISSORPROC glad_glScissor;
PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv;
PFNGLCLIPPLANEPROC glad_glClipPlane;
PFNGLPUSHNAMEPROC glad_glPushName;
PFNGLTEXGENDVPROC glad_glTexGendv;
PFNGLINDEXUBPROC glad_glIndexub;
PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv;
PFNGLSECONDARYCOLOR3IVPROC glad_glSecondaryColor3iv;
PFNGLRASTERPOS4IPROC glad_glRasterPos4i;
PFNGLMULTTRANSPOSEMATRIXDPROC glad_glMultTransposeMatrixd;
PFNGLCLEARCOLORPROC glad_glClearColor;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
PFNGLNORMAL3SPROC glad_glNormal3s;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
PFNGLCOLORP4UIVPROC glad_glColorP4uiv;
PFNGLBLENDCOLORPROC glad_glBlendColor;
PFNGLWINDOWPOS3DPROC glad_glWindowPos3d;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
PFNGLUNIFORM3UIPROC glad_glUniform3ui;
PFNGLCOLOR4DVPROC glad_glColor4dv;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
PFNGLUNIFORM2FVPROC glad_glUniform2fv;
PFNGLSECONDARYCOLOR3UBPROC glad_glSecondaryColor3ub;
PFNGLSECONDARYCOLOR3UIPROC glad_glSecondaryColor3ui;
PFNGLTEXCOORD3DVPROC glad_glTexCoord3dv;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
PFNGLNORMAL3IVPROC glad_glNormal3iv;
PFNGLWINDOWPOS3SPROC glad_glWindowPos3s;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
PFNGLWINDOWPOS3IPROC glad_glWindowPos3i;
PFNGLMULTITEXCOORD4SPROC glad_glMultiTexCoord4s;
PFNGLWINDOWPOS3FPROC glad_glWindowPos3f;
PFNGLCOLOR3USPROC glad_glColor3us;
PFNGLCOLOR3UIVPROC glad_glColor3uiv;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
PFNGLGETLIGHTIVPROC glad_glGetLightiv;
PFNGLDEPTHFUNCPROC glad_glDepthFunc;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
PFNGLLISTBASEPROC glad_glListBase;
PFNGLMULTITEXCOORD4FPROC glad_glMultiTexCoord4f;
PFNGLCOLOR3UBPROC glad_glColor3ub;
PFNGLMULTITEXCOORD4DPROC glad_glMultiTexCoord4d;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
PFNGLCOLOR3UIPROC glad_glColor3ui;
PFNGLMULTITEXCOORD4IPROC glad_glMultiTexCoord4i;
PFNGLGETPOLYGONSTIPPLEPROC glad_glGetPolygonStipple;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
PFNGLMULTITEXCOORD4DVPROC glad_glMultiTexCoord4dv;
PFNGLCOLORMASKPROC glad_glColorMask;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
PFNGLRASTERPOS4SPROC glad_glRasterPos4s;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
PFNGLMULTITEXCOORD3DVPROC glad_glMultiTexCoord3dv;
PFNGLCOLOR4SVPROC glad_glColor4sv;
PFNGLPOPCLIENTATTRIBPROC glad_glPopClientAttrib;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
PFNGLFOGFPROC glad_glFogf;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
PFNGLISSAMPLERPROC glad_glIsSampler;
PFNGLVERTEXP3UIPROC glad_glVertexP3ui;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
PFNGLCOLOR3IVPROC glad_glColor3iv;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
PFNGLTEXCOORD1IPROC glad_glTexCoord1i;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
PFNGLTEXCOORD1DPROC glad_glTexCoord1d;
PFNGLTEXCOORD1FPROC glad_glTexCoord1f;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
PFNGLENABLECLIENTSTATEPROC glad_glEnableClientState;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
PFNGLMULTITEXCOORD2SVPROC glad_glMultiTexCoord2sv;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
PFNGLTEXCOORD1SPROC glad_glTexCoord1s;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
PFNGLGENLISTSPROC glad_glGenLists;
PFNGLCOLOR3BVPROC glad_glColor3bv;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
PFNGLGETTEXGENDVPROC glad_glGetTexGendv;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
PFNGLENDLISTPROC glad_glEndList;
PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv;
PFNGLUNIFORM2UIPROC glad_glUniform2ui;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
PFNGLCOLOR3USVPROC glad_glColor3usv;
PFNGLWINDOWPOS2FVPROC glad_glWindowPos2fv;
PFNGLDISABLEIPROC glad_glDisablei;
PFNGLINDEXMASKPROC glad_glIndexMask;
PFNGLPUSHCLIENTATTRIBPROC glad_glPushClientAttrib;
PFNGLSHADERSOURCEPROC glad_glShaderSource;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
PFNGLCLEARACCUMPROC glad_glClearAccum;
PFNGLGETSYNCIVPROC glad_glGetSynciv;
PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv;
PFNGLUNIFORM2FPROC glad_glUniform2f;
PFNGLBEGINQUERYPROC glad_glBeginQuery;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
PFNGLBINDBUFFERPROC glad_glBindBuffer;
PFNGLMAP2DPROC glad_glMap2d;
PFNGLMAP2FPROC glad_glMap2f;
PFNGLVERTEX4DPROC glad_glVertex4d;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
PFNGLTEXCOORD1SVPROC glad_glTexCoord1sv;
PFNGLBUFFERDATAPROC glad_glBufferData;
PFNGLEVALPOINT1PROC glad_glEvalPoint1;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
PFNGLTEXCOORD1DVPROC glad_glTexCoord1dv;
PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui;
PFNGLGETERRORPROC glad_glGetError;
PFNGLGETTEXENVIVPROC glad_glGetTexEnviv;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
PFNGLGETFLOATVPROC glad_glGetFloatv;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
PFNGLMULTITEXCOORD2FVPROC glad_glMultiTexCoord2fv;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
PFNGLEVALCOORD1DPROC glad_glEvalCoord1d;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
PFNGLEVALCOORD1FPROC glad_glEvalCoord1f;
PFNGLPIXELMAPFVPROC glad_glPixelMapfv;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
PFNGLGETPIXELMAPUSVPROC glad_glGetPixelMapusv;
PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv;
PFNGLGETINTEGERVPROC glad_glGetIntegerv;
PFNGLACCUMPROC glad_glAccum;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
PFNGLRASTERPOS4DVPROC glad_glRasterPos4dv;
PFNGLTEXCOORD2IVPROC glad_glTexCoord2iv;
PFNGLISQUERYPROC glad_glIsQuery;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
PFNGLWINDOWPOS3DVPROC glad_glWindowPos3dv;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
PFNGLSTENCILMASKPROC glad_glStencilMask;
PFNGLDRAWPIXELSPROC glad_glDrawPixels;
PFNGLMULTMATRIXDPROC glad_glMultMatrixd;
PFNGLMULTMATRIXFPROC glad_glMultMatrixf;
PFNGLISTEXTUREPROC glad_glIsTexture;
PFNGLGETMATERIALIVPROC glad_glGetMaterialiv;
PFNGLUNIFORM1FVPROC glad_glUniform1fv;
PFNGLLOADMATRIXFPROC glad_glLoadMatrixf;
PFNGLLOADMATRIXDPROC glad_glLoadMatrixd;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
PFNGLVERTEX4FPROC glad_glVertex4f;
PFNGLRECTSVPROC glad_glRectsv;
PFNGLCOLOR4USVPROC glad_glColor4usv;
PFNGLPOLYGONSTIPPLEPROC glad_glPolygonStipple;
PFNGLINTERLEAVEDARRAYSPROC glad_glInterleavedArrays;
PFNGLNORMAL3IPROC glad_glNormal3i;
PFNGLNORMAL3FPROC glad_glNormal3f;
PFNGLNORMAL3DPROC glad_glNormal3d;
PFNGLNORMAL3BPROC glad_glNormal3b;
PFNGLPIXELMAPUSVPROC glad_glPixelMapusv;
PFNGLGETTEXGENIVPROC glad_glGetTexGeniv;
PFNGLARRAYELEMENTPROC glad_glArrayElement;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
PFNGLDEPTHMASKPROC glad_glDepthMask;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
PFNGLCOLOR3FVPROC glad_glColor3fv;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
PFNGLUNIFORM4FVPROC glad_glUniform4fv;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
PFNGLCOLORPOINTERPROC glad_glColorPointer;
PFNGLFRONTFACEPROC glad_glFrontFace;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
static void load_GL_VERSION_1_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_0) return;
	glad_glCullFace = (PFNGLCULLFACEPROC)load("glCullFace");
	glad_glFrontFace = (PFNGLFRONTFACEPROC)load("glFrontFace");
	glad_glHint = (PFNGLHINTPROC)load("glHint");
	glad_glLineWidth = (PFNGLLINEWIDTHPROC)load("glLineWidth");
	glad_glPointSize = (PFNGLPOINTSIZEPROC)load("glPointSize");
	glad_glPolygonMode = (PFNGLPOLYGONMODEPROC)load("glPolygonMode");
	glad_glScissor = (PFNGLSCISSORPROC)load("glScissor");
	glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC)load("glTexParameterf");
	glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC)load("glTexParameterfv");
	glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC)load("glTexParameteri");
	glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC)load("glTexParameteriv");
	glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC)load("glTexImage1D");
	glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC)load("glTexImage2D");
	glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC)load("glDrawBuffer");
	glad_glClear = (PFNGLCLEARPROC)load("glClear");
	glad_glClearColor = (PFNGLCLEARCOLORPROC)load("glClearColor");
	glad_glClearStencil = (PFNGLCLEARSTENCILPROC)load("glClearStencil");
	glad_glClearDepth = (PFNGLCLEARDEPTHPROC)load("glClearDepth");
	glad_glStencilMask = (PFNGLSTENCILMASKPROC)load("glStencilMask");
	glad_glColorMask = (PFNGLCOLORMASKPROC)load("glColorMask");
	glad_glDepthMask = (PFNGLDEPTHMASKPROC)load("glDepthMask");
	glad_glDisable = (PFNGLDISABLEPROC)load("glDisable");
	glad_glEnable = (PFNGLENABLEPROC)load("glEnable");
	glad_glFinish = (PFNGLFINISHPROC)load("glFinish");
	glad_glFlush = (PFNGLFLUSHPROC)load("glFlush");
	glad_glBlendFunc = (PFNGLBLENDFUNCPROC)load("glBlendFunc");
	glad_glLogicOp = (PFNGLLOGICOPPROC)load("glLogicOp");
	glad_glStencilFunc = (PFNGLSTENCILFUNCPROC)load("glStencilFunc");
	glad_glStencilOp = (PFNGLSTENCILOPPROC)load("glStencilOp");
	glad_glDepthFunc = (PFNGLDEPTHFUNCPROC)load("glDepthFunc");
	glad_glPixelStoref = (PFNGLPIXELSTOREFPROC)load("glPixelStoref");
	glad_glPixelStorei = (PFNGLPIXELSTOREIPROC)load("glPixelStorei");
	glad_glReadBuffer = (PFNGLREADBUFFERPROC)load("glReadBuffer");
	glad_glReadPixels = (PFNGLREADPIXELSPROC)load("glReadPixels");
	glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC)load("glGetBooleanv");
	glad_glGetDoublev = (PFNGLGETDOUBLEVPROC)load("glGetDoublev");
	glad_glGetError = (PFNGLGETERRORPROC)load("glGetError");
	glad_glGetFloatv = (PFNGLGETFLOATVPROC)load("glGetFloatv");
	glad_glGetIntegerv = (PFNGLGETINTEGERVPROC)load("glGetIntegerv");
	glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
	glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC)load("glGetTexImage");
	glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC)load("glGetTexParameterfv");
	glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC)load("glGetTexParameteriv");
	glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC)load("glGetTexLevelParameterfv");
	glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC)load("glGetTexLevelParameteriv");
	glad_glIsEnabled = (PFNGLISENABLEDPROC)load("glIsEnabled");
	glad_glDepthRange = (PFNGLDEPTHRANGEPROC)load("glDepthRange");
	glad_glViewport = (PFNGLVIEWPORTPROC)load("glViewport");
	glad_glNewList = (PFNGLNEWLISTPROC)load("glNewList");
	glad_glEndList = (PFNGLENDLISTPROC)load("glEndList");
	glad_glCallList = (PFNGLCALLLISTPROC)load("glCallList");
	glad_glCallLists = (PFNGLCALLLISTSPROC)load("glCallLists");
	glad_glDeleteLists = (PFNGLDELETELISTSPROC)load("glDeleteLists");
	glad_glGenLists = (PFNGLGENLISTSPROC)load("glGenLists");
	glad_glListBase = (PFNGLLISTBASEPROC)load("glListBase");
	glad_glBegin = (PFNGLBEGINPROC)load("glBegin");
	glad_glBitmap = (PFNGLBITMAPPROC)load("glBitmap");
	glad_glColor3b = (PFNGLCOLOR3BPROC)load("glColor3b");
	glad_glColor3bv = (PFNGLCOLOR3BVPROC)load("glColor3bv");
	glad_glColor3d = (PFNGLCOLOR3DPROC)load("glColor3d");
	glad_glColor3dv = (PFNGLCOLOR3DVPROC)load("glColor3dv");
	glad_glColor3f = (PFNGLCOLOR3FPROC)load("glColor3f");
	glad_glColor3fv = (PFNGLCOLOR3FVPROC)load("glColor3fv");
	glad_glColor3i = (PFNGLCOLOR3IPROC)load("glColor3i");
	glad_glColor3iv = (PFNGLCOLOR3IVPROC)load("glColor3iv");
	glad_glColor3s = (PFNGLCOLOR3SPROC)load("glColor3s");
	glad_glColor3sv = (PFNGLCOLOR3SVPROC)load("glColor3sv");
	glad_glColor3ub = (PFNGLCOLOR3UBPROC)load("glColor3ub");
	glad_glColor3ubv = (PFNGLCOLOR3UBVPROC)load("glColor3ubv");
	glad_glColor3ui = (PFNGLCOLOR3UIPROC)load("glColor3ui");
	glad_glColor3uiv = (PFNGLCOLOR3UIVPROC)load("glColor3uiv");
	glad_glColor3us = (PFNGLCOLOR3USPROC)load("glColor3us");
	glad_glColor3usv = (PFNGLCOLOR3USVPROC)load("glColor3usv");
	glad_glColor4b = (PFNGLCOLOR4BPROC)load("glColor4b");
	glad_glColor4bv = (PFNGLCOLOR4BVPROC)load("glColor4bv");
	glad_glColor4d = (PFNGLCOLOR4DPROC)load("glColor4d");
	glad_glColor4dv = (PFNGLCOLOR4DVPROC)load("glColor4dv");
	glad_glColor4f = (PFNGLCOLOR4FPROC)load("glColor4f");
	glad_glColor4fv = (PFNGLCOLOR4FVPROC)load("glColor4fv");
	glad_glColor4i = (PFNGLCOLOR4IPROC)load("glColor4i");
	glad_glColor4iv = (PFNGLCOLOR4IVPROC)load("glColor4iv");
	glad_glColor4s = (PFNGLCOLOR4SPROC)load("glColor4s");
	glad_glColor4sv = (PFNGLCOLOR4SVPROC)load("glColor4sv");
	glad_glColor4ub = (PFNGLCOLOR4UBPROC)load("glColor4ub");
	glad_glColor4ubv = (PFNGLCOLOR4UBVPROC)load("glColor4ubv");
	glad_glColor4ui = (PFNGLCOLOR4UIPROC)load("glColor4ui");
	glad_glColor4uiv = (PFNGLCOLOR4UIVPROC)load("glColor4uiv");
	glad_glColor4us = (PFNGLCOLOR4USPROC)load("glColor4us");
	glad_glColor4usv = (PFNGLCOLOR4USVPROC)load("glColor4usv");
	glad_glEdgeFlag = (PFNGLEDGEFLAGPROC)load("glEdgeFlag");
	glad_glEdgeFlagv = (PFNGLEDGEFLAGVPROC)load("glEdgeFlagv");
	glad_glEnd = (PFNGLENDPROC)load("glEnd");
	glad_glIndexd = (PFNGLINDEXDPROC)load("glIndexd");
	glad_glIndexdv = (PFNGLINDEXDVPROC)load("glIndexdv");
	glad_glIndexf = (PFNGLINDEXFPROC)load("glIndexf");
	glad_glIndexfv = (PFNGLINDEXFVPROC)load("glIndexfv");
	glad_glIndexi = (PFNGLINDEXIPROC)load("glIndexi");
	glad_glIndexiv = (PFNGLINDEXIVPROC)load("glIndexiv");
	glad_glIndexs = (PFNGLINDEXSPROC)load("glIndexs");
	glad_glIndexsv = (PFNGLINDEXSVPROC)load("glIndexsv");
	glad_glNormal3b = (PFNGLNORMAL3BPROC)load("glNormal3b");
	glad_glNormal3bv = (PFNGLNORMAL3BVPROC)load("glNormal3bv");
	glad_glNormal3d = (PFNGLNORMAL3DPROC)load("glNormal3d");
	glad_glNormal3dv = (PFNGLNORMAL3DVPROC)load("glNormal3dv");
	glad_glNormal3f = (PFNGLNORMAL3FPROC)load("glNormal3f");
	glad_glNormal3fv = (PFNGLNORMAL3FVPROC)load("glNormal3fv");
	glad_glNormal3i = (PFNGLNORMAL3IPROC)load("glNormal3i");
	glad_glNormal3iv = (PFNGLNORMAL3IVPROC)load("glNormal3iv");
	glad_glNormal3s = (PFNGLNORMAL3SPROC)load("glNormal3s");
	glad_glNormal3sv = (PFNGLNORMAL3SVPROC)load("glNormal3sv");
	glad_glRasterPos2d = (PFNGLRASTERPOS2DPROC)load("glRasterPos2d");
	glad_glRasterPos2dv = (PFNGLRASTERPOS2DVPROC)load("glRasterPos2dv");
	glad_glRasterPos2f = (PFNGLRASTERPOS2FPROC)load("glRasterPos2f");
	glad_glRasterPos2fv = (PFNGLRASTERPOS2FVPROC)load("glRasterPos2fv");
	glad_glRasterPos2i = (PFNGLRASTERPOS2IPROC)load("glRasterPos2i");
	glad_glRasterPos2iv = (PFNGLRASTERPOS2IVPROC)load("glRasterPos2iv");
	glad_glRasterPos2s = (PFNGLRASTERPOS2SPROC)load("glRasterPos2s");
	glad_glRasterPos2sv = (PFNGLRASTERPOS2SVPROC)load("glRasterPos2sv");
	glad_glRasterPos3d = (PFNGLRASTERPOS3DPROC)load("glRasterPos3d");
	glad_glRasterPos3dv = (PFNGLRASTERPOS3DVPROC)load("glRasterPos3dv");
	glad_glRasterPos3f = (PFNGLRASTERPOS3FPROC)load("glRasterPos3f");
	glad_glRasterPos3fv = (PFNGLRASTERPOS3FVPROC)load("glRasterPos3fv");
	glad_glRasterPos3i = (PFNGLRASTERPOS3IPROC)load("glRasterPos3i");
	glad_glRasterPos3iv = (PFNGLRASTERPOS3IVPROC)load("glRasterPos3iv");
	glad_glRasterPos3s = (PFNGLRASTERPOS3SPROC)load("glRasterPos3s");
	glad_glRasterPos3sv = (PFNGLRASTERPOS3SVPROC)load("glRasterPos3sv");
	glad_glRasterPos4d = (PFNGLRASTERPOS4DPROC)load("glRasterPos4d");
	glad_glRasterPos4dv = (PFNGLRASTERPOS4DVPROC)load("glRasterPos4dv");
	glad_glRasterPos4f = (PFNGLRASTERPOS4FPROC)load("glRasterPos4f");
	glad_glRasterPos4fv = (PFNGLRASTERPOS4FVPROC)load("glRasterPos4fv");
	glad_glRasterPos4i = (PFNGLRASTERPOS4IPROC)load("glRasterPos4i");
	glad_glRasterPos4iv = (PFNGLRASTERPOS4IVPROC)load("glRasterPos4iv");
	glad_glRasterPos4s = (PFNGLRASTERPOS4SPROC)load("glRasterPos4s");
	glad_glRasterPos4sv = (PFNGLRASTERPOS4SVPROC)load("glRasterPos4sv");
	glad_glRectd = (PFNGLRECTDPROC)load("glRectd");
	glad_glRectdv = (PFNGLRECTDVPROC)load("glRectdv");
	glad_glRectf = (PFNGLRECTFPROC)load("glRectf");
	glad_glRectfv = (PFNGLRECTFVPROC)load("glRectfv");
	glad_glRecti = (PFNGLRECTIPROC)load("glRecti");
	glad_glRectiv = (PFNGLRECTIVPROC)load("glRectiv");
	glad_glRects = (PFNGLRECTSPROC)load("glRects");
	glad_glRectsv = (PFNGLRECTSVPROC)load("glRectsv");
	glad_glTexCoord1d = (PFNGLTEXCOORD1DPROC)load("glTexCoord1d");
	glad_glTexCoord1dv = (PFNGLTEXCOORD1DVPROC)load("glTexCoord1dv");
	glad_glTexCoord1f = (PFNGLTEXCOORD1FPROC)load("glTexCoord1f");
	glad_glTexCoord1fv = (PFNGLTEXCOORD1FVPROC)load("glTexCoord1fv");
	glad_glTexCoord1i = (PFNGLTEXCOORD1IPROC)load("glTexCoord1i");
	glad_glTexCoord1iv = (PFNGLTEXCOORD1IVPROC)load("glTexCoord1iv");
	glad_glTexCoord1s = (PFNGLTEXCOORD1SPROC)load("glTexCoord1s");
	glad_glTexCoord1sv = (PFNGLTEXCOORD1SVPROC)load("glTexCoord1sv");
	glad_glTexCoord2d = (PFNGLTEXCOORD2DPROC)load("glTexCoord2d");
	glad_glTexCoord2dv = (PFNGLTEXCOORD2DVPROC)load("glTexCoord2dv");
	glad_glTexCoord2f = (PFNGLTEXCOORD2FPROC)load("glTexCoord2f");
	glad_glTexCoord2fv = (PFNGLTEXCOORD2FVPROC)load("glTexCoord2fv");
	glad_glTexCoord2i = (PFNGLTEXCOORD2IPROC)load("glTexCoord2i");
	glad_glTexCoord2iv = (PFNGLTEXCOORD2IVPROC)load("glTexCoord2iv");
	glad_glTexCoord2s = (PFNGLTEXCOORD2SPROC)load("glTexCoord2s");
	glad_glTexCoord2sv = (PFNGLTEXCOORD2SVPROC)load("glTexCoord2sv");
	glad_glTexCoord3d = (PFNGLTEXCOORD3DPROC)load("glTexCoord3d");
	glad_glTexCoord3dv = (PFNGLTEXCOORD3DVPROC)load("glTexCoord3dv");
	glad_glTexCoord3f = (PFNGLTEXCOORD3FPROC)load("glTexCoord3f");
	glad_glTexCoord3fv = (PFNGLTEXCOORD3FVPROC)load("glTexCoord3fv");
	glad_glTexCoord3i = (PFNGLTEXCOORD3IPROC)load("glTexCoord3i");
	glad_glTexCoord3iv = (PFNGLTEXCOORD3IVPROC)load("glTexCoord3iv");
	glad_glTexCoord3s = (PFNGLTEXCOORD3SPROC)load("glTexCoord3s");
	glad_glTexCoord3sv = (PFNGLTEXCOORD3SVPROC)load("glTexCoord3sv");
	glad_glTexCoord4d = (PFNGLTEXCOORD4DPROC)load("glTexCoord4d");
	glad_glTexCoord4dv = (PFNGLTEXCOORD4DVPROC)load("glTexCoord4dv");
	glad_glTexCoord4f = (PFNGLTEXCOORD4FPROC)load("glTexCoord4f");
	glad_glTexCoord4fv = (PFNGLTEXCOORD4FVPROC)load("glTexCoord4fv");
	glad_glTexCoord4i = (PFNGLTEXCOORD4IPROC)load("glTexCoord4i");
	glad_glTexCoord4iv = (PFNGLTEXCOORD4IVPROC)load("glTexCoord4iv");
	glad_glTexCoord4s = (PFNGLTEXCOORD4SPROC)load("glTexCoord4s");
	glad_glTexCoord4sv = (PFNGLTEXCOORD4SVPROC)load("glTexCoord4sv");
	glad_glVertex2d = (PFNGLVERTEX2DPROC)load("glVertex2d");
	glad_glVertex2dv = (PFNGLVERTEX2DVPROC)load("glVertex2dv");
	glad_glVertex2f = (PFNGLVERTEX2FPROC)load("glVertex2f");
	glad_glVertex2fv = (PFNGLVERTEX2FVPROC)load("glVertex2fv");
	glad_glVertex2i = (PFNGLVERTEX2IPROC)load("glVertex2i");
	glad_glVertex2iv = (PFNGLVERTEX2IVPROC)load("glVertex2iv");
	glad_glVertex2s = (PFNGLVERTEX2SPROC)load("glVertex2s");
	glad_glVertex2sv = (PFNGLVERTEX2SVPROC)load("glVertex2sv");
	glad_glVertex3d = (PFNGLVERTEX3DPROC)load("glVertex3d");
	glad_glVertex3dv = (PFNGLVERTEX3DVPROC)load("glVertex3dv");
	glad_glVertex3f = (PFNGLVERTEX3FPROC)load("glVertex3f");
	glad_glVertex3fv = (PFNGLVERTEX3FVPROC)load("glVertex3fv");
	glad_glVertex3i = (PFNGLVERTEX3IPROC)load("glVertex3i");
	glad_glVertex3iv = (PFNGLVERTEX3IVPROC)load("glVertex3iv");
	glad_glVertex3s = (PFNGLVERTEX3SPROC)load("glVertex3s");
	glad_glVertex3sv = (PFNGLVERTEX3SVPROC)load("glVertex3sv");
	glad_glVertex4d = (PFNGLVERTEX4DPROC)load("glVertex4d");
	glad_glVertex4dv = (PFNGLVERTEX4DVPROC)load("glVertex4dv");
	glad_glVertex4f = (PFNGLVERTEX4FPROC)load("glVertex4f");
	glad_glVertex4fv = (PFNGLVERTEX4FVPROC)load("glVertex4fv");
	glad_glVertex4i = (PFNGLVERTEX4IPROC)load("glVertex4i");
	glad_glVertex4iv = (PFNGLVERTEX4IVPROC)load("glVertex4iv");
	glad_glVertex4s = (PFNGLVERTEX4SPROC)load("glVertex4s");
	glad_glVertex4sv = (PFNGLVERTEX4SVPROC)load("glVertex4sv");
	glad_glClipPlane = (PFNGLCLIPPLANEPROC)load("glClipPlane");
	glad_glColorMaterial = (PFNGLCOLORMATERIALPROC)load("glColorMaterial");
	glad_glFogf = (PFNGLFOGFPROC)load("glFogf");
	glad_glFogfv = (PFNGLFOGFVPROC)load("glFogfv");
	glad_glFogi = (PFNGLFOGIPROC)load("glFogi");
	glad_glFogiv = (PFNGLFOGIVPROC)load("glFogiv");
	glad_glLightf = (PFNGLLIGHTFPROC)load("glLightf");
	glad_glLightfv = (PFNGLLIGHTFVPROC)load("glLightfv");
	glad_glLighti = (PFNGLLIGHTIPROC)load("glLighti");
	glad_glLightiv = (PFNGLLIGHTIVPROC)load("glLightiv");
	glad_glLightModelf = (PFNGLLIGHTMODELFPROC)load("glLightModelf");
	glad_glLightModelfv = (PFNGLLIGHTMODELFVPROC)load("glLightModelfv");
	glad_glLightModeli = (PFNGLLIGHTMODELIPROC)load("glLightModeli");
	glad_glLightModeliv = (PFNGLLIGHTMODELIVPROC)load("glLightModeliv");
	glad_glLineStipple = (PFNGLLINESTIPPLEPROC)load("glLineStipple");
	glad_glMaterialf = (PFNGLMATERIALFPROC)load("glMaterialf");
	glad_glMaterialfv = (PFNGLMATERIALFVPROC)load("glMaterialfv");
	glad_glMateriali = (PFNGLMATERIALIPROC)load("glMateriali");
	glad_glMaterialiv = (PFNGLMATERIALIVPROC)load("glMaterialiv");
	glad_glPolygonStipple = (PFNGLPOLYGONSTIPPLEPROC)load("glPolygonStipple");
	glad_glShadeModel = (PFNGLSHADEMODELPROC)load("glShadeModel");
	glad_glTexEnvf = (PFNGLTEXENVFPROC)load("glTexEnvf");
	glad_glTexEnvfv = (PFNGLTEXENVFVPROC)load("glTexEnvfv");
	glad_glTexEnvi = (PFNGLTEXENVIPROC)load("glTexEnvi");
	glad_glTexEnviv = (PFNGLTEXENVIVPROC)load("glTexEnviv");
	glad_glTexGend = (PFNGLTEXGENDPROC)load("glTexGend");
	glad_glTexGendv = (PFNGLTEXGENDVPROC)load("glTexGendv");
	glad_glTexGenf = (PFNGLTEXGENFPROC)load("glTexGenf");
	glad_glTexGenfv = (PFNGLTEXGENFVPROC)load("glTexGenfv");
	glad_glTexGeni = (PFNGLTEXGENIPROC)load("glTexGeni");
	glad_glTexGeniv = (PFNGLTEXGENIVPROC)load("glTexGeniv");
	glad_glFeedbackBuffer = (PFNGLFEEDBACKBUFFERPROC)load("glFeedbackBuffer");
	glad_glSelectBuffer = (PFNGLSELECTBUFFERPROC)load("glSelectBuffer");
	glad_glRenderMode = (PFNGLRENDERMODEPROC)load("glRenderMode");
	glad_glInitNames = (PFNGLINITNAMESPROC)load("glInitNames");
	glad_glLoadName = (PFNGLLOADNAMEPROC)load("glLoadName");
	glad_glPassThrough = (PFNGLPASSTHROUGHPROC)load("glPassThrough");
	glad_glPopName = (PFNGLPOPNAMEPROC)load("glPopName");
	glad_glPushName = (PFNGLPUSHNAMEPROC)load("glPushName");
	glad_glClearAccum = (PFNGLCLEARACCUMPROC)load("glClearAccum");
	glad_glClearIndex = (PFNGLCLEARINDEXPROC)load("glClearIndex");
	glad_glIndexMask = (PFNGLINDEXMASKPROC)load("glIndexMask");
	glad_glAccum = (PFNGLACCUMPROC)load("glAccum");
	glad_glPopAttrib = (PFNGLPOPATTRIBPROC)load("glPopAttrib");
	glad_glPushAttrib = (PFNGLPUSHATTRIBPROC)load("glPushAttrib");
	glad_glMap1d = (PFNGLMAP1DPROC)load("glMap1d");
	glad_glMap1f = (PFNGLMAP1FPROC)load("glMap1f");
	glad_glMap2d = (PFNGLMAP2DPROC)load("glMap2d");
	glad_glMap2f = (PFNGLMAP2FPROC)load("glMap2f");
	glad_glMapGrid1d = (PFNGLMAPGRID1DPROC)load("glMapGrid1d");
	glad_glMapGrid1f = (PFNGLMAPGRID1FPROC)load("glMapGrid1f");
	glad_glMapGrid2d = (PFNGLMAPGRID2DPROC)load("glMapGrid2d");
	glad_glMapGrid2f = (PFNGLMAPGRID2FPROC)load("glMapGrid2f");
	glad_glEvalCoord1d = (PFNGLEVALCOORD1DPROC)load("glEvalCoord1d");
	glad_glEvalCoord1dv = (PFNGLEVALCOORD1DVPROC)load("glEvalCoord1dv");
	glad_glEvalCoord1f = (PFNGLEVALCOORD1FPROC)load("glEvalCoord1f");
	glad_glEvalCoord1fv = (PFNGLEVALCOORD1FVPROC)load("glEvalCoord1fv");
	glad_glEvalCoord2d = (PFNGLEVALCOORD2DPROC)load("glEvalCoord2d");
	glad_glEvalCoord2dv = (PFNGLEVALCOORD2DVPROC)load("glEvalCoord2dv");
	glad_glEvalCoord2f = (PFNGLEVALCOORD2FPROC)load("glEvalCoord2f");
	glad_glEvalCoord2fv = (PFNGLEVALCOORD2FVPROC)load("glEvalCoord2fv");
	glad_glEvalMesh1 = (PFNGLEVALMESH1PROC)load("glEvalMesh1");
	glad_glEvalPoint1 = (PFNGLEVALPOINT1PROC)load("glEvalPoint1");
	glad_glEvalMesh2 = (PFNGLEVALMESH2PROC)load("glEvalMesh2");
	glad_glEvalPoint2 = (PFNGLEVALPOINT2PROC)load("glEvalPoint2");
	glad_glAlphaFunc = (PFNGLALPHAFUNCPROC)load("glAlphaFunc");
	glad_glPixelZoom = (PFNGLPIXELZOOMPROC)load("glPixelZoom");
	glad_glPixelTransferf = (PFNGLPIXELTRANSFERFPROC)load("glPixelTransferf");
	glad_glPixelTransferi = (PFNGLPIXELTRANSFERIPROC)load("glPixelTransferi");
	glad_glPixelMapfv = (PFNGLPIXELMAPFVPROC)load("glPixelMapfv");
	glad_glPixelMapuiv = (PFNGLPIXELMAPUIVPROC)load("glPixelMapuiv");
	glad_glPixelMapusv = (PFNGLPIXELMAPUSVPROC)load("glPixelMapusv");
	glad_glCopyPixels = (PFNGLCOPYPIXELSPROC)load("glCopyPixels");
	glad_glDrawPixels = (PFNGLDRAWPIXELSPROC)load("glDrawPixels");
	glad_glGetClipPlane = (PFNGLGETCLIPPLANEPROC)load("glGetClipPlane");
	glad_glGetLightfv = (PFNGLGETLIGHTFVPROC)load("glGetLightfv");
	glad_glGetLightiv = (PFNGLGETLIGHTIVPROC)load("glGetLightiv");
	glad_glGetMapdv = (PFNGLGETMAPDVPROC)load("glGetMapdv");
	glad_glGetMapfv = (PFNGLGETMAPFVPROC)load("glGetMapfv");
	glad_glGetMapiv = (PFNGLGETMAPIVPROC)load("glGetMapiv");
	glad_glGetMaterialfv = (PFNGLGETMATERIALFVPROC)load("glGetMaterialfv");
	glad_glGetMaterialiv = (PFNGLGETMATERIALIVPROC)load("glGetMaterialiv");
	glad_glGetPixelMapfv = (PFNGLGETPIXELMAPFVPROC)load("glGetPixelMapfv");
	glad_glGetPixelMapuiv = (PFNGLGETPIXELMAPUIVPROC)load("glGetPixelMapuiv");
	glad_glGetPixelMapusv = (PFNGLGETPIXELMAPUSVPROC)load("glGetPixelMapusv");
	glad_glGetPolygonStipple = (PFNGLGETPOLYGONSTIPPLEPROC)load("glGetPolygonStipple");
	glad_glGetTexEnvfv = (PFNGLGETTEXENVFVPROC)load("glGetTexEnvfv");
	glad_glGetTexEnviv = (PFNGLGETTEXENVIVPROC)load("glGetTexEnviv");
	glad_glGetTexGendv = (PFNGLGETTEXGENDVPROC)load("glGetTexGendv");
	glad_glGetTexGenfv = (PFNGLGETTEXGENFVPROC)load("glGetTexGenfv");
	glad_glGetTexGeniv = (PFNGLGETTEXGENIVPROC)load("glGetTexGeniv");
	glad_glIsList = (PFNGLISLISTPROC)load("glIsList");
	glad_glFrustum = (PFNGLFRUSTUMPROC)load("glFrustum");
	glad_glLoadIdentity = (PFNGLLOADIDENTITYPROC)load("glLoadIdentity");
	glad_glLoadMatrixf = (PFNGLLOADMATRIXFPROC)load("glLoadMatrixf");
	glad_glLoadMatrixd = (PFNGLLOADMATRIXDPROC)load("glLoadMatrixd");
	glad_glMatrixMode = (PFNGLMATRIXMODEPROC)load("glMatrixMode");
	glad_glMultMatrixf = (PFNGLMULTMATRIXFPROC)load("glMultMatrixf");
	glad_glMultMatrixd = (PFNGLMULTMATRIXDPROC)load("glMultMatrixd");
	glad_glOrtho = (PFNGLORTHOPROC)load("glOrtho");
	glad_glPopMatrix = (PFNGLPOPMATRIXPROC)load("glPopMatrix");
	glad_glPushMatrix = (PFNGLPUSHMATRIXPROC)load("glPushMatrix");
	glad_glRotated = (PFNGLROTATEDPROC)load("glRotated");
	glad_glRotatef = (PFNGLROTATEFPROC)load("glRotatef");
	glad_glScaled = (PFNGLSCALEDPROC)load("glScaled");
	glad_glScalef = (PFNGLSCALEFPROC)load("glScalef");
	glad_glTranslated = (PFNGLTRANSLATEDPROC)load("glTranslated");
	glad_glTranslatef = (PFNGLTRANSLATEFPROC)load("glTranslatef");
}
static void load_GL_VERSION_1_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_1) return;
	glad_glDrawArrays = (PFNGLDRAWARRAYSPROC)load("glDrawArrays");
	glad_glDrawElements = (PFNGLDRAWELEMENTSPROC)load("glDrawElements");
	glad_glGetPointerv = (PFNGLGETPOINTERVPROC)load("glGetPointerv");
	glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC)load("glPolygonOffset");
	glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC)load("glCopyTexImage1D");
	glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC)load("glCopyTexImage2D");
	glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC)load("glCopyTexSubImage1D");
	glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC)load("glCopyTexSubImage2D");
	glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC)load("glTexSubImage1D");
	glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC)load("glTexSubImage2D");
	glad_glBindTexture = (PFNGLBINDTEXTUREPROC)load("glBindTexture");
	glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC)load("glDeleteTextures");
	glad_glGenTextures = (PFNGLGENTEXTURESPROC)load("glGenTextures");
	glad_glIsTexture = (PFNGLISTEXTUREPROC)load("glIsTexture");
	glad_glArrayElement = (PFNGLARRAYELEMENTPROC)load("glArrayElement");
	glad_glColorPointer = (PFNGLCOLORPOINTERPROC)load("glColorPointer");
	glad_glDisableClientState = (PFNGLDISABLECLIENTSTATEPROC)load("glDisableClientState");
	glad_glEdgeFlagPointer = (PFNGLEDGEFLAGPOINTERPROC)load("glEdgeFlagPointer");
	glad_glEnableClientState = (PFNGLENABLECLIENTSTATEPROC)load("glEnableClientState");
	glad_glIndexPointer = (PFNGLINDEXPOINTERPROC)load("glIndexPointer");
	glad_glInterleavedArrays = (PFNGLINTERLEAVEDARRAYSPROC)load("glInterleavedArrays");
	glad_glNormalPointer = (PFNGLNORMALPOINTERPROC)load("glNormalPointer");
	glad_glTexCoordPointer = (PFNGLTEXCOORDPOINTERPROC)load("glTexCoordPointer");
	glad_glVertexPointer = (PFNGLVERTEXPOINTERPROC)load("glVertexPointer");
	glad_glAreTexturesResident = (PFNGLARETEXTURESRESIDENTPROC)load("glAreTexturesResident");
	glad_glPrioritizeTextures = (PFNGLPRIORITIZETEXTURESPROC)load("glPrioritizeTextures");
	glad_glIndexub = (PFNGLINDEXUBPROC)load("glIndexub");
	glad_glIndexubv = (PFNGLINDEXUBVPROC)load("glIndexubv");
	glad_glPopClientAttrib = (PFNGLPOPCLIENTATTRIBPROC)load("glPopClientAttrib");
	glad_glPushClientAttrib = (PFNGLPUSHCLIENTATTRIBPROC)load("glPushClientAttrib");
}
static void load_GL_VERSION_1_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_2) return;
	glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)load("glDrawRangeElements");
	glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC)load("glTexImage3D");
	glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)load("glTexSubImage3D");
	glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)load("glCopyTexSubImage3D");
}
static void load_GL_VERSION_1_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_3) return;
	glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC)load("glActiveTexture");
	glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)load("glSampleCoverage");
	glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)load("glCompressedTexImage3D");
	glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)load("glCompressedTexImage2D");
	glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)load("glCompressedTexImage1D");
	glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)load("glCompressedTexSubImage3D");
	glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)load("glCompressedTexSubImage2D");
	glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)load("glCompressedTexSubImage1D");
	glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)load("glGetCompressedTexImage");
	glad_glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC)load("glClientActiveTexture");
	glad_glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC)load("glMultiTexCoord1d");
	glad_glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC)load("glMultiTexCoord1dv");
	glad_glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC)load("glMultiTexCoord1f");
	glad_glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC)load("glMultiTexCoord1fv");
	glad_glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC)load("glMultiTexCoord1i");
	glad_glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC)load("glMultiTexCoord1iv");
	glad_glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC)load("glMultiTexCoord1s");
	glad_glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC)load("glMultiTexCoord1sv");
	glad_glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC)load("glMultiTexCoord2d");
	glad_glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC)load("glMultiTexCoord2dv");
	glad_glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC)load("glMultiTexCoord2f");
	glad_glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC)load("glMultiTexCoord2fv");
	glad_glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC)load("glMultiTexCoord2i");
	glad_glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC)load("glMultiTexCoord2iv");
	glad_glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC)load("glMultiTexCoord2s");
	glad_glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC)load("glMultiTexCoord2sv");
	glad_glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC)load("glMultiTexCoord3d");
	glad_glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC)load("glMultiTexCoord3dv");
	glad_glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC)load("glMultiTexCoord3f");
	glad_glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC)load("glMultiTexCoord3fv");
	glad_glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC)load("glMultiTexCoord3i");
	glad_glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC)load("glMultiTexCoord3iv");
	glad_glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC)load("glMultiTexCoord3s");
	glad_glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC)load("glMultiTexCoord3sv");
	glad_glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC)load("glMultiTexCoord4d");
	glad_glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC)load("glMultiTexCoord4dv");
	glad_glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC)load("glMultiTexCoord4f");
	glad_glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC)load("glMultiTexCoord4fv");
	glad_glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC)load("glMultiTexCoord4i");
	glad_glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC)load("glMultiTexCoord4iv");
	glad_glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC)load("glMultiTexCoord4s");
	glad_glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC)load("glMultiTexCoord4sv");
	glad_glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC)load("glLoadTransposeMatrixf");
	glad_glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC)load("glLoadTransposeMatrixd");
	glad_glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC)load("glMultTransposeMatrixf");
	glad_glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC)load("glMultTransposeMatrixd");
}
static void load_GL_VERSION_1_4(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_4) return;
	glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)load("glBlendFuncSeparate");
	glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)load("glMultiDrawArrays");
	glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)load("glMultiDrawElements");
	glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC)load("glPointParameterf");
	glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)load("glPointParameterfv");
	glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC)load("glPointParameteri");
	glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)load("glPointParameteriv");
	glad_glFogCoordf = (PFNGLFOGCOORDFPROC)load("glFogCoordf");
	glad_glFogCoordfv = (PFNGLFOGCOORDFVPROC)load("glFogCoordfv");
	glad_glFogCoordd = (PFNGLFOGCOORDDPROC)load("glFogCoordd");
	glad_glFogCoorddv = (PFNGLFOGCOORDDVPROC)load("glFogCoorddv");
	glad_glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC)load("glFogCoordPointer");
	glad_glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC)load("glSecondaryColor3b");
	glad_glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC)load("glSecondaryColor3bv");
	glad_glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC)load("glSecondaryColor3d");
	glad_glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC)load("glSecondaryColor3dv");
	glad_glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC)load("glSecondaryColor3f");
	glad_glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC)load("glSecondaryColor3fv");
	glad_glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC)load("glSecondaryColor3i");
	glad_glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC)load("glSecondaryColor3iv");
	glad_glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC)load("glSecondaryColor3s");
	glad_glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC)load("glSecondaryColor3sv");
	glad_glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC)load("glSecondaryColor3ub");
	glad_glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC)load("glSecondaryColor3ubv");
	glad_glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC)load("glSecondaryColor3ui");
	glad_glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC)load("glSecondaryColor3uiv");
	glad_glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC)load("glSecondaryColor3us");
	glad_glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC)load("glSecondaryColor3usv");
	glad_glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC)load("glSecondaryColorPointer");
	glad_glWindowPos2d = (PFNGLWINDOWPOS2DPROC)load("glWindowPos2d");
	glad_glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC)load("glWindowPos2dv");
	glad_glWindowPos2f = (PFNGLWINDOWPOS2FPROC)load("glWindowPos2f");
	glad_glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC)load("glWindowPos2fv");
	glad_glWindowPos2i = (PFNGLWINDOWPOS2IPROC)load("glWindowPos2i");
	glad_glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC)load("glWindowPos2iv");
	glad_glWindowPos2s = (PFNGLWINDOWPOS2SPROC)load("glWindowPos2s");
	glad_glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC)load("glWindowPos2sv");
	glad_glWindowPos3d = (PFNGLWINDOWPOS3DPROC)load("glWindowPos3d");
	glad_glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC)load("glWindowPos3dv");
	glad_glWindowPos3f = (PFNGLWINDOWPOS3FPROC)load("glWindowPos3f");
	glad_glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC)load("glWindowPos3fv");
	glad_glWindowPos3i = (PFNGLWINDOWPOS3IPROC)load("glWindowPos3i");
	glad_glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC)load("glWindowPos3iv");
	glad_glWindowPos3s = (PFNGLWINDOWPOS3SPROC)load("glWindowPos3s");
	glad_glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC)load("glWindowPos3sv");
	glad_glBlendColor = (PFNGLBLENDCOLORPROC)load("glBlendColor");
	glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC)load("glBlendEquation");
}
static void load_GL_VERSION_1_5(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_5) return;
	glad_glGenQueries = (PFNGLGENQUERIESPROC)load("glGenQueries");
	glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC)load("glDeleteQueries");
	glad_glIsQuery = (PFNGLISQUERYPROC)load("glIsQuery");
	glad_glBeginQuery = (PFNGLBEGINQUERYPROC)load("glBeginQuery");
	glad_glEndQuery = (PFNGLENDQUERYPROC)load("glEndQuery");
	glad_glGetQueryiv = (PFNGLGETQUERYIVPROC)load("glGetQueryiv");
	glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)load("glGetQueryObjectiv");
	glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)load("glGetQueryObjectuiv");
	glad_glBindBuffer = (PFNGLBINDBUFFERPROC)load("glBindBuffer");
	glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)load("glDeleteBuffers");
	glad_glGenBuffers = (PFNGLGENBUFFERSPROC)load("glGenBuffers");
	glad_glIsBuffer = (PFNGLISBUFFERPROC)load("glIsBuffer");
	glad_glBufferData = (PFNGLBUFFERDATAPROC)load("glBufferData");
	glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC)load("glBufferSubData");
	glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)load("glGetBufferSubData");
	glad_glMapBuffer = (PFNGLMAPBUFFERPROC)load("glMapBuffer");
	glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)load("glUnmapBuffer");
	glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)load("glGetBufferParameteriv");
	glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)load("glGetBufferPointerv");
}
static void load_GL_VERSION_2_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_2_0) return;
	glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)load("glBlendEquationSeparate");
	glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC)load("glDrawBuffers");
	glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)load("glStencilOpSeparate");
	glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)load("glStencilFuncSeparate");
	glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)load("glStencilMaskSeparate");
	glad_glAttachShader = (PFNGLATTACHSHADERPROC)load("glAttachShader");
	glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)load("glBindAttribLocation");
	glad_glCompileShader = (PFNGLCOMPILESHADERPROC)load("glCompileShader");
	glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC)load("glCreateProgram");
	glad_glCreateShader = (PFNGLCREATESHADERPROC)load("glCreateShader");
	glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC)load("glDeleteProgram");
	glad_glDeleteShader = (PFNGLDELETESHADERPROC)load("glDeleteShader");
	glad_glDetachShader = (PFNGLDETACHSHADERPROC)load("glDetachShader");
	glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)load("glDisableVertexAttribArray");
	glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)load("glEnableVertexAttribArray");
	glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)load("glGetActiveAttrib");
	glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)load("glGetActiveUniform");
	glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)load("glGetAttachedShaders");
	glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)load("glGetAttribLocation");
	glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC)load("glGetProgramiv");
	glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)load("glGetProgramInfoLog");
	glad_glGetShaderiv = (PFNGLGETSHADERIVPROC)load("glGetShaderiv");
	glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)load("glGetShaderInfoLog");
	glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)load("glGetShaderSource");
	glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)load("glGetUniformLocation");
	glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC)load("glGetUniformfv");
	glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC)load("glGetUniformiv");
	glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)load("glGetVertexAttribdv");
	glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)load("glGetVertexAttribfv");
	glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)load("glGetVertexAttribiv");
	glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)load("glGetVertexAttribPointerv");
	glad_glIsProgram = (PFNGLISPROGRAMPROC)load("glIsProgram");
	glad_glIsShader = (PFNGLISSHADERPROC)load("glIsShader");
	glad_glLinkProgram = (PFNGLLINKPROGRAMPROC)load("glLinkProgram");
	glad_glShaderSource = (PFNGLSHADERSOURCEPROC)load("glShaderSource");
	glad_glUseProgram = (PFNGLUSEPROGRAMPROC)load("glUseProgram");
	glad_glUniform1f = (PFNGLUNIFORM1FPROC)load("glUniform1f");
	glad_glUniform2f = (PFNGLUNIFORM2FPROC)load("glUniform2f");
	glad_glUniform3f = (PFNGLUNIFORM3FPROC)load("glUniform3f");
	glad_glUniform4f = (PFNGLUNIFORM4FPROC)load("glUniform4f");
	glad_glUniform1i = (PFNGLUNIFORM1IPROC)load("glUniform1i");
	glad_glUniform2i = (PFNGLUNIFORM2IPROC)load("glUniform2i");
	glad_glUniform3i = (PFNGLUNIFORM3IPROC)load("glUniform3i");
	glad_glUniform4i = (PFNGLUNIFORM4IPROC)load("glUniform4i");
	glad_glUniform1fv = (PFNGLUNIFORM1FVPROC)load("glUniform1fv");
	glad_glUniform2fv = (PFNGLUNIFORM2FVPROC)load("glUniform2fv");
	glad_glUniform3fv = (PFNGLUNIFORM3FVPROC)load("glUniform3fv");
	glad_glUniform4fv = (PFNGLUNIFORM4FVPROC)load("glUniform4fv");
	glad_glUniform1iv = (PFNGLUNIFORM1IVPROC)load("glUniform1iv");
	glad_glUniform2iv = (PFNGLUNIFORM2IVPROC)load("glUniform2iv");
	glad_glUniform3iv = (PFNGLUNIFORM3IVPROC)load("glUniform3iv");
	glad_glUniform4iv = (PFNGLUNIFORM4IVPROC)load("glUniform4iv");
	glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)load("glUniformMatrix2fv");
	glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)load("glUniformMatrix3fv");
	glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)load("glUniformMatrix4fv");
	glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)load("glValidateProgram");
	glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)load("glVertexAttrib1d");
	glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)load("glVertexAttrib1dv");
	glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)load("glVertexAttrib1f");
	glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)load("glVertexAttrib1fv");
	glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)load("glVertexAttrib1s");
	glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)load("glVertexAttrib1sv");
	glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)load("glVertexAttrib2d");
	glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)load("glVertexAttrib2dv");
	glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)load("glVertexAttrib2f");
	glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)load("glVertexAttrib2fv");
	glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)load("glVertexAttrib2s");
	glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)load("glVertexAttrib2sv");
	glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)load("glVertexAttrib3d");
	glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)load("glVertexAttrib3dv");
	glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)load("glVertexAttrib3f");
	glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)load("glVertexAttrib3fv");
	glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)load("glVertexAttrib3s");
	glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)load("glVertexAttrib3sv");
	glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)load("glVertexAttrib4Nbv");
	glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)load("glVertexAttrib4Niv");
	glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)load("glVertexAttrib4Nsv");
	glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)load("glVertexAttrib4Nub");
	glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)load("glVertexAttrib4Nubv");
	glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)load("glVertexAttrib4Nuiv");
	glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)load("glVertexAttrib4Nusv");
	glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)load("glVertexAttrib4bv");
	glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)load("glVertexAttrib4d");
	glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)load("glVertexAttrib4dv");
	glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)load("glVertexAttrib4f");
	glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)load("glVertexAttrib4fv");
	glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)load("glVertexAttrib4iv");
	glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)load("glVertexAttrib4s");
	glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)load("glVertexAttrib4sv");
	glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)load("glVertexAttrib4ubv");
	glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)load("glVertexAttrib4uiv");
	glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)load("glVertexAttrib4usv");
	glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)load("glVertexAttribPointer");
}
static void load_GL_VERSION_2_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_2_1) return;
	glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)load("glUniformMatrix2x3fv");
	glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)load("glUniformMatrix3x2fv");
	glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)load("glUniformMatrix2x4fv");
	glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)load("glUniformMatrix4x2fv");
	glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)load("glUniformMatrix3x4fv");
	glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)load("glUniformMatrix4x3fv");
}
static void load_GL_VERSION_3_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_0) return;
	glad_glColorMaski = (PFNGLCOLORMASKIPROC)load("glColorMaski");
	glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)load("glGetBooleani_v");
	glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
	glad_glEnablei = (PFNGLENABLEIPROC)load("glEnablei");
	glad_glDisablei = (PFNGLDISABLEIPROC)load("glDisablei");
	glad_glIsEnabledi = (PFNGLISENABLEDIPROC)load("glIsEnabledi");
	glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)load("glBeginTransformFeedback");
	glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)load("glEndTransformFeedback");
	glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
	glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
	glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)load("glTransformFeedbackVaryings");
	glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)load("glGetTransformFeedbackVarying");
	glad_glClampColor = (PFNGLCLAMPCOLORPROC)load("glClampColor");
	glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)load("glBeginConditionalRender");
	glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)load("glEndConditionalRender");
	glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)load("glVertexAttribIPointer");
	glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)load("glGetVertexAttribIiv");
	glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)load("glGetVertexAttribIuiv");
	glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)load("glVertexAttribI1i");
	glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)load("glVertexAttribI2i");
	glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)load("glVertexAttribI3i");
	glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)load("glVertexAttribI4i");
	glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)load("glVertexAttribI1ui");
	glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)load("glVertexAttribI2ui");
	glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)load("glVertexAttribI3ui");
	glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)load("glVertexAttribI4ui");
	glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)load("glVertexAttribI1iv");
	glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)load("glVertexAttribI2iv");
	glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)load("glVertexAttribI3iv");
	glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)load("glVertexAttribI4iv");
	glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)load("glVertexAttribI1uiv");
	glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)load("glVertexAttribI2uiv");
	glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)load("glVertexAttribI3uiv");
	glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)load("glVertexAttribI4uiv");
	glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)load("glVertexAttribI4bv");
	glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)load("glVertexAttribI4sv");
	glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)load("glVertexAttribI4ubv");
	glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)load("glVertexAttribI4usv");
	glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)load("glGetUniformuiv");
	glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)load("glBindFragDataLocation");
	glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)load("glGetFragDataLocation");
	glad_glUniform1ui = (PFNGLUNIFORM1UIPROC)load("glUniform1ui");
	glad_glUniform2ui = (PFNGLUNIFORM2UIPROC)load("glUniform2ui");
	glad_glUniform3ui = (PFNGLUNIFORM3UIPROC)load("glUniform3ui");
	glad_glUniform4ui = (PFNGLUNIFORM4UIPROC)load("glUniform4ui");
	glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC)load("glUniform1uiv");
	glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC)load("glUniform2uiv");
	glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC)load("glUniform3uiv");
	glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC)load("glUniform4uiv");
	glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)load("glTexParameterIiv");
	glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)load("glTexParameterIuiv");
	glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)load("glGetTexParameterIiv");
	glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)load("glGetTexParameterIuiv");
	glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)load("glClearBufferiv");
	glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)load("glClearBufferuiv");
	glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)load("glClearBufferfv");
	glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)load("glClearBufferfi");
	glad_glGetStringi = (PFNGLGETSTRINGIPROC)load("glGetStringi");
	glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)load("glIsRenderbuffer");
	glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)load("glBindRenderbuffer");
	glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)load("glDeleteRenderbuffers");
	glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)load("glGenRenderbuffers");
	glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)load("glRenderbufferStorage");
	glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)load("glGetRenderbufferParameteriv");
	glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)load("glIsFramebuffer");
	glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)load("glBindFramebuffer");
	glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)load("glDeleteFramebuffers");
	glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)load("glGenFramebuffers");
	glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)load("glCheckFramebufferStatus");
	glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)load("glFramebufferTexture1D");
	glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)load("glFramebufferTexture2D");
	glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)load("glFramebufferTexture3D");
	glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)load("glFramebufferRenderbuffer");
	glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetFramebufferAttachmentParameteriv");
	glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)load("glGenerateMipmap");
	glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)load("glBlitFramebuffer");
	glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glRenderbufferStorageMultisample");
	glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)load("glFramebufferTextureLayer");
	glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)load("glMapBufferRange");
	glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)load("glFlushMappedBufferRange");
	glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)load("glBindVertexArray");
	glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)load("glDeleteVertexArrays");
	glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)load("glGenVertexArrays");
	glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC)load("glIsVertexArray");
}
static void load_GL_VERSION_3_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_1) return;
	glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)load("glDrawArraysInstanced");
	glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)load("glDrawElementsInstanced");
	glad_glTexBuffer = (PFNGLTEXBUFFERPROC)load("glTexBuffer");
	glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)load("glPrimitiveRestartIndex");
	glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)load("glCopyBufferSubData");
	glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)load("glGetUniformIndices");
	glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)load("glGetActiveUniformsiv");
	glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)load("glGetActiveUniformName");
	glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)load("glGetUniformBlockIndex");
	glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)load("glGetActiveUniformBlockiv");
	glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)load("glGetActiveUniformBlockName");
	glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)load("glUniformBlockBinding");
	glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
	glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
	glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
}
static void load_GL_VERSION_3_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_2) return;
	glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)load("glDrawElementsBaseVertex");
	glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)load("glDrawRangeElementsBaseVertex");
	glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)load("glDrawElementsInstancedBaseVertex");
	glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)load("glMultiDrawElementsBaseVertex");
	glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)load("glProvokingVertex");
	glad_glFenceSync = (PFNGLFENCESYNCPROC)load("glFenceSync");
	glad_glIsSync = (PFNGLISSYNCPROC)load("glIsSync");
	glad_glDeleteSync = (PFNGLDELETESYNCPROC)load("glDeleteSync");
	glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)load("glClientWaitSync");
	glad_glWaitSync = (PFNGLWAITSYNCPROC)load("glWaitSync");
	glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC)load("glGetInteger64v");
	glad_glGetSynciv = (PFNGLGETSYNCIVPROC)load("glGetSynciv");
	glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)load("glGetInteger64i_v");
	glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)load("glGetBufferParameteri64v");
	glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)load("glFramebufferTexture");
	glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)load("glTexImage2DMultisample");
	glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)load("glTexImage3DMultisample");
	glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)load("glGetMultisamplefv");
	glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC)load("glSampleMaski");
}
static void load_GL_VERSION_3_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_3) return;
	glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)load("glBindFragDataLocationIndexed");
	glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)load("glGetFragDataIndex");
	glad_glGenSamplers = (PFNGLGENSAMPLERSPROC)load("glGenSamplers");
	glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC)load("glDeleteSamplers");
	glad_glIsSampler = (PFNGLISSAMPLERPROC)load("glIsSampler");
	glad_glBindSampler = (PFNGLBINDSAMPLERPROC)load("glBindSampler");
	glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)load("glSamplerParameteri");
	glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)load("glSamplerParameteriv");
	glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)load("glSamplerParameterf");
	glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)load("glSamplerParameterfv");
	glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)load("glSamplerParameterIiv");
	glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)load("glSamplerParameterIuiv");
	glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)load("glGetSamplerParameteriv");
	glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)load("glGetSamplerParameterIiv");
	glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)load("glGetSamplerParameterfv");
	glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)load("glGetSamplerParameterIuiv");
	glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC)load("glQueryCounter");
	glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)load("glGetQueryObjecti64v");
	glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)load("glGetQueryObjectui64v");
	glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)load("glVertexAttribDivisor");
	glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)load("glVertexAttribP1ui");
	glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)load("glVertexAttribP1uiv");
	glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)load("glVertexAttribP2ui");
	glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)load("glVertexAttribP2uiv");
	glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)load("glVertexAttribP3ui");
	glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)load("glVertexAttribP3uiv");
	glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)load("glVertexAttribP4ui");
	glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)load("glVertexAttribP4uiv");
	glad_glVertexP2ui = (PFNGLVERTEXP2UIPROC)load("glVertexP2ui");
	glad_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC)load("glVertexP2uiv");
	glad_glVertexP3ui = (PFNGLVERTEXP3UIPROC)load("glVertexP3ui");
	glad_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC)load("glVertexP3uiv");
	glad_glVertexP4ui = (PFNGLVERTEXP4UIPROC)load("glVertexP4ui");
	glad_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC)load("glVertexP4uiv");
	glad_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)load("glTexCoordP1ui");
	glad_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)load("glTexCoordP1uiv");
	glad_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)load("glTexCoordP2ui");
	glad_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)load("glTexCoordP2uiv");
	glad_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)load("glTexCoordP3ui");
	glad_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)load("glTexCoordP3uiv");
	glad_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)load("glTexCoordP4ui");
	glad_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)load("glTexCoordP4uiv");
	glad_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)load("glMultiTexCoordP1ui");
	glad_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)load("glMultiTexCoordP1uiv");
	glad_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)load("glMultiTexCoordP2ui");
	glad_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)load("glMultiTexCoordP2uiv");
	glad_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)load("glMultiTexCoordP3ui");
	glad_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)load("glMultiTexCoordP3uiv");
	glad_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)load("glMultiTexCoordP4ui");
	glad_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)load("glMultiTexCoordP4uiv");
	glad_glNormalP3ui = (PFNGLNORMALP3UIPROC)load("glNormalP3ui");
	glad_glNormalP3uiv = (PFNGLNORMALP3UIVPROC)load("glNormalP3uiv");
	glad_glColorP3ui = (PFNGLCOLORP3UIPROC)load("glColorP3ui");
	glad_glColorP3uiv = (PFNGLCOLORP3UIVPROC)load("glColorP3uiv");
	glad_glColorP4ui = (PFNGLCOLORP4UIPROC)load("glColorP4ui");
	glad_glColorP4uiv = (PFNGLCOLORP4UIVPROC)load("glColorP4uiv");
	glad_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)load("glSecondaryColorP3ui");
	glad_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)load("glSecondaryColorP3uiv");
}
static int find_extensionsGL(void) {
	if (!get_exts()) return 0;
	(void)&has_ext;
	free_exts();
	return 1;
}

static void find_coreGL(void) {

    



    int i, major, minor;

    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        0
    };

    version = (const char*) glad_glGetString(0x1F02);
    if (!version) return;

    for (i = 0;  prefixes[i];  i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }



    sscanf_s(version, "%d.%d", &major, &minor);


#line 1777 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../glad.c"

    GLVersion.major = major; GLVersion.minor = minor;
    max_loaded_major = major; max_loaded_minor = minor;
	GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
	GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
	GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
	GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
	GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
	GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
	GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
	GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
	GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
	GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
	GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
	GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
	if (GLVersion.major > 3 || (GLVersion.major >= 3 && GLVersion.minor >= 3)) {
		max_loaded_major = 3;
		max_loaded_minor = 3;
	}
}

int gladLoadGLLoader(GLADloadproc load) {
	GLVersion.major = 0; GLVersion.minor = 0;
	glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
	if(glad_glGetString == 0) return 0;
	if(glad_glGetString(0x1F02) == 0) return 0;
	find_coreGL();
	load_GL_VERSION_1_0(load);
	load_GL_VERSION_1_1(load);
	load_GL_VERSION_1_2(load);
	load_GL_VERSION_1_3(load);
	load_GL_VERSION_1_4(load);
	load_GL_VERSION_1_5(load);
	load_GL_VERSION_2_0(load);
	load_GL_VERSION_2_1(load);
	load_GL_VERSION_3_0(load);
	load_GL_VERSION_3_1(load);
	load_GL_VERSION_3_2(load);
	load_GL_VERSION_3_3(load);

	if (!find_extensionsGL()) return 0;
	return GLVersion.major != 0 || GLVersion.minor != 0;
}


#line 7 "..\\src\\graphics\\graphics.cpp"
#line 8 "..\\src\\graphics\\graphics.cpp"


#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/matrix_transform.hpp"




















#pragma once










#line 33 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/matrix_transform.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> translate(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v);
		
	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> rotate(
		tmat4x4<T, P> const & m,
		T angle,
		tvec3<T, P> const & axis);

	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> scale(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v);

	
	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> ortho(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	
	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> orthoLH(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	
	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> orthoRH(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> ortho(
		T left,
		T right,
		T bottom,
		T top);

	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> frustum(
		T left,
		T right,
		T bottom,
		T top,
		T ,
		T );

	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> frustumLH(
		T left,
		T right,
		T bottom,
		T top,
		T ,
		T );

	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> frustumRH(
		T left,
		T right,
		T bottom,
		T top,
		T ,
		T );

	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspective(
		T fovy,
		T aspect,
		T ,
		T );

	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveRH(
		T fovy,
		T aspect,
		T ,
		T );

	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveLH(
		T fovy,
		T aspect,
		T ,
		T );

	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFov(
		T fov,
		T width,
		T height,
		T ,
		T );

	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFovRH(
		T fov,
		T width,
		T height,
		T ,
		T );

	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFovLH(
		T fov,
		T width,
		T height,
		T ,
		T );

	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspective(
		T fovy, T aspect, T );

	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspectiveLH(
		T fovy, T aspect, T );

	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspectiveRH(
		T fovy, T aspect, T );

	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T );

	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T , T ep);

	
	
	
	
	
	
	
	
	
	
	template <typename T, typename U, precision P>
	 tvec3<T, P> project(
		tvec3<T, P> const & obj,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport);

	
	
	
	
	
	
	
	
	
	
	template <typename T, typename U, precision P>
	 tvec3<T, P> unProject(
		tvec3<T, P> const & win,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport);

	
	
	
	
	
	
	
	
	template <typename T, precision P, typename U>
	 tmat4x4<T, P> pickMatrix(
		tvec2<T, P> const & center,
		tvec2<T, P> const & delta,
		tvec4<U, P> const & viewport);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> lookAt(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> lookAtRH(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> lookAtLH(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up);

	
}

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"







namespace glm
{
	template <typename T, precision P>
	 inline tmat4x4<T, P> translate(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
	{
		tmat4x4<T, P> Result(m);
		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
		return Result;
	}
	
	template <typename T, precision P>
	 inline tmat4x4<T, P> rotate(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)
	{
		T const a = angle;
		T const c = cos(a);
		T const s = sin(a);

		tvec3<T, P> axis(normalize(v));
		tvec3<T, P> temp((T(1) - c) * axis);

		tmat4x4<T, P> Rotate(uninitialize);
		Rotate[0][0] = c + temp[0] * axis[0];
		Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
		Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

		Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
		Rotate[1][1] = c + temp[1] * axis[1];
		Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

		Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
		Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
		Rotate[2][2] = c + temp[2] * axis[2];

		tmat4x4<T, P> Result(uninitialize);
		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
		Result[3] = m[3];
		return Result;
	}
		
	template <typename T, precision P>
	 inline tmat4x4<T, P> rotate_slow(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)
	{
		T const a = angle;
		T const c = cos(a);
		T const s = sin(a);
		tmat4x4<T, P> Result;

		tvec3<T, P> axis = normalize(v);

		Result[0][0] = c + (static_cast<T>(1) - c)      * axis.x     * axis.x;
		Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
		Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
		Result[0][3] = static_cast<T>(0);

		Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
		Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
		Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
		Result[1][3] = static_cast<T>(0);

		Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
		Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
		Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
		Result[2][3] = static_cast<T>(0);

		Result[3] = tvec4<T, P>(0, 0, 0, 1);
		return m * Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> scale(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
	{
		tmat4x4<T, P> Result(uninitialize);
		Result[0] = m[0] * v[0];
		Result[1] = m[1] * v[1];
		Result[2] = m[2] * v[2];
		Result[3] = m[3];
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> scale_slow(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
	{
		tmat4x4<T, P> Result(T(1));
		Result[0][0] = v.x;
		Result[1][1] = v.y;
		Result[2][2] = v.z;
		return m * Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> ortho
	(
		T left, T right,
		T bottom, T top,
		T zNear, T zFar
	)
	{


#line 110 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			return orthoRH(left, right, bottom, top, zNear, zFar);
#line 112 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> orthoLH
	(
		T left, T right,
		T bottom, T top,
		T zNear, T zFar
	)
	{
		tmat4x4<T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);




#line 132 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = static_cast<T>(2) / (zFar - zNear);
			Result[3][2] = - (zFar + zNear) / (zFar - zNear);
#line 135 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> orthoRH
	(
		T left, T right,
		T bottom, T top,
		T zNear, T zFar
	)
	{
		tmat4x4<T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);




#line 157 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
			Result[3][2] = - (zFar + zNear) / (zFar - zNear);
#line 160 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> ortho
	(
		T left, T right,
		T bottom, T top
	)
	{
		tmat4x4<T, defaultp> Result(static_cast<T>(1));
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> frustum
	(
		T left, T right,
		T bottom, T top,
		T nearVal, T farVal
	)
	{


#line 191 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			return frustumRH(left, right, bottom, top, nearVal, farVal);
#line 193 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> frustumLH
	(
		T left, T right,
		T bottom, T top,
		T nearVal, T farVal
	)
	{
		tmat4x4<T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][3] = static_cast<T>(1);




#line 214 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
			Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
#line 217 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> frustumRH
	(
		T left, T right,
		T bottom, T top,
		T nearVal, T farVal
	)
	{
		tmat4x4<T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][3] = static_cast<T>(-1);




#line 240 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
			Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
#line 243 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
	{


#line 253 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			return perspectiveRH(fovy, aspect, zNear, zFar);
#line 255 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(260)), 0) );

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][3] = - static_cast<T>(1);




#line 273 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = - (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
#line 276 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}
	
	template <typename T>
	 inline tmat4x4<T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(283)), 0) );

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));
		
		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][3] = static_cast<T>(1);




#line 296 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
#line 299 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
	{


#line 309 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			return perspectiveFovRH(fov, width, height, zNear, zFar);
#line 311 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(316)), 0) );
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(317)), 0) );
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(318)), 0) );
	
		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][3] = - static_cast<T>(1);




#line 333 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = - (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
#line 336 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(343)), 0) );
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(344)), 0) );
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(345)), 0) );
	
		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][3] = static_cast<T>(1);




#line 360 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			Result[2][2] = (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
#line 363 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
	{


#line 373 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			return infinitePerspectiveRH(fovy, aspect, zNear);
#line 375 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - static_cast<T>(2) * zNear;
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		tmat4x4<T, defaultp> Result(T(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = static_cast<T>(1);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - static_cast<T>(2) * zNear;
		return Result;
	}

	
	template <typename T>
	 inline tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
	{
		T const range = tan(fovy / static_cast<T>(2)) * zNear;	
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = ep - static_cast<T>(1);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = (ep - static_cast<T>(2)) * zNear;
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
	{
		return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
	}

	template <typename T, typename U, precision P>
	 inline tvec3<T, P> project
	(
		tvec3<T, P> const & obj,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport
	)
	{
		tvec4<T, P> tmp = tvec4<T, P>(obj, static_cast<T>(1));
		tmp = model * tmp;
		tmp = proj * tmp;

		tmp /= tmp.w;



#line 456 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);
#line 458 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
		tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
		tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

		return tvec3<T, P>(tmp);
	}

	template <typename T, typename U, precision P>
	 inline tvec3<T, P> unProject
	(
		tvec3<T, P> const & win,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport
	)
	{
		tmat4x4<T, P> Inverse = inverse(proj * model);

		tvec4<T, P> tmp = tvec4<T, P>(win, T(1));
		tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
		tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);



#line 482 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			tmp = tmp * static_cast<T>(2) - static_cast<T>(1);
#line 484 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"

		tvec4<T, P> obj = Inverse * tmp;
		obj /= obj.w;

		return tvec3<T, P>(obj);
	}

	template <typename T, precision P, typename U>
	 inline tmat4x4<T, P> pickMatrix(tvec2<T, P> const & center, tvec2<T, P> const & delta, tvec4<U, P> const & viewport)
	{
		(void)( (!!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0))) || (_wassert(L"delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)", L"i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl", (unsigned)(494)), 0) );
		tmat4x4<T, P> Result(static_cast<T>(1));

		if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
			return Result; 

		tvec3<T, P> Temp(
			(static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
			(static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
			static_cast<T>(0));

		
		Result = translate(Result, Temp);
		return scale(Result, tvec3<T, P>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> lookAt(tvec3<T, P> const & eye, tvec3<T, P> const & center, tvec3<T, P> const & up)
	{


#line 516 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
			return lookAtRH(eye, center, up);
#line 518 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\glm\\gtc\\matrix_transform.inl"
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> lookAtRH
	(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up
	)
	{
		tvec3<T, P> const f(normalize(center - eye));
		tvec3<T, P> const s(normalize(cross(f, up)));
		tvec3<T, P> const u(cross(s, f));

		tmat4x4<T, P> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] =-f.x;
		Result[1][2] =-f.y;
		Result[2][2] =-f.z;
		Result[3][0] =-dot(s, eye);
		Result[3][1] =-dot(u, eye);
		Result[3][2] = dot(f, eye);
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> lookAtLH
	(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up
	)
	{
		tvec3<T, P> const f(normalize(center - eye));
		tvec3<T, P> const s(normalize(cross(up, f)));
		tvec3<T, P> const u(cross(f, s));

		tmat4x4<T, P> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] = f.x;
		Result[1][2] = f.y;
		Result[2][2] = f.z;
		Result[3][0] = -dot(s, eye);
		Result[3][1] = -dot(u, eye);
		Result[3][2] = -dot(f, eye);
		return Result;
	}
}
#line 466 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\glm/gtc/matrix_transform.hpp"
#line 11 "..\\src\\graphics\\graphics.cpp"

#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"








#pragma once


#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\imgui\\imconfig.h"






#pragma once






















































#line 13 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"
#line 14 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"










#line 25 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"









#line 11 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 29 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"

#line 31 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"






#line 38 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"


#line 41 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"





#line 47 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"


struct ImDrawChannel;               
struct ImDrawCmd;                   
struct ImDrawData;                  
struct ImDrawList;                  
struct ImDrawListSharedData;        
struct ImDrawVert;                  
struct ImFont;                      
struct ImFontAtlas;                 
struct ImFontConfig;                
struct ImColor;                     
struct ImGuiIO;                     
struct ImGuiOnceUponAFrame;         
struct ImGuiStorage;                
struct ImGuiStyle;                  
struct ImGuiTextFilter;             
struct ImGuiTextBuffer;             
struct ImGuiTextEditCallbackData;   
struct ImGuiSizeConstraintCallbackData;
struct ImGuiListClipper;            
struct ImGuiPayload;                
struct ImGuiContext;                


typedef unsigned int ImU32;         
typedef unsigned int ImGuiID;       
typedef unsigned short ImWchar;     
typedef void* ImTextureID;          
typedef int ImGuiCol;               
typedef int ImGuiCond;              
typedef int ImGuiKey;               
typedef int ImGuiMouseCursor;       
typedef int ImGuiStyleVar;          
typedef int ImDrawCornerFlags;      
typedef int ImDrawListFlags;        
typedef int ImGuiColorEditFlags;    
typedef int ImGuiColumnsFlags;      
typedef int ImGuiDragDropFlags;     
typedef int ImGuiComboFlags;        
typedef int ImGuiFocusedFlags;      
typedef int ImGuiHoveredFlags;      
typedef int ImGuiInputTextFlags;    
typedef int ImGuiSelectableFlags;   
typedef int ImGuiTreeNodeFlags;     
typedef int ImGuiWindowFlags;       
typedef int (*ImGuiTextEditCallback)(ImGuiTextEditCallbackData *data);
typedef void (*ImGuiSizeConstraintCallback)(ImGuiSizeConstraintCallbackData* data);

typedef unsigned __int64 ImU64;     


#line 100 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"





struct ImVec2
{
    float x, y;
    ImVec2() { x = y = 0.0f; }
    ImVec2(float _x, float _y) { x = _x; y = _y; }



};

struct ImVec4
{
    float x, y, z, w;
    ImVec4() { x = y = z = w = 0.0f; }
    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }



};



namespace ImGui
{
    
     ImGuiIO&      GetIO();
     ImGuiStyle&   GetStyle();
     ImDrawData*   GetDrawData();                              
     void          NewFrame();                                 
     void          Render();                                   
     void          EndFrame();                                 
     void          Shutdown();

    
     void          ShowDemoWindow(bool* p_open = 0);        
     void          ShowMetricsWindow(bool* p_open = 0);     
     void          ShowStyleEditor(ImGuiStyle* ref = 0);    
     bool          ShowStyleSelector(const char* label);
     void          ShowFontSelector(const char* label);
     void          ShowUserGuide();                            

    
     bool          Begin(const char* name, bool* p_open = 0, ImGuiWindowFlags flags = 0);                                                   
     void          End();                                                                                                                      
     bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);    
     bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);            
     void          EndChild();
     ImVec2        GetContentRegionMax();                                              
     ImVec2        GetContentRegionAvail();                                            
     float         GetContentRegionAvailWidth();                                       
     ImVec2        GetWindowContentRegionMin();                                        
     ImVec2        GetWindowContentRegionMax();                                        
     float         GetWindowContentRegionWidth();                                      
     ImDrawList*   GetWindowDrawList();                                                
     ImVec2        GetWindowPos();                                                     
     ImVec2        GetWindowSize();                                                    
     float         GetWindowWidth();
     float         GetWindowHeight();
     bool          IsWindowCollapsed();
     bool          IsWindowAppearing();
     void          SetWindowFontScale(float scale);                                    

     void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); 
     void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);          
     void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = 0, void* custom_callback_data = 0); 
     void          SetNextWindowContentSize(const ImVec2& size);                       
     void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);         
     void          SetNextWindowFocus();                                               
     void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                
     void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);              
     void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);             
     void          SetWindowFocus();                                                   
     void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      
     void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    
     void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   
     void          SetWindowFocus(const char* name);                                           

     float         GetScrollX();                                                       
     float         GetScrollY();                                                       
     float         GetScrollMaxX();                                                    
     float         GetScrollMaxY();                                                    
     void          SetScrollX(float scroll_x);                                         
     void          SetScrollY(float scroll_y);                                         
     void          SetScrollHere(float center_y_ratio = 0.5f);                         
     void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        
     void          SetStateStorage(ImGuiStorage* tree);                                
     ImGuiStorage* GetStateStorage();

    
     void          PushFont(ImFont* font);                                             
     void          PopFont();
     void          PushStyleColor(ImGuiCol idx, ImU32 col);
     void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
     void          PopStyleColor(int count = 1);
     void          PushStyleVar(ImGuiStyleVar idx, float val);
     void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
     void          PopStyleVar(int count = 1);
     const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                    
     ImFont*       GetFont();                                                          
     float         GetFontSize();                                                      
     ImVec2        GetFontTexUvWhitePixel();                                           
     ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  
     ImU32         GetColorU32(const ImVec4& col);                                     
     ImU32         GetColorU32(ImU32 col);                                             

    
     void          PushItemWidth(float item_width);                                    
     void          PopItemWidth();
     float         CalcItemWidth();                                                    
     void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           
     void          PopTextWrapPos();
     void          PushAllowKeyboardFocus(bool allow_keyboard_focus);                  
     void          PopAllowKeyboardFocus();
     void          PushButtonRepeat(bool repeat);                                      
     void          PopButtonRepeat();

    
     void          Separator();                                                        
     void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              
     void          NewLine();                                                          
     void          Spacing();                                                          
     void          Dummy(const ImVec2& size);                                          
     void          Indent(float indent_w = 0.0f);                                      
     void          Unindent(float indent_w = 0.0f);                                    
     void          BeginGroup();                                                       
     void          EndGroup();
     ImVec2        GetCursorPos();                                                     
     float         GetCursorPosX();                                                    
     float         GetCursorPosY();                                                    
     void          SetCursorPos(const ImVec2& local_pos);                              
     void          SetCursorPosX(float x);                                             
     void          SetCursorPosY(float y);                                             
     ImVec2        GetCursorStartPos();                                                
     ImVec2        GetCursorScreenPos();                                               
     void          SetCursorScreenPos(const ImVec2& pos);                              
     void          AlignTextToFramePadding();                                          
     float         GetTextLineHeight();                                                
     float         GetTextLineHeightWithSpacing();                                     
     float         GetFrameHeight();                                                   
     float         GetFrameHeightWithSpacing();                                        

    
    
     void          Columns(int count = 1, const char* id = 0, bool border = true);
     void          NextColumn();                                                       
     int           GetColumnIndex();                                                   
     float         GetColumnWidth(int column_index = -1);                              
     void          SetColumnWidth(int column_index, float width);                      
     float         GetColumnOffset(int column_index = -1);                             
     void          SetColumnOffset(int column_index, float offset_x);                  
     int           GetColumnsCount();

    
    
    
     void          PushID(const char* str_id);                                         
     void          PushID(const char* str_id_begin, const char* str_id_end);
     void          PushID(const void* ptr_id);
     void          PushID(int int_id);
     void          PopID();
     ImGuiID       GetID(const char* str_id);                                          
     ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
     ImGuiID       GetID(const void* ptr_id);

    
     void          TextUnformatted(const char* text, const char* text_end = 0);               
     void          Text(const char* fmt, ...)                                     ; 
     void          TextV(const char* fmt, va_list args)                           ;
     void          TextColored(const ImVec4& col, const char* fmt, ...)           ; 
     void          TextColoredV(const ImVec4& col, const char* fmt, va_list args) ;
     void          TextDisabled(const char* fmt, ...)                             ; 
     void          TextDisabledV(const char* fmt, va_list args)                   ;
     void          TextWrapped(const char* fmt, ...)                              ; 
     void          TextWrappedV(const char* fmt, va_list args)                    ;
     void          LabelText(const char* label, const char* fmt, ...)             ; 
     void          LabelTextV(const char* label, const char* fmt, va_list args)   ;
     void          BulletText(const char* fmt, ...)                               ; 
     void          BulletTextV(const char* fmt, va_list args)                     ;
     void          Bullet();                                                                     

    
     bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));            
     bool          SmallButton(const char* label);                                         
     bool          InvisibleButton(const char* str_id, const ImVec2& size);                
     void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
     bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    
     bool          Checkbox(const char* label, bool* v);
     bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
     bool          RadioButton(const char* label, bool active);
     bool          RadioButton(const char* label, int* v, int v_button);
     void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = 0, float scale_min = 3.402823466e+38F, float scale_max = 3.402823466e+38F, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));
     void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = 0, float scale_min = 3.402823466e+38F, float scale_max = 3.402823466e+38F, ImVec2 graph_size = ImVec2(0,0));
     void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = 0, float scale_min = 3.402823466e+38F, float scale_max = 3.402823466e+38F, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));
     void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = 0, float scale_min = 3.402823466e+38F, float scale_max = 3.402823466e+38F, ImVec2 graph_size = ImVec2(0,0));
     void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = 0);

    
    
    
     bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
     void          EndCombo();
     bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
     bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      
     bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

    
    
     bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     
     bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
     bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
     bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
     bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = 0, float power = 1.0f);
     bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       
     bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
     bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
     bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
     bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = 0);

    
     bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = 0, void* user_data = 0);
     bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = 0, void* user_data = 0);
     bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
     bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
     bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
     bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
     bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);
     bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);
     bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);
     bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);

    
     bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     
     bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
     bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
     bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
     bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
     bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");
     bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");
     bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");
     bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");
     bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
     bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");

    
    
     bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
     bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
     bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
     bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = 0);
     bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  
     void          SetColorEditOptions(ImGuiColorEditFlags flags);                         

    
     bool          TreeNode(const char* label);                                            
     bool          TreeNode(const char* str_id, const char* fmt, ...) ;       
     bool          TreeNode(const void* ptr_id, const char* fmt, ...) ;       
     bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) ;
     bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) ;
     bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
     bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) ;
     bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) ;
     bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) ;
     bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) ;
     void          TreePush(const char* str_id);                                           
     void          TreePush(const void* ptr_id = 0);                                    
     void          TreePop();                                                              
     void          TreeAdvanceToLabelPos();                                                
     float         GetTreeNodeToLabelSpacing();                                            
     void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);                  
     bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);      
     bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); 

    
     bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  
     bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));
     bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
     bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
     bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0));     
     bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); 
     void          ListBoxFooter();                                                        

    
     void          Value(const char* prefix, bool b);
     void          Value(const char* prefix, int v);
     void          Value(const char* prefix, unsigned int v);
     void          Value(const char* prefix, float v, const char* float_format = 0);

    
     void          SetTooltip(const char* fmt, ...) ;                     
     void          SetTooltipV(const char* fmt, va_list args) ;
     void          BeginTooltip();                                                     
     void          EndTooltip();

    
     bool          BeginMainMenuBar();                                                 
     void          EndMainMenuBar();
     bool          BeginMenuBar();                                                     
     void          EndMenuBar();
     bool          BeginMenu(const char* label, bool enabled = true);                  
     void          EndMenu();
     bool          MenuItem(const char* label, const char* shortcut = 0, bool selected = false, bool enabled = true);  
     bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              

    
     void          OpenPopup(const char* str_id);                                      
     bool          OpenPopupOnItemClick(const char* str_id = 0, int mouse_button = 1);                                  
     bool          BeginPopup(const char* str_id);                                     
     bool          BeginPopupModal(const char* name, bool* p_open = 0, ImGuiWindowFlags extra_flags = 0);               
     bool          BeginPopupContextItem(const char* str_id = 0, int mouse_button = 1);                                 
     bool          BeginPopupContextWindow(const char* str_id = 0, int mouse_button = 1, bool also_over_items = true);  
     bool          BeginPopupContextVoid(const char* str_id = 0, int mouse_button = 1);                                 
     void          EndPopup();
     bool          IsPopupOpen(const char* str_id);                                    
     void          CloseCurrentPopup();                                                

    
     void          LogToTTY(int max_depth = -1);                                       
     void          LogToFile(int max_depth = -1, const char* filename = 0);         
     void          LogToClipboard(int max_depth = -1);                                 
     void          LogFinish();                                                        
     void          LogButtons();                                                       
     void          LogText(const char* fmt, ...) ;                        

    
    
     bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0, int mouse_button = 0);                
     bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);
     void          EndDragDropSource();
     bool          BeginDragDropTarget();                                                                  
     const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);            
     void          EndDragDropTarget();

    
     void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
     void          PopClipRect();

    
     void          StyleColorsClassic(ImGuiStyle* dst = 0);
     void          StyleColorsDark(ImGuiStyle* dst = 0);
     void          StyleColorsLight(ImGuiStyle* dst = 0);

    
    
    
     void          SetItemDefaultFocus();                                              
     void          SetKeyboardFocusHere(int offset = 0);                               

    
     bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         
     bool          IsItemActive();                                                     
     bool          IsItemClicked(int mouse_button = 0);                                
     bool          IsItemVisible();                                                    
     bool          IsAnyItemHovered();
     bool          IsAnyItemActive();
     ImVec2        GetItemRectMin();                                                   
     ImVec2        GetItemRectMax();                                                   
     ImVec2        GetItemRectSize();                                                  
     void          SetItemAllowOverlap();                                              
     bool          IsWindowFocused(ImGuiFocusedFlags flags = 0);                       
     bool          IsWindowHovered(ImGuiHoveredFlags flags = 0);                       
     bool          IsAnyWindowFocused();
     bool          IsAnyWindowHovered();                                               
     bool          IsRectVisible(const ImVec2& size);                                  
     bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      
     float         GetTime();
     int           GetFrameCount();
     ImDrawList*   GetOverlayDrawList();                                               
     ImDrawListSharedData* GetDrawListSharedData();
     const char*   GetStyleColorName(ImGuiCol idx);
     ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   
     ImVec2        CalcTextSize(const char* text, const char* text_end = 0, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
     void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    

     bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0);    
     void          EndChildFrame();

     ImVec4        ColorConvertU32ToFloat4(ImU32 in);
     ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
     void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
     void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

    
     int           GetKeyIndex(ImGuiKey imgui_key);                                    
     bool          IsKeyDown(int user_key_index);                                      
     bool          IsKeyPressed(int user_key_index, bool repeat = true);               
     bool          IsKeyReleased(int user_key_index);                                  
     int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); 
     bool          IsMouseDown(int button);                                            
     bool          IsMouseClicked(int button, bool repeat = false);                    
     bool          IsMouseDoubleClicked(int button);                                   
     bool          IsMouseReleased(int button);                                        
     bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      
     bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  
     bool          IsMousePosValid(const ImVec2* mouse_pos = 0);                    
     ImVec2        GetMousePos();                                                      
     ImVec2        GetMousePosOnOpeningCurrentPopup();                                 
     ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    
     void          ResetMouseDragDelta(int button = 0);                                
     ImGuiMouseCursor GetMouseCursor();                                                
     void          SetMouseCursor(ImGuiMouseCursor type);                              
     void          CaptureKeyboardFromApp(bool capture = true);                        
     void          CaptureMouseFromApp(bool capture = true);                           

    
     void*         MemAlloc(size_t sz);
     void          MemFree(void* ptr);
     const char*   GetClipboardText();
     void          SetClipboardText(const char* text);

    
    
     const char*   GetVersion();
     ImGuiContext* CreateContext(void* (*malloc_fn)(size_t) = 0, void (*free_fn)(void*) = 0);
     void          DestroyContext(ImGuiContext* ctx);
     ImGuiContext* GetCurrentContext();
     void          SetCurrentContext(ImGuiContext* ctx);

} 


enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   
    ImGuiWindowFlags_NoResize               = 1 << 1,   
    ImGuiWindowFlags_NoMove                 = 1 << 2,   
    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   
    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   
    ImGuiWindowFlags_NoCollapse             = 1 << 5,   
    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   
    
    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   
    ImGuiWindowFlags_NoInputs               = 1 << 9,   
    ImGuiWindowFlags_MenuBar                = 1 << 10,  
    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  
    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  
    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  
    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  
    ImGuiWindowFlags_ResizeFromAnySide      = 1 << 17,  

    
    ImGuiWindowFlags_ChildWindow            = 1 << 24,  
    ImGuiWindowFlags_Tooltip                = 1 << 25,  
    ImGuiWindowFlags_Popup                  = 1 << 26,  
    ImGuiWindowFlags_Modal                  = 1 << 27,  
    ImGuiWindowFlags_ChildMenu              = 1 << 28   
};


enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   
    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   
    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   
    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   
    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   
    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   
    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   
    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   
    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   
    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   
    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  
    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  
    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  
    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  
    ImGuiInputTextFlags_Password            = 1 << 15,  
    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  
    
    ImGuiInputTextFlags_Multiline           = 1 << 20   
};


enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_Selected             = 1 << 0,   
    ImGuiTreeNodeFlags_Framed               = 1 << 1,   
    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   
    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   
    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   
    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   
    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   
    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   
    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   
    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   
    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  
    
    
    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoAutoOpenOnLog

    

    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap
#line 600 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"
};


enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   
    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   
    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2    
};


enum ImGuiComboFlags_
{
    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   
    ImGuiComboFlags_HeightSmall             = 1 << 1,   
    ImGuiComboFlags_HeightRegular           = 1 << 2,   
    ImGuiComboFlags_HeightLarge             = 1 << 3,   
    ImGuiComboFlags_HeightLargest           = 1 << 4,   
    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};


enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   
    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   
    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};


enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_Default                       = 0,        
    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   
    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   
    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 2,   
    
    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 4,   
    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 5,   
    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};


enum ImGuiDragDropFlags_
{
    
    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,       
    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,       
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,       
    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,       
    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,       
    
    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,      
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,      
    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  
};






enum ImGuiKey_
{
    ImGuiKey_Tab,       
    ImGuiKey_LeftArrow, 
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,   
    ImGuiKey_DownArrow, 
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,      
    ImGuiKey_End,       
    ImGuiKey_Delete,    
    ImGuiKey_Backspace, 
    ImGuiKey_Enter,     
    ImGuiKey_Escape,    
    ImGuiKey_A,         
    ImGuiKey_C,         
    ImGuiKey_V,         
    ImGuiKey_X,         
    ImGuiKey_Y,         
    ImGuiKey_Z,         
    ImGuiKey_COUNT
};


enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,              
    ImGuiCol_ChildBg,               
    ImGuiCol_PopupBg,               
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,               
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_CloseButton,
    ImGuiCol_CloseButtonHovered,
    ImGuiCol_CloseButtonActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_ModalWindowDarkening,  
    ImGuiCol_DragDropTarget,
    ImGuiCol_COUNT

    

    
    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg, ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive
#line 740 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"
};




enum ImGuiStyleVar_
{
    
    ImGuiStyleVar_Alpha,               
    ImGuiStyleVar_WindowPadding,       
    ImGuiStyleVar_WindowRounding,      
    ImGuiStyleVar_WindowBorderSize,    
    ImGuiStyleVar_WindowMinSize,       
    ImGuiStyleVar_ChildRounding,       
    ImGuiStyleVar_ChildBorderSize,     
    ImGuiStyleVar_PopupRounding,       
    ImGuiStyleVar_PopupBorderSize,     
    ImGuiStyleVar_FramePadding,        
    ImGuiStyleVar_FrameRounding,       
    ImGuiStyleVar_FrameBorderSize,     
    ImGuiStyleVar_ItemSpacing,         
    ImGuiStyleVar_ItemInnerSpacing,    
    ImGuiStyleVar_IndentSpacing,       
    ImGuiStyleVar_GrabMinSize,         
    ImGuiStyleVar_ButtonTextAlign,     
    ImGuiStyleVar_Count_

    

    , ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding
#line 771 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"
};


enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   
    ImGuiColorEditFlags_NoPicker        = 1 << 2,   
    ImGuiColorEditFlags_NoOptions       = 1 << 3,   
    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   
    ImGuiColorEditFlags_NoInputs        = 1 << 5,   
    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   
    ImGuiColorEditFlags_NoLabel         = 1 << 7,   
    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   
    
    ImGuiColorEditFlags_AlphaBar        = 1 << 9,   
    ImGuiColorEditFlags_AlphaPreview    = 1 << 10,  
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 11,  
    ImGuiColorEditFlags_HDR             = 1 << 12,  
    ImGuiColorEditFlags_RGB             = 1 << 13,  
    ImGuiColorEditFlags_HSV             = 1 << 14,  
    ImGuiColorEditFlags_HEX             = 1 << 15,  
    ImGuiColorEditFlags_Uint8           = 1 << 16,  
    ImGuiColorEditFlags_Float           = 1 << 17,  
    ImGuiColorEditFlags_PickerHueBar    = 1 << 18,  
    ImGuiColorEditFlags_PickerHueWheel  = 1 << 19,  
    
    ImGuiColorEditFlags__InputsMask     = ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_HSV|ImGuiColorEditFlags_HEX,
    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_PickerHueBar    
};


enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,         
    ImGuiMouseCursor_Move,              
    ImGuiMouseCursor_ResizeNS,          
    ImGuiMouseCursor_ResizeEW,          
    ImGuiMouseCursor_ResizeNESW,        
    ImGuiMouseCursor_ResizeNWSE,        
    ImGuiMouseCursor_Count_
};



enum ImGuiCond_
{
    ImGuiCond_Always        = 1 << 0,   
    ImGuiCond_Once          = 1 << 1,   
    ImGuiCond_FirstUseEver  = 1 << 2,   
    ImGuiCond_Appearing     = 1 << 3    

    

    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing
#line 830 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"
};

struct ImGuiStyle
{
    float       Alpha;                      
    ImVec2      WindowPadding;              
    float       WindowRounding;             
    float       WindowBorderSize;           
    ImVec2      WindowMinSize;              
    ImVec2      WindowTitleAlign;           
    float       ChildRounding;              
    float       ChildBorderSize;            
    float       PopupRounding;              
    float       PopupBorderSize;            
    ImVec2      FramePadding;               
    float       FrameRounding;              
    float       FrameBorderSize;            
    ImVec2      ItemSpacing;                
    ImVec2      ItemInnerSpacing;           
    ImVec2      TouchExtraPadding;          
    float       IndentSpacing;              
    float       ColumnsMinSpacing;          
    float       ScrollbarSize;              
    float       ScrollbarRounding;          
    float       GrabMinSize;                
    float       GrabRounding;               
    ImVec2      ButtonTextAlign;            
    ImVec2      DisplayWindowPadding;       
    ImVec2      DisplaySafeAreaPadding;     
    bool        AntiAliasedLines;           
    bool        AntiAliasedFill;            
    float       CurveTessellationTol;       
    ImVec4      Colors[ImGuiCol_COUNT];

     ImGuiStyle();
     void ScaleAllSizes(float scale_factor);
};



struct ImGuiIO
{
    
    
    

    ImVec2        DisplaySize;              
    float         DeltaTime;                
    float         IniSavingRate;            
    const char*   IniFilename;              
    const char*   LogFilename;              
    float         MouseDoubleClickTime;     
    float         MouseDoubleClickMaxDist;  
    float         MouseDragThreshold;       
    int           KeyMap[ImGuiKey_COUNT];   
    float         KeyRepeatDelay;           
    float         KeyRepeatRate;            
    void*         UserData;                 

    ImFontAtlas*  Fonts;                    
    float         FontGlobalScale;          
    bool          FontAllowUserScaling;     
    ImFont*       FontDefault;              
    ImVec2        DisplayFramebufferScale;  
    ImVec2        DisplayVisibleMin;        
    ImVec2        DisplayVisibleMax;        

    
    bool          OptMacOSXBehaviors;       
    bool          OptCursorBlink;           

    
    
    

    
    
    
    void        (*RenderDrawListsFn)(ImDrawData* data);

    
    
    const char* (*GetClipboardTextFn)(void* user_data);
    void        (*SetClipboardTextFn)(void* user_data, const char* text);
    void*       ClipboardUserData;

    
    
    void*       (*MemAllocFn)(size_t sz);
    void        (*MemFreeFn)(void* ptr);

    
    
    void        (*ImeSetInputScreenPosFn)(int x, int y);
    void*       ImeWindowHandle;            

    
    
    

    ImVec2      MousePos;                   
    bool        MouseDown[5];               
    float       MouseWheel;                 
    bool        MouseDrawCursor;            
    bool        KeyCtrl;                    
    bool        KeyShift;                   
    bool        KeyAlt;                     
    bool        KeySuper;                   
    bool        KeysDown[512];              
    ImWchar     InputCharacters[16+1];      

    
     void AddInputCharacter(ImWchar c);                        
     void AddInputCharactersUTF8(const char* utf8_chars);      
    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   

    
    
    

    bool        WantCaptureMouse;           
    bool        WantCaptureKeyboard;        
    bool        WantTextInput;              
    bool        WantMoveMouse;              
    float       Framerate;                  
    int         MetricsAllocs;              
    int         MetricsRenderVertices;      
    int         MetricsRenderIndices;       
    int         MetricsActiveWindows;       
    ImVec2      MouseDelta;                 

    
    
    

    ImVec2      MousePosPrev;               
    ImVec2      MouseClickedPos[5];         
    float       MouseClickedTime[5];        
    bool        MouseClicked[5];            
    bool        MouseDoubleClicked[5];      
    bool        MouseReleased[5];           
    bool        MouseDownOwned[5];          
    float       MouseDownDuration[5];       
    float       MouseDownDurationPrev[5];   
    ImVec2      MouseDragMaxDistanceAbs[5]; 
    float       MouseDragMaxDistanceSqr[5]; 
    float       KeysDownDuration[512];      
    float       KeysDownDurationPrev[512];  

       ImGuiIO();
};






namespace ImGui
{
    static inline void  ShowTestWindow() { return ShowDemoWindow(); } 
    static inline bool  IsRootWindowFocused() { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); } 
    static inline bool  IsRootWindowOrAnyChildFocused() { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); } 
    static inline void  SetNextWindowContentWidth(float width) { SetNextWindowContentSize(ImVec2(width, 0.0f)); } 
    static inline bool  IsRootWindowOrAnyChildHovered(ImGuiHoveredFlags flags = 0) { return IsItemHovered(flags | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows); } 
    bool                Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); 
    static inline void  AlignFirstTextHeightToWidgets() { AlignTextToFramePadding(); }     
    static inline void  SetNextWindowPosCenter(ImGuiCond cond = 0) { SetNextWindowPos(ImVec2(GetIO().DisplaySize.x * 0.5f, GetIO().DisplaySize.y * 0.5f), cond, ImVec2(0.5f, 0.5f)); } 
    static inline bool  IsItemHoveredRect() { return IsItemHovered(ImGuiHoveredFlags_RectOnly); } 
    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { (void)( (!!(0)) || (_wassert(L"0", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(998)), 0) ); return false; } 
    static inline bool  IsMouseHoveringAnyWindow() { return IsAnyWindowHovered(); }        
    static inline bool  IsMouseHoveringWindow() { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); } 
    static inline bool  CollapsingHeader(const char* label, const char* str_id, bool framed = true, bool default_open = false) { (void)str_id; (void)framed; ImGuiTreeNodeFlags default_open_flags = 1 << 5; return CollapsingHeader(label, (default_open ? default_open_flags : 0)); } 
}
#line 1004 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"







template<typename T>
class ImVector
{
public:
    int                         Size;
    int                         Capacity;
    T*                          Data;

    typedef T                   value_type;
    typedef value_type*         iterator;
    typedef const value_type*   const_iterator;

    inline ImVector()           { Size = Capacity = 0; Data = 0; }
    inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }

    inline bool                 empty() const                   { return Size == 0; }
    inline int                  size() const                    { return Size; }
    inline int                  capacity() const                { return Capacity; }

    inline value_type&          operator[](int i)               { (void)( (!!(i < Size)) || (_wassert(L"i < Size", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1030)), 0) ); return Data[i]; }
    inline const value_type&    operator[](int i) const         { (void)( (!!(i < Size)) || (_wassert(L"i < Size", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1031)), 0) ); return Data[i]; }

    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = 0; } }
    inline iterator             begin()                         { return Data; }
    inline const_iterator       begin() const                   { return Data; }
    inline iterator             end()                           { return Data + Size; }
    inline const_iterator       end() const                     { return Data + Size; }
    inline value_type&          front()                         { (void)( (!!(Size > 0)) || (_wassert(L"Size > 0", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1038)), 0) ); return Data[0]; }
    inline const value_type&    front() const                   { (void)( (!!(Size > 0)) || (_wassert(L"Size > 0", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1039)), 0) ); return Data[0]; }
    inline value_type&          back()                          { (void)( (!!(Size > 0)) || (_wassert(L"Size > 0", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1040)), 0) ); return Data[Size - 1]; }
    inline const value_type&    back() const                    { (void)( (!!(Size > 0)) || (_wassert(L"Size > 0", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1041)), 0) ); return Data[Size - 1]; }
    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int                  _grow_capacity(int sz) const    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void                 resize(int new_size, const T& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) Data[n] = v; Size = new_size; }
    inline void                 reserve(int new_capacity)
    {
        if (new_capacity <= Capacity) 
            return;
        T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T));
        if (Data)
            memcpy(new_data, Data, (size_t)Size * sizeof(T));
        ImGui::MemFree(Data);
        Data = new_data;
        Capacity = new_capacity;
    }

    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); Data[Size++] = v; }
    inline void                 pop_back()                      { (void)( (!!(Size > 0)) || (_wassert(L"Size > 0", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1061)), 0) ); Size--; }
    inline void                 push_front(const value_type& v) { if (Size == 0) push_back(v); else insert(Data, v); }

    inline iterator             erase(const_iterator it)        { (void)( (!!(it >= Data && it < Data+Size)) || (_wassert(L"it >= Data && it < Data+Size", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1064)), 0) ); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }
    inline iterator             insert(const_iterator it, const value_type& v)  { (void)( (!!(it >= Data && it <= Data+Size)) || (_wassert(L"it >= Data && it <= Data+Size", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1065)), 0) ); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }
    inline bool                 contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
};






struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};




#line 1085 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"


struct ImGuiTextFilter
{
    struct TextRange
    {
        const char* b;
        const char* e;

        TextRange() { b = e = 0; }
        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        const char* begin() const { return b; }
        const char* end() const { return e; }
        bool empty() const { return b == e; }
        char front() const { return *b; }
        static bool is_blank(char c) { return c == ' ' || c == '\t'; }
        void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }
         void split(char separator, ImVector<TextRange>& out);
    };

    char                InputBuf[256];
    ImVector<TextRange> Filters;
    int                 CountGrep;

               ImGuiTextFilter(const char* default_filter = "");
     bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    
     bool      PassFilter(const char* text, const char* text_end = 0) const;
     void      Build();
    void                Clear() { InputBuf[0] = 0; Build(); }
    bool                IsActive() const { return !Filters.empty(); }
};


struct ImGuiTextBuffer
{
    ImVector<char>      Buf;

    ImGuiTextBuffer()   { Buf.push_back(0); }
    inline char         operator[](int i) { return Buf.Data[i]; }
    const char*         begin() const { return &Buf.front(); }
    const char*         end() const { return &Buf.back(); }      
    int                 size() const { return Buf.Size - 1; }
    bool                empty() { return Buf.Size <= 1; }
    void                clear() { Buf.clear(); Buf.push_back(0); }
    void                reserve(int capacity) { Buf.reserve(capacity); }
    const char*         c_str() const { return Buf.Data; }
     void      appendf(const char* fmt, ...) ;
     void      appendfv(const char* fmt, va_list args) ;
};









struct ImGuiStorage
{
    struct Pair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }
        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
    };
    ImVector<Pair>      Data;

    
    
    
    void                Clear() { Data.clear(); }
     int       GetInt(ImGuiID key, int default_val = 0) const;
     void      SetInt(ImGuiID key, int val);
     bool      GetBool(ImGuiID key, bool default_val = false) const;
     void      SetBool(ImGuiID key, bool val);
     float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
     void      SetFloat(ImGuiID key, float val);
     void*     GetVoidPtr(ImGuiID key) const; 
     void      SetVoidPtr(ImGuiID key, void* val);

    
    
    
    
     int*      GetIntRef(ImGuiID key, int default_val = 0);
     bool*     GetBoolRef(ImGuiID key, bool default_val = false);
     float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
     void**    GetVoidPtrRef(ImGuiID key, void* default_val = 0);

    
     void      SetAllInt(int val);

    
     void      BuildSortByKey();
};


struct ImGuiTextEditCallbackData
{
    ImGuiInputTextFlags EventFlag;      
    ImGuiInputTextFlags Flags;          
    void*               UserData;       
    bool                ReadOnly;       

    
    ImWchar             EventChar;      

    
    
    ImGuiKey            EventKey;       
    char*               Buf;            
    int                 BufTextLen;     
    int                 BufSize;        
    bool                BufDirty;       
    int                 CursorPos;      
    int                 SelectionStart; 
    int                 SelectionEnd;   

    
     void    DeleteChars(int pos, int bytes_count);
     void    InsertChars(int pos, const char* text, const char* text_end = 0);
    bool              HasSelection() const { return SelectionStart != SelectionEnd; }
};



struct ImGuiSizeConstraintCallbackData
{
    void*   UserData;       
    ImVec2  Pos;            
    ImVec2  CurrentSize;    
    ImVec2  DesiredSize;    
};


struct ImGuiPayload
{
    
    const void*     Data;               
    int             DataSize;           

    
    ImGuiID         SourceId;           
    ImGuiID         SourceParentId;     
    int             DataFrameCount;     
    char            DataType[8 + 1];    
    bool            Preview;            
    bool            Delivery;           

    ImGuiPayload()  { Clear(); }
    void Clear()    { SourceId = SourceParentId = 0; Data = 0; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const                  { return Preview; }
    bool IsDelivery() const                 { return Delivery; }
};














#line 1258 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"









struct ImColor
{
    ImVec4              Value;

    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>0)&0xFF) * sc; Value.y = (float)((rgba>>8)&0xFF) * sc; Value.z = (float)((rgba>>16)&0xFF) * sc; Value.w = (float)((rgba>>24)&0xFF) * sc; }
    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
    ImColor(const ImVec4& col)                                      { Value = col; }
    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const                                  { return Value; }

    
    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
};














struct ImGuiListClipper
{
    float   StartPosY;
    float   ItemsHeight;
    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;

    
    
    
    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } 
    ~ImGuiListClipper()                                                 { (void)( (!!(ItemsCount == -1)) || (_wassert(L"ItemsCount == -1", L"i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h", (unsigned)(1307)), 0) ); }      

     bool Step();                                              
     void Begin(int items_count, float items_height = -1.0f);  
     void End();                                               
};










typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);


struct ImDrawCmd
{
    unsigned int    ElemCount;              
    ImVec4          ClipRect;               
    ImTextureID     TextureId;              
    ImDrawCallback  UserCallback;           
    void*           UserCallbackData;       

    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = 0; UserCallback = 0; UserCallbackData = 0; }
};



typedef unsigned short ImDrawIdx;
#line 1341 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"



struct ImDrawVert
{
    ImVec2  pos;
    ImVec2  uv;
    ImU32   col;
};






#line 1357 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"



struct ImDrawChannel
{
    ImVector<ImDrawCmd>     CmdBuffer;
    ImVector<ImDrawIdx>     IdxBuffer;
};

enum ImDrawCornerFlags_
{
    ImDrawCornerFlags_TopLeft   = 1 << 0, 
    ImDrawCornerFlags_TopRight  = 1 << 1, 
    ImDrawCornerFlags_BotLeft   = 1 << 2, 
    ImDrawCornerFlags_BotRight  = 1 << 3, 
    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   
    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   
    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    
    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  
    ImDrawCornerFlags_All       = 0xF     
};

enum ImDrawListFlags_
{
    ImDrawListFlags_AntiAliasedLines = 1 << 0,
    ImDrawListFlags_AntiAliasedFill  = 1 << 1
};







struct ImDrawList
{
    
    ImVector<ImDrawCmd>     CmdBuffer;          
    ImVector<ImDrawIdx>     IdxBuffer;          
    ImVector<ImDrawVert>    VtxBuffer;          

    
    ImDrawListFlags         Flags;              
    const ImDrawListSharedData* _Data;          
    const char*             _OwnerName;         
    unsigned int            _VtxCurrentIdx;     
    ImDrawVert*             _VtxWritePtr;       
    ImDrawIdx*              _IdxWritePtr;       
    ImVector<ImVec4>        _ClipRectStack;     
    ImVector<ImTextureID>   _TextureIdStack;    
    ImVector<ImVec2>        _Path;              
    int                     _ChannelsCurrent;   
    int                     _ChannelsCount;     
    ImVector<ImDrawChannel> _Channels;          

    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = 0; Clear(); }
    ~ImDrawList() { ClearFreeMemory(); }
     void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  
     void  PushClipRectFullScreen();
     void  PopClipRect();
     void  PushTextureID(const ImTextureID& texture_id);
     void  PopTextureID();
    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }

    
     void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
     void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   
     void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     
     void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
     void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
     void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
     void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
     void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
     void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
     void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
     void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = 0);
     void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = 0, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = 0);
     void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
     void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
     void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
     void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
     void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);
     void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);

    
    inline    void  PathClear()                                                 { _Path.resize(0); }
    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }
    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
     void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
     void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                
     void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
     void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);

    
    
    
     void  ChannelsSplit(int channels_count);
     void  ChannelsMerge();
     void  ChannelsSetCurrent(int channel_index);

    
     void  AddCallback(ImDrawCallback callback, void* callback_data);  
     void  AddDrawCmd();                                               

    
    
     void  Clear();
     void  ClearFreeMemory();
     void  PrimReserve(int idx_count, int vtx_count);
     void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      
     void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
     void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
     void  UpdateClipRect();
     void  UpdateTextureID();
};


struct ImDrawData
{
    bool            Valid;                  
    ImDrawList**    CmdLists;
    int             CmdListsCount;
    int             TotalVtxCount;          
    int             TotalIdxCount;          

    
    ImDrawData() { Valid = false; CmdLists = 0; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }
     void DeIndexAllBuffers();               
     void ScaleClipRects(const ImVec2& sc);  
};

struct ImFontConfig
{
    void*           FontData;                   
    int             FontDataSize;               
    bool            FontDataOwnedByAtlas;       
    int             FontNo;                     
    float           SizePixels;                 
    int             OversampleH, OversampleV;   
    bool            PixelSnapH;                 
    ImVec2          GlyphExtraSpacing;          
    ImVec2          GlyphOffset;                
    const ImWchar*  GlyphRanges;                
    bool            MergeMode;                  
    unsigned int    RasterizerFlags;            
    float           RasterizerMultiply;         

    
    char            Name[32];                               
    ImFont*         DstFont;

     ImFontConfig();
};

struct ImFontGlyph
{
    ImWchar         Codepoint;          
    float           AdvanceX;           
    float           X0, Y0, X1, Y1;     
    float           U0, V0, U1, V1;     
};









struct ImFontAtlas
{
     ImFontAtlas();
     ~ImFontAtlas();
     ImFont*           AddFont(const ImFontConfig* font_cfg);
     ImFont*           AddFontDefault(const ImFontConfig* font_cfg = 0);
     ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = 0, const ImWchar* glyph_ranges = 0);
     ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = 0, const ImWchar* glyph_ranges = 0); 
     ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = 0, const ImWchar* glyph_ranges = 0); 
     ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = 0, const ImWchar* glyph_ranges = 0);              
     void              ClearTexData();             
     void              ClearInputData();           
     void              ClearFonts();               
     void              Clear();                    

    
    
    
    
     bool              Build();                    
     void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = 0);  
     void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = 0);  
    void                        SetTexID(ImTextureID id)    { TexID = id; }

    
    
    

    
    
     const ImWchar*    GetGlyphRangesDefault();    
     const ImWchar*    GetGlyphRangesKorean();     
     const ImWchar*    GetGlyphRangesJapanese();   
     const ImWchar*    GetGlyphRangesChinese();    
     const ImWchar*    GetGlyphRangesCyrillic();   
     const ImWchar*    GetGlyphRangesThai();       

    
    struct GlyphRangesBuilder
    {
        ImVector<unsigned char> UsedChars;  
        GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
        bool           GetBit(int n)        { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
        void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  
        void           AddChar(ImWchar c)   { SetBit(c); }                          
         void AddText(const char* text, const char* text_end = 0);      
         void AddRanges(const ImWchar* ranges);                            
         void BuildRanges(ImVector<ImWchar>* out_ranges);                  
    };

    
    
    

    
    
    struct CustomRect
    {
        unsigned int    ID;             
        unsigned short  Width, Height;  
        unsigned short  X, Y;           
        float           GlyphAdvanceX;  
        ImVec2          GlyphOffset;    
        ImFont*         Font;           
        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = 0; }
        bool IsPacked() const   { return X != 0xFFFF; }
    };

     int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   
     int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   
     void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return 0; return &CustomRects[index]; }

    
    
    

    ImTextureID                 TexID;              
    int                         TexDesiredWidth;    
    int                         TexGlyphPadding;    

    
    
    unsigned char*              TexPixelsAlpha8;    
    unsigned int*               TexPixelsRGBA32;    
    int                         TexWidth;           
    int                         TexHeight;          
    ImVec2                      TexUvWhitePixel;    
    ImVector<ImFont*>           Fonts;              
    ImVector<CustomRect>        CustomRects;        
    ImVector<ImFontConfig>      ConfigData;         
    int                         CustomRectIds[1];   
};



struct ImFont
{
    
    float                       FontSize;           
    float                       Scale;              
    ImVec2                      DisplayOffset;      
    ImVector<ImFontGlyph>       Glyphs;             
    ImVector<float>             IndexAdvanceX;      
    ImVector<unsigned short>    IndexLookup;        
    const ImFontGlyph*          FallbackGlyph;      
    float                       FallbackAdvanceX;   
    ImWchar                     FallbackChar;       

    
    short                       ConfigDataCount;    
    ImFontConfig*               ConfigData;         
    ImFontAtlas*                ContainerAtlas;     
    float                       Ascent, Descent;    
    int                         MetricsTotalSurface;

    
     ImFont();
     ~ImFont();
     void              ClearOutputData();
     void              BuildLookupTable();
     const ImFontGlyph*FindGlyph(ImWchar c) const;
     void              SetFallbackChar(ImWchar c);
    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool                        IsLoaded() const                    { return ContainerAtlas != 0; }
    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }

    
    
     ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = 0, const char** remaining = 0) const; 
     const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
     void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;
     void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;

    
     void              GrowIndex(int new_size);
     void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
     void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); 


    typedef ImFontGlyph Glyph; 
#line 1675 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"
};



#line 1680 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui.h"






#line 13 "..\\src\\graphics\\graphics.cpp"
#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"











#line 1 "i:\\dev\\motors\\pikkumoottori\\src\\imgui\\imgui_impl_sdl_gl3.h"










struct SDL_Window;
typedef union SDL_Event SDL_Event;

 bool        ImGui_ImplSdlGL3_Init(SDL_Window* window);
 void        ImGui_ImplSdlGL3_Shutdown();
 void        ImGui_ImplSdlGL3_NewFrame(SDL_Window* window);
 bool        ImGui_ImplSdlGL3_ProcessEvent(SDL_Event* event);


 void        ImGui_ImplSdlGL3_InvalidateDeviceObjects();
 bool        ImGui_ImplSdlGL3_CreateDeviceObjects();
#line 13 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"


#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"
























#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"






























#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"
























#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"

































#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 47 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 51 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 55 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 59 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 63 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"




#line 68 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"






















#line 91 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"




#line 96 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 100 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 104 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 108 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 112 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 116 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 120 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"













#line 134 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 138 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"
#line 139 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"




#line 144 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"



#line 148 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"








#line 157 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"






#line 164 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






































#line 40 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"

#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






#line 50 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 51 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"












#line 64 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 72 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







#line 80 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 81 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"














#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"




#line 112 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"



#line 119 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#line 125 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 126 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"








#line 135 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 136 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"










#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 167 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"


extern "C" {
#line 171 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"




extern __declspec(dllexport) const char * __cdecl SDL_GetPlatform (void);



}
#line 181 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 182 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"

#line 184 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_platform.h"


#line 26 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"






#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"
typedef signed __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef signed __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef signed __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef signed __int64 int64_t;
typedef unsigned __int64 uint64_t;











#line 53 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 56 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"














#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"
#line 72 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"





#line 78 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"












































































#line 155 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"





























#line 185 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 188 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"




#line 193 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 196 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 199 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 202 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 205 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"


#line 208 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"













#line 222 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_config.h"
#line 32 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"











#line 44 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


#line 47 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"

#line 49 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


#line 52 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


#line 55 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 56 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"











#line 68 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"

#line 70 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"













































#line 116 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"














typedef enum
{
    SDL_FALSE = 0,
    SDL_TRUE = 1
} SDL_bool;




typedef int8_t Sint8;



typedef uint8_t Uint8;



typedef int16_t Sint16;



typedef uint16_t Uint16;



typedef int32_t Sint32;



typedef uint32_t Uint32;




typedef int64_t Sint64;



typedef uint64_t Uint64;















#line 185 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 186 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"









#line 196 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 197 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"









#line 207 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 208 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"









#line 218 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 219 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"



































#line 255 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"



#line 259 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


#line 262 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 263 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"





typedef int SDL_dummy_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_dummy_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_dummy_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_dummy_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_dummy_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_dummy_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_dummy_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_dummy_sint64[(sizeof(Sint64) == 8) * 2 - 1];
#line 277 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"











   
typedef enum
{
    DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

typedef int SDL_dummy_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];
#line 296 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 297 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 300 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


extern "C" {
#line 304 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"






















#line 327 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"






#line 334 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"

extern __declspec(dllexport) void *__cdecl SDL_malloc(size_t size);
extern __declspec(dllexport) void *__cdecl SDL_calloc(size_t nmemb, size_t size);
extern __declspec(dllexport) void *__cdecl SDL_realloc(void *mem, size_t size);
extern __declspec(dllexport) void __cdecl SDL_free(void *mem);

extern __declspec(dllexport) char *__cdecl SDL_getenv(const char *name);
extern __declspec(dllexport) int __cdecl SDL_setenv(const char *name, const char *value, int overwrite);

extern __declspec(dllexport) void __cdecl SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));

extern __declspec(dllexport) int __cdecl SDL_abs(int x);






extern __declspec(dllexport) int __cdecl SDL_isdigit(int x);
extern __declspec(dllexport) int __cdecl SDL_isspace(int x);
extern __declspec(dllexport) int __cdecl SDL_toupper(int x);
extern __declspec(dllexport) int __cdecl SDL_tolower(int x);

extern __declspec(dllexport) void *__cdecl SDL_memset( void *dst, int c, size_t len);





__forceinline void SDL_memset4(void *dst, Uint32 val, size_t dwords)
{









#line 375 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
    size_t _n = (dwords + 3) / 4;
    Uint32 *_p = static_cast<Uint32 *>(dst);
    Uint32 _val = (val);
    if (dwords == 0)
        return;
    switch (dwords % 4)
    {
        case 0: do {    *_p++ = _val;
        case 3:         *_p++ = _val;
        case 2:         *_p++ = _val;
        case 1:         *_p++ = _val;
        } while ( --_n );
    }
#line 389 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
}


extern __declspec(dllexport) void *__cdecl SDL_memcpy( void *dst,  const void *src, size_t len);

extern __declspec(dllexport) void *__cdecl SDL_memmove( void *dst,  const void *src, size_t len);
extern __declspec(dllexport) int __cdecl SDL_memcmp(const void *s1, const void *s2, size_t len);

extern __declspec(dllexport) size_t __cdecl SDL_wcslen(const wchar_t *wstr);
extern __declspec(dllexport) size_t __cdecl SDL_wcslcpy(  wchar_t *dst, const wchar_t *src, size_t maxlen);
extern __declspec(dllexport) size_t __cdecl SDL_wcslcat(  wchar_t *dst, const wchar_t *src, size_t maxlen);

extern __declspec(dllexport) size_t __cdecl SDL_strlen(const char *str);
extern __declspec(dllexport) size_t __cdecl SDL_strlcpy(  char *dst, const char *src, size_t maxlen);
extern __declspec(dllexport) size_t __cdecl SDL_utf8strlcpy(  char *dst, const char *src, size_t dst_bytes);
extern __declspec(dllexport) size_t __cdecl SDL_strlcat(  char *dst, const char *src, size_t maxlen);
extern __declspec(dllexport) char *__cdecl SDL_strdup(const char *str);
extern __declspec(dllexport) char *__cdecl SDL_strrev(char *str);
extern __declspec(dllexport) char *__cdecl SDL_strupr(char *str);
extern __declspec(dllexport) char *__cdecl SDL_strlwr(char *str);
extern __declspec(dllexport) char *__cdecl SDL_strchr(const char *str, int c);
extern __declspec(dllexport) char *__cdecl SDL_strrchr(const char *str, int c);
extern __declspec(dllexport) char *__cdecl SDL_strstr(const char *haystack, const char *needle);

extern __declspec(dllexport) char *__cdecl SDL_itoa(int value, char *str, int radix);
extern __declspec(dllexport) char *__cdecl SDL_uitoa(unsigned int value, char *str, int radix);
extern __declspec(dllexport) char *__cdecl SDL_ltoa(long value, char *str, int radix);
extern __declspec(dllexport) char *__cdecl SDL_ultoa(unsigned long value, char *str, int radix);
extern __declspec(dllexport) char *__cdecl SDL_lltoa(Sint64 value, char *str, int radix);
extern __declspec(dllexport) char *__cdecl SDL_ulltoa(Uint64 value, char *str, int radix);

extern __declspec(dllexport) int __cdecl SDL_atoi(const char *str);
extern __declspec(dllexport) double __cdecl SDL_atof(const char *str);
extern __declspec(dllexport) long __cdecl SDL_strtol(const char *str, char **endp, int base);
extern __declspec(dllexport) unsigned long __cdecl SDL_strtoul(const char *str, char **endp, int base);
extern __declspec(dllexport) Sint64 __cdecl SDL_strtoll(const char *str, char **endp, int base);
extern __declspec(dllexport) Uint64 __cdecl SDL_strtoull(const char *str, char **endp, int base);
extern __declspec(dllexport) double __cdecl SDL_strtod(const char *str, char **endp);

extern __declspec(dllexport) int __cdecl SDL_strcmp(const char *str1, const char *str2);
extern __declspec(dllexport) int __cdecl SDL_strncmp(const char *str1, const char *str2, size_t maxlen);
extern __declspec(dllexport) int __cdecl SDL_strcasecmp(const char *str1, const char *str2);
extern __declspec(dllexport) int __cdecl SDL_strncasecmp(const char *str1, const char *str2, size_t len);

extern __declspec(dllexport) int __cdecl SDL_sscanf(const char *text,  const char *fmt, ...) ;
extern __declspec(dllexport) int __cdecl SDL_vsscanf(const char *text, const char *fmt, va_list ap);
extern __declspec(dllexport) int __cdecl SDL_snprintf(  char *text, size_t maxlen,   const char *fmt, ... ) ;
extern __declspec(dllexport) int __cdecl SDL_vsnprintf(  char *text, size_t maxlen, const char *fmt, va_list ap);




#line 442 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 443 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"

extern __declspec(dllexport) double __cdecl SDL_acos(double x);
extern __declspec(dllexport) double __cdecl SDL_asin(double x);
extern __declspec(dllexport) double __cdecl SDL_atan(double x);
extern __declspec(dllexport) double __cdecl SDL_atan2(double x, double y);
extern __declspec(dllexport) double __cdecl SDL_ceil(double x);
extern __declspec(dllexport) double __cdecl SDL_copysign(double x, double y);
extern __declspec(dllexport) double __cdecl SDL_cos(double x);
extern __declspec(dllexport) float __cdecl SDL_cosf(float x);
extern __declspec(dllexport) double __cdecl SDL_fabs(double x);
extern __declspec(dllexport) double __cdecl SDL_floor(double x);
extern __declspec(dllexport) double __cdecl SDL_log(double x);
extern __declspec(dllexport) double __cdecl SDL_pow(double x, double y);
extern __declspec(dllexport) double __cdecl SDL_scalbn(double x, int n);
extern __declspec(dllexport) double __cdecl SDL_sin(double x);
extern __declspec(dllexport) float __cdecl SDL_sinf(float x);
extern __declspec(dllexport) double __cdecl SDL_sqrt(double x);
extern __declspec(dllexport) float __cdecl SDL_sqrtf(float x);
extern __declspec(dllexport) double __cdecl SDL_tan(double x);
extern __declspec(dllexport) float __cdecl SDL_tanf(float x);








typedef struct _SDL_iconv_t *SDL_iconv_t;
extern __declspec(dllexport) SDL_iconv_t __cdecl SDL_iconv_open(const char *tocode,
                                                   const char *fromcode);
extern __declspec(dllexport) int __cdecl SDL_iconv_close(SDL_iconv_t cd);
extern __declspec(dllexport) size_t __cdecl SDL_iconv(SDL_iconv_t cd, const char **inbuf,
                                         size_t * inbytesleft, char **outbuf,
                                         size_t * outbytesleft);




extern __declspec(dllexport) char *__cdecl SDL_iconv_string(const char *tocode,
                                               const char *fromcode,
                                               const char *inbuf,
                                               size_t inbytesleft);






























#line 517 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"

__forceinline void *SDL_memcpy4( void *dst,  const void *src, size_t dwords)
{
    return SDL_memcpy(dst, src, dwords * 4);
}



}
#line 527 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 528 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"

#line 530 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_stdinc.h"


#line 26 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"





















































#line 80 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"
#line 81 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"





#line 87 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"


















#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"




extern "C" int SDL_main(int argc, char *argv[]);


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 114 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"

extern "C" {
#line 117 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"








extern __declspec(dllexport) void __cdecl SDL_SetMainReady(void);






extern __declspec(dllexport) int __cdecl SDL_RegisterApp(char *name, Uint32 style,
                                            void *hInst);
extern __declspec(dllexport) void __cdecl SDL_UnregisterApp(void);

#line 137 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"


















}
#line 157 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 158 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"

#line 160 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_main.h"


#line 33 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"


























#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 28 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"


extern "C" {
#line 32 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"








#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"









    extern void __cdecl __debugbreak(void);
    








#line 63 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"



#line 67 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"



#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"
























#line 96 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"




typedef enum
{
    SDL_ASSERTION_RETRY,  
    SDL_ASSERTION_BREAK,  
    SDL_ASSERTION_ABORT,  
    SDL_ASSERTION_IGNORE,  
    SDL_ASSERTION_ALWAYS_IGNORE  
} SDL_AssertState;

typedef struct SDL_AssertData
{
    int always_ignore;
    unsigned int trigger_count;
    const char *condition;
    const char *filename;
    int linenum;
    const char *function;
    const struct SDL_AssertData *next;
} SDL_AssertData;




extern __declspec(dllexport) SDL_AssertState __cdecl SDL_ReportAssertion(SDL_AssertData *,
                                                             const char *,
                                                             const char *, int)







#line 134 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"
;
























#line 160 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"






#line 167 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"



#line 171 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"









#line 181 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"





typedef SDL_AssertState (__cdecl *SDL_AssertionHandler)(
                                 const SDL_AssertData* data, void* userdata);





















extern __declspec(dllexport) void __cdecl SDL_SetAssertionHandler(
                                            SDL_AssertionHandler handler,
                                            void *userdata);











extern __declspec(dllexport) SDL_AssertionHandler __cdecl SDL_GetDefaultAssertionHandler(void);
















extern __declspec(dllexport) SDL_AssertionHandler __cdecl SDL_GetAssertionHandler(void **puserdata);























extern __declspec(dllexport) const SDL_AssertData * __cdecl SDL_GetAssertionReport(void);








extern __declspec(dllexport) void __cdecl SDL_ResetAssertionReport(void);









}
#line 285 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 286 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"

#line 288 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_assert.h"


#line 35 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"
































































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 66 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"



extern "C" {
#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"


















typedef int SDL_SpinLock;








extern __declspec(dllexport) SDL_bool __cdecl SDL_AtomicTryLock(SDL_SpinLock *lock);






extern __declspec(dllexport) void __cdecl SDL_AtomicLock(SDL_SpinLock *lock);






extern __declspec(dllexport) void __cdecl SDL_AtomicUnlock(SDL_SpinLock *lock);









void _ReadWriteBarrier(void);
#pragma intrinsic(_ReadWriteBarrier)







#line 132 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"























#line 156 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"
















#line 173 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"





#line 179 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"



#line 183 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"
#line 184 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"





typedef struct { int value; } SDL_atomic_t;








extern __declspec(dllexport) SDL_bool __cdecl SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval);






extern __declspec(dllexport) int __cdecl SDL_AtomicSet(SDL_atomic_t *a, int v);




extern __declspec(dllexport) int __cdecl SDL_AtomicGet(SDL_atomic_t *a);








extern __declspec(dllexport) int __cdecl SDL_AtomicAdd(SDL_atomic_t *a, int v);






#line 227 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"









#line 237 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"








extern __declspec(dllexport) SDL_bool __cdecl SDL_AtomicCASPtr(void **a, void *oldval, void *newval);






extern __declspec(dllexport) void* __cdecl SDL_AtomicSetPtr(void **a, void* v);




extern __declspec(dllexport) void* __cdecl SDL_AtomicGetPtr(void **a);



}
#line 263 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 265 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"

#line 267 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_atomic.h"


#line 36 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_error.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_error.h"


extern "C" {
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_error.h"



extern __declspec(dllexport) int __cdecl SDL_SetError(  const char *fmt, ...) ;
extern __declspec(dllexport) const char *__cdecl SDL_GetError(void);
extern __declspec(dllexport) void __cdecl SDL_ClearError(void);











typedef enum
{
    SDL_ENOMEM,
    SDL_EFREAD,
    SDL_EFWRITE,
    SDL_EFSEEK,
    SDL_UNSUPPORTED,
    SDL_LASTERROR
} SDL_errorcode;

extern __declspec(dllexport) int __cdecl SDL_Error(SDL_errorcode code);




}
#line 72 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_error.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 73 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_error.h"

#line 75 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_error.h"


#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"















































#line 53 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"

#line 55 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
#line 56 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
#line 57 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 60 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"


extern "C" {
#line 64 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"











#line 77 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"






#line 84 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"








#line 93 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"






#line 100 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
__forceinline Uint16
SDL_Swap16(Uint16 x)
{
    return static_cast<Uint16>(((x << 8) | (x >> 8)));
}
#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"








#line 115 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"






#line 122 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"










#line 133 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"






#line 140 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
__forceinline Uint32
SDL_Swap32(Uint32 x)
{
    return static_cast<Uint32>(((x << 24) | ((x << 8) & 0x00FF0000) | ((x >> 8) & 0x0000FF00) | (x >> 24)));
#line 145 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
}
#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"



















#line 167 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"






#line 174 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
__forceinline Uint64
SDL_Swap64(Uint64 x)
{
    Uint32 hi, lo;

    
    lo = static_cast<Uint32>(x & 0xFFFFFFFF);
    x >>= 32;
    hi = static_cast<Uint32>(x & 0xFFFFFFFF);
    x = SDL_Swap32(lo);
    x <<= 32;
    x |= SDL_Swap32(hi);
    return (x);
}
#line 189 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"


__forceinline float
SDL_SwapFloat(float x)
{
    union
    {
        float f;
        Uint32 ui32;
    } swapper;
    swapper.f = x;
    swapper.ui32 = SDL_Swap32(swapper.ui32);
    return swapper.f;
}

























#line 229 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"




}
#line 235 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 236 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"

#line 238 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_endian.h"


#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mutex.h"

































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mutex.h"


extern "C" {
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mutex.h"



















struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;




extern __declspec(dllexport) SDL_mutex *__cdecl SDL_CreateMutex(void);







extern __declspec(dllexport) int __cdecl SDL_LockMutex(SDL_mutex * mutex);






extern __declspec(dllexport) int __cdecl SDL_TryLockMutex(SDL_mutex * mutex);










extern __declspec(dllexport) int __cdecl SDL_UnlockMutex(SDL_mutex * mutex);




extern __declspec(dllexport) void __cdecl SDL_DestroyMutex(SDL_mutex * mutex);










struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;




extern __declspec(dllexport) SDL_sem *__cdecl SDL_CreateSemaphore(Uint32 initial_value);




extern __declspec(dllexport) void __cdecl SDL_DestroySemaphore(SDL_sem * sem);






extern __declspec(dllexport) int __cdecl SDL_SemWait(SDL_sem * sem);







extern __declspec(dllexport) int __cdecl SDL_SemTryWait(SDL_sem * sem);










extern __declspec(dllexport) int __cdecl SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms);






extern __declspec(dllexport) int __cdecl SDL_SemPost(SDL_sem * sem);




extern __declspec(dllexport) Uint32 __cdecl SDL_SemValue(SDL_sem * sem);










struct SDL_cond;
typedef struct SDL_cond SDL_cond;





























extern __declspec(dllexport) SDL_cond *__cdecl SDL_CreateCond(void);




extern __declspec(dllexport) void __cdecl SDL_DestroyCond(SDL_cond * cond);






extern __declspec(dllexport) int __cdecl SDL_CondSignal(SDL_cond * cond);






extern __declspec(dllexport) int __cdecl SDL_CondBroadcast(SDL_cond * cond);










extern __declspec(dllexport) int __cdecl SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex);









extern __declspec(dllexport) int __cdecl SDL_CondWaitTimeout(SDL_cond * cond,
                                                SDL_mutex * mutex, Uint32 ms);






}
#line 247 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mutex.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 248 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mutex.h"

#line 250 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mutex.h"


#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"





































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"


extern "C" {
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"


struct SDL_Thread;
typedef struct SDL_Thread SDL_Thread;


typedef unsigned long SDL_threadID;


typedef unsigned int SDL_TLSID;






typedef enum {
    SDL_THREAD_PRIORITY_LOW,
    SDL_THREAD_PRIORITY_NORMAL,
    SDL_THREAD_PRIORITY_HIGH
} SDL_ThreadPriority;





typedef int (__cdecl * SDL_ThreadFunction) (void *data);























#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\process.h"








#pragma once



#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_startup.h"








#pragma once


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\math.h"















#line 13 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_startup.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_startup.h"







#pragma once

#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime.h"





















































































































































































































































































































#line 11 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_startup.h"
#line 1 "H:\\Visual Studio\\VC\\INCLUDE\\stdbool.h"




















#line 22 "H:\\Visual Studio\\VC\\INCLUDE\\stdbool.h"





#line 12 "H:\\Visual Studio\\VC\\INCLUDE\\vcruntime_startup.h"

__pragma(pack(push, 8)) extern "C" {



typedef enum _crt_argv_mode
{
    _crt_argv_no_arguments,
    _crt_argv_unexpanded_arguments,
    _crt_argv_expanded_arguments,
} _crt_argv_mode;

typedef enum _crt_exit_return_mode
{
    _crt_exit_terminate_process,
    _crt_exit_return_to_caller
} _crt_exit_return_mode;

typedef enum _crt_exit_cleanup_mode
{
    _crt_exit_full_cleanup,
    _crt_exit_quick_cleanup,
    _crt_exit_no_cleanup
} _crt_exit_cleanup_mode;

extern _crt_exit_return_mode __current_exit_return_mode;



bool __cdecl __vcrt_initialize(void);
bool __cdecl __vcrt_uninitialize(  bool _Terminating);
bool __cdecl __vcrt_uninitialize_critical(void);
bool __cdecl __vcrt_thread_attach(void);
bool __cdecl __vcrt_thread_detach(void);

int __cdecl __isa_available_init(void);
_crt_argv_mode __cdecl _get_startup_argv_mode(void); 



} __pragma(pack(pop))
#line 14 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_startup.h"

__pragma(pack(push, 8)) extern "C" {








struct _EXCEPTION_POINTERS;

__declspec(dllimport) int __cdecl _seh_filter_dll(
      unsigned long               _ExceptionNum,
      struct _EXCEPTION_POINTERS* _ExceptionPtr
    );

__declspec(dllimport) int __cdecl _seh_filter_exe(
      unsigned long               _ExceptionNum,
      struct _EXCEPTION_POINTERS* _ExceptionPtr
    );








typedef enum _crt_app_type
{
    _crt_unknown_app,
    _crt_console_app,
    _crt_gui_app
} _crt_app_type;

__declspec(dllimport) _crt_app_type __cdecl _query_app_type(void);

__declspec(dllimport) void __cdecl _set_app_type(
      _crt_app_type _Type
    );

typedef int (__cdecl *_UserMathErrorFunctionPointer)(struct _exception *);

__declspec(dllimport) void __cdecl __setusermatherr(
    _UserMathErrorFunctionPointer _UserMathErrorFunction
    );

int __cdecl _is_c_termination_complete(void);








__declspec(dllimport) errno_t __cdecl _configure_narrow_argv(
      _crt_argv_mode mode
    );

__declspec(dllimport) errno_t __cdecl _configure_wide_argv(
      _crt_argv_mode mode
    );



int __cdecl _initialize_narrow_environment(void);
int __cdecl _initialize_wide_environment(void);

__declspec(dllimport) char**    __cdecl _get_initial_narrow_environment(void);
__declspec(dllimport) wchar_t** __cdecl _get_initial_wide_environment(void);

char*    __cdecl _get_narrow_winmain_command_line(void);
wchar_t* __cdecl _get_wide_winmain_command_line(void);

__declspec(dllimport) char**    __cdecl __p__acmdln(void);
__declspec(dllimport) wchar_t** __cdecl __p__wcmdln(void);





    
    
#line 100 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_startup.h"








typedef void (__cdecl* _PVFV)(void);
typedef int  (__cdecl* _PIFV)(void);
typedef void (__cdecl* _PVFI)(int);


    __declspec(dllimport) void __cdecl _initterm(
            _PVFV*  _First,
                                     _PVFV*  _Last
        );

    __declspec(dllimport) int  __cdecl _initterm_e(
               _PIFV*  _First,
                                     _PIFV*  _Last
        );
#line 123 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_startup.h"










typedef struct _onexit_table_t
{
    _PVFV* _first;
    _PVFV* _last;
    _PVFV* _end;
} _onexit_table_t;

__declspec(dllimport) int __cdecl _initialize_onexit_table(
      _onexit_table_t* _Table
    );

__declspec(dllimport) int __cdecl _register_onexit_function(
      _onexit_table_t* _Table,
      _onexit_t        _Function
    );

__declspec(dllimport) int __cdecl _execute_onexit_table(
      _onexit_table_t* _Table
    );

__declspec(dllimport) int __cdecl _crt_atexit(
      _PVFV _Function
    );

__declspec(dllimport) int __cdecl _crt_at_quick_exit(
      _PVFV _Function
    );










     
    __crt_bool __cdecl __acrt_initialize(void);

     
    __crt_bool __cdecl __acrt_uninitialize(
          __crt_bool _Terminating
        );

     
    __crt_bool __cdecl __acrt_uninitialize_critical(
          __crt_bool _Terminating
        );

     
    __crt_bool __cdecl __acrt_thread_attach(void);

     
    __crt_bool __cdecl __acrt_thread_detach(void);

#line 190 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\corecrt_startup.h"



} __pragma(pack(pop))
#line 14 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\process.h"


__pragma(pack(push, 8)) extern "C" {




















    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);

    __declspec(dllimport) int __cdecl system(  char const* _Command);

    __declspec(dllimport) void __cdecl _cexit(void);
    __declspec(dllimport) void __cdecl _c_exit(void);

    typedef void (__stdcall *_tls_callback_type)(void *, unsigned long, void *);
    __declspec(dllimport) void __cdecl _register_thread_local_exe_atexit_callback(  _tls_callback_type _Callback);

#line 52 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\process.h"



























typedef void     (__cdecl*   _beginthread_proc_type  )(void*);
typedef unsigned (__stdcall* _beginthreadex_proc_type)(void*);

__declspec(dllimport) uintptr_t __cdecl _beginthread(
          _beginthread_proc_type _StartAddress,
          unsigned               _StackSize,
      void*                  _ArgList
    );

__declspec(dllimport) void __cdecl _endthread(void);

 
__declspec(dllimport) uintptr_t __cdecl _beginthreadex(
       void*                    _Security,
           unsigned                 _StackSize,
           _beginthreadex_proc_type _StartAddress,
       void*                    _ArgList,
           unsigned                 _InitFlag,
      unsigned*                _ThrdAddr
    );

__declspec(dllimport) void __cdecl _endthreadex(
      unsigned _ReturnCode
    );





    __declspec(dllimport) int __cdecl _getpid(void);

    __declspec(dllimport) intptr_t __cdecl _cwait(
          int*     _TermStat,
               intptr_t _ProcHandle,
               int      _Action
        );

    __declspec(dllimport) intptr_t __cdecl _execl(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execle(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execlp(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execlpe(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execv(
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _execve(
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(dllimport) intptr_t __cdecl _execvp(
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _execvpe(
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(dllimport) intptr_t __cdecl _spawnl(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnle(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnlp(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnlpe(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnv(
            int                _Mode,
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _spawnve(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(dllimport) intptr_t __cdecl _spawnvp(
            int                _Mode,
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _spawnvpe(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "LoadLibrary" " " "instead. See online help for details."))
    __declspec(dllimport) intptr_t __cdecl _loaddll(
          char* _FileName
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "FreeLibrary" " " "instead. See online help for details."))
    __declspec(dllimport) int __cdecl _unloaddll(
          intptr_t _Handle
        );

    typedef int (__cdecl* _GetDllProcAddrProcType)(void);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetProcAddress" " " "instead. See online help for details."))
    __declspec(dllimport) _GetDllProcAddrProcType __cdecl _getdllprocaddr(
                intptr_t _Handle,
          char*    _ProcedureName,
                intptr_t _Ordinal
        );

#line 228 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\process.h"





    
    
    
    
    
    
    
    

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_cwait" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl cwait(
              int*     _TermStat,
                   intptr_t _ProcHandle,
                   int      _Action
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execl" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execl(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execle" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execle(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execlp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execlp(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execlpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execlpe(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execv" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execv(
              char const*        _FileName,
              char const* const* _Arguments
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execve" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execve(
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execvp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execvp(
              char const*        _FileName,
              char const* const* _Arguments
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execvpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execvpe(
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnl" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnl(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnle" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnle(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnlp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnlp(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnlpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnlpe(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnv" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnv(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnve" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnve(
                    int                _Mode,
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnvp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnvp(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnvpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnvpe(
                    int                _Mode,
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getpid" ". See online help for details."))
        __declspec(dllimport) int __cdecl getpid(void);

    #line 362 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\process.h"

#line 364 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\process.h"



} __pragma(pack(pop))
#line 94 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"

typedef uintptr_t(__cdecl * pfnSDL_CurrentBeginThread) (void *, unsigned,
                                                        unsigned (__stdcall *
                                                                  func) (void
                                                                         *),
                                                        void *arg, unsigned,
                                                        unsigned *threadID);
typedef void (__cdecl * pfnSDL_CurrentEndThread) (unsigned code);




extern __declspec(dllexport) SDL_Thread *__cdecl
SDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data,
                 pfnSDL_CurrentBeginThread pfnBeginThread,
                 pfnSDL_CurrentEndThread pfnEndThread);







#line 118 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"

#line 120 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"
























#line 145 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"








extern __declspec(dllexport) const char *__cdecl SDL_GetThreadName(SDL_Thread *thread);




extern __declspec(dllexport) SDL_threadID __cdecl SDL_ThreadID(void);






extern __declspec(dllexport) SDL_threadID __cdecl SDL_GetThreadID(SDL_Thread * thread);




extern __declspec(dllexport) int __cdecl SDL_SetThreadPriority(SDL_ThreadPriority priority);



















extern __declspec(dllexport) void __cdecl SDL_WaitThread(SDL_Thread * thread, int *status);



























extern __declspec(dllexport) void __cdecl SDL_DetachThread(SDL_Thread * thread);































extern __declspec(dllexport) SDL_TLSID __cdecl SDL_TLSCreate(void);











extern __declspec(dllexport) void * __cdecl SDL_TLSGet(SDL_TLSID id);













extern __declspec(dllexport) int __cdecl SDL_TLSSet(SDL_TLSID id, const void *value, void (*destructor)(void*));




}
#line 283 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 284 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"

#line 286 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_thread.h"


#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"


































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"


extern "C" {
#line 40 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"












typedef struct SDL_RWops
{
    


    Sint64 (__cdecl * size) (struct SDL_RWops * context);

    





    Sint64 (__cdecl * seek) (struct SDL_RWops * context, Sint64 offset,
                             int whence);

    





    size_t (__cdecl * read) (struct SDL_RWops * context, void *ptr,
                             size_t size, size_t maxnum);

    





    size_t (__cdecl * write) (struct SDL_RWops * context, const void *ptr,
                              size_t size, size_t num);

    




    int (__cdecl * close) (struct SDL_RWops * context);

    Uint32 type;
    union
    {













#line 110 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"
        struct
        {
            SDL_bool append;
            void *h;
            struct
            {
                void *data;
                size_t size;
                size_t left;
            } buffer;
        } windowsio;
#line 122 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"








        struct
        {
            Uint8 *base;
            Uint8 *here;
            Uint8 *stop;
        } mem;
        struct
        {
            void *data1;
            void *data2;
        } unknown;
    } hidden;

} SDL_RWops;









extern __declspec(dllexport) SDL_RWops *__cdecl SDL_RWFromFile(const char *file,
                                                  const char *mode);





extern __declspec(dllexport) SDL_RWops *__cdecl SDL_RWFromFP(void * fp,
                                                SDL_bool autoclose);
#line 163 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"

extern __declspec(dllexport) SDL_RWops *__cdecl SDL_RWFromMem(void *mem, int size);
extern __declspec(dllexport) SDL_RWops *__cdecl SDL_RWFromConstMem(const void *mem,
                                                      int size);




extern __declspec(dllexport) SDL_RWops *__cdecl SDL_AllocRW(void);
extern __declspec(dllexport) void __cdecl SDL_FreeRW(SDL_RWops * area);


























extern __declspec(dllexport) Uint8 __cdecl SDL_ReadU8(SDL_RWops * src);
extern __declspec(dllexport) Uint16 __cdecl SDL_ReadLE16(SDL_RWops * src);
extern __declspec(dllexport) Uint16 __cdecl SDL_ReadBE16(SDL_RWops * src);
extern __declspec(dllexport) Uint32 __cdecl SDL_ReadLE32(SDL_RWops * src);
extern __declspec(dllexport) Uint32 __cdecl SDL_ReadBE32(SDL_RWops * src);
extern __declspec(dllexport) Uint64 __cdecl SDL_ReadLE64(SDL_RWops * src);
extern __declspec(dllexport) Uint64 __cdecl SDL_ReadBE64(SDL_RWops * src);








extern __declspec(dllexport) size_t __cdecl SDL_WriteU8(SDL_RWops * dst, Uint8 value);
extern __declspec(dllexport) size_t __cdecl SDL_WriteLE16(SDL_RWops * dst, Uint16 value);
extern __declspec(dllexport) size_t __cdecl SDL_WriteBE16(SDL_RWops * dst, Uint16 value);
extern __declspec(dllexport) size_t __cdecl SDL_WriteLE32(SDL_RWops * dst, Uint32 value);
extern __declspec(dllexport) size_t __cdecl SDL_WriteBE32(SDL_RWops * dst, Uint32 value);
extern __declspec(dllexport) size_t __cdecl SDL_WriteLE64(SDL_RWops * dst, Uint64 value);
extern __declspec(dllexport) size_t __cdecl SDL_WriteBE64(SDL_RWops * dst, Uint64 value);




}
#line 227 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 228 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"

#line 230 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rwops.h"


#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"


extern "C" {
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"





















typedef Uint16 SDL_AudioFormat;


































































#line 132 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"






























typedef void (__cdecl * SDL_AudioCallback) (void *userdata, Uint8 * stream,
                                            int len);




typedef struct SDL_AudioSpec
{
    int freq;                   
    SDL_AudioFormat format;     
    Uint8 channels;             
    Uint8 silence;              
    Uint16 samples;             
    Uint16 padding;             
    Uint32 size;                
    SDL_AudioCallback callback; 
    void *userdata;             
} SDL_AudioSpec;


struct SDL_AudioCVT;
typedef void (__cdecl * SDL_AudioFilter) (struct SDL_AudioCVT * cvt,
                                          SDL_AudioFormat format);













#line 199 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"

typedef struct SDL_AudioCVT
{
    int needed;                 
    SDL_AudioFormat src_format; 
    SDL_AudioFormat dst_format; 
    double rate_incr;           
    Uint8 *buf;                 
    int len;                    
    int len_cvt;                
    int len_mult;               
    double len_ratio;           
    SDL_AudioFilter filters[10];        
    int filter_index;           
}  SDL_AudioCVT;











extern __declspec(dllexport) int __cdecl SDL_GetNumAudioDrivers(void);
extern __declspec(dllexport) const char *__cdecl SDL_GetAudioDriver(int index);










extern __declspec(dllexport) int __cdecl SDL_AudioInit(const char *driver_name);
extern __declspec(dllexport) void __cdecl SDL_AudioQuit(void);






extern __declspec(dllexport) const char *__cdecl SDL_GetCurrentAudioDriver(void);














































extern __declspec(dllexport) int __cdecl SDL_OpenAudio(SDL_AudioSpec * desired,
                                          SDL_AudioSpec * obtained);










typedef Uint32 SDL_AudioDeviceID;













extern __declspec(dllexport) int __cdecl SDL_GetNumAudioDevices(int iscapture);














extern __declspec(dllexport) const char *__cdecl SDL_GetAudioDeviceName(int index,
                                                           int iscapture);















extern __declspec(dllexport) SDL_AudioDeviceID __cdecl SDL_OpenAudioDevice(const char
                                                              *device,
                                                              int iscapture,
                                                              const
                                                              SDL_AudioSpec *
                                                              desired,
                                                              SDL_AudioSpec *
                                                              obtained,
                                                              int
                                                              allowed_changes);









typedef enum
{
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING,
    SDL_AUDIO_PAUSED
} SDL_AudioStatus;
extern __declspec(dllexport) SDL_AudioStatus __cdecl SDL_GetAudioStatus(void);

extern __declspec(dllexport) SDL_AudioStatus __cdecl
SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev);












extern __declspec(dllexport) void __cdecl SDL_PauseAudio(int pause_on);
extern __declspec(dllexport) void __cdecl SDL_PauseAudioDevice(SDL_AudioDeviceID dev,
                                                  int pause_on);





















extern __declspec(dllexport) SDL_AudioSpec *__cdecl SDL_LoadWAV_RW(SDL_RWops * src,
                                                      int freesrc,
                                                      SDL_AudioSpec * spec,
                                                      Uint8 ** audio_buf,
                                                      Uint32 * audio_len);











extern __declspec(dllexport) void __cdecl SDL_FreeWAV(Uint8 * audio_buf);










extern __declspec(dllexport) int __cdecl SDL_BuildAudioCVT(SDL_AudioCVT * cvt,
                                              SDL_AudioFormat src_format,
                                              Uint8 src_channels,
                                              int src_rate,
                                              SDL_AudioFormat dst_format,
                                              Uint8 dst_channels,
                                              int dst_rate);











extern __declspec(dllexport) int __cdecl SDL_ConvertAudio(SDL_AudioCVT * cvt);









extern __declspec(dllexport) void __cdecl SDL_MixAudio(Uint8 * dst, const Uint8 * src,
                                          Uint32 len, int volume);






extern __declspec(dllexport) void __cdecl SDL_MixAudioFormat(Uint8 * dst,
                                                const Uint8 * src,
                                                SDL_AudioFormat format,
                                                Uint32 len, int volume);








































extern __declspec(dllexport) int __cdecl SDL_QueueAudio(SDL_AudioDeviceID dev, const void *data, Uint32 len);













































extern __declspec(dllexport) Uint32 __cdecl SDL_DequeueAudio(SDL_AudioDeviceID dev, void *data, Uint32 len);



































extern __declspec(dllexport) Uint32 __cdecl SDL_GetQueuedAudioSize(SDL_AudioDeviceID dev);



































extern __declspec(dllexport) void __cdecl SDL_ClearQueuedAudio(SDL_AudioDeviceID dev);











extern __declspec(dllexport) void __cdecl SDL_LockAudio(void);
extern __declspec(dllexport) void __cdecl SDL_LockAudioDevice(SDL_AudioDeviceID dev);
extern __declspec(dllexport) void __cdecl SDL_UnlockAudio(void);
extern __declspec(dllexport) void __cdecl SDL_UnlockAudioDevice(SDL_AudioDeviceID dev);





extern __declspec(dllexport) void __cdecl SDL_CloseAudio(void);
extern __declspec(dllexport) void __cdecl SDL_CloseAudioDevice(SDL_AudioDeviceID dev);



}
#line 668 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 669 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"

#line 671 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_audio.h"


#line 37 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_clipboard.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_clipboard.h"


extern "C" {
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_clipboard.h"








extern __declspec(dllexport) int __cdecl SDL_SetClipboardText(const char *text);






extern __declspec(dllexport) char * __cdecl SDL_GetClipboardText(void);






extern __declspec(dllexport) SDL_bool __cdecl SDL_HasClipboardText(void);




}
#line 67 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_clipboard.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 68 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_clipboard.h"

#line 70 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_clipboard.h"


#line 38 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"































































#line 65 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 67 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"


extern "C" {
#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"











extern __declspec(dllexport) int __cdecl SDL_GetCPUCount(void);







extern __declspec(dllexport) int __cdecl SDL_GetCPUCacheLineSize(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasRDTSC(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasAltiVec(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasMMX(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_Has3DNow(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasSSE(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasSSE2(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasSSE3(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasSSE41(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasSSE42(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasAVX(void);




extern __declspec(dllexport) SDL_bool __cdecl SDL_HasAVX2(void);




extern __declspec(dllexport) int __cdecl SDL_GetSystemRAM(void);




}
#line 157 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 158 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"

#line 160 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_cpuinfo.h"


#line 39 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"

































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"


extern "C" {
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"












enum
{
    SDL_PIXELTYPE_UNKNOWN,
    SDL_PIXELTYPE_INDEX1,
    SDL_PIXELTYPE_INDEX4,
    SDL_PIXELTYPE_INDEX8,
    SDL_PIXELTYPE_PACKED8,
    SDL_PIXELTYPE_PACKED16,
    SDL_PIXELTYPE_PACKED32,
    SDL_PIXELTYPE_ARRAYU8,
    SDL_PIXELTYPE_ARRAYU16,
    SDL_PIXELTYPE_ARRAYU32,
    SDL_PIXELTYPE_ARRAYF16,
    SDL_PIXELTYPE_ARRAYF32
};


enum
{
    SDL_BITMAPORDER_NONE,
    SDL_BITMAPORDER_4321,
    SDL_BITMAPORDER_1234
};


enum
{
    SDL_PACKEDORDER_NONE,
    SDL_PACKEDORDER_XRGB,
    SDL_PACKEDORDER_RGBX,
    SDL_PACKEDORDER_ARGB,
    SDL_PACKEDORDER_RGBA,
    SDL_PACKEDORDER_XBGR,
    SDL_PACKEDORDER_BGRX,
    SDL_PACKEDORDER_ABGR,
    SDL_PACKEDORDER_BGRA
};




enum
{
    SDL_ARRAYORDER_NONE,
    SDL_ARRAYORDER_RGB,
    SDL_ARRAYORDER_RGBA,
    SDL_ARRAYORDER_ARGB,
    SDL_ARRAYORDER_BGR,
    SDL_ARRAYORDER_BGRA,
    SDL_ARRAYORDER_ABGR
};


enum
{
    SDL_PACKEDLAYOUT_NONE,
    SDL_PACKEDLAYOUT_332,
    SDL_PACKEDLAYOUT_4444,
    SDL_PACKEDLAYOUT_1555,
    SDL_PACKEDLAYOUT_5551,
    SDL_PACKEDLAYOUT_565,
    SDL_PACKEDLAYOUT_8888,
    SDL_PACKEDLAYOUT_2101010,
    SDL_PACKEDLAYOUT_1010102
};























































enum
{
    SDL_PIXELFORMAT_UNKNOWN,
    SDL_PIXELFORMAT_INDEX1LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),
#line 177 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_INDEX1MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),
#line 180 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_INDEX4LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),
#line 183 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_INDEX4MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),
#line 186 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_INDEX8 =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX8) << 24) | ((0) << 20) | ((0) << 16) | ((8) << 8) | ((1) << 0)),
    SDL_PIXELFORMAT_RGB332 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED8) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_332) << 16) | ((8) << 8) | ((1) << 0)),
#line 191 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGB444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((12) << 8) | ((2) << 0)),
#line 194 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGB555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),
#line 197 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGR555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),
#line 200 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ARGB4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),
#line 203 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGBA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),
#line 206 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ABGR4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),
#line 209 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGRA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),
#line 212 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ARGB1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),
#line 215 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGBA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),
#line 218 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ABGR1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),
#line 221 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGRA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),
#line 224 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGB565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),
#line 227 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGR565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),
#line 230 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGB24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_RGB) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),
#line 233 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGR24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_BGR) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),
#line 236 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGB888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),
#line 239 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGBX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),
#line 242 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGR888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),
#line 245 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGRX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),
#line 248 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ARGB8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),
#line 251 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGBA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),
#line 254 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ABGR8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),
#line 257 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_BGRA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),
#line 260 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_ARGB2101010 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_2101010) << 16) | ((32) << 8) | ((4) << 0)),
#line 263 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"

    





#line 271 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
    SDL_PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_ABGR8888,
    SDL_PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_BGRA8888,
    SDL_PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_ARGB8888,
    SDL_PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_RGBA8888,
#line 276 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"

    SDL_PIXELFORMAT_YV12 =      
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_IYUV =      
        ((static_cast<Uint32>(static_cast<Uint8>(('I'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 24)),
    SDL_PIXELFORMAT_YUY2 =      
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_UYVY =      
        ((static_cast<Uint32>(static_cast<Uint8>(('U'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 24)),
    SDL_PIXELFORMAT_YVYU =      
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 24)),
    SDL_PIXELFORMAT_NV12 =      
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_NV21 =      
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 24))
};

typedef struct SDL_Color
{
    Uint8 r;
    Uint8 g;
    Uint8 b;
    Uint8 a;
} SDL_Color;


typedef struct SDL_Palette
{
    int ncolors;
    SDL_Color *colors;
    Uint32 version;
    int refcount;
} SDL_Palette;




typedef struct SDL_PixelFormat
{
    Uint32 format;
    SDL_Palette *palette;
    Uint8 BitsPerPixel;
    Uint8 BytesPerPixel;
    Uint8 padding[2];
    Uint32 Rmask;
    Uint32 Gmask;
    Uint32 Bmask;
    Uint32 Amask;
    Uint8 Rloss;
    Uint8 Gloss;
    Uint8 Bloss;
    Uint8 Aloss;
    Uint8 Rshift;
    Uint8 Gshift;
    Uint8 Bshift;
    Uint8 Ashift;
    int refcount;
    struct SDL_PixelFormat *next;
} SDL_PixelFormat;




extern __declspec(dllexport) const char* __cdecl SDL_GetPixelFormatName(Uint32 format);








extern __declspec(dllexport) SDL_bool __cdecl SDL_PixelFormatEnumToMasks(Uint32 format,
                                                            int *bpp,
                                                            Uint32 * Rmask,
                                                            Uint32 * Gmask,
                                                            Uint32 * Bmask,
                                                            Uint32 * Amask);









extern __declspec(dllexport) Uint32 __cdecl SDL_MasksToPixelFormatEnum(int bpp,
                                                          Uint32 Rmask,
                                                          Uint32 Gmask,
                                                          Uint32 Bmask,
                                                          Uint32 Amask);




extern __declspec(dllexport) SDL_PixelFormat * __cdecl SDL_AllocFormat(Uint32 pixel_format);




extern __declspec(dllexport) void __cdecl SDL_FreeFormat(SDL_PixelFormat *format);











extern __declspec(dllexport) SDL_Palette *__cdecl SDL_AllocPalette(int ncolors);




extern __declspec(dllexport) int __cdecl SDL_SetPixelFormatPalette(SDL_PixelFormat * format,
                                                      SDL_Palette *palette);











extern __declspec(dllexport) int __cdecl SDL_SetPaletteColors(SDL_Palette * palette,
                                                 const SDL_Color * colors,
                                                 int firstcolor, int ncolors);






extern __declspec(dllexport) void __cdecl SDL_FreePalette(SDL_Palette * palette);






extern __declspec(dllexport) Uint32 __cdecl SDL_MapRGB(const SDL_PixelFormat * format,
                                          Uint8 r, Uint8 g, Uint8 b);






extern __declspec(dllexport) Uint32 __cdecl SDL_MapRGBA(const SDL_PixelFormat * format,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);






extern __declspec(dllexport) void __cdecl SDL_GetRGB(Uint32 pixel,
                                        const SDL_PixelFormat * format,
                                        Uint8 * r, Uint8 * g, Uint8 * b);






extern __declspec(dllexport) void __cdecl SDL_GetRGBA(Uint32 pixel,
                                         const SDL_PixelFormat * format,
                                         Uint8 * r, Uint8 * g, Uint8 * b,
                                         Uint8 * a);




extern __declspec(dllexport) void __cdecl SDL_CalculateGammaRamp(float gamma, Uint16 * ramp);




}
#line 464 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 465 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"

#line 467 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_pixels.h"


#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rect.h"



































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rect.h"


extern "C" {
#line 41 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rect.h"







typedef struct SDL_Point
{
    int x;
    int y;
} SDL_Point;











typedef struct SDL_Rect
{
    int x, y;
    int w, h;
} SDL_Rect;




__forceinline SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)
{
    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&
             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;
}




__forceinline SDL_bool SDL_RectEmpty(const SDL_Rect *r)
{
    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;
}




__forceinline SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)
{
    return (a && b && (a->x == b->x) && (a->y == b->y) &&
            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;
}






extern __declspec(dllexport) SDL_bool __cdecl SDL_HasIntersection(const SDL_Rect * A,
                                                     const SDL_Rect * B);






extern __declspec(dllexport) SDL_bool __cdecl SDL_IntersectRect(const SDL_Rect * A,
                                                   const SDL_Rect * B,
                                                   SDL_Rect * result);




extern __declspec(dllexport) void __cdecl SDL_UnionRect(const SDL_Rect * A,
                                           const SDL_Rect * B,
                                           SDL_Rect * result);






extern __declspec(dllexport) SDL_bool __cdecl SDL_EnclosePoints(const SDL_Point * points,
                                                   int count,
                                                   const SDL_Rect * clip,
                                                   SDL_Rect * result);






extern __declspec(dllexport) SDL_bool __cdecl SDL_IntersectRectAndLine(const SDL_Rect *
                                                          rect, int *X1,
                                                          int *Y1, int *X2,
                                                          int *Y2);



}
#line 144 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rect.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 145 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rect.h"

#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_rect.h"


#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"

































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_blendmode.h"






























#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 32 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_blendmode.h"


extern "C" {
#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_blendmode.h"




typedef enum
{
    SDL_BLENDMODE_NONE = 0x00000000,     

    SDL_BLENDMODE_BLEND = 0x00000001,    


    SDL_BLENDMODE_ADD = 0x00000002,      


    SDL_BLENDMODE_MOD = 0x00000004       


} SDL_BlendMode;



}
#line 59 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_blendmode.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 60 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_blendmode.h"

#line 62 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_blendmode.h"


#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"


extern "C" {
#line 42 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"



























typedef struct SDL_Surface
{
    Uint32 flags;               
    SDL_PixelFormat *format;    
    int w, h;                   
    int pitch;                  
    void *pixels;               

    
    void *userdata;             

    
    int locked;                 
    void *lock_data;            

    
    SDL_Rect clip_rect;         

    
    struct SDL_BlitMap *map;    

    
    int refcount;               
} SDL_Surface;




typedef int (*SDL_blit) (struct SDL_Surface * src, SDL_Rect * srcrect,
                         struct SDL_Surface * dst, SDL_Rect * dstrect);



















extern __declspec(dllexport) SDL_Surface *__cdecl SDL_CreateRGBSurface
    (Uint32 flags, int width, int height, int depth,
     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern __declspec(dllexport) SDL_Surface *__cdecl SDL_CreateRGBSurfaceWithFormat
    (Uint32 flags, int width, int height, int depth, Uint32 format);
extern __declspec(dllexport) SDL_Surface *__cdecl SDL_CreateRGBSurfaceFrom(void *pixels,
                                                              int width,
                                                              int height,
                                                              int depth,
                                                              int pitch,
                                                              Uint32 Rmask,
                                                              Uint32 Gmask,
                                                              Uint32 Bmask,
                                                              Uint32 Amask);
extern __declspec(dllexport) SDL_Surface *__cdecl SDL_CreateRGBSurfaceWithFormatFrom
    (void *pixels, int width, int height, int depth, int pitch, Uint32 format);
extern __declspec(dllexport) void __cdecl SDL_FreeSurface(SDL_Surface * surface);








extern __declspec(dllexport) int __cdecl SDL_SetSurfacePalette(SDL_Surface * surface,
                                                  SDL_Palette * palette);




















extern __declspec(dllexport) int __cdecl SDL_LockSurface(SDL_Surface * surface);

extern __declspec(dllexport) void __cdecl SDL_UnlockSurface(SDL_Surface * surface);










extern __declspec(dllexport) SDL_Surface *__cdecl SDL_LoadBMP_RW(SDL_RWops * src,
                                                    int freesrc);





















extern __declspec(dllexport) int __cdecl SDL_SaveBMP_RW
    (SDL_Surface * surface, SDL_RWops * dst, int freedst);

















extern __declspec(dllexport) int __cdecl SDL_SetSurfaceRLE(SDL_Surface * surface,
                                              int flag);












extern __declspec(dllexport) int __cdecl SDL_SetColorKey(SDL_Surface * surface,
                                            int flag, Uint32 key);











extern __declspec(dllexport) int __cdecl SDL_GetColorKey(SDL_Surface * surface,
                                            Uint32 * key);













extern __declspec(dllexport) int __cdecl SDL_SetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 r, Uint8 g, Uint8 b);














extern __declspec(dllexport) int __cdecl SDL_GetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);











extern __declspec(dllexport) int __cdecl SDL_SetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 alpha);











extern __declspec(dllexport) int __cdecl SDL_GetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 * alpha);











extern __declspec(dllexport) int __cdecl SDL_SetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode blendMode);











extern __declspec(dllexport) int __cdecl SDL_GetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode *blendMode);














extern __declspec(dllexport) SDL_bool __cdecl SDL_SetClipRect(SDL_Surface * surface,
                                                 const SDL_Rect * rect);







extern __declspec(dllexport) void __cdecl SDL_GetClipRect(SDL_Surface * surface,
                                             SDL_Rect * rect);











extern __declspec(dllexport) SDL_Surface *__cdecl SDL_ConvertSurface
    (SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags);
extern __declspec(dllexport) SDL_Surface *__cdecl SDL_ConvertSurfaceFormat
    (SDL_Surface * src, Uint32 pixel_format, Uint32 flags);






extern __declspec(dllexport) int __cdecl SDL_ConvertPixels(int width, int height,
                                              Uint32 src_format,
                                              const void * src, int src_pitch,
                                              Uint32 dst_format,
                                              void * dst, int dst_pitch);











extern __declspec(dllexport) int __cdecl SDL_FillRect
    (SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
extern __declspec(dllexport) int __cdecl SDL_FillRects
    (SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color);
































































extern __declspec(dllexport) int __cdecl SDL_UpperBlit
    (SDL_Surface * src, const SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);





extern __declspec(dllexport) int __cdecl SDL_LowerBlit
    (SDL_Surface * src, SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);







extern __declspec(dllexport) int __cdecl SDL_SoftStretch(SDL_Surface * src,
                                            const SDL_Rect * srcrect,
                                            SDL_Surface * dst,
                                            const SDL_Rect * dstrect);







extern __declspec(dllexport) int __cdecl SDL_UpperBlitScaled
    (SDL_Surface * src, const SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);





extern __declspec(dllexport) int __cdecl SDL_LowerBlitScaled
    (SDL_Surface * src, SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);




}
#line 509 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 510 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"

#line 512 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_surface.h"


#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"


extern "C" {
#line 41 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"












typedef struct
{
    Uint32 format;              
    int w;                      
    int h;                      
    int refresh_rate;           
    void *driverdata;           
} SDL_DisplayMode;





























typedef struct SDL_Window SDL_Window;






typedef enum
{
    
    SDL_WINDOW_FULLSCREEN = 0x00000001,         
    SDL_WINDOW_OPENGL = 0x00000002,             
    SDL_WINDOW_SHOWN = 0x00000004,              
    SDL_WINDOW_HIDDEN = 0x00000008,             
    SDL_WINDOW_BORDERLESS = 0x00000010,         
    SDL_WINDOW_RESIZABLE = 0x00000020,          
    SDL_WINDOW_MINIMIZED = 0x00000040,          
    SDL_WINDOW_MAXIMIZED = 0x00000080,          
    SDL_WINDOW_INPUT_GRABBED = 0x00000100,      
    SDL_WINDOW_INPUT_FOCUS = 0x00000200,        
    SDL_WINDOW_MOUSE_FOCUS = 0x00000400,        
    SDL_WINDOW_FULLSCREEN_DESKTOP = ( SDL_WINDOW_FULLSCREEN | 0x00001000 ),
    SDL_WINDOW_FOREIGN = 0x00000800,            
    SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000,      
    SDL_WINDOW_MOUSE_CAPTURE = 0x00004000,      
    SDL_WINDOW_ALWAYS_ON_TOP = 0x00008000,      
    SDL_WINDOW_SKIP_TASKBAR  = 0x00010000,      
    SDL_WINDOW_UTILITY       = 0x00020000,      
    SDL_WINDOW_TOOLTIP       = 0x00040000,      
    SDL_WINDOW_POPUP_MENU    = 0x00080000       
} SDL_WindowFlags;






















typedef enum
{
    SDL_WINDOWEVENT_NONE,           
    SDL_WINDOWEVENT_SHOWN,          
    SDL_WINDOWEVENT_HIDDEN,         
    SDL_WINDOWEVENT_EXPOSED,        

    SDL_WINDOWEVENT_MOVED,          

    SDL_WINDOWEVENT_RESIZED,        
    SDL_WINDOWEVENT_SIZE_CHANGED,   


    SDL_WINDOWEVENT_MINIMIZED,      
    SDL_WINDOWEVENT_MAXIMIZED,      
    SDL_WINDOWEVENT_RESTORED,       

    SDL_WINDOWEVENT_ENTER,          
    SDL_WINDOWEVENT_LEAVE,          
    SDL_WINDOWEVENT_FOCUS_GAINED,   
    SDL_WINDOWEVENT_FOCUS_LOST,     
    SDL_WINDOWEVENT_CLOSE,          
    SDL_WINDOWEVENT_TAKE_FOCUS,     
    SDL_WINDOWEVENT_HIT_TEST        
} SDL_WindowEventID;




typedef void *SDL_GLContext;




typedef enum
{
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_RETAINED_BACKING,
    SDL_GL_CONTEXT_MAJOR_VERSION,
    SDL_GL_CONTEXT_MINOR_VERSION,
    SDL_GL_CONTEXT_EGL,
    SDL_GL_CONTEXT_FLAGS,
    SDL_GL_CONTEXT_PROFILE_MASK,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR
} SDL_GLattr;

typedef enum
{
    SDL_GL_CONTEXT_PROFILE_CORE           = 0x0001,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY  = 0x0002,
    SDL_GL_CONTEXT_PROFILE_ES             = 0x0004 
} SDL_GLprofile;

typedef enum
{
    SDL_GL_CONTEXT_DEBUG_FLAG              = 0x0001,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG      = 0x0004,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG    = 0x0008
} SDL_GLcontextFlag;

typedef enum
{
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE   = 0x0000,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH  = 0x0001
} SDL_GLcontextReleaseFlag;









extern __declspec(dllexport) int __cdecl SDL_GetNumVideoDrivers(void);









extern __declspec(dllexport) const char *__cdecl SDL_GetVideoDriver(int index);















extern __declspec(dllexport) int __cdecl SDL_VideoInit(const char *driver_name);








extern __declspec(dllexport) void __cdecl SDL_VideoQuit(void);










extern __declspec(dllexport) const char *__cdecl SDL_GetCurrentVideoDriver(void);






extern __declspec(dllexport) int __cdecl SDL_GetNumVideoDisplays(void);








extern __declspec(dllexport) const char * __cdecl SDL_GetDisplayName(int displayIndex);









extern __declspec(dllexport) int __cdecl SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect);











extern __declspec(dllexport) int __cdecl SDL_GetDisplayDPI(int displayIndex, float * ddpi, float * hdpi, float * vdpi);


















extern __declspec(dllexport) int __cdecl SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect);






extern __declspec(dllexport) int __cdecl SDL_GetNumDisplayModes(int displayIndex);












extern __declspec(dllexport) int __cdecl SDL_GetDisplayMode(int displayIndex, int modeIndex,
                                               SDL_DisplayMode * mode);




extern __declspec(dllexport) int __cdecl SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode);




extern __declspec(dllexport) int __cdecl SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode);























extern __declspec(dllexport) SDL_DisplayMode * __cdecl SDL_GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode * mode, SDL_DisplayMode * closest);







extern __declspec(dllexport) int __cdecl SDL_GetWindowDisplayIndex(SDL_Window * window);















extern __declspec(dllexport) int __cdecl SDL_SetWindowDisplayMode(SDL_Window * window,
                                                     const SDL_DisplayMode
                                                         * mode);








extern __declspec(dllexport) int __cdecl SDL_GetWindowDisplayMode(SDL_Window * window,
                                                     SDL_DisplayMode * mode);




extern __declspec(dllexport) Uint32 __cdecl SDL_GetWindowPixelFormat(SDL_Window * window);




























extern __declspec(dllexport) SDL_Window * __cdecl SDL_CreateWindow(const char *title,
                                                      int x, int y, int w,
                                                      int h, Uint32 flags);










extern __declspec(dllexport) SDL_Window * __cdecl SDL_CreateWindowFrom(const void *data);




extern __declspec(dllexport) Uint32 __cdecl SDL_GetWindowID(SDL_Window * window);




extern __declspec(dllexport) SDL_Window * __cdecl SDL_GetWindowFromID(Uint32 id);




extern __declspec(dllexport) Uint32 __cdecl SDL_GetWindowFlags(SDL_Window * window);






extern __declspec(dllexport) void __cdecl SDL_SetWindowTitle(SDL_Window * window,
                                                const char *title);






extern __declspec(dllexport) const char *__cdecl SDL_GetWindowTitle(SDL_Window * window);







extern __declspec(dllexport) void __cdecl SDL_SetWindowIcon(SDL_Window * window,
                                               SDL_Surface * icon);














extern __declspec(dllexport) void* __cdecl SDL_SetWindowData(SDL_Window * window,
                                                const char *name,
                                                void *userdata);











extern __declspec(dllexport) void *__cdecl SDL_GetWindowData(SDL_Window * window,
                                                const char *name);














extern __declspec(dllexport) void __cdecl SDL_SetWindowPosition(SDL_Window * window,
                                                   int x, int y);












extern __declspec(dllexport) void __cdecl SDL_GetWindowPosition(SDL_Window * window,
                                                   int *x, int *y);


















extern __declspec(dllexport) void __cdecl SDL_SetWindowSize(SDL_Window * window, int w,
                                               int h);

















extern __declspec(dllexport) void __cdecl SDL_GetWindowSize(SDL_Window * window, int *w,
                                               int *h);
















extern __declspec(dllexport) int __cdecl SDL_GetWindowBordersSize(SDL_Window * window,
                                                     int *top, int *left,
                                                     int *bottom, int *right);














extern __declspec(dllexport) void __cdecl SDL_SetWindowMinimumSize(SDL_Window * window,
                                                      int min_w, int min_h);











extern __declspec(dllexport) void __cdecl SDL_GetWindowMinimumSize(SDL_Window * window,
                                                      int *w, int *h);














extern __declspec(dllexport) void __cdecl SDL_SetWindowMaximumSize(SDL_Window * window,
                                                      int max_w, int max_h);











extern __declspec(dllexport) void __cdecl SDL_GetWindowMaximumSize(SDL_Window * window,
                                                      int *w, int *h);















extern __declspec(dllexport) void __cdecl SDL_SetWindowBordered(SDL_Window * window,
                                                   SDL_bool bordered);















extern __declspec(dllexport) void __cdecl SDL_SetWindowResizable(SDL_Window * window,
                                                    SDL_bool resizable);






extern __declspec(dllexport) void __cdecl SDL_ShowWindow(SDL_Window * window);






extern __declspec(dllexport) void __cdecl SDL_HideWindow(SDL_Window * window);




extern __declspec(dllexport) void __cdecl SDL_RaiseWindow(SDL_Window * window);






extern __declspec(dllexport) void __cdecl SDL_MaximizeWindow(SDL_Window * window);






extern __declspec(dllexport) void __cdecl SDL_MinimizeWindow(SDL_Window * window);







extern __declspec(dllexport) void __cdecl SDL_RestoreWindow(SDL_Window * window);









extern __declspec(dllexport) int __cdecl SDL_SetWindowFullscreen(SDL_Window * window,
                                                    Uint32 flags);














extern __declspec(dllexport) SDL_Surface * __cdecl SDL_GetWindowSurface(SDL_Window * window);









extern __declspec(dllexport) int __cdecl SDL_UpdateWindowSurface(SDL_Window * window);









extern __declspec(dllexport) int __cdecl SDL_UpdateWindowSurfaceRects(SDL_Window * window,
                                                         const SDL_Rect * rects,
                                                         int numrects);












extern __declspec(dllexport) void __cdecl SDL_SetWindowGrab(SDL_Window * window,
                                               SDL_bool grabbed);








extern __declspec(dllexport) SDL_bool __cdecl SDL_GetWindowGrab(SDL_Window * window);








extern __declspec(dllexport) SDL_Window * __cdecl SDL_GetGrabbedWindow(void);









extern __declspec(dllexport) int __cdecl SDL_SetWindowBrightness(SDL_Window * window, float brightness);








extern __declspec(dllexport) float __cdecl SDL_GetWindowBrightness(SDL_Window * window);












extern __declspec(dllexport) int __cdecl SDL_SetWindowOpacity(SDL_Window * window, float opacity);














extern __declspec(dllexport) int __cdecl SDL_GetWindowOpacity(SDL_Window * window, float * out_opacity);









extern __declspec(dllexport) int __cdecl SDL_SetWindowModalFor(SDL_Window * modal_window, SDL_Window * parent_window);













extern __declspec(dllexport) int __cdecl SDL_SetWindowInputFocus(SDL_Window * window);



















extern __declspec(dllexport) int __cdecl SDL_SetWindowGammaRamp(SDL_Window * window,
                                                   const Uint16 * red,
                                                   const Uint16 * green,
                                                   const Uint16 * blue);
















extern __declspec(dllexport) int __cdecl SDL_GetWindowGammaRamp(SDL_Window * window,
                                                   Uint16 * red,
                                                   Uint16 * green,
                                                   Uint16 * blue);






typedef enum
{
    SDL_HITTEST_NORMAL,  
    SDL_HITTEST_DRAGGABLE,  
    SDL_HITTEST_RESIZE_TOPLEFT,
    SDL_HITTEST_RESIZE_TOP,
    SDL_HITTEST_RESIZE_TOPRIGHT,
    SDL_HITTEST_RESIZE_RIGHT,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT,
    SDL_HITTEST_RESIZE_BOTTOM,
    SDL_HITTEST_RESIZE_BOTTOMLEFT,
    SDL_HITTEST_RESIZE_LEFT
} SDL_HitTestResult;






typedef SDL_HitTestResult (__cdecl *SDL_HitTest)(SDL_Window *win,
                                                 const SDL_Point *area,
                                                 void *data);






































extern __declspec(dllexport) int __cdecl SDL_SetWindowHitTest(SDL_Window * window,
                                                 SDL_HitTest callback,
                                                 void *callback_data);




extern __declspec(dllexport) void __cdecl SDL_DestroyWindow(SDL_Window * window);








extern __declspec(dllexport) SDL_bool __cdecl SDL_IsScreenSaverEnabled(void);







extern __declspec(dllexport) void __cdecl SDL_EnableScreenSaver(void);







extern __declspec(dllexport) void __cdecl SDL_DisableScreenSaver(void);

























extern __declspec(dllexport) int __cdecl SDL_GL_LoadLibrary(const char *path);




extern __declspec(dllexport) void *__cdecl SDL_GL_GetProcAddress(const char *proc);






extern __declspec(dllexport) void __cdecl SDL_GL_UnloadLibrary(void);





extern __declspec(dllexport) SDL_bool __cdecl SDL_GL_ExtensionSupported(const char
                                                           *extension);




extern __declspec(dllexport) void __cdecl SDL_GL_ResetAttributes(void);




extern __declspec(dllexport) int __cdecl SDL_GL_SetAttribute(SDL_GLattr attr, int value);




extern __declspec(dllexport) int __cdecl SDL_GL_GetAttribute(SDL_GLattr attr, int *value);







extern __declspec(dllexport) SDL_GLContext __cdecl SDL_GL_CreateContext(SDL_Window *
                                                           window);






extern __declspec(dllexport) int __cdecl SDL_GL_MakeCurrent(SDL_Window * window,
                                               SDL_GLContext context);




extern __declspec(dllexport) SDL_Window* __cdecl SDL_GL_GetCurrentWindow(void);




extern __declspec(dllexport) SDL_GLContext __cdecl SDL_GL_GetCurrentContext(void);

















extern __declspec(dllexport) void __cdecl SDL_GL_GetDrawableSize(SDL_Window * window, int *w,
                                                    int *h);













extern __declspec(dllexport) int __cdecl SDL_GL_SetSwapInterval(int interval);












extern __declspec(dllexport) int __cdecl SDL_GL_GetSwapInterval(void);





extern __declspec(dllexport) void __cdecl SDL_GL_SwapWindow(SDL_Window * window);






extern __declspec(dllexport) void __cdecl SDL_GL_DeleteContext(SDL_GLContext context);






}
#line 1214 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 1215 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"

#line 1217 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_video.h"



#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keycode.h"































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_scancode.h"










































typedef enum
{
    SDL_SCANCODE_UNKNOWN = 0,

    




    

    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,

    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,

    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,

    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49, 













    SDL_SCANCODE_NONUSHASH = 50, 











    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53, 
















    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,

    SDL_SCANCODE_CAPSLOCK = 57,

    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,

    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73, 

    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,

    SDL_SCANCODE_NUMLOCKCLEAR = 83, 

    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,

    SDL_SCANCODE_NONUSBACKSLASH = 100, 









    SDL_SCANCODE_APPLICATION = 101, 
    SDL_SCANCODE_POWER = 102, 


    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,   
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,




    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,

    SDL_SCANCODE_INTERNATIONAL1 = 135, 

    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137, 
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144, 
    SDL_SCANCODE_LANG2 = 145, 
    SDL_SCANCODE_LANG3 = 146, 
    SDL_SCANCODE_LANG4 = 147, 
    SDL_SCANCODE_LANG5 = 148, 
    SDL_SCANCODE_LANG6 = 149, 
    SDL_SCANCODE_LANG7 = 150, 
    SDL_SCANCODE_LANG8 = 151, 
    SDL_SCANCODE_LANG9 = 152, 

    SDL_SCANCODE_ALTERASE = 153, 
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,

    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,

    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226, 
    SDL_SCANCODE_LGUI = 227, 
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230, 
    SDL_SCANCODE_RGUI = 231, 

    SDL_SCANCODE_MODE = 257,    




    

    




    

    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,

    

    




    

    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    SDL_SCANCODE_DISPLAYSWITCH = 277, 

    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,

    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,

    

    

    SDL_NUM_SCANCODES = 512 

} SDL_Scancode;

#line 400 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_scancode.h"


#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keycode.h"









typedef Sint32 SDL_Keycode;




enum
{
    SDLK_UNKNOWN = 0,

    SDLK_RETURN = '\r',
    SDLK_ESCAPE = '\033',
    SDLK_BACKSPACE = '\b',
    SDLK_TAB = '\t',
    SDLK_SPACE = ' ',
    SDLK_EXCLAIM = '!',
    SDLK_QUOTEDBL = '"',
    SDLK_HASH = '#',
    SDLK_PERCENT = '%',
    SDLK_DOLLAR = '$',
    SDLK_AMPERSAND = '&',
    SDLK_QUOTE = '\'',
    SDLK_LEFTPAREN = '(',
    SDLK_RIGHTPAREN = ')',
    SDLK_ASTERISK = '*',
    SDLK_PLUS = '+',
    SDLK_COMMA = ',',
    SDLK_MINUS = '-',
    SDLK_PERIOD = '.',
    SDLK_SLASH = '/',
    SDLK_0 = '0',
    SDLK_1 = '1',
    SDLK_2 = '2',
    SDLK_3 = '3',
    SDLK_4 = '4',
    SDLK_5 = '5',
    SDLK_6 = '6',
    SDLK_7 = '7',
    SDLK_8 = '8',
    SDLK_9 = '9',
    SDLK_COLON = ':',
    SDLK_SEMICOLON = ';',
    SDLK_LESS = '<',
    SDLK_EQUALS = '=',
    SDLK_GREATER = '>',
    SDLK_QUESTION = '?',
    SDLK_AT = '@',
    


    SDLK_LEFTBRACKET = '[',
    SDLK_BACKSLASH = '\\',
    SDLK_RIGHTBRACKET = ']',
    SDLK_CARET = '^',
    SDLK_UNDERSCORE = '_',
    SDLK_BACKQUOTE = '`',
    SDLK_a = 'a',
    SDLK_b = 'b',
    SDLK_c = 'c',
    SDLK_d = 'd',
    SDLK_e = 'e',
    SDLK_f = 'f',
    SDLK_g = 'g',
    SDLK_h = 'h',
    SDLK_i = 'i',
    SDLK_j = 'j',
    SDLK_k = 'k',
    SDLK_l = 'l',
    SDLK_m = 'm',
    SDLK_n = 'n',
    SDLK_o = 'o',
    SDLK_p = 'p',
    SDLK_q = 'q',
    SDLK_r = 'r',
    SDLK_s = 's',
    SDLK_t = 't',
    SDLK_u = 'u',
    SDLK_v = 'v',
    SDLK_w = 'w',
    SDLK_x = 'x',
    SDLK_y = 'y',
    SDLK_z = 'z',

    SDLK_CAPSLOCK = (SDL_SCANCODE_CAPSLOCK | (1<<30)),

    SDLK_F1 = (SDL_SCANCODE_F1 | (1<<30)),
    SDLK_F2 = (SDL_SCANCODE_F2 | (1<<30)),
    SDLK_F3 = (SDL_SCANCODE_F3 | (1<<30)),
    SDLK_F4 = (SDL_SCANCODE_F4 | (1<<30)),
    SDLK_F5 = (SDL_SCANCODE_F5 | (1<<30)),
    SDLK_F6 = (SDL_SCANCODE_F6 | (1<<30)),
    SDLK_F7 = (SDL_SCANCODE_F7 | (1<<30)),
    SDLK_F8 = (SDL_SCANCODE_F8 | (1<<30)),
    SDLK_F9 = (SDL_SCANCODE_F9 | (1<<30)),
    SDLK_F10 = (SDL_SCANCODE_F10 | (1<<30)),
    SDLK_F11 = (SDL_SCANCODE_F11 | (1<<30)),
    SDLK_F12 = (SDL_SCANCODE_F12 | (1<<30)),

    SDLK_PRINTSCREEN = (SDL_SCANCODE_PRINTSCREEN | (1<<30)),
    SDLK_SCROLLLOCK = (SDL_SCANCODE_SCROLLLOCK | (1<<30)),
    SDLK_PAUSE = (SDL_SCANCODE_PAUSE | (1<<30)),
    SDLK_INSERT = (SDL_SCANCODE_INSERT | (1<<30)),
    SDLK_HOME = (SDL_SCANCODE_HOME | (1<<30)),
    SDLK_PAGEUP = (SDL_SCANCODE_PAGEUP | (1<<30)),
    SDLK_DELETE = '\177',
    SDLK_END = (SDL_SCANCODE_END | (1<<30)),
    SDLK_PAGEDOWN = (SDL_SCANCODE_PAGEDOWN | (1<<30)),
    SDLK_RIGHT = (SDL_SCANCODE_RIGHT | (1<<30)),
    SDLK_LEFT = (SDL_SCANCODE_LEFT | (1<<30)),
    SDLK_DOWN = (SDL_SCANCODE_DOWN | (1<<30)),
    SDLK_UP = (SDL_SCANCODE_UP | (1<<30)),

    SDLK_NUMLOCKCLEAR = (SDL_SCANCODE_NUMLOCKCLEAR | (1<<30)),
    SDLK_KP_DIVIDE = (SDL_SCANCODE_KP_DIVIDE | (1<<30)),
    SDLK_KP_MULTIPLY = (SDL_SCANCODE_KP_MULTIPLY | (1<<30)),
    SDLK_KP_MINUS = (SDL_SCANCODE_KP_MINUS | (1<<30)),
    SDLK_KP_PLUS = (SDL_SCANCODE_KP_PLUS | (1<<30)),
    SDLK_KP_ENTER = (SDL_SCANCODE_KP_ENTER | (1<<30)),
    SDLK_KP_1 = (SDL_SCANCODE_KP_1 | (1<<30)),
    SDLK_KP_2 = (SDL_SCANCODE_KP_2 | (1<<30)),
    SDLK_KP_3 = (SDL_SCANCODE_KP_3 | (1<<30)),
    SDLK_KP_4 = (SDL_SCANCODE_KP_4 | (1<<30)),
    SDLK_KP_5 = (SDL_SCANCODE_KP_5 | (1<<30)),
    SDLK_KP_6 = (SDL_SCANCODE_KP_6 | (1<<30)),
    SDLK_KP_7 = (SDL_SCANCODE_KP_7 | (1<<30)),
    SDLK_KP_8 = (SDL_SCANCODE_KP_8 | (1<<30)),
    SDLK_KP_9 = (SDL_SCANCODE_KP_9 | (1<<30)),
    SDLK_KP_0 = (SDL_SCANCODE_KP_0 | (1<<30)),
    SDLK_KP_PERIOD = (SDL_SCANCODE_KP_PERIOD | (1<<30)),

    SDLK_APPLICATION = (SDL_SCANCODE_APPLICATION | (1<<30)),
    SDLK_POWER = (SDL_SCANCODE_POWER | (1<<30)),
    SDLK_KP_EQUALS = (SDL_SCANCODE_KP_EQUALS | (1<<30)),
    SDLK_F13 = (SDL_SCANCODE_F13 | (1<<30)),
    SDLK_F14 = (SDL_SCANCODE_F14 | (1<<30)),
    SDLK_F15 = (SDL_SCANCODE_F15 | (1<<30)),
    SDLK_F16 = (SDL_SCANCODE_F16 | (1<<30)),
    SDLK_F17 = (SDL_SCANCODE_F17 | (1<<30)),
    SDLK_F18 = (SDL_SCANCODE_F18 | (1<<30)),
    SDLK_F19 = (SDL_SCANCODE_F19 | (1<<30)),
    SDLK_F20 = (SDL_SCANCODE_F20 | (1<<30)),
    SDLK_F21 = (SDL_SCANCODE_F21 | (1<<30)),
    SDLK_F22 = (SDL_SCANCODE_F22 | (1<<30)),
    SDLK_F23 = (SDL_SCANCODE_F23 | (1<<30)),
    SDLK_F24 = (SDL_SCANCODE_F24 | (1<<30)),
    SDLK_EXECUTE = (SDL_SCANCODE_EXECUTE | (1<<30)),
    SDLK_HELP = (SDL_SCANCODE_HELP | (1<<30)),
    SDLK_MENU = (SDL_SCANCODE_MENU | (1<<30)),
    SDLK_SELECT = (SDL_SCANCODE_SELECT | (1<<30)),
    SDLK_STOP = (SDL_SCANCODE_STOP | (1<<30)),
    SDLK_AGAIN = (SDL_SCANCODE_AGAIN | (1<<30)),
    SDLK_UNDO = (SDL_SCANCODE_UNDO | (1<<30)),
    SDLK_CUT = (SDL_SCANCODE_CUT | (1<<30)),
    SDLK_COPY = (SDL_SCANCODE_COPY | (1<<30)),
    SDLK_PASTE = (SDL_SCANCODE_PASTE | (1<<30)),
    SDLK_FIND = (SDL_SCANCODE_FIND | (1<<30)),
    SDLK_MUTE = (SDL_SCANCODE_MUTE | (1<<30)),
    SDLK_VOLUMEUP = (SDL_SCANCODE_VOLUMEUP | (1<<30)),
    SDLK_VOLUMEDOWN = (SDL_SCANCODE_VOLUMEDOWN | (1<<30)),
    SDLK_KP_COMMA = (SDL_SCANCODE_KP_COMMA | (1<<30)),
    SDLK_KP_EQUALSAS400 =
        (SDL_SCANCODE_KP_EQUALSAS400 | (1<<30)),

    SDLK_ALTERASE = (SDL_SCANCODE_ALTERASE | (1<<30)),
    SDLK_SYSREQ = (SDL_SCANCODE_SYSREQ | (1<<30)),
    SDLK_CANCEL = (SDL_SCANCODE_CANCEL | (1<<30)),
    SDLK_CLEAR = (SDL_SCANCODE_CLEAR | (1<<30)),
    SDLK_PRIOR = (SDL_SCANCODE_PRIOR | (1<<30)),
    SDLK_RETURN2 = (SDL_SCANCODE_RETURN2 | (1<<30)),
    SDLK_SEPARATOR = (SDL_SCANCODE_SEPARATOR | (1<<30)),
    SDLK_OUT = (SDL_SCANCODE_OUT | (1<<30)),
    SDLK_OPER = (SDL_SCANCODE_OPER | (1<<30)),
    SDLK_CLEARAGAIN = (SDL_SCANCODE_CLEARAGAIN | (1<<30)),
    SDLK_CRSEL = (SDL_SCANCODE_CRSEL | (1<<30)),
    SDLK_EXSEL = (SDL_SCANCODE_EXSEL | (1<<30)),

    SDLK_KP_00 = (SDL_SCANCODE_KP_00 | (1<<30)),
    SDLK_KP_000 = (SDL_SCANCODE_KP_000 | (1<<30)),
    SDLK_THOUSANDSSEPARATOR =
        (SDL_SCANCODE_THOUSANDSSEPARATOR | (1<<30)),
    SDLK_DECIMALSEPARATOR =
        (SDL_SCANCODE_DECIMALSEPARATOR | (1<<30)),
    SDLK_CURRENCYUNIT = (SDL_SCANCODE_CURRENCYUNIT | (1<<30)),
    SDLK_CURRENCYSUBUNIT =
        (SDL_SCANCODE_CURRENCYSUBUNIT | (1<<30)),
    SDLK_KP_LEFTPAREN = (SDL_SCANCODE_KP_LEFTPAREN | (1<<30)),
    SDLK_KP_RIGHTPAREN = (SDL_SCANCODE_KP_RIGHTPAREN | (1<<30)),
    SDLK_KP_LEFTBRACE = (SDL_SCANCODE_KP_LEFTBRACE | (1<<30)),
    SDLK_KP_RIGHTBRACE = (SDL_SCANCODE_KP_RIGHTBRACE | (1<<30)),
    SDLK_KP_TAB = (SDL_SCANCODE_KP_TAB | (1<<30)),
    SDLK_KP_BACKSPACE = (SDL_SCANCODE_KP_BACKSPACE | (1<<30)),
    SDLK_KP_A = (SDL_SCANCODE_KP_A | (1<<30)),
    SDLK_KP_B = (SDL_SCANCODE_KP_B | (1<<30)),
    SDLK_KP_C = (SDL_SCANCODE_KP_C | (1<<30)),
    SDLK_KP_D = (SDL_SCANCODE_KP_D | (1<<30)),
    SDLK_KP_E = (SDL_SCANCODE_KP_E | (1<<30)),
    SDLK_KP_F = (SDL_SCANCODE_KP_F | (1<<30)),
    SDLK_KP_XOR = (SDL_SCANCODE_KP_XOR | (1<<30)),
    SDLK_KP_POWER = (SDL_SCANCODE_KP_POWER | (1<<30)),
    SDLK_KP_PERCENT = (SDL_SCANCODE_KP_PERCENT | (1<<30)),
    SDLK_KP_LESS = (SDL_SCANCODE_KP_LESS | (1<<30)),
    SDLK_KP_GREATER = (SDL_SCANCODE_KP_GREATER | (1<<30)),
    SDLK_KP_AMPERSAND = (SDL_SCANCODE_KP_AMPERSAND | (1<<30)),
    SDLK_KP_DBLAMPERSAND =
        (SDL_SCANCODE_KP_DBLAMPERSAND | (1<<30)),
    SDLK_KP_VERTICALBAR =
        (SDL_SCANCODE_KP_VERTICALBAR | (1<<30)),
    SDLK_KP_DBLVERTICALBAR =
        (SDL_SCANCODE_KP_DBLVERTICALBAR | (1<<30)),
    SDLK_KP_COLON = (SDL_SCANCODE_KP_COLON | (1<<30)),
    SDLK_KP_HASH = (SDL_SCANCODE_KP_HASH | (1<<30)),
    SDLK_KP_SPACE = (SDL_SCANCODE_KP_SPACE | (1<<30)),
    SDLK_KP_AT = (SDL_SCANCODE_KP_AT | (1<<30)),
    SDLK_KP_EXCLAM = (SDL_SCANCODE_KP_EXCLAM | (1<<30)),
    SDLK_KP_MEMSTORE = (SDL_SCANCODE_KP_MEMSTORE | (1<<30)),
    SDLK_KP_MEMRECALL = (SDL_SCANCODE_KP_MEMRECALL | (1<<30)),
    SDLK_KP_MEMCLEAR = (SDL_SCANCODE_KP_MEMCLEAR | (1<<30)),
    SDLK_KP_MEMADD = (SDL_SCANCODE_KP_MEMADD | (1<<30)),
    SDLK_KP_MEMSUBTRACT =
        (SDL_SCANCODE_KP_MEMSUBTRACT | (1<<30)),
    SDLK_KP_MEMMULTIPLY =
        (SDL_SCANCODE_KP_MEMMULTIPLY | (1<<30)),
    SDLK_KP_MEMDIVIDE = (SDL_SCANCODE_KP_MEMDIVIDE | (1<<30)),
    SDLK_KP_PLUSMINUS = (SDL_SCANCODE_KP_PLUSMINUS | (1<<30)),
    SDLK_KP_CLEAR = (SDL_SCANCODE_KP_CLEAR | (1<<30)),
    SDLK_KP_CLEARENTRY = (SDL_SCANCODE_KP_CLEARENTRY | (1<<30)),
    SDLK_KP_BINARY = (SDL_SCANCODE_KP_BINARY | (1<<30)),
    SDLK_KP_OCTAL = (SDL_SCANCODE_KP_OCTAL | (1<<30)),
    SDLK_KP_DECIMAL = (SDL_SCANCODE_KP_DECIMAL | (1<<30)),
    SDLK_KP_HEXADECIMAL =
        (SDL_SCANCODE_KP_HEXADECIMAL | (1<<30)),

    SDLK_LCTRL = (SDL_SCANCODE_LCTRL | (1<<30)),
    SDLK_LSHIFT = (SDL_SCANCODE_LSHIFT | (1<<30)),
    SDLK_LALT = (SDL_SCANCODE_LALT | (1<<30)),
    SDLK_LGUI = (SDL_SCANCODE_LGUI | (1<<30)),
    SDLK_RCTRL = (SDL_SCANCODE_RCTRL | (1<<30)),
    SDLK_RSHIFT = (SDL_SCANCODE_RSHIFT | (1<<30)),
    SDLK_RALT = (SDL_SCANCODE_RALT | (1<<30)),
    SDLK_RGUI = (SDL_SCANCODE_RGUI | (1<<30)),

    SDLK_MODE = (SDL_SCANCODE_MODE | (1<<30)),

    SDLK_AUDIONEXT = (SDL_SCANCODE_AUDIONEXT | (1<<30)),
    SDLK_AUDIOPREV = (SDL_SCANCODE_AUDIOPREV | (1<<30)),
    SDLK_AUDIOSTOP = (SDL_SCANCODE_AUDIOSTOP | (1<<30)),
    SDLK_AUDIOPLAY = (SDL_SCANCODE_AUDIOPLAY | (1<<30)),
    SDLK_AUDIOMUTE = (SDL_SCANCODE_AUDIOMUTE | (1<<30)),
    SDLK_MEDIASELECT = (SDL_SCANCODE_MEDIASELECT | (1<<30)),
    SDLK_WWW = (SDL_SCANCODE_WWW | (1<<30)),
    SDLK_MAIL = (SDL_SCANCODE_MAIL | (1<<30)),
    SDLK_CALCULATOR = (SDL_SCANCODE_CALCULATOR | (1<<30)),
    SDLK_COMPUTER = (SDL_SCANCODE_COMPUTER | (1<<30)),
    SDLK_AC_SEARCH = (SDL_SCANCODE_AC_SEARCH | (1<<30)),
    SDLK_AC_HOME = (SDL_SCANCODE_AC_HOME | (1<<30)),
    SDLK_AC_BACK = (SDL_SCANCODE_AC_BACK | (1<<30)),
    SDLK_AC_FORWARD = (SDL_SCANCODE_AC_FORWARD | (1<<30)),
    SDLK_AC_STOP = (SDL_SCANCODE_AC_STOP | (1<<30)),
    SDLK_AC_REFRESH = (SDL_SCANCODE_AC_REFRESH | (1<<30)),
    SDLK_AC_BOOKMARKS = (SDL_SCANCODE_AC_BOOKMARKS | (1<<30)),

    SDLK_BRIGHTNESSDOWN =
        (SDL_SCANCODE_BRIGHTNESSDOWN | (1<<30)),
    SDLK_BRIGHTNESSUP = (SDL_SCANCODE_BRIGHTNESSUP | (1<<30)),
    SDLK_DISPLAYSWITCH = (SDL_SCANCODE_DISPLAYSWITCH | (1<<30)),
    SDLK_KBDILLUMTOGGLE =
        (SDL_SCANCODE_KBDILLUMTOGGLE | (1<<30)),
    SDLK_KBDILLUMDOWN = (SDL_SCANCODE_KBDILLUMDOWN | (1<<30)),
    SDLK_KBDILLUMUP = (SDL_SCANCODE_KBDILLUMUP | (1<<30)),
    SDLK_EJECT = (SDL_SCANCODE_EJECT | (1<<30)),
    SDLK_SLEEP = (SDL_SCANCODE_SLEEP | (1<<30))
};




typedef enum
{
    KMOD_NONE = 0x0000,
    KMOD_LSHIFT = 0x0001,
    KMOD_RSHIFT = 0x0002,
    KMOD_LCTRL = 0x0040,
    KMOD_RCTRL = 0x0080,
    KMOD_LALT = 0x0100,
    KMOD_RALT = 0x0200,
    KMOD_LGUI = 0x0400,
    KMOD_RGUI = 0x0800,
    KMOD_NUM = 0x1000,
    KMOD_CAPS = 0x2000,
    KMOD_MODE = 0x4000,
    KMOD_RESERVED = 0x8000
} SDL_Keymod;






#line 340 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keycode.h"


#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"


extern "C" {
#line 41 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"






typedef struct SDL_Keysym
{
    SDL_Scancode scancode;      
    SDL_Keycode sym;            
    Uint16 mod;                 
    Uint32 unused;
} SDL_Keysym;






extern __declspec(dllexport) SDL_Window * __cdecl SDL_GetKeyboardFocus(void);
















extern __declspec(dllexport) const Uint8 *__cdecl SDL_GetKeyboardState(int *numkeys);




extern __declspec(dllexport) SDL_Keymod __cdecl SDL_GetModState(void);






extern __declspec(dllexport) void __cdecl SDL_SetModState(SDL_Keymod modstate);









extern __declspec(dllexport) SDL_Keycode __cdecl SDL_GetKeyFromScancode(SDL_Scancode scancode);









extern __declspec(dllexport) SDL_Scancode __cdecl SDL_GetScancodeFromKey(SDL_Keycode key);










extern __declspec(dllexport) const char *__cdecl SDL_GetScancodeName(SDL_Scancode scancode);








extern __declspec(dllexport) SDL_Scancode __cdecl SDL_GetScancodeFromName(const char *name);











extern __declspec(dllexport) const char *__cdecl SDL_GetKeyName(SDL_Keycode key);








extern __declspec(dllexport) SDL_Keycode __cdecl SDL_GetKeyFromName(const char *name);









extern __declspec(dllexport) void __cdecl SDL_StartTextInput(void);







extern __declspec(dllexport) SDL_bool __cdecl SDL_IsTextInputActive(void);








extern __declspec(dllexport) void __cdecl SDL_StopTextInput(void);







extern __declspec(dllexport) void __cdecl SDL_SetTextInputRect(SDL_Rect *rect);










extern __declspec(dllexport) SDL_bool __cdecl SDL_HasScreenKeyboardSupport(void);










extern __declspec(dllexport) SDL_bool __cdecl SDL_IsScreenKeyboardShown(SDL_Window *window);



}
#line 213 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 214 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"

#line 216 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_keyboard.h"


#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mouse.h"


































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mouse.h"


extern "C" {
#line 40 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mouse.h"

typedef struct SDL_Cursor SDL_Cursor;   




typedef enum
{
    SDL_SYSTEM_CURSOR_ARROW,     
    SDL_SYSTEM_CURSOR_IBEAM,     
    SDL_SYSTEM_CURSOR_WAIT,      
    SDL_SYSTEM_CURSOR_CROSSHAIR, 
    SDL_SYSTEM_CURSOR_WAITARROW, 
    SDL_SYSTEM_CURSOR_SIZENWSE,  
    SDL_SYSTEM_CURSOR_SIZENESW,  
    SDL_SYSTEM_CURSOR_SIZEWE,    
    SDL_SYSTEM_CURSOR_SIZENS,    
    SDL_SYSTEM_CURSOR_SIZEALL,   
    SDL_SYSTEM_CURSOR_NO,        
    SDL_SYSTEM_CURSOR_HAND,      
    SDL_NUM_SYSTEM_CURSORS
} SDL_SystemCursor;




typedef enum
{
    SDL_MOUSEWHEEL_NORMAL,    
    SDL_MOUSEWHEEL_FLIPPED    
} SDL_MouseWheelDirection;






extern __declspec(dllexport) SDL_Window * __cdecl SDL_GetMouseFocus(void);









extern __declspec(dllexport) Uint32 __cdecl SDL_GetMouseState(int *x, int *y);
























extern __declspec(dllexport) Uint32 __cdecl SDL_GetGlobalMouseState(int *x, int *y);








extern __declspec(dllexport) Uint32 __cdecl SDL_GetRelativeMouseState(int *x, int *y);










extern __declspec(dllexport) void __cdecl SDL_WarpMouseInWindow(SDL_Window * window,
                                                   int x, int y);










extern __declspec(dllexport) int __cdecl SDL_WarpMouseGlobal(int x, int y);

















extern __declspec(dllexport) int __cdecl SDL_SetRelativeMouseMode(SDL_bool enabled);






























extern __declspec(dllexport) int __cdecl SDL_CaptureMouse(SDL_bool enabled);






extern __declspec(dllexport) SDL_bool __cdecl SDL_GetRelativeMouseMode(void);



















extern __declspec(dllexport) SDL_Cursor *__cdecl SDL_CreateCursor(const Uint8 * data,
                                                     const Uint8 * mask,
                                                     int w, int h, int hot_x,
                                                     int hot_y);






extern __declspec(dllexport) SDL_Cursor *__cdecl SDL_CreateColorCursor(SDL_Surface *surface,
                                                          int hot_x,
                                                          int hot_y);






extern __declspec(dllexport) SDL_Cursor *__cdecl SDL_CreateSystemCursor(SDL_SystemCursor id);




extern __declspec(dllexport) void __cdecl SDL_SetCursor(SDL_Cursor * cursor);




extern __declspec(dllexport) SDL_Cursor *__cdecl SDL_GetCursor(void);




extern __declspec(dllexport) SDL_Cursor *__cdecl SDL_GetDefaultCursor(void);








extern __declspec(dllexport) void __cdecl SDL_FreeCursor(SDL_Cursor * cursor);









extern __declspec(dllexport) int __cdecl SDL_ShowCursor(int toggle);






















}
#line 298 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mouse.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 299 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mouse.h"

#line 301 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_mouse.h"


#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_joystick.h"












































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 46 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_joystick.h"


extern "C" {
#line 50 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_joystick.h"














struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;


typedef struct {
    Uint8 data[16];
} SDL_JoystickGUID;

typedef Sint32 SDL_JoystickID;

typedef enum
{
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY,
    SDL_JOYSTICK_POWER_LOW,
    SDL_JOYSTICK_POWER_MEDIUM,
    SDL_JOYSTICK_POWER_FULL,
    SDL_JOYSTICK_POWER_WIRED,
    SDL_JOYSTICK_POWER_MAX
} SDL_JoystickPowerLevel;





extern __declspec(dllexport) int __cdecl SDL_NumJoysticks(void);






extern __declspec(dllexport) const char *__cdecl SDL_JoystickNameForIndex(int device_index);










extern __declspec(dllexport) SDL_Joystick *__cdecl SDL_JoystickOpen(int device_index);




extern __declspec(dllexport) SDL_Joystick *__cdecl SDL_JoystickFromInstanceID(SDL_JoystickID joyid);





extern __declspec(dllexport) const char *__cdecl SDL_JoystickName(SDL_Joystick * joystick);




extern __declspec(dllexport) SDL_JoystickGUID __cdecl SDL_JoystickGetDeviceGUID(int device_index);




extern __declspec(dllexport) SDL_JoystickGUID __cdecl SDL_JoystickGetGUID(SDL_Joystick * joystick);





extern __declspec(dllexport) void __cdecl SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char *pszGUID, int cbGUID);




extern __declspec(dllexport) SDL_JoystickGUID __cdecl SDL_JoystickGetGUIDFromString(const char *pchGUID);




extern __declspec(dllexport) SDL_bool __cdecl SDL_JoystickGetAttached(SDL_Joystick * joystick);




extern __declspec(dllexport) SDL_JoystickID __cdecl SDL_JoystickInstanceID(SDL_Joystick * joystick);




extern __declspec(dllexport) int __cdecl SDL_JoystickNumAxes(SDL_Joystick * joystick);







extern __declspec(dllexport) int __cdecl SDL_JoystickNumBalls(SDL_Joystick * joystick);




extern __declspec(dllexport) int __cdecl SDL_JoystickNumHats(SDL_Joystick * joystick);




extern __declspec(dllexport) int __cdecl SDL_JoystickNumButtons(SDL_Joystick * joystick);







extern __declspec(dllexport) void __cdecl SDL_JoystickUpdate(void);










extern __declspec(dllexport) int __cdecl SDL_JoystickEventState(int state);








extern __declspec(dllexport) Sint16 __cdecl SDL_JoystickGetAxis(SDL_Joystick * joystick,
                                                   int axis);
































extern __declspec(dllexport) Uint8 __cdecl SDL_JoystickGetHat(SDL_Joystick * joystick,
                                                 int hat);








extern __declspec(dllexport) int __cdecl SDL_JoystickGetBall(SDL_Joystick * joystick,
                                                int ball, int *dx, int *dy);






extern __declspec(dllexport) Uint8 __cdecl SDL_JoystickGetButton(SDL_Joystick * joystick,
                                                    int button);




extern __declspec(dllexport) void __cdecl SDL_JoystickClose(SDL_Joystick * joystick);




extern __declspec(dllexport) SDL_JoystickPowerLevel __cdecl SDL_JoystickCurrentPowerLevel(SDL_Joystick * joystick);



}
#line 269 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_joystick.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 270 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_joystick.h"

#line 272 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_joystick.h"


#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gamecontroller.h"



































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gamecontroller.h"


extern "C" {
#line 41 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gamecontroller.h"














struct _SDL_GameController;
typedef struct _SDL_GameController SDL_GameController;


typedef enum
{
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON,
    SDL_CONTROLLER_BINDTYPE_AXIS,
    SDL_CONTROLLER_BINDTYPE_HAT
} SDL_GameControllerBindType;




typedef struct SDL_GameControllerButtonBind
{
    SDL_GameControllerBindType bindType;
    union
    {
        int button;
        int axis;
        struct {
            int hat;
            int hat_mask;
        } hat;
    } value;

} SDL_GameControllerButtonBind;




































extern __declspec(dllexport) int __cdecl SDL_GameControllerAddMappingsFromRW( SDL_RWops * rw, int freerw );













extern __declspec(dllexport) int __cdecl SDL_GameControllerAddMapping( const char* mappingString );






extern __declspec(dllexport) char * __cdecl SDL_GameControllerMappingForGUID( SDL_JoystickGUID guid );






extern __declspec(dllexport) char * __cdecl SDL_GameControllerMapping( SDL_GameController * gamecontroller );




extern __declspec(dllexport) SDL_bool __cdecl SDL_IsGameController(int joystick_index);







extern __declspec(dllexport) const char *__cdecl SDL_GameControllerNameForIndex(int joystick_index);










extern __declspec(dllexport) SDL_GameController *__cdecl SDL_GameControllerOpen(int joystick_index);




extern __declspec(dllexport) SDL_GameController *__cdecl SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);




extern __declspec(dllexport) const char *__cdecl SDL_GameControllerName(SDL_GameController *gamecontroller);





extern __declspec(dllexport) SDL_bool __cdecl SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);




extern __declspec(dllexport) SDL_Joystick *__cdecl SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);










extern __declspec(dllexport) int __cdecl SDL_GameControllerEventState(int state);







extern __declspec(dllexport) void __cdecl SDL_GameControllerUpdate(void);





typedef enum
{
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX,
    SDL_CONTROLLER_AXIS_LEFTY,
    SDL_CONTROLLER_AXIS_RIGHTX,
    SDL_CONTROLLER_AXIS_RIGHTY,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
    SDL_CONTROLLER_AXIS_MAX
} SDL_GameControllerAxis;




extern __declspec(dllexport) SDL_GameControllerAxis __cdecl SDL_GameControllerGetAxisFromString(const char *pchString);




extern __declspec(dllexport) const char* __cdecl SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);




extern __declspec(dllexport) SDL_GameControllerButtonBind __cdecl
SDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller,
                                 SDL_GameControllerAxis axis);









extern __declspec(dllexport) Sint16 __cdecl
SDL_GameControllerGetAxis(SDL_GameController *gamecontroller,
                          SDL_GameControllerAxis axis);




typedef enum
{
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A,
    SDL_CONTROLLER_BUTTON_B,
    SDL_CONTROLLER_BUTTON_X,
    SDL_CONTROLLER_BUTTON_Y,
    SDL_CONTROLLER_BUTTON_BACK,
    SDL_CONTROLLER_BUTTON_GUIDE,
    SDL_CONTROLLER_BUTTON_START,
    SDL_CONTROLLER_BUTTON_LEFTSTICK,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
    SDL_CONTROLLER_BUTTON_DPAD_UP,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,
    SDL_CONTROLLER_BUTTON_MAX
} SDL_GameControllerButton;




extern __declspec(dllexport) SDL_GameControllerButton __cdecl SDL_GameControllerGetButtonFromString(const char *pchString);




extern __declspec(dllexport) const char* __cdecl SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);




extern __declspec(dllexport) SDL_GameControllerButtonBind __cdecl
SDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller,
                                   SDL_GameControllerButton button);







extern __declspec(dllexport) Uint8 __cdecl SDL_GameControllerGetButton(SDL_GameController *gamecontroller,
                                                          SDL_GameControllerButton button);




extern __declspec(dllexport) void __cdecl SDL_GameControllerClose(SDL_GameController *gamecontroller);




}
#line 319 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gamecontroller.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 320 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gamecontroller.h"

#line 322 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gamecontroller.h"


#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_quit.h"

























































#line 59 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_quit.h"
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"


































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_touch.h"


































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_touch.h"


extern "C" {
#line 40 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_touch.h"

typedef Sint64 SDL_TouchID;
typedef Sint64 SDL_FingerID;

typedef struct SDL_Finger
{
    SDL_FingerID id;
    float x;
    float y;
    float pressure;
} SDL_Finger;










extern __declspec(dllexport) int __cdecl SDL_GetNumTouchDevices(void);




extern __declspec(dllexport) SDL_TouchID __cdecl SDL_GetTouchDevice(int index);




extern __declspec(dllexport) int __cdecl SDL_GetNumTouchFingers(SDL_TouchID touchID);




extern __declspec(dllexport) SDL_Finger * __cdecl SDL_GetTouchFinger(SDL_TouchID touchID, int index);



}
#line 82 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_touch.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 83 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_touch.h"

#line 85 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_touch.h"


#line 36 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"


extern "C" {
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"

typedef Sint64 SDL_GestureID;








extern __declspec(dllexport) int __cdecl SDL_RecordGesture(SDL_TouchID touchId);







extern __declspec(dllexport) int __cdecl SDL_SaveAllDollarTemplates(SDL_RWops *dst);






extern __declspec(dllexport) int __cdecl SDL_SaveDollarTemplate(SDL_GestureID gestureId,SDL_RWops *dst);







extern __declspec(dllexport) int __cdecl SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src);




}
#line 83 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 84 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"

#line 86 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_gesture.h"


#line 40 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"


extern "C" {
#line 47 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"








typedef enum
{
    SDL_FIRSTEVENT     = 0,     

    
    SDL_QUIT           = 0x100, 

    
    SDL_APP_TERMINATING,        



    SDL_APP_LOWMEMORY,          



    SDL_APP_WILLENTERBACKGROUND, 



    SDL_APP_DIDENTERBACKGROUND, 



    SDL_APP_WILLENTERFOREGROUND, 



    SDL_APP_DIDENTERFOREGROUND, 




    
    SDL_WINDOWEVENT    = 0x200, 
    SDL_SYSWMEVENT,             

    
    SDL_KEYDOWN        = 0x300, 
    SDL_KEYUP,                  
    SDL_TEXTEDITING,            
    SDL_TEXTINPUT,              
    SDL_KEYMAPCHANGED,          



    
    SDL_MOUSEMOTION    = 0x400, 
    SDL_MOUSEBUTTONDOWN,        
    SDL_MOUSEBUTTONUP,          
    SDL_MOUSEWHEEL,             

    
    SDL_JOYAXISMOTION  = 0x600, 
    SDL_JOYBALLMOTION,          
    SDL_JOYHATMOTION,           
    SDL_JOYBUTTONDOWN,          
    SDL_JOYBUTTONUP,            
    SDL_JOYDEVICEADDED,         
    SDL_JOYDEVICEREMOVED,       

    
    SDL_CONTROLLERAXISMOTION  = 0x650, 
    SDL_CONTROLLERBUTTONDOWN,          
    SDL_CONTROLLERBUTTONUP,            
    SDL_CONTROLLERDEVICEADDED,         
    SDL_CONTROLLERDEVICEREMOVED,       
    SDL_CONTROLLERDEVICEREMAPPED,      

    
    SDL_FINGERDOWN      = 0x700,
    SDL_FINGERUP,
    SDL_FINGERMOTION,

    
    SDL_DOLLARGESTURE   = 0x800,
    SDL_DOLLARRECORD,
    SDL_MULTIGESTURE,

    
    SDL_CLIPBOARDUPDATE = 0x900, 

    
    SDL_DROPFILE        = 0x1000, 
    SDL_DROPTEXT,                 
    SDL_DROPBEGIN,                
    SDL_DROPCOMPLETE,             

    
    SDL_AUDIODEVICEADDED = 0x1100, 
    SDL_AUDIODEVICEREMOVED,        

    
    SDL_RENDER_TARGETS_RESET = 0x2000, 
    SDL_RENDER_DEVICE_RESET, 

    


    SDL_USEREVENT    = 0x8000,

    


    SDL_LASTEVENT    = 0xFFFF
} SDL_EventType;




typedef struct SDL_CommonEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_CommonEvent;




typedef struct SDL_WindowEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 windowID;    
    Uint8 event;        
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint32 data1;       
    Sint32 data2;       
} SDL_WindowEvent;




typedef struct SDL_KeyboardEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 windowID;    
    Uint8 state;        
    Uint8 repeat;       
    Uint8 padding2;
    Uint8 padding3;
    SDL_Keysym keysym;  
} SDL_KeyboardEvent;





typedef struct SDL_TextEditingEvent
{
    Uint32 type;                                
    Uint32 timestamp;
    Uint32 windowID;                            
    char text[(32)];  
    Sint32 start;                               
    Sint32 length;                              
} SDL_TextEditingEvent;






typedef struct SDL_TextInputEvent
{
    Uint32 type;                              
    Uint32 timestamp;
    Uint32 windowID;                          
    char text[(32)];  
} SDL_TextInputEvent;




typedef struct SDL_MouseMotionEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 windowID;    
    Uint32 which;       
    Uint32 state;       
    Sint32 x;           
    Sint32 y;           
    Sint32 xrel;        
    Sint32 yrel;        
} SDL_MouseMotionEvent;




typedef struct SDL_MouseButtonEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 windowID;    
    Uint32 which;       
    Uint8 button;       
    Uint8 state;        
    Uint8 clicks;       
    Uint8 padding1;
    Sint32 x;           
    Sint32 y;           
} SDL_MouseButtonEvent;




typedef struct SDL_MouseWheelEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 windowID;    
    Uint32 which;       
    Sint32 x;           
    Sint32 y;           
    Uint32 direction;   
} SDL_MouseWheelEvent;




typedef struct SDL_JoyAxisEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_JoystickID which; 
    Uint8 axis;         
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;       
    Uint16 padding4;
} SDL_JoyAxisEvent;




typedef struct SDL_JoyBallEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_JoystickID which; 
    Uint8 ball;         
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 xrel;        
    Sint16 yrel;        
} SDL_JoyBallEvent;




typedef struct SDL_JoyHatEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_JoystickID which; 
    Uint8 hat;          
    Uint8 value;        






    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyHatEvent;




typedef struct SDL_JoyButtonEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_JoystickID which; 
    Uint8 button;       
    Uint8 state;        
    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyButtonEvent;




typedef struct SDL_JoyDeviceEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Sint32 which;       
} SDL_JoyDeviceEvent;





typedef struct SDL_ControllerAxisEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_JoystickID which; 
    Uint8 axis;         
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;       
    Uint16 padding4;
} SDL_ControllerAxisEvent;





typedef struct SDL_ControllerButtonEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_JoystickID which; 
    Uint8 button;       
    Uint8 state;        
    Uint8 padding1;
    Uint8 padding2;
} SDL_ControllerButtonEvent;





typedef struct SDL_ControllerDeviceEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Sint32 which;       
} SDL_ControllerDeviceEvent;




typedef struct SDL_AudioDeviceEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 which;       
    Uint8 iscapture;    
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_AudioDeviceEvent;





typedef struct SDL_TouchFingerEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_TouchID touchId; 
    SDL_FingerID fingerId;
    float x;            
    float y;            
    float dx;           
    float dy;           
    float pressure;     
} SDL_TouchFingerEvent;





typedef struct SDL_MultiGestureEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_TouchID touchId; 
    float dTheta;
    float dDist;
    float x;
    float y;
    Uint16 numFingers;
    Uint16 padding;
} SDL_MultiGestureEvent;





typedef struct SDL_DollarGestureEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_TouchID touchId; 
    SDL_GestureID gestureId;
    Uint32 numFingers;
    float error;
    float x;            
    float y;            
} SDL_DollarGestureEvent;







typedef struct SDL_DropEvent
{
    Uint32 type;        
    Uint32 timestamp;
    char *file;         
    Uint32 windowID;    
} SDL_DropEvent;





typedef struct SDL_QuitEvent
{
    Uint32 type;        
    Uint32 timestamp;
} SDL_QuitEvent;




typedef struct SDL_OSEvent
{
    Uint32 type;        
    Uint32 timestamp;
} SDL_OSEvent;




typedef struct SDL_UserEvent
{
    Uint32 type;        
    Uint32 timestamp;
    Uint32 windowID;    
    Sint32 code;        
    void *data1;        
    void *data2;        
} SDL_UserEvent;


struct SDL_SysWMmsg;
typedef struct SDL_SysWMmsg SDL_SysWMmsg;







typedef struct SDL_SysWMEvent
{
    Uint32 type;        
    Uint32 timestamp;
    SDL_SysWMmsg *msg;  
} SDL_SysWMEvent;




typedef union SDL_Event
{
    Uint32 type;                    
    SDL_CommonEvent common;         
    SDL_WindowEvent window;         
    SDL_KeyboardEvent key;          
    SDL_TextEditingEvent edit;      
    SDL_TextInputEvent text;        
    SDL_MouseMotionEvent motion;    
    SDL_MouseButtonEvent button;    
    SDL_MouseWheelEvent wheel;      
    SDL_JoyAxisEvent jaxis;         
    SDL_JoyBallEvent jball;         
    SDL_JoyHatEvent jhat;           
    SDL_JoyButtonEvent jbutton;     
    SDL_JoyDeviceEvent jdevice;     
    SDL_ControllerAxisEvent caxis;      
    SDL_ControllerButtonEvent cbutton;  
    SDL_ControllerDeviceEvent cdevice;  
    SDL_AudioDeviceEvent adevice;   
    SDL_QuitEvent quit;             
    SDL_UserEvent user;             
    SDL_SysWMEvent syswm;           
    SDL_TouchFingerEvent tfinger;   
    SDL_MultiGestureEvent mgesture; 
    SDL_DollarGestureEvent dgesture; 
    SDL_DropEvent drop;             

    






    Uint8 padding[56];
} SDL_Event;











extern __declspec(dllexport) void __cdecl SDL_PumpEvents(void);


typedef enum
{
    SDL_ADDEVENT,
    SDL_PEEKEVENT,
    SDL_GETEVENT
} SDL_eventaction;



















extern __declspec(dllexport) int __cdecl SDL_PeepEvents(SDL_Event * events, int numevents,
                                           SDL_eventaction action,
                                           Uint32 minType, Uint32 maxType);





extern __declspec(dllexport) SDL_bool __cdecl SDL_HasEvent(Uint32 type);
extern __declspec(dllexport) SDL_bool __cdecl SDL_HasEvents(Uint32 minType, Uint32 maxType);







extern __declspec(dllexport) void __cdecl SDL_FlushEvent(Uint32 type);
extern __declspec(dllexport) void __cdecl SDL_FlushEvents(Uint32 minType, Uint32 maxType);









extern __declspec(dllexport) int __cdecl SDL_PollEvent(SDL_Event * event);









extern __declspec(dllexport) int __cdecl SDL_WaitEvent(SDL_Event * event);











extern __declspec(dllexport) int __cdecl SDL_WaitEventTimeout(SDL_Event * event,
                                                 int timeout);







extern __declspec(dllexport) int __cdecl SDL_PushEvent(SDL_Event * event);

typedef int (__cdecl * SDL_EventFilter) (void *userdata, SDL_Event * event);


























extern __declspec(dllexport) void __cdecl SDL_SetEventFilter(SDL_EventFilter filter,
                                                void *userdata);





extern __declspec(dllexport) SDL_bool __cdecl SDL_GetEventFilter(SDL_EventFilter * filter,
                                                    void **userdata);




extern __declspec(dllexport) void __cdecl SDL_AddEventWatch(SDL_EventFilter filter,
                                               void *userdata);




extern __declspec(dllexport) void __cdecl SDL_DelEventWatch(SDL_EventFilter filter,
                                               void *userdata);





extern __declspec(dllexport) void __cdecl SDL_FilterEvents(SDL_EventFilter filter,
                                              void *userdata);
















extern __declspec(dllexport) Uint8 __cdecl SDL_EventState(Uint32 type, int state);










extern __declspec(dllexport) Uint32 __cdecl SDL_RegisterEvents(int numevents);



}
#line 750 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 751 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"

#line 753 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_events.h"


#line 42 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_filesystem.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_filesystem.h"



extern "C" {
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_filesystem.h"
























extern __declspec(dllexport) char *__cdecl SDL_GetBasePath(void);






























































extern __declspec(dllexport) char *__cdecl SDL_GetPrefPath(const char *org, const char *app);



}
#line 132 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_filesystem.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 133 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_filesystem.h"

#line 135 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_filesystem.h"


#line 43 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_haptic.h"

















































































































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 115 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_haptic.h"


extern "C" {
#line 119 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_haptic.h"










struct _SDL_Haptic;
typedef struct _SDL_Haptic SDL_Haptic;


















































































































































































































































































































typedef struct SDL_HapticDirection
{
    Uint8 type;         
    Sint32 dir[3];      
} SDL_HapticDirection;













typedef struct SDL_HapticConstant
{
    
    Uint16 type;            
    SDL_HapticDirection direction;  

    
    Uint32 length;          
    Uint16 delay;           

    
    Uint16 button;          
    Uint16 interval;        

    
    Sint16 level;           

    
    Uint16 attack_length;   
    Uint16 attack_level;    
    Uint16 fade_length;     
    Uint16 fade_level;      
} SDL_HapticConstant;


























































typedef struct SDL_HapticPeriodic
{
    
    Uint16 type;        


    SDL_HapticDirection direction;  

    
    Uint32 length;      
    Uint16 delay;       

    
    Uint16 button;      
    Uint16 interval;    

    
    Uint16 period;      
    Sint16 magnitude;   
    Sint16 offset;      
    Uint16 phase;       

    
    Uint16 attack_length;   
    Uint16 attack_level;    
    Uint16 fade_length; 
    Uint16 fade_level;  
} SDL_HapticPeriodic;

























typedef struct SDL_HapticCondition
{
    
    Uint16 type;            

    SDL_HapticDirection direction;  

    
    Uint32 length;          
    Uint16 delay;           

    
    Uint16 button;          
    Uint16 interval;        

    
    Uint16 right_sat[3];    
    Uint16 left_sat[3];     
    Sint16 right_coeff[3];  
    Sint16 left_coeff[3];   
    Uint16 deadband[3];     
    Sint16 center[3];       
} SDL_HapticCondition;














typedef struct SDL_HapticRamp
{
    
    Uint16 type;            
    SDL_HapticDirection direction;  

    
    Uint32 length;          
    Uint16 delay;           

    
    Uint16 button;          
    Uint16 interval;        

    
    Sint16 start;           
    Sint16 end;             

    
    Uint16 attack_length;   
    Uint16 attack_level;    
    Uint16 fade_length;     
    Uint16 fade_level;      
} SDL_HapticRamp;













typedef struct SDL_HapticLeftRight
{
    
    Uint16 type;            

    
    Uint32 length;          

    
    Uint16 large_magnitude; 
    Uint16 small_magnitude; 
} SDL_HapticLeftRight;














typedef struct SDL_HapticCustom
{
    
    Uint16 type;            
    SDL_HapticDirection direction;  

    
    Uint32 length;          
    Uint16 delay;           

    
    Uint16 button;          
    Uint16 interval;        

    
    Uint8 channels;         
    Uint16 period;          
    Uint16 samples;         
    Uint16 *data;           

    
    Uint16 attack_length;   
    Uint16 attack_level;    
    Uint16 fade_length;     
    Uint16 fade_level;      
} SDL_HapticCustom;






































































typedef union SDL_HapticEffect
{
    
    Uint16 type;                    
    SDL_HapticConstant constant;    
    SDL_HapticPeriodic periodic;    
    SDL_HapticCondition condition;  
    SDL_HapticRamp ramp;            
    SDL_HapticLeftRight leftright;  
    SDL_HapticCustom custom;        
} SDL_HapticEffect;








extern __declspec(dllexport) int __cdecl SDL_NumHaptics(void);












extern __declspec(dllexport) const char *__cdecl SDL_HapticName(int device_index);























extern __declspec(dllexport) SDL_Haptic *__cdecl SDL_HapticOpen(int device_index);










extern __declspec(dllexport) int __cdecl SDL_HapticOpened(int device_index);










extern __declspec(dllexport) int __cdecl SDL_HapticIndex(SDL_Haptic * haptic);








extern __declspec(dllexport) int __cdecl SDL_MouseIsHaptic(void);









extern __declspec(dllexport) SDL_Haptic *__cdecl SDL_HapticOpenFromMouse(void);










extern __declspec(dllexport) int __cdecl SDL_JoystickIsHaptic(SDL_Joystick * joystick);


















extern __declspec(dllexport) SDL_Haptic *__cdecl SDL_HapticOpenFromJoystick(SDL_Joystick *
                                                               joystick);






extern __declspec(dllexport) void __cdecl SDL_HapticClose(SDL_Haptic * haptic);















extern __declspec(dllexport) int __cdecl SDL_HapticNumEffects(SDL_Haptic * haptic);















extern __declspec(dllexport) int __cdecl SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic);

















extern __declspec(dllexport) unsigned int __cdecl SDL_HapticQuery(SDL_Haptic * haptic);







extern __declspec(dllexport) int __cdecl SDL_HapticNumAxes(SDL_Haptic * haptic);











extern __declspec(dllexport) int __cdecl SDL_HapticEffectSupported(SDL_Haptic * haptic,
                                                      SDL_HapticEffect *
                                                      effect);












extern __declspec(dllexport) int __cdecl SDL_HapticNewEffect(SDL_Haptic * haptic,
                                                SDL_HapticEffect * effect);


















extern __declspec(dllexport) int __cdecl SDL_HapticUpdateEffect(SDL_Haptic * haptic,
                                                   int effect,
                                                   SDL_HapticEffect * data);



















extern __declspec(dllexport) int __cdecl SDL_HapticRunEffect(SDL_Haptic * haptic,
                                                int effect,
                                                Uint32 iterations);











extern __declspec(dllexport) int __cdecl SDL_HapticStopEffect(SDL_Haptic * haptic,
                                                 int effect);












extern __declspec(dllexport) void __cdecl SDL_HapticDestroyEffect(SDL_Haptic * haptic,
                                                     int effect);













extern __declspec(dllexport) int __cdecl SDL_HapticGetEffectStatus(SDL_Haptic * haptic,
                                                      int effect);

















extern __declspec(dllexport) int __cdecl SDL_HapticSetGain(SDL_Haptic * haptic, int gain);















extern __declspec(dllexport) int __cdecl SDL_HapticSetAutocenter(SDL_Haptic * haptic,
                                                    int autocenter);















extern __declspec(dllexport) int __cdecl SDL_HapticPause(SDL_Haptic * haptic);











extern __declspec(dllexport) int __cdecl SDL_HapticUnpause(SDL_Haptic * haptic);







extern __declspec(dllexport) int __cdecl SDL_HapticStopAll(SDL_Haptic * haptic);











extern __declspec(dllexport) int __cdecl SDL_HapticRumbleSupported(SDL_Haptic * haptic);












extern __declspec(dllexport) int __cdecl SDL_HapticRumbleInit(SDL_Haptic * haptic);













extern __declspec(dllexport) int __cdecl SDL_HapticRumblePlay(SDL_Haptic * haptic, float strength, Uint32 length );











extern __declspec(dllexport) int __cdecl SDL_HapticRumbleStop(SDL_Haptic * haptic);



}
#line 1219 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_haptic.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 1220 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_haptic.h"

#line 1222 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_haptic.h"



#line 46 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_hints.h"











































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 45 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_hints.h"


extern "C" {
#line 49 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_hints.h"







































































































































































































































































































































































































































































































































































 
























 























































































typedef enum
{
    SDL_HINT_DEFAULT,
    SDL_HINT_NORMAL,
    SDL_HINT_OVERRIDE
} SDL_HintPriority;











extern __declspec(dllexport) SDL_bool __cdecl SDL_SetHintWithPriority(const char *name,
                                                         const char *value,
                                                         SDL_HintPriority priority);






extern __declspec(dllexport) SDL_bool __cdecl SDL_SetHint(const char *name,
                                             const char *value);






extern __declspec(dllexport) const char * __cdecl SDL_GetHint(const char *name);






extern __declspec(dllexport) SDL_bool __cdecl SDL_GetHintBoolean(const char *name, SDL_bool default_value);








typedef void (*SDL_HintCallback)(void *userdata, const char *name, const char *oldValue, const char *newValue);
extern __declspec(dllexport) void __cdecl SDL_AddHintCallback(const char *name,
                                                 SDL_HintCallback callback,
                                                 void *userdata);








extern __declspec(dllexport) void __cdecl SDL_DelHintCallback(const char *name,
                                                 SDL_HintCallback callback,
                                                 void *userdata);






extern __declspec(dllexport) void __cdecl SDL_ClearHints(void);




}
#line 791 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_hints.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 792 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_hints.h"

#line 794 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_hints.h"



#line 47 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_loadso.h"














































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 48 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_loadso.h"


extern "C" {
#line 52 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_loadso.h"






extern __declspec(dllexport) void *__cdecl SDL_LoadObject(const char *sofile);






extern __declspec(dllexport) void *__cdecl SDL_LoadFunction(void *handle,
                                               const char *name);




extern __declspec(dllexport) void __cdecl SDL_UnloadObject(void *handle);



}
#line 77 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_loadso.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 78 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_loadso.h"

#line 80 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_loadso.h"


#line 48 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_log.h"









































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 43 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_log.h"


extern "C" {
#line 47 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_log.h"

















enum
{
    SDL_LOG_CATEGORY_APPLICATION,
    SDL_LOG_CATEGORY_ERROR,
    SDL_LOG_CATEGORY_ASSERT,
    SDL_LOG_CATEGORY_SYSTEM,
    SDL_LOG_CATEGORY_AUDIO,
    SDL_LOG_CATEGORY_VIDEO,
    SDL_LOG_CATEGORY_RENDER,
    SDL_LOG_CATEGORY_INPUT,
    SDL_LOG_CATEGORY_TEST,

    
    SDL_LOG_CATEGORY_RESERVED1,
    SDL_LOG_CATEGORY_RESERVED2,
    SDL_LOG_CATEGORY_RESERVED3,
    SDL_LOG_CATEGORY_RESERVED4,
    SDL_LOG_CATEGORY_RESERVED5,
    SDL_LOG_CATEGORY_RESERVED6,
    SDL_LOG_CATEGORY_RESERVED7,
    SDL_LOG_CATEGORY_RESERVED8,
    SDL_LOG_CATEGORY_RESERVED9,
    SDL_LOG_CATEGORY_RESERVED10,

    







    SDL_LOG_CATEGORY_CUSTOM
};




typedef enum
{
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG,
    SDL_LOG_PRIORITY_INFO,
    SDL_LOG_PRIORITY_WARN,
    SDL_LOG_PRIORITY_ERROR,
    SDL_LOG_PRIORITY_CRITICAL,
    SDL_NUM_LOG_PRIORITIES
} SDL_LogPriority;





extern __declspec(dllexport) void __cdecl SDL_LogSetAllPriority(SDL_LogPriority priority);




extern __declspec(dllexport) void __cdecl SDL_LogSetPriority(int category,
                                                SDL_LogPriority priority);




extern __declspec(dllexport) SDL_LogPriority __cdecl SDL_LogGetPriority(int category);






extern __declspec(dllexport) void __cdecl SDL_LogResetPriorities(void);




extern __declspec(dllexport) void __cdecl SDL_Log(  const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogVerbose(int category,   const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogDebug(int category,   const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogInfo(int category,   const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogWarn(int category,   const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogError(int category,   const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogCritical(int category,   const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogMessage(int category,
                                            SDL_LogPriority priority,
                                              const char *fmt, ...) ;




extern __declspec(dllexport) void __cdecl SDL_LogMessageV(int category,
                                             SDL_LogPriority priority,
                                             const char *fmt, va_list ap);




typedef void (*SDL_LogOutputFunction)(void *userdata, int category, SDL_LogPriority priority, const char *message);




extern __declspec(dllexport) void __cdecl SDL_LogGetOutputFunction(SDL_LogOutputFunction *callback, void **userdata);





extern __declspec(dllexport) void __cdecl SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void *userdata);




}
#line 207 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_log.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 208 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_log.h"

#line 210 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_log.h"


#line 49 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_messagebox.h"



























#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 29 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_messagebox.h"


extern "C" {
#line 33 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_messagebox.h"




typedef enum
{
    SDL_MESSAGEBOX_ERROR        = 0x00000010,   
    SDL_MESSAGEBOX_WARNING      = 0x00000020,   
    SDL_MESSAGEBOX_INFORMATION  = 0x00000040    
} SDL_MessageBoxFlags;




typedef enum
{
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 0x00000001,  
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 0x00000002   
} SDL_MessageBoxButtonFlags;




typedef struct
{
    Uint32 flags;       
    int buttonid;       
    const char * text;  
} SDL_MessageBoxButtonData;




typedef struct
{
    Uint8 r, g, b;
} SDL_MessageBoxColor;

typedef enum
{
    SDL_MESSAGEBOX_COLOR_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_TEXT,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED,
    SDL_MESSAGEBOX_COLOR_MAX
} SDL_MessageBoxColorType;




typedef struct
{
    SDL_MessageBoxColor colors[SDL_MESSAGEBOX_COLOR_MAX];
} SDL_MessageBoxColorScheme;




typedef struct
{
    Uint32 flags;                       
    SDL_Window *window;                 
    const char *title;                  
    const char *message;                

    int numbuttons;
    const SDL_MessageBoxButtonData *buttons;

    const SDL_MessageBoxColorScheme *colorScheme;   
} SDL_MessageBoxData;















extern __declspec(dllexport) int __cdecl SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);













extern __declspec(dllexport) int __cdecl SDL_ShowSimpleMessageBox(Uint32 flags, const char *title, const char *message, SDL_Window *window);




}
#line 140 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_messagebox.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 141 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_messagebox.h"

#line 143 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_messagebox.h"


#line 50 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_power.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_power.h"


extern "C" {
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_power.h"




typedef enum
{
    SDL_POWERSTATE_UNKNOWN,      
    SDL_POWERSTATE_ON_BATTERY,   
    SDL_POWERSTATE_NO_BATTERY,   
    SDL_POWERSTATE_CHARGING,     
    SDL_POWERSTATE_CHARGED       
} SDL_PowerState;















extern __declspec(dllexport) SDL_PowerState __cdecl SDL_GetPowerInfo(int *secs, int *pct);



}
#line 71 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_power.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 72 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_power.h"

#line 74 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_power.h"


#line 52 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_render.h"






















































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 56 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_render.h"


extern "C" {
#line 60 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_render.h"




typedef enum
{
    SDL_RENDERER_SOFTWARE = 0x00000001,         
    SDL_RENDERER_ACCELERATED = 0x00000002,      

    SDL_RENDERER_PRESENTVSYNC = 0x00000004,     

    SDL_RENDERER_TARGETTEXTURE = 0x00000008     

} SDL_RendererFlags;




typedef struct SDL_RendererInfo
{
    const char *name;           
    Uint32 flags;               
    Uint32 num_texture_formats; 
    Uint32 texture_formats[16]; 
    int max_texture_width;      
    int max_texture_height;     
} SDL_RendererInfo;




typedef enum
{
    SDL_TEXTUREACCESS_STATIC,    
    SDL_TEXTUREACCESS_STREAMING, 
    SDL_TEXTUREACCESS_TARGET     
} SDL_TextureAccess;




typedef enum
{
    SDL_TEXTUREMODULATE_NONE = 0x00000000,     
    SDL_TEXTUREMODULATE_COLOR = 0x00000001,    
    SDL_TEXTUREMODULATE_ALPHA = 0x00000002     
} SDL_TextureModulate;




typedef enum
{
    SDL_FLIP_NONE = 0x00000000,     
    SDL_FLIP_HORIZONTAL = 0x00000001,    
    SDL_FLIP_VERTICAL = 0x00000002     
} SDL_RendererFlip;




struct SDL_Renderer;
typedef struct SDL_Renderer SDL_Renderer;




struct SDL_Texture;
typedef struct SDL_Texture SDL_Texture;















extern __declspec(dllexport) int __cdecl SDL_GetNumRenderDrivers(void);













extern __declspec(dllexport) int __cdecl SDL_GetRenderDriverInfo(int index,
                                                    SDL_RendererInfo * info);












extern __declspec(dllexport) int __cdecl SDL_CreateWindowAndRenderer(
                                int width, int height, Uint32 window_flags,
                                SDL_Window **window, SDL_Renderer **renderer);
















extern __declspec(dllexport) SDL_Renderer * __cdecl SDL_CreateRenderer(SDL_Window * window,
                                               int index, Uint32 flags);











extern __declspec(dllexport) SDL_Renderer * __cdecl SDL_CreateSoftwareRenderer(SDL_Surface * surface);




extern __declspec(dllexport) SDL_Renderer * __cdecl SDL_GetRenderer(SDL_Window * window);




extern __declspec(dllexport) int __cdecl SDL_GetRendererInfo(SDL_Renderer * renderer,
                                                SDL_RendererInfo * info);




extern __declspec(dllexport) int __cdecl SDL_GetRendererOutputSize(SDL_Renderer * renderer,
                                                      int *w, int *h);


















extern __declspec(dllexport) SDL_Texture * __cdecl SDL_CreateTexture(SDL_Renderer * renderer,
                                                        Uint32 format,
                                                        int access, int w,
                                                        int h);














extern __declspec(dllexport) SDL_Texture * __cdecl SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface);














extern __declspec(dllexport) int __cdecl SDL_QueryTexture(SDL_Texture * texture,
                                             Uint32 * format, int *access,
                                             int *w, int *h);














extern __declspec(dllexport) int __cdecl SDL_SetTextureColorMod(SDL_Texture * texture,
                                                   Uint8 r, Uint8 g, Uint8 b);














extern __declspec(dllexport) int __cdecl SDL_GetTextureColorMod(SDL_Texture * texture,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);












extern __declspec(dllexport) int __cdecl SDL_SetTextureAlphaMod(SDL_Texture * texture,
                                                   Uint8 alpha);











extern __declspec(dllexport) int __cdecl SDL_GetTextureAlphaMod(SDL_Texture * texture,
                                                   Uint8 * alpha);















extern __declspec(dllexport) int __cdecl SDL_SetTextureBlendMode(SDL_Texture * texture,
                                                    SDL_BlendMode blendMode);











extern __declspec(dllexport) int __cdecl SDL_GetTextureBlendMode(SDL_Texture * texture,
                                                    SDL_BlendMode *blendMode);














extern __declspec(dllexport) int __cdecl SDL_UpdateTexture(SDL_Texture * texture,
                                              const SDL_Rect * rect,
                                              const void *pixels, int pitch);




















extern __declspec(dllexport) int __cdecl SDL_UpdateYUVTexture(SDL_Texture * texture,
                                                 const SDL_Rect * rect,
                                                 const Uint8 *Yplane, int Ypitch,
                                                 const Uint8 *Uplane, int Upitch,
                                                 const Uint8 *Vplane, int Vpitch);
















extern __declspec(dllexport) int __cdecl SDL_LockTexture(SDL_Texture * texture,
                                            const SDL_Rect * rect,
                                            void **pixels, int *pitch);






extern __declspec(dllexport) void __cdecl SDL_UnlockTexture(SDL_Texture * texture);








extern __declspec(dllexport) SDL_bool __cdecl SDL_RenderTargetSupported(SDL_Renderer *renderer);











extern __declspec(dllexport) int __cdecl SDL_SetRenderTarget(SDL_Renderer *renderer,
                                                SDL_Texture *texture);








extern __declspec(dllexport) SDL_Texture * __cdecl SDL_GetRenderTarget(SDL_Renderer *renderer);
























extern __declspec(dllexport) int __cdecl SDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h);










extern __declspec(dllexport) void __cdecl SDL_RenderGetLogicalSize(SDL_Renderer * renderer, int *w, int *h);













extern __declspec(dllexport) int __cdecl SDL_RenderSetIntegerScale(SDL_Renderer * renderer,
                                                      SDL_bool enable);








extern __declspec(dllexport) SDL_bool __cdecl SDL_RenderGetIntegerScale(SDL_Renderer * renderer);
















extern __declspec(dllexport) int __cdecl SDL_RenderSetViewport(SDL_Renderer * renderer,
                                                  const SDL_Rect * rect);






extern __declspec(dllexport) void __cdecl SDL_RenderGetViewport(SDL_Renderer * renderer,
                                                   SDL_Rect * rect);












extern __declspec(dllexport) int __cdecl SDL_RenderSetClipRect(SDL_Renderer * renderer,
                                                  const SDL_Rect * rect);










extern __declspec(dllexport) void __cdecl SDL_RenderGetClipRect(SDL_Renderer * renderer,
                                                   SDL_Rect * rect);








extern __declspec(dllexport) SDL_bool __cdecl SDL_RenderIsClipEnabled(SDL_Renderer * renderer);




















extern __declspec(dllexport) int __cdecl SDL_RenderSetScale(SDL_Renderer * renderer,
                                               float scaleX, float scaleY);










extern __declspec(dllexport) void __cdecl SDL_RenderGetScale(SDL_Renderer * renderer,
                                               float *scaleX, float *scaleY);













extern __declspec(dllexport) int __cdecl SDL_SetRenderDrawColor(SDL_Renderer * renderer,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);













extern __declspec(dllexport) int __cdecl SDL_GetRenderDrawColor(SDL_Renderer * renderer,
                                           Uint8 * r, Uint8 * g, Uint8 * b,
                                           Uint8 * a);














extern __declspec(dllexport) int __cdecl SDL_SetRenderDrawBlendMode(SDL_Renderer * renderer,
                                                       SDL_BlendMode blendMode);











extern __declspec(dllexport) int __cdecl SDL_GetRenderDrawBlendMode(SDL_Renderer * renderer,
                                                       SDL_BlendMode *blendMode);









extern __declspec(dllexport) int __cdecl SDL_RenderClear(SDL_Renderer * renderer);










extern __declspec(dllexport) int __cdecl SDL_RenderDrawPoint(SDL_Renderer * renderer,
                                                int x, int y);










extern __declspec(dllexport) int __cdecl SDL_RenderDrawPoints(SDL_Renderer * renderer,
                                                 const SDL_Point * points,
                                                 int count);












extern __declspec(dllexport) int __cdecl SDL_RenderDrawLine(SDL_Renderer * renderer,
                                               int x1, int y1, int x2, int y2);










extern __declspec(dllexport) int __cdecl SDL_RenderDrawLines(SDL_Renderer * renderer,
                                                const SDL_Point * points,
                                                int count);









extern __declspec(dllexport) int __cdecl SDL_RenderDrawRect(SDL_Renderer * renderer,
                                               const SDL_Rect * rect);










extern __declspec(dllexport) int __cdecl SDL_RenderDrawRects(SDL_Renderer * renderer,
                                                const SDL_Rect * rects,
                                                int count);










extern __declspec(dllexport) int __cdecl SDL_RenderFillRect(SDL_Renderer * renderer,
                                               const SDL_Rect * rect);










extern __declspec(dllexport) int __cdecl SDL_RenderFillRects(SDL_Renderer * renderer,
                                                const SDL_Rect * rects,
                                                int count);













extern __declspec(dllexport) int __cdecl SDL_RenderCopy(SDL_Renderer * renderer,
                                           SDL_Texture * texture,
                                           const SDL_Rect * srcrect,
                                           const SDL_Rect * dstrect);
















extern __declspec(dllexport) int __cdecl SDL_RenderCopyEx(SDL_Renderer * renderer,
                                           SDL_Texture * texture,
                                           const SDL_Rect * srcrect,
                                           const SDL_Rect * dstrect,
                                           const double angle,
                                           const SDL_Point *center,
                                           const SDL_RendererFlip flip);
















extern __declspec(dllexport) int __cdecl SDL_RenderReadPixels(SDL_Renderer * renderer,
                                                 const SDL_Rect * rect,
                                                 Uint32 format,
                                                 void *pixels, int pitch);




extern __declspec(dllexport) void __cdecl SDL_RenderPresent(SDL_Renderer * renderer);







extern __declspec(dllexport) void __cdecl SDL_DestroyTexture(SDL_Texture * texture);







extern __declspec(dllexport) void __cdecl SDL_DestroyRenderer(SDL_Renderer * renderer);












extern __declspec(dllexport) int __cdecl SDL_GL_BindTexture(SDL_Texture *texture, float *texw, float *texh);








extern __declspec(dllexport) int __cdecl SDL_GL_UnbindTexture(SDL_Texture *texture);




}
#line 901 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_render.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 902 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_render.h"

#line 904 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_render.h"



#line 53 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"



































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 37 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"


extern "C" {
#line 41 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"




	



typedef void (__cdecl * SDL_WindowsMessageHook)(void *userdata, void *hWnd, unsigned int message, Uint64 wParam, Sint64 lParam);
extern __declspec(dllexport) void __cdecl SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);







extern __declspec(dllexport) int __cdecl SDL_Direct3D9GetAdapterIndex( int displayIndex );

typedef struct IDirect3DDevice9 IDirect3DDevice9;





extern __declspec(dllexport) IDirect3DDevice9* __cdecl SDL_RenderGetD3D9Device(SDL_Renderer * renderer);







extern __declspec(dllexport) SDL_bool __cdecl SDL_DXGIGetOutputInfo( int displayIndex, int *adapterIndex, int *outputIndex );

#line 77 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"











#line 89 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"






















































#line 144 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"






























































#line 207 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"



}
#line 212 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 213 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"

#line 215 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_system.h"


#line 55 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"

#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_timer.h"

































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 35 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_timer.h"


extern "C" {
#line 39 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_timer.h"






extern __declspec(dllexport) Uint32 __cdecl SDL_GetTicks(void);















extern __declspec(dllexport) Uint64 __cdecl SDL_GetPerformanceCounter(void);




extern __declspec(dllexport) Uint64 __cdecl SDL_GetPerformanceFrequency(void);




extern __declspec(dllexport) void __cdecl SDL_Delay(Uint32 ms);









typedef Uint32 (__cdecl * SDL_TimerCallback) (Uint32 interval, void *param);




typedef int SDL_TimerID;






extern __declspec(dllexport) SDL_TimerID __cdecl SDL_AddTimer(Uint32 interval,
                                                 SDL_TimerCallback callback,
                                                 void *param);








extern __declspec(dllexport) SDL_bool __cdecl SDL_RemoveTimer(SDL_TimerID id);




}
#line 111 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_timer.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 112 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_timer.h"

#line 114 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_timer.h"


#line 57 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_version.h"
































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 34 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_version.h"


extern "C" {
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_version.h"













typedef struct SDL_version
{
    Uint8 major;        
    Uint8 minor;        
    Uint8 patch;        
} SDL_version;












































































extern __declspec(dllexport) void __cdecl SDL_GetVersion(SDL_version * ver);








extern __declspec(dllexport) const char *__cdecl SDL_GetRevision(void);








extern __declspec(dllexport) int __cdecl SDL_GetRevisionNumber(void);




}
#line 158 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_version.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 159 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_version.h"

#line 161 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\SDL_version.h"


#line 58 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"


#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 61 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"


extern "C" {
#line 65 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"



























extern __declspec(dllexport) int __cdecl SDL_Init(Uint32 flags);










extern __declspec(dllexport) int __cdecl SDL_InitSubSystem(Uint32 flags);




extern __declspec(dllexport) void __cdecl SDL_QuitSubSystem(Uint32 flags);







extern __declspec(dllexport) Uint32 __cdecl SDL_WasInit(Uint32 flags);





extern __declspec(dllexport) void __cdecl SDL_Quit(void);



}
#line 128 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 129 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"

#line 131 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL.h"


#line 16 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"


#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"



































#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"






























































































#pragma warning(disable: 4103)
#line 97 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"





#pragma pack(push,8)


#line 106 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 107 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"







































#line 147 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\begin_code.h"
#line 37 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"


extern "C" {
#line 41 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"


















#line 60 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"



#line 64 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"
















#line 81 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"



#line 85 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"







#line 93 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"









#line 103 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"




#line 108 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"



#line 112 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"




typedef enum
{
    SDL_SYSWM_UNKNOWN,
    SDL_SYSWM_WINDOWS,
    SDL_SYSWM_X11,
    SDL_SYSWM_DIRECTFB,
    SDL_SYSWM_COCOA,
    SDL_SYSWM_UIKIT,
    SDL_SYSWM_WAYLAND,
    SDL_SYSWM_MIR,
    SDL_SYSWM_WINRT,
    SDL_SYSWM_ANDROID,
    SDL_SYSWM_VIVANTE
} SDL_SYSWM_TYPE;




struct SDL_SysWMmsg
{
    SDL_version version;
    SDL_SYSWM_TYPE subsystem;
    union
    {

        struct {
            HWND hwnd;                  
            UINT msg;                   
            WPARAM wParam;              
            LPARAM lParam;              
        } win;
#line 148 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"




#line 153 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"




#line 158 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"









#line 168 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"






#line 175 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"






#line 182 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"
        
        int dummy;
    } msg;
};







struct SDL_SysWMinfo
{
    SDL_version version;
    SDL_SYSWM_TYPE subsystem;
    union
    {

        struct
        {
            HWND window;                
            HDC hdc;                    
        } win;
#line 206 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"





#line 212 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"






#line 219 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"







#line 227 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"









#line 237 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"












#line 250 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"







#line 258 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"






#line 265 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"







#line 273 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"







#line 281 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"

        
        int dummy;
    } info;
};

#line 288 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"

typedef struct SDL_SysWMinfo SDL_SysWMinfo;



















extern __declspec(dllexport) SDL_bool __cdecl SDL_GetWindowWMInfo(SDL_Window * window,
                                                     SDL_SysWMinfo * info);




}
#line 317 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"
#line 1 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"



































#pragma pack(pop)
#line 38 "i:\\dev\\motors\\pikkumoottori\\deps\\include\\sdl2\\close_code.h"
#line 318 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"

#line 320 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\SDL2/SDL_syswm.h"


#line 19 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
#line 20 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"






#line 27 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"



static double       g_Time = 0.0f;
static bool         g_MousePressed[3] = { false, false, false };
static float        g_MouseWheel = 0.0f;
static GLuint       g_FontTexture = 0;
static int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;
static int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;
static int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;
static unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;




void ImGui_ImplSdlGL3_RenderDrawLists(ImDrawData* draw_data)
{
    
    ImGuiIO& io = ImGui::GetIO();
    int fb_width = (int)(io.DisplaySize.x * io.DisplayFramebufferScale.x);
    int fb_height = (int)(io.DisplaySize.y * io.DisplayFramebufferScale.y);
    if (fb_width == 0 || fb_height == 0)
        return;
    draw_data->ScaleClipRects(io.DisplayFramebufferScale);

    
    GLenum last_active_texture; glad_glGetIntegerv(0x84E0, (GLint*)&last_active_texture);
    glad_glActiveTexture(0x84C0);
    GLint last_program; glad_glGetIntegerv(0x8B8D, &last_program);
    GLint last_texture; glad_glGetIntegerv(0x8069, &last_texture);


    GLint last_sampler; glad_glGetIntegerv(0x8919, &last_sampler);
    GLint last_array_buffer; glad_glGetIntegerv(0x8894, &last_array_buffer);
    GLint last_element_array_buffer; glad_glGetIntegerv(0x8895, &last_element_array_buffer);
    GLint last_vertex_array; glad_glGetIntegerv(0x85B5, &last_vertex_array);
    GLint last_polygon_mode[2]; glad_glGetIntegerv(0x0B40, last_polygon_mode);
#line 65 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    GLint last_viewport[4]; glad_glGetIntegerv(0x0BA2, last_viewport);
    GLint last_scissor_box[4]; glad_glGetIntegerv(0x0C10, last_scissor_box);
    GLenum last_blend_src_rgb; glad_glGetIntegerv(0x80C9, (GLint*)&last_blend_src_rgb);
    GLenum last_blend_dst_rgb; glad_glGetIntegerv(0x80C8, (GLint*)&last_blend_dst_rgb);
    GLenum last_blend_src_alpha; glad_glGetIntegerv(0x80CB, (GLint*)&last_blend_src_alpha);
    GLenum last_blend_dst_alpha; glad_glGetIntegerv(0x80CA, (GLint*)&last_blend_dst_alpha);
    GLenum last_blend_equation_rgb; glad_glGetIntegerv(0x8009, (GLint*)&last_blend_equation_rgb);
    GLenum last_blend_equation_alpha; glad_glGetIntegerv(0x883D, (GLint*)&last_blend_equation_alpha);
    GLboolean last_enable_blend = glad_glIsEnabled(0x0BE2);
    GLboolean last_enable_cull_face = glad_glIsEnabled(0x0B44);
    GLboolean last_enable_depth_test = glad_glIsEnabled(0x0B71);
    GLboolean last_enable_scissor_test = glad_glIsEnabled(0x0C11);

    
    glad_glEnable(0x0BE2);
    glad_glBlendEquation(0x8006);
    glad_glBlendFunc(0x0302, 0x0303);
    glad_glDisable(0x0B44);

    glad_glDisable(0x0B71);
#line 86 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    glad_glEnable(0x0C11);

    glad_glPolygonMode(0x0408, 0x1B02);
#line 90 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"

    
    glad_glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);
    const float ortho_projection[4][4] =
    {
        { 2.0f/io.DisplaySize.x, 0.0f,                   0.0f, 0.0f },
        { 0.0f,                  2.0f/-io.DisplaySize.y, 0.0f, 0.0f },
        { 0.0f,                  0.0f,                  -1.0f, 0.0f },
        {-1.0f,                  1.0f,                   0.0f, 1.0f },
    };
    glad_glUseProgram(g_ShaderHandle);
    glad_glUniform1i(g_AttribLocationTex, 0);
    glad_glUniformMatrix4fv(g_AttribLocationProjMtx, 1, 0, &ortho_projection[0][0]);

    glad_glBindVertexArray(g_VaoHandle);
    glad_glBindSampler(0, 0); 


#line 109 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"

    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        const ImDrawIdx* idx_buffer_offset = 0;

        glad_glBindBuffer(0x8892, g_VboHandle);
        glad_glBufferData(0x8892, (GLsizeiptr)cmd_list->VtxBuffer.Size * sizeof(ImDrawVert), (const GLvoid*)cmd_list->VtxBuffer.Data, 0x88E0);

        glad_glBindBuffer(0x8893, g_ElementsHandle);
        glad_glBufferData(0x8893, (GLsizeiptr)cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx), (const GLvoid*)cmd_list->IdxBuffer.Data, 0x88E0);

        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                glad_glBindTexture(0x0DE1, (GLuint)(intptr_t)pcmd->TextureId);
                glad_glScissor((int)pcmd->ClipRect.x, (int)(fb_height - pcmd->ClipRect.w), (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));
                glad_glDrawElements(0x0004, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? 0x1403 : 0x1405, idx_buffer_offset);
            }
            idx_buffer_offset += pcmd->ElemCount;
        }
    }

    
    glad_glUseProgram(last_program);
    glad_glBindTexture(0x0DE1, last_texture);

    glad_glBindSampler(0, last_sampler);
#line 144 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    glad_glActiveTexture(last_active_texture);

    glad_glBindVertexArray(last_vertex_array);
    glad_glBindBuffer(0x8892, last_array_buffer);
    glad_glBindBuffer(0x8893, last_element_array_buffer);
#line 150 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    glad_glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
    glad_glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
    if (last_enable_blend) glad_glEnable(0x0BE2); else glad_glDisable(0x0BE2);
    if (last_enable_cull_face) glad_glEnable(0x0B44); else glad_glDisable(0x0B44);
    if (last_enable_depth_test) glad_glEnable(0x0B71); else glad_glDisable(0x0B71);
    if (last_enable_scissor_test) glad_glEnable(0x0C11); else glad_glDisable(0x0C11);

    glad_glPolygonMode(0x0408, last_polygon_mode[0]);
#line 159 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    glad_glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
    glad_glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
}

static const char* ImGui_ImplSdlGL3_GetClipboardText(void*)
{
    return SDL_GetClipboardText();
}

static void ImGui_ImplSdlGL3_SetClipboardText(void*, const char* text)
{
    SDL_SetClipboardText(text);
}





bool ImGui_ImplSdlGL3_ProcessEvent(SDL_Event* event)
{
    ImGuiIO& io = ImGui::GetIO();
    switch (event->type)
    {
    case SDL_MOUSEWHEEL:
        {
            if (event->wheel.y > 0)
                g_MouseWheel = 1;
            if (event->wheel.y < 0)
                g_MouseWheel = -1;
            return true;
        }
    case SDL_MOUSEBUTTONDOWN:
        {
            if (event->button.button == 1) g_MousePressed[0] = true;
            if (event->button.button == 3) g_MousePressed[1] = true;
            if (event->button.button == 2) g_MousePressed[2] = true;
            return true;
        }
    case SDL_TEXTINPUT:
        {
            io.AddInputCharactersUTF8(event->text.text);
            return true;
        }
    case SDL_KEYDOWN:
    case SDL_KEYUP:
        {
            int key = event->key.keysym.sym & ~(1<<30);
            io.KeysDown[key] = (event->type == SDL_KEYDOWN);
            io.KeyShift = ((SDL_GetModState() & (KMOD_LSHIFT|KMOD_RSHIFT)) != 0);
            io.KeyCtrl = ((SDL_GetModState() & (KMOD_LCTRL|KMOD_RCTRL)) != 0);
            io.KeyAlt = ((SDL_GetModState() & (KMOD_LALT|KMOD_RALT)) != 0);
            io.KeySuper = ((SDL_GetModState() & (KMOD_LGUI|KMOD_RGUI)) != 0);
            return true;
        }
    }
    return false;
}

void ImGui_ImplSdlGL3_CreateFontsTexture()
{
    
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   

    
    GLint last_texture;
    glad_glGetIntegerv(0x8069, &last_texture);
    glad_glGenTextures(1, &g_FontTexture);
    glad_glBindTexture(0x0DE1, g_FontTexture);
    glad_glTexParameteri(0x0DE1, 0x2801, 0x2601);
    glad_glTexParameteri(0x0DE1, 0x2800, 0x2601);

    glad_glPixelStorei(0x0CF2, 0);

#line 236 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    glad_glTexImage2D(0x0DE1, 0, 0x1908, width, height, 0, 0x1908, 0x1401, pixels);

    
    io.Fonts->TexID = (void *)(intptr_t)g_FontTexture;

    
    glad_glBindTexture(0x0DE1, last_texture);
}

bool ImGui_ImplSdlGL3_CreateDeviceObjects()
{
    
    GLint last_texture, last_array_buffer, last_vertex_array;
    glad_glGetIntegerv(0x8069, &last_texture);

    glad_glGetIntegerv(0x8894, &last_array_buffer);
    glad_glGetIntegerv(0x85B5, &last_vertex_array);
#line 254 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"


    const GLchar *vertex_shader =
        "#version 330\n"
        "uniform mat4 ProjMtx;\n"
        "in vec2 Position;\n"
        "in vec2 UV;\n"
        "in vec4 Color;\n"
        "out vec2 Frag_UV;\n"
        "out vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "	Frag_UV = UV;\n"
        "	Frag_Color = Color;\n"
        "	gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* fragment_shader =
        "#version 330\n"
        "uniform sampler2D Texture;\n"
        "in vec2 Frag_UV;\n"
        "in vec4 Frag_Color;\n"
        "out vec4 Out_Color;\n"
        "void main()\n"
        "{\n"
        "	Out_Color = Frag_Color * texture( Texture, Frag_UV.st);\n"
        "}\n";



























#line 309 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"

    g_ShaderHandle = glad_glCreateProgram();
    g_VertHandle = glad_glCreateShader(0x8B31);
    g_FragHandle = glad_glCreateShader(0x8B30);
    glad_glShaderSource(g_VertHandle, 1, &vertex_shader, 0);
    glad_glShaderSource(g_FragHandle, 1, &fragment_shader, 0);
    glad_glCompileShader(g_VertHandle);
    glad_glCompileShader(g_FragHandle);
    glad_glAttachShader(g_ShaderHandle, g_VertHandle);
    glad_glAttachShader(g_ShaderHandle, g_FragHandle);
    glad_glLinkProgram(g_ShaderHandle);

    g_AttribLocationTex = glad_glGetUniformLocation(g_ShaderHandle, "Texture");
    g_AttribLocationProjMtx = glad_glGetUniformLocation(g_ShaderHandle, "ProjMtx");
    g_AttribLocationPosition = glad_glGetAttribLocation(g_ShaderHandle, "Position");
    g_AttribLocationUV = glad_glGetAttribLocation(g_ShaderHandle, "UV");
    g_AttribLocationColor = glad_glGetAttribLocation(g_ShaderHandle, "Color");

    glad_glGenBuffers(1, &g_VboHandle);
    glad_glGenBuffers(1, &g_ElementsHandle);


    glad_glGenVertexArrays(1, &g_VaoHandle);
    glad_glBindVertexArray(g_VaoHandle);



#line 337 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    glad_glBindBuffer(0x8892, g_VboHandle);
    glad_glEnableVertexAttribArray(g_AttribLocationPosition);
    glad_glEnableVertexAttribArray(g_AttribLocationUV);
    glad_glEnableVertexAttribArray(g_AttribLocationColor);


    glad_glVertexAttribPointer(g_AttribLocationPosition, 2, 0x1406, 0, sizeof(ImDrawVert), (GLvoid*)((size_t)&(((ImDrawVert *)0)->pos)));
    glad_glVertexAttribPointer(g_AttribLocationUV, 2, 0x1406, 0, sizeof(ImDrawVert), (GLvoid*)((size_t)&(((ImDrawVert *)0)->uv)));
    glad_glVertexAttribPointer(g_AttribLocationColor, 4, 0x1401, 1, sizeof(ImDrawVert), (GLvoid*)((size_t)&(((ImDrawVert *)0)->col)));


    ImGui_ImplSdlGL3_CreateFontsTexture();

    
    glad_glBindTexture(0x0DE1, last_texture);
    glad_glBindBuffer(0x8892, last_array_buffer);
    glad_glBindVertexArray(last_vertex_array);

    glad_glGetError();
    glad_glGetError();
    return true;
}

void    ImGui_ImplSdlGL3_InvalidateDeviceObjects()
{

    if (g_VaoHandle) glad_glDeleteVertexArrays(1, &g_VaoHandle);


#line 367 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"
    if (g_VboHandle) glad_glDeleteBuffers(1, &g_VboHandle);
    if (g_ElementsHandle) glad_glDeleteBuffers(1, &g_ElementsHandle);
    g_VaoHandle = g_VboHandle = g_ElementsHandle = 0;

    if (g_ShaderHandle && g_VertHandle) glad_glDetachShader(g_ShaderHandle, g_VertHandle);
    if (g_VertHandle) glad_glDeleteShader(g_VertHandle);
    g_VertHandle = 0;

    if (g_ShaderHandle && g_FragHandle) glad_glDetachShader(g_ShaderHandle, g_FragHandle);
    if (g_FragHandle) glad_glDeleteShader(g_FragHandle);
    g_FragHandle = 0;

    if (g_ShaderHandle) glad_glDeleteProgram(g_ShaderHandle);
    g_ShaderHandle = 0;

    if (g_FontTexture)
    {
        glad_glDeleteTextures(1, &g_FontTexture);
        ImGui::GetIO().Fonts->TexID = 0;
        g_FontTexture = 0;
    }
}

bool    ImGui_ImplSdlGL3_Init(SDL_Window* window)
{
    ImGuiIO& io = ImGui::GetIO();
    io.KeyMap[ImGuiKey_Tab] = SDLK_TAB;                     
    io.KeyMap[ImGuiKey_LeftArrow] = SDL_SCANCODE_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = SDL_SCANCODE_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = SDL_SCANCODE_UP;
    io.KeyMap[ImGuiKey_DownArrow] = SDL_SCANCODE_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = SDL_SCANCODE_PAGEUP;
    io.KeyMap[ImGuiKey_PageDown] = SDL_SCANCODE_PAGEDOWN;
    io.KeyMap[ImGuiKey_Home] = SDL_SCANCODE_HOME;
    io.KeyMap[ImGuiKey_End] = SDL_SCANCODE_END;
    io.KeyMap[ImGuiKey_Delete] = SDLK_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = SDLK_BACKSPACE;
    io.KeyMap[ImGuiKey_Enter] = SDLK_RETURN;
    io.KeyMap[ImGuiKey_Escape] = SDLK_ESCAPE;
    io.KeyMap[ImGuiKey_A] = SDLK_a;
    io.KeyMap[ImGuiKey_C] = SDLK_c;
    io.KeyMap[ImGuiKey_V] = SDLK_v;
    io.KeyMap[ImGuiKey_X] = SDLK_x;
    io.KeyMap[ImGuiKey_Y] = SDLK_y;
    io.KeyMap[ImGuiKey_Z] = SDLK_z;

    io.RenderDrawListsFn = ImGui_ImplSdlGL3_RenderDrawLists;   
    io.SetClipboardTextFn = ImGui_ImplSdlGL3_SetClipboardText;
    io.GetClipboardTextFn = ImGui_ImplSdlGL3_GetClipboardText;
    io.ClipboardUserData = 0;


    SDL_SysWMinfo wmInfo;
    { (&wmInfo.version)->major = 2; (&wmInfo.version)->minor = 0; (&wmInfo.version)->patch = 5; };
    SDL_GetWindowWMInfo(window, &wmInfo);
    io.ImeWindowHandle = wmInfo.info.win.window;


#line 426 "i:\\dev\\motors\\pikkumoottori\\src\\graphics\\../Imgui/imgui_impl_sdl_gl3.cpp"

    return true;
}

void ImGui_ImplSdlGL3_Shutdown()
{
    ImGui_ImplSdlGL3_InvalidateDeviceObjects();
    ImGui::Shutdown();
}

void ImGui_ImplSdlGL3_NewFrame(SDL_Window* window)
{
    if (!g_FontTexture)
        ImGui_ImplSdlGL3_CreateDeviceObjects();

    ImGuiIO& io = ImGui::GetIO();

    
    int w, h;
    int display_w, display_h;
    SDL_GetWindowSize(window, &w, &h);
    SDL_GL_GetDrawableSize(window, &display_w, &display_h);
    io.DisplaySize = ImVec2((float)w, (float)h);
    io.DisplayFramebufferScale = ImVec2(w > 0 ? ((float)display_w / w) : 0, h > 0 ? ((float)display_h / h) : 0);

    
    Uint32	time = SDL_GetTicks();
    double current_time = time / 1000.0;
    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f / 60.0f);
    g_Time = current_time;

    
    
    int mx, my;
    Uint32 mouseMask = SDL_GetMouseState(&mx, &my);
    if (SDL_GetWindowFlags(window) & SDL_WINDOW_MOUSE_FOCUS)
        io.MousePos = ImVec2((float)mx, (float)my);   
    else
        io.MousePos = ImVec2(-3.402823466e+38F, -3.402823466e+38F);

    io.MouseDown[0] = g_MousePressed[0] || (mouseMask & (1 << ((1)-1))) != 0;		
    io.MouseDown[1] = g_MousePressed[1] || (mouseMask & (1 << ((3)-1))) != 0;
    io.MouseDown[2] = g_MousePressed[2] || (mouseMask & (1 << ((2)-1))) != 0;
    g_MousePressed[0] = g_MousePressed[1] = g_MousePressed[2] = false;

    io.MouseWheel = g_MouseWheel;
    g_MouseWheel = 0.0f;

    
    SDL_ShowCursor(io.MouseDrawCursor ? 0 : 1);

    
    ImGui::NewFrame();
}
#line 14 "..\\src\\graphics\\graphics.cpp"


#line 1 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

















































































































































































































































































































#line 307 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



enum
{
   STBI_default = 0, 

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;


extern "C" {
#line 326 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





#line 332 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"










typedef struct
{
   int      (*read)  (void *user,char *data,int size);   
   void     (*skip)  (void *user,int n);                 
   int      (*eof)   (void *user);                       
} stbi_io_callbacks;






extern stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);


extern stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);

#line 362 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"






extern stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);


extern stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
extern stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#line 375 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"






   extern float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   extern float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   
   extern float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   extern float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #line 388 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
#line 389 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


   extern void   stbi_hdr_to_ldr_gamma(float gamma);
   extern void   stbi_hdr_to_ldr_scale(float scale);
#line 394 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


   extern void   stbi_ldr_to_hdr_gamma(float gamma);
   extern void   stbi_ldr_to_hdr_scale(float scale);
#line 399 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


extern int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
extern int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);

extern int      stbi_is_hdr          (char const *filename);
extern int      stbi_is_hdr_from_file(FILE *f);
#line 407 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"




extern const char *stbi_failure_reason  (void);


extern void     stbi_image_free      (void *retval_from_stbi_load);


extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);


extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);

#line 425 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"






extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);



extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);


extern void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);



extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
extern char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);



}
#line 454 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"




#line 459 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"































#line 494 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



#line 498 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"









#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\math.h"















#line 508 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
#line 509 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



#line 513 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


#line 1 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"









#line 11 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "E:\\sdk\\include\\10.0.16299.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 516 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

#line 518 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"









   
#line 529 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;






#line 543 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];





#line 552 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



#line 556 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


   


#line 562 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



#line 566 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



#line 570 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





#line 576 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



#line 580 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"






#line 587 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"










#line 598 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"














#line 613 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"









static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}











#line 640 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}










#line 659 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
#line 660 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"




#line 665 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

















typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);


static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = 0;
   s->read_from_callbacks = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}


static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}



static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   fseek((FILE*) user, n, 1);
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}



#line 754 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

static void stbi__rewind(stbi__context *s)
{
   
   
   
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;


static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#line 782 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
#line 788 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#line 794 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#line 800 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
#line 806 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#line 812 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#line 818 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#line 824 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#line 830 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static const char *stbi__g_failure_reason;

extern const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}

static void *stbi__malloc(size_t size)
{
    return malloc(size);
}













static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   
   
   
   
   return a <= 2147483647 - b;
}



static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; 
   
   return a <= 2147483647/b;
}


static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}


static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}


static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}


static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return 0;
   return stbi__malloc(a*b + add);
}

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return 0;
   return stbi__malloc(a*b*c + add);
}

static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return 0;
   return stbi__malloc(a*b*c*d + add);
}









#line 930 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
#line 932 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"




extern void stbi_image_free(void *retval_from_stbi_load)
{
   free(retval_from_stbi_load);
}


static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#line 944 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#line 948 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

static int stbi__vertically_flip_on_load = 0;

extern void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
    stbi__vertically_flip_on_load = flag_true_if_should_flip;
}

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); 
   ri->bits_per_channel = 8; 
   ri->channel_order = STBI_ORDER_RGB; 
   ri->num_channels = 0;

   
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #line 966 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #line 969 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #line 972 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #line 975 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #line 978 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #line 981 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #line 984 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #line 991 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #line 997 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   return ((unsigned char *)(size_t) (stbi__err("unknown image type")?0:0));
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == 0) return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); 

   free(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == 0) return (stbi__uint16 *) ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); 

   free(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == 0)
      return 0;

   if (ri.bits_per_channel != 8) {
      (void)( (!!(ri.bits_per_channel == 16)) || (_wassert(L"ri.bits_per_channel == 16", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1066)), 0) );
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == 0)
      return 0;

   if (ri.bits_per_channel != 16) {
      (void)( (!!(ri.bits_per_channel == 8)) || (_wassert(L"ri.bits_per_channel == 8", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1090)), 0) );
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   
   

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}


static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != 0) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#line 1115 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;

   if (0 != fopen_s(&f, filename, mode))
      f=0;


#line 1127 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   return f;
}


extern stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return ((unsigned char *)(size_t) (stbi__err("can't fopen")?0:0));
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

extern stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), 1);
   }
   return result;
}

extern stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), 1);
   }
   return result;
}

extern stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) ((unsigned char *)(size_t) (stbi__err("can't fopen")?0:0));
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#line 1179 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

extern stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

extern stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

extern stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}


static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #line 1221 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return ((float *)(size_t) (stbi__err("unknown image type")?0:0));
}

extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

extern float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}


extern float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return ((float *)(size_t) (stbi__err("can't fopen")?0:0));
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

extern float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#line 1259 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

#line 1261 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





extern int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   



#line 1277 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
}


extern int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

extern int      stbi_is_hdr_from_file(FILE *f)
{
   
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__hdr_test(&s);
   


#line 1301 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
}
#line 1303 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

extern int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   



#line 1315 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
}


static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

extern void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
extern void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#line 1323 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

extern void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
extern void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }







enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   if (n == 0) {
      
      
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

__forceinline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

__forceinline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      
      
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}

static void stbi__skip(stbi__context *s, int n)
{
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}

static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}

static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}

static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}



#line 1437 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#line 1443 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   return z + (stbi__get16le(s) << 16);
}
#line 1451 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"















static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   (void)( (!!(req_comp >= 1 && req_comp <= 4)) || (_wassert(L"req_comp >= 1 && req_comp <= 4", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1477)), 0) );

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == 0) {
      free(data);
      return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      
      
      
      
      switch (((img_n)*8+(req_comp))) {
         case ((1)*8+(2)): for(i=x-1; i >= 0; --i, src += 1, dest += 2) { dest[0]=src[0], dest[1]=255;                                     } break;
         case ((1)*8+(3)): for(i=x-1; i >= 0; --i, src += 1, dest += 3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         case ((1)*8+(4)): for(i=x-1; i >= 0; --i, src += 1, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=255;                     } break;
         case ((2)*8+(1)): for(i=x-1; i >= 0; --i, src += 2, dest += 1) { dest[0]=src[0];                                                  } break;
         case ((2)*8+(3)): for(i=x-1; i >= 0; --i, src += 2, dest += 3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         case ((2)*8+(4)): for(i=x-1; i >= 0; --i, src += 2, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                  } break;
         case ((3)*8+(4)): for(i=x-1; i >= 0; --i, src += 3, dest += 4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255;        } break;
         case ((3)*8+(1)): for(i=x-1; i >= 0; --i, src += 3, dest += 1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         case ((3)*8+(2)): for(i=x-1; i >= 0; --i, src += 3, dest += 2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255;    } break;
         case ((4)*8+(1)): for(i=x-1; i >= 0; --i, src += 4, dest += 1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         case ((4)*8+(2)): for(i=x-1; i >= 0; --i, src += 4, dest += 2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; } break;
         case ((4)*8+(3)): for(i=x-1; i >= 0; --i, src += 4, dest += 3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                    } break;
         default: (void)( (!!(0)) || (_wassert(L"0", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1506)), 0) );
      }
      
   }

   free(data);
   return good;
}

static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   (void)( (!!(req_comp >= 1 && req_comp <= 4)) || (_wassert(L"req_comp >= 1 && req_comp <= 4", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1526)), 0) );

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == 0) {
      free(data);
      return (stbi__uint16 *) ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      
      
      
      
      switch (((img_n)*8+(req_comp))) {
         case ((1)*8+(2)): for(i=x-1; i >= 0; --i, src += 1, dest += 2) { dest[0]=src[0], dest[1]=0xffff;                                     } break;
         case ((1)*8+(3)): for(i=x-1; i >= 0; --i, src += 1, dest += 3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         case ((1)*8+(4)): for(i=x-1; i >= 0; --i, src += 1, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=0xffff;                     } break;
         case ((2)*8+(1)): for(i=x-1; i >= 0; --i, src += 2, dest += 1) { dest[0]=src[0];                                                     } break;
         case ((2)*8+(3)): for(i=x-1; i >= 0; --i, src += 2, dest += 3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         case ((2)*8+(4)): for(i=x-1; i >= 0; --i, src += 2, dest += 4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                     } break;
         case ((3)*8+(4)): for(i=x-1; i >= 0; --i, src += 3, dest += 4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=0xffff;        } break;
         case ((3)*8+(1)): for(i=x-1; i >= 0; --i, src += 3, dest += 1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         case ((3)*8+(2)): for(i=x-1; i >= 0; --i, src += 3, dest += 2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = 0xffff; } break;
         case ((4)*8+(1)): for(i=x-1; i >= 0; --i, src += 4, dest += 1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         case ((4)*8+(2)): for(i=x-1; i >= 0; --i, src += 4, dest += 2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = src[3]; } break;
         case ((4)*8+(3)): for(i=x-1; i >= 0; --i, src += 4, dest += 3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                       } break;
         default: (void)( (!!(0)) || (_wassert(L"0", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1555)), 0) );
      }
      
   }

   free(data);
   return good;
}


static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return 0;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == 0) { free(data); return ((float *)(size_t) (stbi__err("outofmem")?0:0)); }
   
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
   }
   free(data);
   return output;
}
#line 1584 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return 0;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == 0) { free(data); return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0)); }
   
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) ((int) (z));
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) ((int) (z));
      }
   }
   free(data);
   return output;
}
#line 1614 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



























typedef struct
{
   stbi_uc  fast[1 << 9];
   
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << 9];


   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;


   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   
      int      coeff_w, coeff_h; 
   } img_comp[4];

   stbi__uint32   code_buffer; 
   int            code_bits;   
   unsigned char  marker;      
   int            nomore;      

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; 
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;


   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0,code;
   
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1 << j)) return stbi__err("bad code lengths");
      }
      
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   
   memset(h->fast, 255, 1 << 9);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= 9) {
         int c = h->code[i] << (9-s);
         int m = 1 << (9-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}



static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << 9); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= 9) {
            
            int k = ((i << len) & ((1 << 9) - 1)) >> (9 - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); 
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}


static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};


__forceinline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   
   
   c = (j->code_buffer >> (32 - 9)) & ((1 << 9)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   
   
   
   
   
   
   temp = j->code_buffer >> 16;
   for (k=9+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   (void)( (!!((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c])) || (_wassert(L"(((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1837)), 0) );

   
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}


static int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};



__forceinline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = (stbi__int32)j->code_buffer >> 31; 
   k = _lrotl(j->code_buffer,n);
   (void)( (!!(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)))) || (_wassert(L"n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask))", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(1858)), 0) );
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & ~sgn);
}


__forceinline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = _lrotl(j->code_buffer,n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

__forceinline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}



static stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};


static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0) return stbi__err("bad huffman code");

   
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - 9)) & ((1 << 9)-1);
      r = fac[c];
      if (r) { 
         k += (r >> 4) & 15; 
         s = r & 15; 
         j->code_buffer <<= s;
         j->code_bits -= s;
         
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; 
            k += 16;
         } else {
            k += r;
            
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      
      memset(data,0,64*sizeof(data[0])); 
      t = stbi__jpeg_huff_decode(j, hdc);
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc << j->succ_low);
   } else {
      
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}



static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - 9)) & ((1 << 9)-1);
         r = fac[c];
         if (r) { 
            k += (r >> 4) & 15; 
            s = r & 15; 
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) << shift);
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) << shift);
            }
         }
      } while (k <= j->spec_end);
   } else {
      

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); 
            if (rs < 0) return stbi__err("bad huffman code");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; 
               } else {
                  
                  
                  
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code");
               
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}


__forceinline static stbi_uc stbi__clamp(int x)
{
   
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}










































static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   
   for (i=0; i < 8; ++i,++d, ++v) {
      
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         
         
         
         
         int dcterm = d[0] << 2;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; p2 = d[16]; p3 = d[48]; p1 = (p2+p3) * ((int) (((0.5411961f) * 4096 + 0.5))); t2 = p1 + p3*((int) (((-1.847759065f) * 4096 + 0.5))); t3 = p1 + p2*((int) (((0.765366865f) * 4096 + 0.5))); p2 = d[ 0]; p3 = d[32]; t0 = ((p2+p3) << 12); t1 = ((p2-p3) << 12); x0 = t0+t3; x3 = t0-t3; x1 = t1+t2; x2 = t1-t2; t0 = d[56]; t1 = d[40]; t2 = d[24]; t3 = d[ 8]; p3 = t0+t2; p4 = t1+t3; p1 = t0+t3; p2 = t1+t2; p5 = (p3+p4)*((int) (((1.175875602f) * 4096 + 0.5))); t0 = t0*((int) (((0.298631336f) * 4096 + 0.5))); t1 = t1*((int) (((2.053119869f) * 4096 + 0.5))); t2 = t2*((int) (((3.072711026f) * 4096 + 0.5))); t3 = t3*((int) (((1.501321110f) * 4096 + 0.5))); p1 = p5 + p1*((int) (((-0.899976223f) * 4096 + 0.5))); p2 = p5 + p2*((int) (((-2.562915447f) * 4096 + 0.5))); p3 = p3*((int) (((-1.961570560f) * 4096 + 0.5))); p4 = p4*((int) (((-0.390180644f) * 4096 + 0.5))); t3 += p1+p4; t2 += p2+p3; t1 += p2+p4; t0 += p1+p3;
         
         
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      
      int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; p2 = v[2]; p3 = v[6]; p1 = (p2+p3) * ((int) (((0.5411961f) * 4096 + 0.5))); t2 = p1 + p3*((int) (((-1.847759065f) * 4096 + 0.5))); t3 = p1 + p2*((int) (((0.765366865f) * 4096 + 0.5))); p2 = v[0]; p3 = v[4]; t0 = ((p2+p3) << 12); t1 = ((p2-p3) << 12); x0 = t0+t3; x3 = t0-t3; x1 = t1+t2; x2 = t1-t2; t0 = v[7]; t1 = v[5]; t2 = v[3]; t3 = v[1]; p3 = t0+t2; p4 = t1+t3; p1 = t0+t3; p2 = t1+t2; p5 = (p3+p4)*((int) (((1.175875602f) * 4096 + 0.5))); t0 = t0*((int) (((0.298631336f) * 4096 + 0.5))); t1 = t1*((int) (((2.053119869f) * 4096 + 0.5))); t2 = t2*((int) (((3.072711026f) * 4096 + 0.5))); t3 = t3*((int) (((1.501321110f) * 4096 + 0.5))); p1 = p5 + p1*((int) (((-0.899976223f) * 4096 + 0.5))); p2 = p5 + p2*((int) (((-2.562915447f) * 4096 + 0.5))); p3 = p3*((int) (((-1.961570560f) * 4096 + 0.5))); p4 = p4*((int) (((-0.390180644f) * 4096 + 0.5))); t3 += p1+p4; t2 += p2+p3; t1 += p2+p4; t0 += p1+p3;
      
      
      
      
      
      
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      
      
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}





static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   
   

   
   
   







   
   



   
   



   
   



   
   









   
   




   
   




   



























   __m128i rot0_0 = _mm_setr_epi16((((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((-1.847759065f) * 4096 + 0.5)))));
   __m128i rot0_1 = _mm_setr_epi16((((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5))) + ((int) (((0.765366865f) * 4096 + 0.5)))),(((int) (((0.5411961f) * 4096 + 0.5)))));
   __m128i rot1_0 = _mm_setr_epi16((((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-0.899976223f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))));
   __m128i rot1_1 = _mm_setr_epi16((((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5)))),(((int) (((1.175875602f) * 4096 + 0.5))) + ((int) (((-2.562915447f) * 4096 + 0.5)))));
   __m128i rot2_0 = _mm_setr_epi16((((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((0.298631336f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))));
   __m128i rot2_1 = _mm_setr_epi16((((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5)))),(((int) (((-1.961570560f) * 4096 + 0.5))) + ((int) (((3.072711026f) * 4096 + 0.5)))));
   __m128i rot3_0 = _mm_setr_epi16((((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((2.053119869f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))));
   __m128i rot3_1 = _mm_setr_epi16((((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5)))),(((int) (((-0.390180644f) * 4096 + 0.5))) + ((int) (((1.501321110f) * 4096 + 0.5)))));

   
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   
   { __m128i rot0_0lo = _mm_unpacklo_epi16((row2),(row6)); __m128i rot0_0hi = _mm_unpackhi_epi16((row2),(row6)); __m128i t2e_l = _mm_madd_epi16(rot0_0lo, rot0_0); __m128i t2e_h = _mm_madd_epi16(rot0_0hi, rot0_0); __m128i t3e_l = _mm_madd_epi16(rot0_0lo, rot0_1); __m128i t3e_h = _mm_madd_epi16(rot0_0hi, rot0_1); __m128i sum04 = _mm_add_epi16(row0, row4); __m128i dif04 = _mm_sub_epi16(row0, row4); __m128i t0e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t0e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t1e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i t1e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i x0_l = _mm_add_epi32(t0e_l, t3e_l); __m128i x0_h = _mm_add_epi32(t0e_h, t3e_h); __m128i x3_l = _mm_sub_epi32(t0e_l, t3e_l); __m128i x3_h = _mm_sub_epi32(t0e_h, t3e_h); __m128i x1_l = _mm_add_epi32(t1e_l, t2e_l); __m128i x1_h = _mm_add_epi32(t1e_h, t2e_h); __m128i x2_l = _mm_sub_epi32(t1e_l, t2e_l); __m128i x2_h = _mm_sub_epi32(t1e_h, t2e_h); __m128i rot2_0lo = _mm_unpacklo_epi16((row7),(row3)); __m128i rot2_0hi = _mm_unpackhi_epi16((row7),(row3)); __m128i y0o_l = _mm_madd_epi16(rot2_0lo, rot2_0); __m128i y0o_h = _mm_madd_epi16(rot2_0hi, rot2_0); __m128i y2o_l = _mm_madd_epi16(rot2_0lo, rot2_1); __m128i y2o_h = _mm_madd_epi16(rot2_0hi, rot2_1); __m128i rot3_0lo = _mm_unpacklo_epi16((row5),(row1)); __m128i rot3_0hi = _mm_unpackhi_epi16((row5),(row1)); __m128i y1o_l = _mm_madd_epi16(rot3_0lo, rot3_0); __m128i y1o_h = _mm_madd_epi16(rot3_0hi, rot3_0); __m128i y3o_l = _mm_madd_epi16(rot3_0lo, rot3_1); __m128i y3o_h = _mm_madd_epi16(rot3_0hi, rot3_1); __m128i sum17 = _mm_add_epi16(row1, row7); __m128i sum35 = _mm_add_epi16(row3, row5); __m128i rot1_0lo = _mm_unpacklo_epi16((sum17),(sum35)); __m128i rot1_0hi = _mm_unpackhi_epi16((sum17),(sum35)); __m128i y4o_l = _mm_madd_epi16(rot1_0lo, rot1_0); __m128i y4o_h = _mm_madd_epi16(rot1_0hi, rot1_0); __m128i y5o_l = _mm_madd_epi16(rot1_0lo, rot1_1); __m128i y5o_h = _mm_madd_epi16(rot1_0hi, rot1_1); __m128i x4_l = _mm_add_epi32(y0o_l, y4o_l); __m128i x4_h = _mm_add_epi32(y0o_h, y4o_h); __m128i x5_l = _mm_add_epi32(y1o_l, y5o_l); __m128i x5_h = _mm_add_epi32(y1o_h, y5o_h); __m128i x6_l = _mm_add_epi32(y2o_l, y5o_l); __m128i x6_h = _mm_add_epi32(y2o_h, y5o_h); __m128i x7_l = _mm_add_epi32(y3o_l, y4o_l); __m128i x7_h = _mm_add_epi32(y3o_h, y4o_h); { __m128i abiased_l = _mm_add_epi32(x0_l, bias_0); __m128i abiased_h = _mm_add_epi32(x0_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x7_l); __m128i sum_h = _mm_add_epi32(abiased_h, x7_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x7_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x7_h); row0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row7 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; { __m128i abiased_l = _mm_add_epi32(x1_l, bias_0); __m128i abiased_h = _mm_add_epi32(x1_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x6_l); __m128i sum_h = _mm_add_epi32(abiased_h, x6_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x6_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x6_h); row1 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row6 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; { __m128i abiased_l = _mm_add_epi32(x2_l, bias_0); __m128i abiased_h = _mm_add_epi32(x2_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x5_l); __m128i sum_h = _mm_add_epi32(abiased_h, x5_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x5_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x5_h); row2 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row5 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; { __m128i abiased_l = _mm_add_epi32(x3_l, bias_0); __m128i abiased_h = _mm_add_epi32(x3_h, bias_0); __m128i sum_l = _mm_add_epi32(abiased_l, x4_l); __m128i sum_h = _mm_add_epi32(abiased_h, x4_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x4_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x4_h); row3 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 10), _mm_srai_epi32(sum_h, 10)); row4 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 10), _mm_srai_epi32(dif_h, 10)); }; };

   {
      
      tmp = row0; row0 = _mm_unpacklo_epi16(row0, row4); row4 = _mm_unpackhi_epi16(tmp, row4);
      tmp = row1; row1 = _mm_unpacklo_epi16(row1, row5); row5 = _mm_unpackhi_epi16(tmp, row5);
      tmp = row2; row2 = _mm_unpacklo_epi16(row2, row6); row6 = _mm_unpackhi_epi16(tmp, row6);
      tmp = row3; row3 = _mm_unpacklo_epi16(row3, row7); row7 = _mm_unpackhi_epi16(tmp, row7);

      
      tmp = row0; row0 = _mm_unpacklo_epi16(row0, row2); row2 = _mm_unpackhi_epi16(tmp, row2);
      tmp = row1; row1 = _mm_unpacklo_epi16(row1, row3); row3 = _mm_unpackhi_epi16(tmp, row3);
      tmp = row4; row4 = _mm_unpacklo_epi16(row4, row6); row6 = _mm_unpackhi_epi16(tmp, row6);
      tmp = row5; row5 = _mm_unpacklo_epi16(row5, row7); row7 = _mm_unpackhi_epi16(tmp, row7);

      
      tmp = row0; row0 = _mm_unpacklo_epi16(row0, row1); row1 = _mm_unpackhi_epi16(tmp, row1);
      tmp = row2; row2 = _mm_unpacklo_epi16(row2, row3); row3 = _mm_unpackhi_epi16(tmp, row3);
      tmp = row4; row4 = _mm_unpacklo_epi16(row4, row5); row5 = _mm_unpackhi_epi16(tmp, row5);
      tmp = row6; row6 = _mm_unpacklo_epi16(row6, row7); row7 = _mm_unpackhi_epi16(tmp, row7);
   }

   
   { __m128i rot0_0lo = _mm_unpacklo_epi16((row2),(row6)); __m128i rot0_0hi = _mm_unpackhi_epi16((row2),(row6)); __m128i t2e_l = _mm_madd_epi16(rot0_0lo, rot0_0); __m128i t2e_h = _mm_madd_epi16(rot0_0hi, rot0_0); __m128i t3e_l = _mm_madd_epi16(rot0_0lo, rot0_1); __m128i t3e_h = _mm_madd_epi16(rot0_0hi, rot0_1); __m128i sum04 = _mm_add_epi16(row0, row4); __m128i dif04 = _mm_sub_epi16(row0, row4); __m128i t0e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t0e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (sum04)), 4); __m128i t1e_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i t1e_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (dif04)), 4); __m128i x0_l = _mm_add_epi32(t0e_l, t3e_l); __m128i x0_h = _mm_add_epi32(t0e_h, t3e_h); __m128i x3_l = _mm_sub_epi32(t0e_l, t3e_l); __m128i x3_h = _mm_sub_epi32(t0e_h, t3e_h); __m128i x1_l = _mm_add_epi32(t1e_l, t2e_l); __m128i x1_h = _mm_add_epi32(t1e_h, t2e_h); __m128i x2_l = _mm_sub_epi32(t1e_l, t2e_l); __m128i x2_h = _mm_sub_epi32(t1e_h, t2e_h); __m128i rot2_0lo = _mm_unpacklo_epi16((row7),(row3)); __m128i rot2_0hi = _mm_unpackhi_epi16((row7),(row3)); __m128i y0o_l = _mm_madd_epi16(rot2_0lo, rot2_0); __m128i y0o_h = _mm_madd_epi16(rot2_0hi, rot2_0); __m128i y2o_l = _mm_madd_epi16(rot2_0lo, rot2_1); __m128i y2o_h = _mm_madd_epi16(rot2_0hi, rot2_1); __m128i rot3_0lo = _mm_unpacklo_epi16((row5),(row1)); __m128i rot3_0hi = _mm_unpackhi_epi16((row5),(row1)); __m128i y1o_l = _mm_madd_epi16(rot3_0lo, rot3_0); __m128i y1o_h = _mm_madd_epi16(rot3_0hi, rot3_0); __m128i y3o_l = _mm_madd_epi16(rot3_0lo, rot3_1); __m128i y3o_h = _mm_madd_epi16(rot3_0hi, rot3_1); __m128i sum17 = _mm_add_epi16(row1, row7); __m128i sum35 = _mm_add_epi16(row3, row5); __m128i rot1_0lo = _mm_unpacklo_epi16((sum17),(sum35)); __m128i rot1_0hi = _mm_unpackhi_epi16((sum17),(sum35)); __m128i y4o_l = _mm_madd_epi16(rot1_0lo, rot1_0); __m128i y4o_h = _mm_madd_epi16(rot1_0hi, rot1_0); __m128i y5o_l = _mm_madd_epi16(rot1_0lo, rot1_1); __m128i y5o_h = _mm_madd_epi16(rot1_0hi, rot1_1); __m128i x4_l = _mm_add_epi32(y0o_l, y4o_l); __m128i x4_h = _mm_add_epi32(y0o_h, y4o_h); __m128i x5_l = _mm_add_epi32(y1o_l, y5o_l); __m128i x5_h = _mm_add_epi32(y1o_h, y5o_h); __m128i x6_l = _mm_add_epi32(y2o_l, y5o_l); __m128i x6_h = _mm_add_epi32(y2o_h, y5o_h); __m128i x7_l = _mm_add_epi32(y3o_l, y4o_l); __m128i x7_h = _mm_add_epi32(y3o_h, y4o_h); { __m128i abiased_l = _mm_add_epi32(x0_l, bias_1); __m128i abiased_h = _mm_add_epi32(x0_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x7_l); __m128i sum_h = _mm_add_epi32(abiased_h, x7_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x7_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x7_h); row0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row7 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; { __m128i abiased_l = _mm_add_epi32(x1_l, bias_1); __m128i abiased_h = _mm_add_epi32(x1_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x6_l); __m128i sum_h = _mm_add_epi32(abiased_h, x6_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x6_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x6_h); row1 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row6 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; { __m128i abiased_l = _mm_add_epi32(x2_l, bias_1); __m128i abiased_h = _mm_add_epi32(x2_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x5_l); __m128i sum_h = _mm_add_epi32(abiased_h, x5_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x5_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x5_h); row2 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row5 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; { __m128i abiased_l = _mm_add_epi32(x3_l, bias_1); __m128i abiased_h = _mm_add_epi32(x3_h, bias_1); __m128i sum_l = _mm_add_epi32(abiased_l, x4_l); __m128i sum_h = _mm_add_epi32(abiased_h, x4_h); __m128i dif_l = _mm_sub_epi32(abiased_l, x4_l); __m128i dif_h = _mm_sub_epi32(abiased_h, x4_h); row3 = _mm_packs_epi32(_mm_srai_epi32(sum_l, 17), _mm_srai_epi32(sum_h, 17)); row4 = _mm_packs_epi32(_mm_srai_epi32(dif_l, 17), _mm_srai_epi32(dif_h, 17)); }; };

   {
      
      __m128i p0 = _mm_packus_epi16(row0, row1); 
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      
      tmp = p0; p0 = _mm_unpacklo_epi8(p0, p2); p2 = _mm_unpackhi_epi8(tmp, p2); 
      tmp = p1; p1 = _mm_unpacklo_epi8(p1, p3); p3 = _mm_unpackhi_epi8(tmp, p3); 

      
      tmp = p0; p0 = _mm_unpacklo_epi8(p0, p1); p1 = _mm_unpackhi_epi8(tmp, p1); 
      tmp = p2; p2 = _mm_unpacklo_epi8(p2, p3); p3 = _mm_unpackhi_epi8(tmp, p3); 

      
      tmp = p0; p0 = _mm_unpacklo_epi8(p0, p2); p2 = _mm_unpackhi_epi8(tmp, p2); 
      tmp = p1; p1 = _mm_unpacklo_epi8(p1, p3); p3 = _mm_unpackhi_epi8(tmp, p3); 

      
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }










}

#line 2394 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





















































































































































































































static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != 0xff) { x = j->marker; j->marker = 0xff; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return 0xff;
   while (x == 0xff)
      x = stbi__get8(j->s); 
   return x;
}







static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = 0xff;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   
   
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         __declspec(align(16)) short data[64];
         int n = z->order[0];
         
         
         
         
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  
                  
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { 
         int i,j,k,x,y;
         __declspec(align(16)) short data[64];
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  
                  
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               
               
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         
         
         
         
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { 
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  
                  
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               
               
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!((z->marker) >= 0xd0 && (z->marker) <= 0xd7)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case 0xff: 
         return stbi__err("expected marker");

      case 0xDD: 
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: 
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type");
            if (t > 3) return stbi__err("bad DQT table");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: 
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len");
         else
            return stbi__err("bad APP len");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { 
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { 
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); 
            stbi__get16be(z->s); 
            stbi__get16be(z->s); 
            z->app14_color_transform = stbi__get8(z->s); 
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker");
}


static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; 
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); 
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         free(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = 0;
         z->img_comp[i].data = 0;
      }
      if (z->img_comp[i].raw_coeff) {
         free(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         free(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = 0;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len"); 
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit"); 
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height"); 
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width"); 
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = 0;
      z->img_comp[i].linebuf = 0;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      
      
      
      
      
      
      
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = 0;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == 0)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem"));
      
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == 0)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}










static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; 
   z->marker = 0xff; 
   m = stbi__get_marker(z);
   if (!((m) == 0xd8)) return stbi__err("no SOI");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!((m) == 0xc0 || (m) == 0xc1 || (m) == 0xc2)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == 0xff) {
         
         if (stbi__at_eof(z->s)) return stbi__err("no SOF");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = ((m) == 0xc2);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}


static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = 0;
      j->img_comp[m].raw_coeff = 0;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!((m) == 0xd9)) {
      if (((m) == 0xda)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == 0xff ) {
            
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            
         }
      } else if (((m) == 0xdc)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) stbi__err("bad DNL len");
         if (NL != j->s->img_y) stbi__err("bad DNL height");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}



typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);



static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   (void)(out);
   (void)(in_far);
   (void)(w);
   (void)(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   
   int i;
   (void)(hs);
   for (i=0; i < w; ++i)
      out[i] = ((stbi_uc) ((3*in_near[i] + in_far[i] + 2) >> 2));
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = ((stbi_uc) ((input[0]*3 + input[1] + 2) >> 2));
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = ((stbi_uc) ((n+input[i-1]) >> 2));
      out[i*2+1] = ((stbi_uc) ((n+input[i+1]) >> 2));
   }
   out[i*2+0] = ((stbi_uc) ((input[w-2]*3 + input[w-1] + 2) >> 2));
   out[i*2+1] = input[w-1];

   (void)(in_far);
   (void)(hs);

   return out;
}



static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = ((stbi_uc) ((3*in_near[0] + in_far[0] + 2) >> 2));
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = ((stbi_uc) ((t1+2) >> 2));
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = ((stbi_uc) ((3*t0 + t1 + 8) >> 4));
      out[i*2  ] = ((stbi_uc) ((3*t1 + t0 + 8) >> 4));
   }
   out[w*2-1] = ((stbi_uc) ((t1+2) >> 2));

   (void)(hs);

   return out;
}


static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = ((stbi_uc) ((3*in_near[0] + in_far[0] + 2) >> 2));
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   
   
   
   for (; i < ((w-1) & ~7); i += 8) {

      
      
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); 

      
      
      
      
      
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      
      
      
      
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);


































#line 3282 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

      
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = ((stbi_uc) ((3*t1 + t0 + 8) >> 4));

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = ((stbi_uc) ((3*t0 + t1 + 8) >> 4));
      out[i*2  ] = ((stbi_uc) ((3*t1 + t0 + 8) >> 4));
   }
   out[w*2-1] = ((stbi_uc) ((t1+2) >> 2));

   (void)(hs);

   return out;
}
#line 3304 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   
   int i,j;
   (void)(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}




static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); 
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* (((int) ((1.40200f) * 4096.0f + 0.5f)) << 8);
      g = y_fixed + (cr*-(((int) ((0.71414f) * 4096.0f + 0.5f)) << 8)) + ((cb*-(((int) ((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000);
      b = y_fixed                                     +   cb* (((int) ((1.77200f) * 4096.0f + 0.5f)) << 8);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}


static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;


   
   
   
   if (step == 4) {
      
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); 

      for (; i+7 < count; i += 8) {
         
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); 
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); 

         
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#line 3409 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"















































   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); 
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* (((int) ((1.40200f) * 4096.0f + 0.5f)) << 8);
      g = y_fixed + cr*-(((int) ((0.71414f) * 4096.0f + 0.5f)) << 8) + ((cb*-(((int) ((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000);
      b = y_fixed                                   +   cb* (((int) ((1.77200f) * 4096.0f + 0.5f)) << 8);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#line 3478 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;


   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#line 3493 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"






}


static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   
   int w_lores; 
   int ystep;   
   int ypos;    
} stbi__resample;


static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; 

   
   if (req_comp < 0 || req_comp > 4) return ((unsigned char *)(size_t) (stbi__err("bad req_comp")?0:0));

   
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return 0; }

   
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4];

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         
         
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0)); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0)); }

      
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { 
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { 
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { 
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; 
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; 
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   (void)(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   free(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   free(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   free(j);
   return result;
}
#line 3729 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
















typedef struct
{
   stbi__uint16 fast[1 << 9];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[288];
   stbi__uint16 value[288];
} stbi__zhuffman;

__forceinline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

__forceinline static int stbi__bit_reverse(int v, int bits)
{
   (void)( (!!(bits <= 16)) || (_wassert(L"bits <= 16", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(3766)), 0) );
   
   
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths");
      z->maxcode[i] = code << (16-i); 
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; 
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= 9) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << 9)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}







typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

__forceinline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      (void)( (!!(z->code_buffer < (1U << z->num_bits))) || (_wassert(L"z->code_buffer < (1U << z->num_bits)", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(3848)), 0) );
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

__forceinline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   
   
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=9+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s == 16) return -1; 
   
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   (void)( (!!(z->size[b] == s)) || (_wassert(L"z->size[b] == s", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(3876)), 0) );
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

__forceinline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) stbi__fill_bits(a);
   b = z->fast[a->code_buffer & ((1 << 9) - 1)];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  
{
   char *q;
   int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit");
   cur   = (int) (z->zout     - z->zout_start);
   limit = old_limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
      limit *= 2;
   q = (char *) realloc(z->zout_start,limit);
   (void)(old_limit);
   if (q == 0) return stbi__err("outofmem");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code"); 
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { 
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths");
            fill = lencodes[n-1];
         } else if (c == 17)
            c = stbi__zreceive(a,3)+3;
         else {
            (void)( (!!(c == 18)) || (_wassert(L"c == 18", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4006)), 0) );
            c = stbi__zreceive(a,7)+11;
         }
         if (ntot - n < c) return stbi__err("bad codelengths");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); 
   
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); 
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   (void)( (!!(a->num_bits == 0)) || (_wassert(L"a->num_bits == 0", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4033)), 0) );
   
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   
   int flg   = stbi__zget8(a);
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header"); 
   if (flg & 32) return stbi__err("no preset dict"); 
   if (cm != 8) return stbi__err("bad compression"); 
   
   return 1;
}

static const stbi_uc stbi__zdefault_length[288] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};













static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == 0) return 0;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      free(a.zout_start);
      return 0;
   }
}

extern char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

extern char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == 0) return 0;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      free(a.zout_start);
      return 0;
   }
}

extern int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

extern char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == 0) return 0;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      free(a.zout_start);
      return 0;
   }
}

extern int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#line 4204 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"












typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };


static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; 

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   (void)( (!!(out_n == s->img_n || out_n == s->img_n+1)) || (_wassert(L"out_n == s->img_n || out_n == s->img_n+1", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4294)), 0) );
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); 
   if (!a->out) return stbi__err("outofmem");

   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;
   
   
   
   if (raw_len < img_len) return stbi__err("not enough pixels");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter");

      if (depth < 8) {
         (void)( (!!(img_width_bytes <= x)) || (_wassert(L"img_width_bytes <= x", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4314)), 0) );
         cur += x*out_n - img_width_bytes; 
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; 

      
      if (j == 0) filter = first_row_filter[filter];

      
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = ((stbi_uc) ((raw[k] + prior[k]) & 255)); break;
            case STBI__F_avg        : cur[k] = ((stbi_uc) ((raw[k] + (prior[k]>>1)) & 255)); break;
            case STBI__F_paeth      : cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(0,prior[k],0)) & 255)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; 
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; 
            cur[filter_bytes+1] = 255; 
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         


         switch (filter) {
            
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            case STBI__F_sub: for (k=0; k < nk; ++k)          { cur[k] = ((stbi_uc) ((raw[k] + cur[k-filter_bytes]) & 255)); } break;
            case STBI__F_up: for (k=0; k < nk; ++k)           { cur[k] = ((stbi_uc) ((raw[k] + prior[k]) & 255)); } break;
            case STBI__F_avg: for (k=0; k < nk; ++k)          { cur[k] = ((stbi_uc) ((raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)) & 255)); } break;
            case STBI__F_paeth: for (k=0; k < nk; ++k)        { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])) & 255)); } break;
            case STBI__F_avg_first: for (k=0; k < nk; ++k)    { cur[k] = ((stbi_uc) ((raw[k] + (cur[k-filter_bytes] >> 1)) & 255)); } break;
            case STBI__F_paeth_first: for (k=0; k < nk; ++k)  { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)) & 255)); } break;
         }
         
         raw += nk;
      } else {
         (void)( (!!(img_n+1 == out_n)) || (_wassert(L"img_n+1 == out_n", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4376)), 0) );
         



         switch (filter) {
            case STBI__F_none: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)         { cur[k] = raw[k]; } break;
            case STBI__F_sub: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)          { cur[k] = ((stbi_uc) ((raw[k] + cur[k- output_bytes]) & 255)); } break;
            case STBI__F_up: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)           { cur[k] = ((stbi_uc) ((raw[k] + prior[k]) & 255)); } break;
            case STBI__F_avg: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)          { cur[k] = ((stbi_uc) ((raw[k] + ((prior[k] + cur[k- output_bytes])>>1)) & 255)); } break;
            case STBI__F_paeth: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)        { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])) & 255)); } break;
            case STBI__F_avg_first: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)    { cur[k] = ((stbi_uc) ((raw[k] + (cur[k- output_bytes] >> 1)) & 255)); } break;
            case STBI__F_paeth_first: for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) for (k=0; k < filter_bytes; ++k)  { cur[k] = ((stbi_uc) ((raw[k] + stbi__paeth(cur[k- output_bytes],0,0)) & 255)); } break;
         }
         

         
         
         if (depth == 16) {
            cur = a->out + stride*j; 
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   
   
   
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         
         
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; 

         
         
         
         
         

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               (void)( (!!(img_n == 3)) || (_wassert(L"img_n == 3", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4465)), 0) );
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      
      
      
      
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            free(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         free(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   
   
   (void)( (!!(out_n == 2 || out_n == 4)) || (_wassert(L"out_n == 2 || out_n == 4", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4543)), 0) );

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   
   
   (void)( (!!(out_n == 2 || out_n == 4)) || (_wassert(L"out_n == 2 || out_n == 4", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4568)), 0) );

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == 0) return stbi__err("outofmem");

   
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   free(a->out);
   a->out = temp_out;

   (void)(len);

   return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      (void)( (!!(s->img_out_n == 4)) || (_wassert(L"s->img_out_n == 4", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(4649)), 0) );
      if (stbi__unpremultiply_on_load) {
         
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}



static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3];
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = 0;
   z->idata = 0;
   z->out = 0;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case ((('C') << 24) + (('g') << 16) + (('B') << 8) + ('I')):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case ((('I') << 24) + (('H') << 16) + (('D') << 8) + ('R')): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len");
            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large");
            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               
               
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large");
               
            }
            break;
         }

         case ((('P') << 24) + (('L') << 16) + (('T') << 8) + ('E')):  {
            if (first) return stbi__err("first not IHDR");
            if (c.length > 256*3) return stbi__err("invalid PLTE");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case ((('t') << 24) + (('R') << 16) + (('N') << 8) + ('S')): {
            if (first) return stbi__err("first not IHDR");
            if (z->idata) return stbi__err("tRNS after IDAT");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE");
               if (c.length > pal_len) return stbi__err("bad tRNS len");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); 
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; 
               }
            }
            break;
         }

         case ((('I') << 24) + (('D') << 16) + (('A') << 8) + ('T')): {
            if (first) return stbi__err("first not IHDR");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               (void)(idata_limit_old);
               p = (stbi_uc *) realloc(z->idata,idata_limit); if (p == 0) return stbi__err("outofmem");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata");
            ioff += c.length;
            break;
         }

         case ((('I') << 24) + (('E') << 16) + (('N') << 8) + ('D')): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == 0) return stbi__err("no IDAT");
            
            bpl = (s->img_x * z->depth + 7) / 8; 
            raw_len = bpl * s->img_y * s->img_n  + s->img_y ;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == 0) return 0; 
            free(z->idata); z->idata = 0;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               
               s->img_n = pal_img_n; 
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               
               ++s->img_n;
            }
            free(z->expanded); z->expanded = 0;
            return 1;
         }

         default:
            
            if (first) return stbi__err("first not IHDR");
            if ((c.type & (1 << 29)) == 0) {
               
               
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = ((stbi_uc) ((c.type >> 24) & 255));
               invalid_chunk[1] = ((stbi_uc) ((c.type >> 16) & 255));
               invalid_chunk[2] = ((stbi_uc) ((c.type >> 8) & 255));
               invalid_chunk[3] = ((stbi_uc) ((c.type >> 0) & 255));
               #line 4842 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
               return stbi__err(invalid_chunk);
            }
            stbi__skip(s, c.length);
            break;
      }
      
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=0;
   if (req_comp < 0 || req_comp > 4) return ((unsigned char *)(size_t) (stbi__err("bad req_comp")?0:0));
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth < 8)
         ri->bits_per_channel = 8;
      else
         ri->bits_per_channel = p->depth;
      result = p->out;
      p->out = 0;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == 0) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   free(p->out);      p->out      = 0;
   free(p->expanded); p->expanded = 0;
   free(p->idata);    p->idata    = 0;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}
#line 4916 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"




static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); 
   stbi__get16le(s); 
   stbi__get16le(s); 
   stbi__get32le(s); 
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}



static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) n += 16, z >>= 16;
   if (z >= 0x00100) n +=  8, z >>=  8;
   if (z >= 0x00010) n +=  4, z >>=  4;
   if (z >= 0x00004) n +=  2, z >>=  2;
   if (z >= 0x00002) n +=  1, z >>=  1;
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); 
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); 
   a = (a + (a >> 4)) & 0x0f0f0f0f; 
   a = (a + (a >> 8)); 
   a = (a + (a >> 16)); 
   return a & 0xff;
}

static int stbi__shiftsigned(int v, int shift, int bits)
{
   int result;
   int z=0;

   if (shift < 0) v <<= -shift;
   else v >>= shift;
   result = v;

   z = bits;
   while (z < 8) {
      result += v >> z;
      z += bits;
   }
   return result;
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return ((unsigned char *)(size_t) (stbi__err("not BMP")?0:0));
   stbi__get32le(s); 
   stbi__get16le(s); 
   stbi__get16le(s); 
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return ((unsigned char *)(size_t) (stbi__err("unknown BMP")?0:0));
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return ((unsigned char *)(size_t) (stbi__err("bad BMP")?0:0));
   info->bpp = stbi__get16le(s);
   if (info->bpp == 1) return ((unsigned char *)(size_t) (stbi__err("monochrome")?0:0));
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return ((unsigned char *)(size_t) (stbi__err("BMP RLE")?0:0));
      stbi__get32le(s); 
      stbi__get32le(s); 
      stbi__get32le(s); 
      stbi__get32le(s); 
      stbi__get32le(s); 
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               if (info->bpp == 32) {
                  info->mr = 0xffu << 16;
                  info->mg = 0xffu <<  8;
                  info->mb = 0xffu <<  0;
                  info->ma = 0xffu << 24;
                  info->all_a = 0; 
               } else {
                  info->mr = 31u << 10;
                  info->mg = 31u <<  5;
                  info->mb = 31u <<  0;
               }
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               
               if (info->mr == info->mg && info->mg == info->mb) {
                  
                  return ((unsigned char *)(size_t) (stbi__err("bad BMP")?0:0));
               }
            } else
               return ((unsigned char *)(size_t) (stbi__err("bad BMP")?0:0));
         }
      } else {
         int i;
         if (hsz != 108 && hsz != 124)
            return ((unsigned char *)(size_t) (stbi__err("bad BMP")?0:0));
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         stbi__get32le(s); 
         for (i=0; i < 12; ++i)
            stbi__get32le(s); 
         if (hsz == 124) {
            stbi__get32le(s); 
            stbi__get32le(s); 
            stbi__get32le(s); 
            stbi__get32le(s); 
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   (void)(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == 0)
      return 0; 

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - 14 - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - 14 - info.hsz) >> 2;
   }

   s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) 
      target = req_comp;
   else
      target = s->img_n; 

   
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return ((unsigned char *)(size_t) (stbi__err("too large")?0:0));

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { free(out); return ((unsigned char *)(size_t) (stbi__err("invalid")?0:0)); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { free(out); return ((unsigned char *)(size_t) (stbi__err("bad bpp")?0:0)); }
      pad = (-width)&3;
      for (j=0; j < (int) s->img_y; ++j) {
         for (i=0; i < (int) s->img_x; i += 2) {
            int v=stbi__get8(s),v2=0;
            if (info.bpp == 4) {
               v2 = v & 15;
               v >>= 4;
            }
            out[z++] = pal[v][0];
            out[z++] = pal[v][1];
            out[z++] = pal[v][2];
            if (target == 4) out[z++] = 255;
            if (i+1 == (int) s->img_x) break;
            v = (info.bpp == 8) ? stbi__get8(s) : v2;
            out[z++] = pal[v][0];
            out[z++] = pal[v][1];
            out[z++] = pal[v][2];
            if (target == 4) out[z++] = 255;
         }
         stbi__skip(s, pad);
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - 14 - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else  width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { free(out); return ((unsigned char *)(size_t) (stbi__err("bad masks")?0:0)); }
         
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               int a;
               out[z++] = ((stbi_uc) ((stbi__shiftsigned(v & mr, rshift, rcount)) & 255));
               out[z++] = ((stbi_uc) ((stbi__shiftsigned(v & mg, gshift, gcount)) & 255));
               out[z++] = ((stbi_uc) ((stbi__shiftsigned(v & mb, bshift, bcount)) & 255));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = ((stbi_uc) ((a) & 255));
            }
         }
         stbi__skip(s, pad);
      }
   }

   
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i], p1[i] = p2[i], p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == 0) return out; 
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#line 5231 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   
   if(is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
            
      case 15: if(is_rgb16) *is_rgb16 = 1;
            return STBI_rgb;
      case 24: 
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   
    tga_colormap_type = stbi__get8(s); 
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      
    }
    tga_image_type = stbi__get8(s); 
    if ( tga_colormap_type == 1 ) { 
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       
        sz = stbi__get8(s);    
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       
        tga_colormap_bpp = sz;
    } else { 
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; 
        }
        stbi__skip(s,9); 
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   
    }
    tga_bits_per_pixel = stbi__get8(s); 
    stbi__get8(s); 
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            
            
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, 0);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), 0);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      
   tga_color_type = stbi__get8(s);   
   if ( tga_color_type > 1 ) goto errorEnd;   
   sz = stbi__get8(s);   
   if ( tga_color_type == 1 ) { 
      if (sz != 1 && sz != 9) goto errorEnd; 
      stbi__skip(s,4);       
      sz = stbi__get8(s);    
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       
   } else { 
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; 
      stbi__skip(s,9); 
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      
   sz = stbi__get8(s);   
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; 
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; 

errorEnd:
   stbi__rewind(s);
   return res;
}


static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   
   
   
   
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   
   
   unsigned char *tga_data;
   unsigned char *tga_palette = 0;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   (void)(ri);

   
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) 
      return ((unsigned char *)(size_t) (stbi__err("bad format")?0:0));

   
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return ((unsigned char *)(size_t) (stbi__err("too large")?0:0));

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));

   
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      
      if ( tga_indexed)
      {
         
         stbi__skip(s, tga_palette_start );
         
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            free(tga_data);
            return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            (void)( (!!(tga_comp == STBI_rgb)) || (_wassert(L"tga_comp == STBI_rgb", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(5445)), 0) );
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               free(tga_data);
               free(tga_palette);
               return ((unsigned char *)(size_t) (stbi__err("bad palette")?0:0));
         }
      }
      
      for (i=0; i < tga_width * tga_height; ++i)
      {
         
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         
         if ( read_next_pixel )
         {
            
            if ( tga_indexed )
            {
               
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               (void)( (!!(tga_comp == STBI_rgb)) || (_wassert(L"tga_comp == STBI_rgb", L"I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h", (unsigned)(5494)), 0) );
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            
            read_next_pixel = 0;
         } 

         
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         
         --RLE_count;
      }
      
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      
      if ( tga_palette != 0 )
      {
         free(tga_palette);
      }
   }

   
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   
   
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   
   return tga_data;
}
#line 5562 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         
      } else if (len < 128) {
         
         len++;
         if (len > nleft) return 0; 
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         
         
         len = 257 - len;
         if (len > nleft) return 0; 
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   (void)(ri);

   
   if (stbi__get32be(s) != 0x38425053)   
      return ((unsigned char *)(size_t) (stbi__err("not PSD")?0:0));

   
   if (stbi__get16be(s) != 1)
      return ((unsigned char *)(size_t) (stbi__err("wrong version")?0:0));

   
   stbi__skip(s, 6 );

   
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return ((unsigned char *)(size_t) (stbi__err("wrong channel count")?0:0));

   
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return ((unsigned char *)(size_t) (stbi__err("unsupported bit depth")?0:0));

   
   
   
   
   
   
   
   
   
   
   if (stbi__get16be(s) != 3)
      return ((unsigned char *)(size_t) (stbi__err("wrong color format")?0:0));

   
   stbi__skip(s,stbi__get32be(s) );

   
   stbi__skip(s, stbi__get32be(s) );

   
   stbi__skip(s, stbi__get32be(s) );

   
   
   
   
   compression = stbi__get16be(s);
   if (compression > 1)
      return ((unsigned char *)(size_t) (stbi__err("bad compression")?0:0));

   
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return ((unsigned char *)(size_t) (stbi__err("too large")?0:0));

   

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));
   pixelCount = w*h;

   
   

   
   if (compression) {
      
      
      
      
      
      
      

      
      
      stbi__skip(s, h * channelCount * 2 );

      
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               free(out);
               return ((unsigned char *)(size_t) (stbi__err("corrupt")?0:0));
            }
         }
      }

   } else {
      
      

      
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == 0) return out; 
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#line 5810 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"









static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   
    
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return ((unsigned char *)(size_t) (stbi__err("bad format")?0:0));

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));
      if (packet->size != 8)  return ((unsigned char *)(size_t) (stbi__err("bad format")?0:0));
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); 

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return ((unsigned char *)(size_t) (stbi__err("bad format")?0:0));

            case 0: {
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1:
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));

                  if (count >= 128) { 
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { 
                     ++count;
                     if (count>left) return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   (void)(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);
   if (stbi__at_eof(s))  return ((unsigned char *)(size_t) (stbi__err("bad file")?0:0));
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return ((unsigned char *)(size_t) (stbi__err("too large")?0:0));

   stbi__get32be(s); 
   stbi__get16be(s); 
   stbi__get16be(s); 

   
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      free(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#line 6026 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out, *old_out;             
   int flags, bgindex, ratio, transparent, eflags, delay;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[4096];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (comp != 0) *comp = 4;  

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!stbi__gif_header(s, g, comp, 1)) {
      free(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   free(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;

   
   
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   p = &g->out[g->cur_x + g->cur_y];
   c = &g->color_table[g->codes[code].suffix * 4];

   if (c[3] >= 128) {
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return 0;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); 
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         
         if (code == clear) {  
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { 
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) return ((unsigned char *)(size_t) (stbi__err("no clear code")?0:0));

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 4096)        return ((unsigned char *)(size_t) (stbi__err("too many codes")?0:0));
               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return ((unsigned char *)(size_t) (stbi__err("illegal code in raster")?0:0));

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return ((unsigned char *)(size_t) (stbi__err("illegal code in raster")?0:0));
         }
      }
   }
}

static void stbi__fill_gif_background(stbi__gif *g, int x0, int y0, int x1, int y1)
{
   int x, y;
   stbi_uc *c = g->pal[g->bgindex];
   for (y = y0; y < y1; y += 4 * g->w) {
      for (x = x0; x < x1; x += 4) {
         stbi_uc *p  = &g->out[y + x];
         p[0] = c[2];
         p[1] = c[1];
         p[2] = c[0];
         p[3] = 0;
      }
   }
}


static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
{
   int i;
   stbi_uc *prev_out = 0;

   if (g->out == 0 && !stbi__gif_header(s, g, comp,0))
      return 0; 

   if (!stbi__mad3sizes_valid(g->w, g->h, 4, 0))
      return ((unsigned char *)(size_t) (stbi__err("too large")?0:0));

   prev_out = g->out;
   g->out = (stbi_uc *) stbi__malloc_mad3(4, g->w, g->h, 0);
   if (g->out == 0) return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));

   switch ((g->eflags & 0x1C) >> 2) {
      case 0: 
         stbi__fill_gif_background(g, 0, 0, 4 * g->w, 4 * g->w * g->h);
         break;
      case 1: 
         if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);
         g->old_out = prev_out;
         break;
      case 2: 
         if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);
         stbi__fill_gif_background(g, g->start_x, g->start_y, g->max_x, g->max_y);
         break;
      case 3: 
         if (g->old_out) {
            for (i = g->start_y; i < g->max_y; i += 4 * g->w)
               memcpy(&g->out[i + g->start_x], &g->old_out[i + g->start_x], g->max_x - g->start_x);
         }
         break;
   }

   for (;;) {
      switch (stbi__get8(s)) {
         case 0x2C: 
         {
            int prev_trans = -1;
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return ((unsigned char *)(size_t) (stbi__err("bad Image Descriptor")?0:0));

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; 
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               if (g->transparent >= 0 && (g->eflags & 0x01)) {
                  prev_trans = g->pal[g->transparent][3];
                  g->pal[g->transparent][3] = 0;
               }
               g->color_table = (stbi_uc *) g->pal;
            } else
               return ((unsigned char *)(size_t) (stbi__err("missing color table")?0:0));

            o = stbi__process_gif_raster(s, g);
            if (o == 0) return 0;

            if (prev_trans != -1)
               g->pal[g->transparent][3] = (stbi_uc) prev_trans;

            return o;
         }

         case 0x21: 
         {
            int len;
            if (stbi__get8(s) == 0xF9) { 
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = stbi__get16le(s);
                  g->transparent = stbi__get8(s);
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0)
               stbi__skip(s, len);
            break;
         }

         case 0x3B: 
            return (stbi_uc *) s; 

         default:
            return ((unsigned char *)(size_t) (stbi__err("unknown code")?0:0));
      }
   }

   (void)(req_comp);
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   memset(g, 0, sizeof(*g));
   (void)(ri);

   u = stbi__gif_load_next(s, g, comp, req_comp);
   if (u == (stbi_uc *) s) u = 0;  
   if (u) {
      *x = g->w;
      *y = g->h;
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g->w, g->h);
   }
   else if (g->out)
      free(g->out);
   free(g);
   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#line 6400 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"





static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}


static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == 1024-1) {
         
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; 
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; 
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[1024];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   (void)(ri);

   
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return ((float *)(size_t) (stbi__err("not HDR")?0:0));

   
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return ((float *)(size_t) (stbi__err("unsupported format")?0:0));

   
   
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return ((float *)(size_t) (stbi__err("unsupported data layout")?0:0));
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return ((float *)(size_t) (stbi__err("unsupported data layout")?0:0));
   token += 3;
   width = (int) strtol(token, 0, 10);

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return ((float *)(size_t) (stbi__err("too large")?0:0));

   
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return ((float *)(size_t) (stbi__err("outofmem")?0:0));

   
   
   if ( width < 8 || width >= 32768) {
      
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      
      scanline = 0;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            
            
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            free(scanline);
            goto main_decode_loop; 
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { free(hdr_data); free(scanline); return ((float *)(size_t) (stbi__err("invalid decoded scanline length")?0:0)); }
         if (scanline == 0) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               free(hdr_data);
               return ((float *)(size_t) (stbi__err("outofmem")?0:0));
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { free(hdr_data); free(scanline); return ((float *)(size_t) (stbi__err("corrupt")?0:0)); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  
                  if (count > nleft) { free(hdr_data); free(scanline); return ((float *)(size_t) (stbi__err("corrupt")?0:0)); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         free(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[1024];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, 0, 10);
   *comp = 3;
   return 1;
}
#line 6648 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   stbi__rewind( s );
   if (p == 0)
      return 0;
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) *comp = info.ma ? 4 : 3;
   return 1;
}
#line 6666 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   if (stbi__get16be(s) != 8) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}
#line 6702 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"


static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#line 6761 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"















static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   (void)(ri);

   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
      return 0;

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
      return ((unsigned char *)(size_t) (stbi__err("too large")?0:0));

   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
   if (!out) return ((unsigned char *)(size_t) (stbi__err("outofmem")?0:0));
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == 0) return out; 
   }
   return out;
}

static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); 
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); 
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  

   if (maxv > 255)
      return stbi__err("max value > 255");
   else
      return 1;
}
#line 6888 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #line 6894 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__png_info(s, x, y, comp))  return 1;
   #line 6898 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #line 6902 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #line 6906 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #line 6910 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #line 6914 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #line 6918 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #line 6922 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

   
   
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #line 6928 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"
   return stbi__err("unknown image type");
}


extern int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

extern int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,0);
   return r;
}
#line 6953 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"

extern int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

extern int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

#line 6969 "I:\\Dev\\Motors\\pikkumoottori\\deps\\include\\3rdparty/stb_image.h"



























































































































































































































#line 17 "..\\src\\graphics\\graphics.cpp"

static SpriteBatch spriteBatch;
static Camera2D camera;

constexpr int POS = 0;
constexpr int UVS = 1;
constexpr int ID = 2;
constexpr int COLOR = 3;
constexpr int ROTATION = 4;
constexpr int INDEX = 5;
constexpr int MAX_TEXTURES = 8;

void initSpriteBatch(SpriteBatch* sb)
{
	glad_glGenVertexArrays(1, &sb->VAO);
	glad_glGenBuffers((sizeof(SpriteBatch::buffers) / sizeof((SpriteBatch::buffers)[0])), sb->buffers);

	glad_glBindVertexArray(sb->VAO);

	glad_glEnableVertexAttribArray(0);
	glad_glEnableVertexAttribArray(1);
	glad_glEnableVertexAttribArray(2);
	glad_glEnableVertexAttribArray(3);
	glad_glEnableVertexAttribArray(4);

	glad_glBindBuffer(0x8892, sb->buffers[POS]);
	glad_glVertexAttribPointer(0, 4, 0x1406, false, 0, 0);
	glad_glBufferData(0x8892, MAX_SPRITES * sizeof(float) * 4 * 4, 0, 0x88E8); 

	glad_glBindBuffer(0x8892, sb->buffers[UVS]);
	glad_glVertexAttribPointer(1, 2, 0x1406, false, 0, 0);
	glad_glBufferData(0x8892, MAX_SPRITES * sizeof(float) * 4 * 2, 0, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[ID]);
	glad_glVertexAttribPointer(2, 1, 0x1406, false, 0, 0);
	glad_glBufferData(0x8892, MAX_SPRITES * sizeof(float) * 4 * 1, 0, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[COLOR]);
	glad_glVertexAttribPointer(3, 4, 0x1401, 1, 0, 0);
	glad_glBufferData(0x8892, MAX_SPRITES * sizeof(unsigned int) * 4 * 1, 0, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[ROTATION]);
	glad_glVertexAttribPointer(4, 1, 0x1406, 0, 0, 0);
	glad_glBufferData(0x8892, MAX_SPRITES * sizeof(float) * 4 * 1, 0, 0x88E8);


	int indexBufferSize = MAX_SPRITES * 6 * sizeof(float);
	unsigned int* indices = (unsigned int*)malloc(indexBufferSize);
	int index = 0;
	for (int i = 0; i < MAX_SPRITES * 6; i += 6)
	{
		indices[i] = index + 0;
		indices[i + 1] = index + 1;
		indices[i + 2] = index + 2;
		indices[i + 3] = index + 2;
		indices[i + 4] = index + 3;
		indices[i + 5] = index + 0;
		index += 4;
	}
	glad_glBindBuffer(0x8893, sb->buffers[INDEX]);
	glad_glBufferData(0x8893, MAX_SPRITES * sizeof(GLuint) * 6, indices, 0x88E4);
	free(indices); 

	glad_glBindVertexArray(0);

	sb->shader.compileShaderFromFile(
		"assets/shaders/spriteVert.txt",
		"assets/shaders/spriteFrag.txt");

	glCheckError__("..\\src\\graphics\\graphics.cpp", 86);

	sb->shader.use();
	int values[8]{ 0, 1, 2, 3, 4, 5, 6, 7 };
	sb->shader.setInts("textures", 8, values);

	glCheckError__("..\\src\\graphics\\graphics.cpp", 92);
}

static inline Vec2 rotate(Vec2 pos, float angle)
{
	Vec2 result;
	result.x = pos.x * cos(angle) - pos.y * sin(angle);
	result.y = pos.x * sin(angle) + pos.y * cos(angle);
	return result;
}

void prepareBatch(Sprites* sprites, SpriteBatch* sb)
{
	int count = sprites->count;
	VertexData* vertexData = &sb->vertexData;
	vertexData->indicesCount = 6 * sprites->count;

	{
		float* positions = vertexData->pos;
		Vec2* __restrict pos = sprites->positions;
		Vec2* __restrict size = sprites->sizes;

		float* __restrict angle = sprites->rotation;

		for (int i = 0; i < count * 16; i += 16)
		{



































#line 154 "..\\src\\graphics\\graphics.cpp"
















#line 171 "..\\src\\graphics\\graphics.cpp"
			Vec2 half = *size / 2.f;
			*(positions + i + 0) = pos->x;
			*(positions + i + 1) = pos->y; 
			*(positions + i + 2) = -half.x;
			*(positions + i + 3) = half.y;

			*(positions + i + 4) = pos->x;
			*(positions + i + 5) = pos->y;
			*(positions + i + 6) = -half.x;
			*(positions + i + 7) = -half.y;

			*(positions + i + 8) = pos->x; 
			*(positions + i + 9) = pos->y;
			*(positions + i + 10) = half.x;
			*(positions + i + 11) = -half.y;

			*(positions + i + 12) = pos->x; 
			*(positions + i + 13) = pos->y; 
			*(positions + i + 14) = half.x;
			*(positions + i + 15) = half.y;
#line 192 "..\\src\\graphics\\graphics.cpp"
			++pos;
			++size;
		}
	}

	{
		vec4* __restrict uvs = sprites->uvs;
		float* __restrict uvsOut = vertexData->uvs;

		for (int i = 0; i < count * 8; i += 8)
		{
			*(uvsOut + i + 0) = uvs->x;
			*(uvsOut + i + 1) = uvs->y;

			*(uvsOut + i + 2) = uvs->x;
			*(uvsOut + i + 3) = uvs->y + uvs->h;

			*(uvsOut + i + 4) = uvs->x + uvs->w;
			*(uvsOut + i + 5) = uvs->y + uvs->h;

			*(uvsOut + i + 6) = uvs->x + uvs->w;
			*(uvsOut + i + 7) = uvs->y;

			++uvs;
		}
	}

	{
		vec4* __restrict color = sprites->colors;
		unsigned int* colorOut = vertexData->colors;

		for (int i = 0; i < count * 4; i += 4)
		{
			int r = int(color->x * 255.0f);
			int g = int(color->y * 255.0f);
			int b = int(color->w * 255.0f);
			int a = int(color->h * 255.0f);

			unsigned int c = (a << 24 | b << 16 | g << 8 | r);

			*(colorOut + i + 0) = c;
			*(colorOut + i + 1) = c;
			*(colorOut + i + 2) = c;
			*(colorOut + i + 3) = c;

			++color;
		}
	}

	{
		float* rot = vertexData->rot;
		float* s_rots = sprites->rotation;

		for (int i = 0; i < count * 4; i += 4)
		{
			*(rot + i + 0) = *s_rots;
			*(rot + i + 1) = *s_rots;
			*(rot + i + 2) = *s_rots;
			*(rot + i + 3) = *s_rots;
			 ++s_rots;
			
		}
	}


	{
		float* __restrict idsOut = vertexData->ids;
		int* __restrict ids = sprites->ids;

		for (int i = 0; i < (sizeof(VertexData::textureSlots) / sizeof((VertexData::textureSlots)[0])); ++i)
		{
			vertexData->textureSlots[i] = -1;
		}

		vertexData->slotCount = 0;

		for (int i = 0; i < count * 4; i += 4)
		{
			
			float ts;
			bool found = false;
			for (int i = 0; i < MAX_TEXTURES; i++)
			{
				if (vertexData->textureSlots[i] == *ids)
				{
					ts = (float)(i + 1);
					found = true;
					break;
				}
			}

			if (!found)
			{
				vertexData->textureSlots[vertexData->slotCount] = *ids;
				(vertexData->slotCount)++;
				ts = (float)(vertexData->slotCount);
			}

			*(idsOut + i + 0) = ts;
			*(idsOut + i + 1) = ts;
			*(idsOut + i + 2) = ts;
			*(idsOut + i + 3) = ts;

			++ids;
		}
	}
}

void renderBatch(Sprites* sprites, SpriteBatch* sb, glm::mat4* cam)
{
	int count = sprites->count;
	VertexData* vertexData = &sb->vertexData;
	glad_glBindBuffer(0x8892, sb->buffers[POS]);
	glad_glBufferData(0x8892, count * sizeof(float) * 4 * 4, vertexData->pos, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[UVS]);
	glad_glBufferData(0x8892, count * sizeof(float) * 2 * 4, vertexData->uvs, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[ID]);
	glad_glBufferData(0x8892, count * sizeof(float) * 4, vertexData->ids, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[COLOR]);
	glad_glBufferData(0x8892, count * sizeof(unsigned int) * 4, vertexData->colors, 0x88E8);

	glad_glBindBuffer(0x8892, sb->buffers[ROTATION]);
	glad_glBufferData(0x8892, count * sizeof(float) * 4, vertexData->rot, 0x88E8);
	glCheckError__("..\\src\\graphics\\graphics.cpp", 318);

	sb->shader.use();
	sb->shader.setMat4("position", *cam);

	glad_glBindVertexArray(sb->VAO);

	for (int i = 0; i < MAX_TEXTURES; i++)
	{
		if (vertexData->textureSlots[i] == -1)
			break;

		glad_glActiveTexture(0x84C0 + i);
		glad_glBindTexture(0x0DE1, vertexData->textureSlots[i]);
	}

	glad_glBindBuffer(0x8893, sb->buffers[INDEX]);
	glad_glDrawElements(0x0004, vertexData->indicesCount, 0x1405, 0);

}

struct Texture2D
{
	int width, height;
	unsigned int ID;
	uint64_t writeTime;
};

static bool IsPowerOfTwo(unsigned long x)
{
	return (x & (x - 1)) == 0;
}

static Texture2D loadTexture(int width, int height, int bytesPerPixel, const unsigned char* pixels,
	bool clampToEdge = false, bool nearest = true)
{
	Texture2D value;

	if (bytesPerPixel == 3 || bytesPerPixel == 4) { } else { __debugbreak();; };
	value.width = width;
	value.height = height;

	glad_glPixelStorei(0x0CF5, 1);

	glad_glGenTextures(1, &value.ID);
	glad_glBindTexture(0x0DE1, value.ID);


	if (!IsPowerOfTwo(width) || !IsPowerOfTwo(height))
		clampToEdge = true;


	clampToEdge = true;
	if (clampToEdge)
	{
		glad_glTexParameteri(0x0DE1, 0x2802, 0x812F);
		glad_glTexParameteri(0x0DE1, 0x2803, 0x812F);
	}
	else
	{
		glad_glTexParameteri(0x0DE1, 0x2801, 0x2600);
		glad_glTexParameteri(0x0DE1, 0x2800, 0x2600);
	}

	GLuint fmt = bytesPerPixel == 3 ? 0x1907 : 0x1908;
	glad_glTexImage2D(0x0DE1, 0, fmt, width, height, 0, fmt, 0x1401, pixels);

	if (IsPowerOfTwo(width) && IsPowerOfTwo(height))
		glad_glGenerateMipmap(0x0DE1);              
													  
	return value;
}

static Texture2D testTexture()
{
	unsigned char pixels[3] = {
		255, 0, 255,
	};
	return loadTexture(1, 1, 3, pixels, false, false);
}



























enum TextureEnum {
	Texture_infantry, Texture_circle, Texture_box, Texture_awesomeface, Texture_noise, Texture_count,
};


const char* const TextureEnumToStr[] = {
	"infantry", "circle", "box", "awesomeface", "noise", "count",
};














const char* baseTexturePath = "assets/textures/";

static Texture2D loadTexture(TextureEnum texture)
{
	const char* path = TextureEnumToStr[texture];
	char buffer[256];
	if (strlen(baseTexturePath) + strlen(path) < 256) { } else { __debugbreak();; };
	strcpy(buffer, baseTexturePath);
	strcat(buffer, path);
	strcat(buffer, ".png");

	int w, h, nrChannels;
	unsigned char* data = stbi_load(buffer, &w, &h, &nrChannels, 0);
	if (data)
	{
		return loadTexture(w, h, nrChannels, data);
		stbi_image_free(data);
	}
	else
	{
		printf("failed to load image %s \n", buffer);
		if (false) { } else { __debugbreak();; };
		return testTexture();
	}
}



static Texture2D* getTexture(TextureEnum texture)
{
	static Texture2D textureCache[Texture_count] = { 0 };
	static bool loaded[Texture_count] = { 0 };

	if (!loaded[texture])
	{
		textureCache[texture] = loadTexture(texture);
		loaded[texture] = true;
	}

	return &textureCache[texture];
}

void initCamera(Camera2D* cam, int screenW, int screenH);
extern "C" __declspec(dllexport) void initGraphics(EngineContext* engine)
{
	GraphicsContext* c = &engine->context;
	if (!engine->context.initted)
	{
		printf("Graphics init\n");


		if (!gladLoadGL())
		{
			printf("failed to initaliaze GLAD\n");
			if (false) { } else { __debugbreak();; };
		}
#line 504 "..\\src\\graphics\\graphics.cpp"

		glad_glViewport(0, 0, engine->windowDims.x, engine->windowDims.y);
		glad_glEnable(0x0BE2);
		glad_glBlendFunc(0x0302, 0x0303);
		glad_glClearColor(114.f / 255.0f, 144.f / 255.0f, 154.f / 255.0f, 1.0f);

		
		initSpriteBatch(&spriteBatch);

		
		initCamera(&camera, (int)engine->windowDims.x, (int)engine->windowDims.y);
		engine->context.camera.scale = 1.f;

		stbi_set_flip_vertically_on_load(false);

		engine->context.initted = true;


		ImGui::SetCurrentContext((ImGuiContext*)engine->imguiContext);
#line 524 "..\\src\\graphics\\graphics.cpp"
	}
}

extern "C" __declspec(dllexport) void updateGraphics(EngineContext* engine)
{
	auto* c = &engine->context;

}

void initCamera(Camera2D* cam, int screenW, int screenH)
{
	cam->orthoMatrix = glm::ortho(0.0f, (float)screenW, 0.0f, (float)screenH);
}

void updateCamera(Camera2D* cam, CameraState* state, Vec2* screen)
{
	if (state->needUpdate)
	{
		glm::vec3 translate(-state->position.x + screen->x / 2, -state->position.y + screen->y / 2, 0.0f);  
		cam->cameraMatrix = glm::translate(cam->orthoMatrix, translate);

		
		
		

		
		
		

		

		
		glm::vec3 scale(state->scale, state->scale, 0.0f);
		cam->cameraMatrix =  glm::scale(glm::mat4(1.0f), scale) * cam->cameraMatrix;
		
		state->needUpdate = false;
	}
}

constexpr int BENCH_COUNT = 200000;
struct Entitys
{
	Vec2 pos[BENCH_COUNT];
	Vec2 size[BENCH_COUNT];
	Vec2 vel[BENCH_COUNT];
	int textureId[BENCH_COUNT];
	vec4 uvs[BENCH_COUNT];
	vec4 colors[BENCH_COUNT];
	float rotation[BENCH_COUNT];
	unsigned int count;

	vec4 bounds{};
};

extern "C" __declspec(dllexport) void drawGraphics(EngineContext* engine)
{
	auto* c = &engine->context;
	if (c->updateViewPort)
	{
		glad_glViewport(0, 0, engine->windowDims.x, engine->windowDims.y);
	}

	glad_glClear(0x00004000);

	static bool init = false;
	static Entitys* test = 0;
	static Texture2D* testTextures[] = {
		
		getTexture(Texture_box),
		getTexture(Texture_circle),
		
		getTexture(Texture_awesomeface),
	};


	if (!init)
	{
		test = new Entitys;
		init = true;

		int count = (sizeof(Entitys::pos) / sizeof((Entitys::pos)[0]));
		const int RNG_MAX = 0xFFFFFFFF;
		for (int i = 0; i < count; ++i)
		{
			test->pos[i].x = rand() % (int)engine->windowDims.x;
			test->pos[i].y = rand() % (int)engine->windowDims.y;
		}

		for (int i = 0; i < count; ++i)
		{
			test->size[i] = { 14.f, 14.f };
			test->uvs[i] = { 0.f, 0.f, 1.f, 1.f };
			test->colors[i] = { 1.f, 1.f, 1.f, 1.f };
			test->rotation[i] = i / 10.f;
		}
		
		int a = getTexture(Texture_box)->ID;
		int b = getTexture(Texture_circle)->ID;
		for (int i = 0; i < count; ++i)
		{
			int r = rand() % (sizeof(testTextures) / sizeof((testTextures)[0]));
			test->textureId[i] = testTextures[r]->ID;

			if (test->textureId[i] == a || test->textureId[i] == b)
			{
				vec4 randomColor{ (rand() % 255) / 255.f , (rand() % 255) / 255.f, (rand() % 255) / 255.f };
				randomColor.h = rand() % 120 / 255.f + 0.2f;
				test->colors[i] = randomColor;
			}
		}

		for (int i = 0; i < count; ++i)
		{
			test->vel[i].x = (rand() % 100) / 100.f;
			test->vel[i].y = (rand() % 100) / 100.f;
		}

		

		c->sprites.colors = test->colors;
		c->sprites.ids = test->textureId;
		c->sprites.positions = test->pos;
		c->sprites.sizes = test->size;
		c->sprites.uvs = test->uvs;
		c->sprites.rotation = test->rotation;
		c->sprites.count = count;

		test->bounds.x = 0.f;
		test->bounds.y = 0.f;
		test->bounds.w = engine->windowDims.x;
		test->bounds.h = engine->windowDims.y;
	}


	ImGui::DragFloat2("bounds x, y", (&test->bounds.x));
	ImGui::DragFloat2("bounds w, h", (&test->bounds.w));
#line 661 "..\\src\\graphics\\graphics.cpp"

	Vec2 vel = {};
	float speed = 40.f * engine->dt;
	auto* controller = &engine->controller;
	if (controller->cameraMovement[Controller::ctrl])
	{
		speed *= 5.f;
	}
	if (controller->cameraMovement[Controller::w])
	{
		vel.y += speed;
	}
	if (controller->cameraMovement[Controller::s])
	{
		vel.y -= speed;
	}
	if (controller->cameraMovement[Controller::d])
	{
		vel.x += speed;
	}
	if (controller->cameraMovement[Controller::a])
	{
		vel.x -= speed;
	}
	if (controller->cameraMovement[Controller::q])
	{
		zoom(&c->camera, 0.33f * engine->dt);
	}
	if (controller->cameraMovement[Controller::e])
	{
		zoom(&c->camera, -0.33f * engine->dt);
	}
	translate(&c->camera, vel);

	float unitSpeed = 100 * engine->dt;
	for (int i = 0; i < BENCH_COUNT; ++i)
	{
		test->pos[i].x += test->vel[i].x * unitSpeed;
		test->pos[i].y += test->vel[i].y * unitSpeed;
	}

	for (int i = 0; i < BENCH_COUNT; ++i)
	{
		if (test->pos[i].x < test->bounds.x | test->pos[i].x > test->bounds.w)
		{
			test->vel[i].x = -test->vel[i].x; 

			test->pos[i].x = test->pos[i].x < test->bounds.x ? test->bounds.x : test->bounds.w - 1.f;
		}

		if (test->pos[i].y < test->bounds.y | test->pos[i].y > test->bounds.h)
		{
			test->vel[i].y = -test->vel[i].y; 
			test->pos[i].y = test->pos[i].y < test->bounds.y ? test->bounds.y : test->bounds.h - 1.f;
		}
	}

	for (int i = 0; i < BENCH_COUNT / 2; ++i)
	{
		test->rotation[i] += test->vel[i].x;
	}
	for (int i = BENCH_COUNT / 2; i < BENCH_COUNT; ++i)
	{
		test->rotation[i] -= test->vel[i].x;
	}

	
	test->textureId[0] = testTextures[0]->ID;
	test->pos[0].x = 0.f;
	test->pos[0].y = 0.f;
	
	test->rotation[0] += 0.001f;

	test->textureId[1] = testTextures[0]->ID;
	test->pos[1].x = 10.f;
	test->pos[1].y = 10.f;
	
	test->rotation[1] += 0.001f;



	prepareBatch(&c->sprites, &spriteBatch);

	updateCamera(&camera, &c->camera, &engine->windowDims);
	renderBatch(&c->sprites, &spriteBatch, &camera.cameraMatrix);
}
