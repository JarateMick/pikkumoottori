{"version":3,"file":"pikkuMoottori.html","sources":["../inc\\vec2.h","../src/graphics/graphicsF.h","../src/application/game.cpp","../inc\\../src/IO.cpp","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\fstream","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\ios","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\istream","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\string","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\memory","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\type_traits","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\iosfwd","../src/graphics/shader.cpp","../src/graphics/graphics.h","../deps/include\\3rdparty/stb_image.h","../src/graphics/graphics.cpp","../inc\\graphics/Shader.h","../deps/include\\glm/gtc/matrix_transform.inl","../deps/include\\glm/detail/type_vec3.inl","../deps/include\\glm/detail/type_mat4x4.inl","../deps/include\\glm/detail/type_mat4x4.hpp","../src/main.cpp","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\functional","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\__locale","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\streambuf","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\algorithm","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\math.h","../deps/include\\glm/detail/type_vec4.inl","../deps/include\\glm/gtc/type_ptr.inl","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\exception","../deps/include\\glm/detail/type_vec4.hpp","../deps/include\\glm/detail/type_vec3.hpp","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\new","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\tuple","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\typeinfo","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\__functional_base","I:\\Dev\\Emsripten\\emscripten\\1.37.1\\system\\include\\libcxx\\chrono"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AA7EA;AAAA;AAAA;;AAkFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAdA;AAAA;AAAA;;AAmBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAdA;AAAA;AAAA;;AAmBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;ADzDA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEskBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AFnhBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AGnDA;;;AAAA;AAAA;AAAA;;;;;;;ADgBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJogBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAKA;AAAA;;;AAAA;AAAA;;;AACA;;;;;;AAuJA;AAAA;AAxJA;AAAA;;;;AAAA;;AAEA;;;;;;AAsJA;AAAA;AAxJA;AAAA;;;;AAAA;;AAGA;;;;;;AAqJA;AAAA;AAxJA;AAAA;;;;AAAA;;AAKA;;;;;;AAmJA;AAAA;AAxJA;AAAA;;;;AAAA;;;;;;AASA;AAAA;;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAQA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AARA;AAAA;AAAA;;AAYA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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A;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAEA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6DA;AAAA;;;AAtDA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AARA;AAAA;AAAA;;;AAWA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;;;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AARA;AAAA;AAAA;;;;AAWA;AAAA;AAAA;AAzB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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwBA;;;;;;;;;;;;;;;;;;;;;;AAslCA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;;AAAA;;;AAAA;;;;;AACA;AAAA;;;AAAA;AAAA;;AAAA;;;AAAA;;;;;AACA;AAAA;;;AAAA;AAAA;;AAAA;;;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAlBA;AAAA;AAAA;;AAoBA;;;;;;;;;;;;;;;;;;;;AA9KA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAgBA;AAAA;;AAbA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;;;;;;;;AAvjCA;AAAA;;;AACA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;;;;;;;;;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;AAkfA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAIA;AAAA;;;AAHA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AA8KA;;;AAEA;AAAA;AA+FA;AAAA;;;;AA5FA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA4FA;AAAA;;AA3FA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA0FA;AAAA;;;;;AAvFA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AALA;AAAA;AAkFA;AAAA;;;AAjFA;AAAA;AAiFA;AAAA;;;AA3EA;AAAA;AAAA;AAAA;AA2EA;AAAA;;;;;AAxEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAjBA;AAAA;AAiEA;AAAA;;;AA1DA;AA0DA;AAAA;;;AAvDA;AAuDA;AAAA;;;AA9CA;AAAA;AAAA;AAAA;AA8CA;AAAA;;;;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyCA;AAAA;AACA;AAAA;;AAzCA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAsCA;AAAA;;AApCA;AAAA;AAoCA;AAAA;;;AAlCA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAFA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAFA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;;;;;;;;;;;;AA5+CA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAOA;AAAA;;AAJA;AAAA;AAAA;AAAA;;AAAA;AAIA;AAAA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsiDA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA6EA;AAAA;;AA5EA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA4EA;AAAA;;AA3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA2EA;AAAA;;AA1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA0EA;AAAA;;AAzEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAwEA;AAAA;;AAvEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAiEA;AAAA;;AA/DA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AARA;AAAA;AAAA;;;AAMA;AAAA;AAwDA;AAAA;;;AAvDA;AAAA;AAuDA;AAAA;;;AAtDA;AAAA;AAsDA;AAAA;;;AAnDA;AAAA;;AAAA;AAmDA;AAAA;;AAjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAiDA;AAAA;;AA/CA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA5BA;AAAA;AAAA;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;;AADA;AACA;AAAA;;;;;;;;;;;;AAxoDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;AALA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;;AAHA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AAoEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AA2RA;AAEA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAVA;AAAA;AAAA;;;AAMA;AAAA;AAqBA;AAAA;;AAfA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AALA;AAAA;AAAA;;AAUA;AACA;AAAA;;;;;;;;;;;;;;AAOA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAhBA;AAAA;AAAA;;AAoBA;;;;;;;;;;;;AArYA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;;AATA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAzfA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAFA;AAEA;AAAA;;;;;;;;;;;;;;;;;AAy+DA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAbA;AAAA;AAAA;;AAgBA;AAAA;;;;;;;;;;;;;;;AAr/DA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAFA;AAEA;AAAA;;;;;;;;;;;;AArCA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AACA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;AAhBA;AAAA;;AAAA;AAMA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAklFA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAuJA;AAAA;;AApJA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAoJA;AAAA;;AAjJA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAFA;;AAaA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;AAnBA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyHA;AAAA;;AAxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuGA;AAAA;;AApGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAXA;AAAA;AAAA;;AAcA;AAAA;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AARA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;;AAUA;AAAA;AAAA;AAAA;AAAA;;AAuBA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;AAtBA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;;;AAiBA;AAAA;;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;;;AASA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;AAMA;AAAA;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AA1FA;AAAA;AAAA;;AA8FA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;;AAlmBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AA8BA;AAAA;;AA7BA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AACA;;AAKA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAIA;AAAA;AAAA;AAAA;;;AArBA;AA0BA;AAAA;;;AAzBA;AAyBA;AAAA;;;AAPA;AAOA;AAAA;;;AAHA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AACA;AAAA;;;;;;;;;;AA8YA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAhYA;AAAA;;;;;;;;;;;;;;;;;AAQA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAiBA;AAAA;;AAdA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAsJA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;;AAGA;AAAA;;;;;;;;;;AA+MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AArgEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAi5CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA+BA;AAAA;;AA9BA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;;AAMA;AAwBA;AAAA;;;AAvBA;AAAA;AAuBA;AAAA;;;AAtBA;AAAA;AAsBA;AAAA;;;AAhBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AASA;AAAA;;AAPA;;AAAA;AAAA;AAOA;AAAA;;AANA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AADA;AAAA;AAMA;AAAA;;;AADA;AACA;AAAA;;;;;AAhCA;AAAA;AAgCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhSA;AAAA;AACA;AAAA;AAAA;AAAA;AA2DA;AAAA;AAAA;AAAA;;;AAvDA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAVA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAGA;AAyGA;AAAA;;;AAlGA;AAkGA;AAAA;;;AA7FA;AA6FA;AAAA;;;AAzFA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AArBA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAYA;AA6EA;AAAA;;;AApEA;AAoEA;AAAA;;;AA/DA;AA+DA;AAAA;;;;AA1DA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAdA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAKA;AA8CA;AAAA;;;AA1CA;AA0CA;AAAA;;;AArCA;AAqCA;AAAA;;;AAhCA;AAgCA;AAAA;;;AA7BA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAJA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AArBA;AAAA;AAAA;;AADA;AAAA;AAAA;;;AAaA;AAgBA;AAAA;;;AARA;AAQA;AAAA;;;AAHA;AAGA;AAAA;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;;AAeA;;AAZA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AAYA;;;;;;;;;AA/JA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;;AAJA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;AArtBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AA2CA;AAAA;;AAxCA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AANA;AAAA;;;;;AACA;AAAA;AAAA;;;AAQA;AAAA;;;;;;;AAbA;AAAA;AAeA;AAAA;;;AADA;AACA;AAAA;;;;;;;;;;;;;AAlLA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;AACA;;AARA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAOA;;;;;;;;;;;;;;;;;AA2KA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAmBA;AAAA;;AAjBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAkHA;AAAA;;AAhHA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AACA;AA2GA;AAAA;;AAxGA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAXA;;;;AAOA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;;;;;;AAlBA;AAAA;AAwFA;AAAA;;AAnFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAcA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;;;;AARA;AAAA;AAAA;;;AAYA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAOA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAEA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AASA;AAAA;;;;;AAIA;AAAA;AAAA;;;AAZA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;;;;;;AA1CA;AAAA;AA8CA;AAAA;;;AA/BA;AAAA;AA+BA;AAAA;;;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;AA5SA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAiCA;AAAA;;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AAAA;;;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;AAHA;AAAA;;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAcA;AAAA;;AAXA;AAAA;AAAA;AAAA;AAAA;;AACA;AAUA;AAAA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAJA;AAAA;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;AAfA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;AA03BA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;AA47CA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;;AACA;AAAA;AAEA;AAAA;;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAymBA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AAAA;;AAxBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAWA;AAAA;;;;AATA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtMA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AA6JA;AAAA;;AA3JA;AAAA;;AAAA;AA2JA;AAAA;;;AAxJA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAEA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAhFA;AAAA;;;;;AACA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAYA;AAAA;;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;;;;;;;;;;;AAUA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AACA;AAAA;;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;;;;AACA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AA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;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA+BA;AAAA;;AA5BA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AApBA;AAAA;AAAA;;;AAqBA;AAAA;;AAKA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;AAAA;AAAA;AAqCA;AAAA;;AApCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA+BA;AAAA;;AA5BA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AApBA;AAAA;AAAA;;;AAqBA;AAAA;;AAKA;AACA;AAAA;AACA;AAAA;;;;;;;;;AAumFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA7uFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AA/BA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAUA;AAAA;;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAigGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAIA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCA;AAAA;;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAHA;AAAA;AAAA;;AADA;AAAA;;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAzBA;AAAA;AAAA;;;AAYA;AAAA;AACA;AAkBA;AAAA;;;AAHA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;AA6BA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AACA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAWA;;;AANA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;;;;;;;;;;;;;;AA7CA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AACA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAWA;;;AANA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;;;;;;;;;;;;;AAgFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAkCA;;AA3BA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAEA;;;AAgBA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAQA;;;AAxBA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAwBA;;;;;;;;;;;;;;;;;;;AAzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AA6BA;AAAA;;AA1BA;AAAA;AAEA;AAAA;AACA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;;;AAQA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AANA;AAAA;AAAA;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjVA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAiMA;AAAA;;AA/LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAAA;AAAA;AA0LA;AAAA;;AAxLA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;AAGA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;;;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AARA;AAAA;AAAA;;AAYA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAVA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAQA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAkBA;AAAA;AAAA;AAAA;;;;;AAKA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAMA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AArCA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AAEA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;AArEA;AAAA;AAAA;;;AAMA;AAAA;AAkLA;AAAA;;;AA/KA;AAAA;;;AA8DA;AAAA;;;AA8BA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAQA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAA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","sourcesContent":["#pragma once\r\n\r\n// vector 2 \r\n\r\nintrospect() struct Vec2\r\n{\r\nfloat x;\r\nfloat y;\r\n\r\nignore Vec2& operator+=(const Vec2& rhs);\r\nignore Vec2& operator-=(const Vec2& rhs);\r\nignore friend Vec2 operator+(Vec2 lhs, const Vec2& rhs);\r\nignore friend Vec2 operator-(Vec2 lhs, const Vec2& rhs);\r\n\r\n// ignore Vec2 operator+=(const float rhs);\r\n\r\nignore Vec2& operator*=(const float s);\r\nignore Vec2& operator*=(const int s);\r\nignore Vec2& operator/=(const float s);\r\nignore Vec2& operator/=(const int s);\r\n\r\nignore Vec2 operator*(const float s);\r\nignore Vec2 operator*(const int s);\r\n\r\nignore Vec2 operator/(const float s);\r\nignore Vec2 operator/(const int s);\r\n\r\nignore float length();\r\n\r\nignore void normalizeInPlace();\r\nignore void safeNormalizeInPlace();\r\nignore Vec2 normalize();\r\n};\r\n\r\n\r\nstatic Vec2 rotateVec(Vec2* vec, float theta)\r\n{\r\nfloat cs = cos(theta);\r\nfloat sn = sin(theta);\r\n\r\nfloat x = vec->x * cs - vec->y * sn;\r\nfloat y = vec->x * sn + vec->y * cs;\r\n\r\nreturn \t{ x, y };\r\n}\r\n\r\nVec2 Vec2::operator/(const float s)\r\n{\r\nreturn { x / s, y / s };\r\n}\r\n\r\nVec2 Vec2::operator/(const int s)\r\n{\r\nreturn { x / s, y / s };\r\n}\r\n\r\nVec2 Vec2::operator*(const float s)\r\n{\r\nreturn { x * s, y * s };\r\n}\r\n\r\nVec2 Vec2::operator*(const int s)\r\n{\r\nreturn { x * s, y * s };\r\n}\r\n\r\n\r\nvoid Vec2::normalizeInPlace()\r\n{\r\nfloat x = (this->x);\r\nfloat y = (this->y);\r\nfloat l = sqrt(x * x + y * y);\r\n\r\nthis->x /= l;\r\nthis->y /= l;\r\n}\r\n\r\nvoid Vec2::safeNormalizeInPlace()\r\n{\r\n\tif (this->x == 0.f && this->y == 0.f)\r\n\t\treturn;\r\n\r\n\tfloat x = (this->x);\r\n\tfloat y = (this->y);\r\n\tfloat l = sqrt(x * x + y * y);\r\n\r\n\tthis->x /= l;\r\n\tthis->y /= l;\r\n}\r\n// täällä ei pelätä vaaroja!\r\nVec2 Vec2::normalize()\r\n{\r\n\tfloat x = (this->x);\r\n\tfloat y = (this->y);\r\n\tfloat l = sqrt(x * x + y * y);\r\n\r\n\treturn { x / l, y / l };\r\n}\r\n\r\nVec2& Vec2::operator+=(const Vec2& rhs)\r\n{\r\n\tx += rhs.x;\t\ty += rhs.y;\r\n\treturn *this;\r\n}\r\n\r\nVec2& Vec2::operator-=(const Vec2& rhs)\r\n{\r\n\tx -= rhs.x;\t\ty -= rhs.y;\r\n\treturn *this;\r\n}\r\n\r\nVec2 operator+(Vec2 lhs, const Vec2& rhs)\r\n{\r\n\treturn { lhs.x + rhs.x, lhs.y + rhs.y };\r\n}\r\n\r\nVec2 operator-(Vec2 lhs, const Vec2& rhs)\r\n{\r\n\treturn { lhs.x - rhs.x, lhs.y - rhs.y };\r\n}\r\n\r\n\r\n\r\nVec2& Vec2::operator*=(const float s)\r\n{\r\n\tx *= s;\r\n\ty *= s;\r\n\treturn *this;\r\n}\r\n\r\nVec2& Vec2::operator*=(const int s)\r\n{\r\n\tx *= s;\r\n\ty *= s;\r\n\treturn *this;\r\n}\r\nVec2& Vec2::operator/=(const float s)\r\n{\r\n\tx /= s;\r\n\ty /= s;\r\n\treturn *this;\r\n}\r\n\r\nVec2& Vec2::operator/=(const int s)\r\n{\r\n\tx /= s;\r\n\ty /= s;\r\n\treturn *this;\r\n}\r\n\r\nfloat Vec2::length()\r\n{\r\n\tfloat x = abs(this->x);\r\n\tfloat y = abs(this->y);\r\n\treturn sqrt(x * x + y * y);\r\n}\r\n\r\n","#pragma once\r\n\r\nstruct CameraState\r\n{\r\n\tVec2  position;\r\n\tfloat scale;\r\n\tbool needUpdate;\r\n};\r\n\r\nstruct Sprites\r\n{\r\n\tVec2* positions;\r\n\tVec2* sizes;\r\n\tvec4* uvs;\r\n\tvec4* colors;\r\n\tint* ids;\r\n\tfloat* rotation;\r\n\r\n\tunsigned int count;\r\n\t// rotation jne\r\n};\r\n\r\n/// hahaa\r\nstruct GraphicsContext\r\n{\r\n\tbool initted;\r\n\tbool updateViewPort;\r\n\tCameraState camera;\r\n\tSprites sprites;\r\n\tvoid* window;\r\n};\r\n\r\nvoid zoom(CameraState* camera, float factor)\r\n{\r\n\tcamera->scale += factor;\r\n\tcamera->needUpdate = true;\r\n\tif (camera->scale < 0.01f)\r\n\t\tcamera->scale = 0.f;\r\n}\r\n\r\nvoid translate(CameraState* camera, const Vec2& position)\r\n{\r\n\tcamera->needUpdate = true;\r\n\tcamera->position += position;\r\n}\r\n\r\n// camera front\r\n// sprite front\r\n// \r\n","#define _CRT_SECURE_NO_WARNINGS 1\r\n#include \"game.h\"\r\n\r\n\r\nEXPORT INIT_GAME(initGame)\r\n{\r\n\tLOGI(\"game init\\n\");\r\n\r\n\tGraphicsContext* c = &engine->context;\r\n\r\n\tzoom(&c->camera, 1.f);\r\n\t\r\n}\r\n\r\nEXPORT UPDATE_GAME(updateGame)\r\n{\r\n//\tLOGI(\"update \\n\");\r\n}\r\n\r\nEXPORT DRAW_GAME(drawGame)\r\n{\r\n//\tLOGI(\"render \\n\");\r\n}\r\n","// #include <core/IO.h>\r\n// #include <istream>\r\n\r\n#ifndef DLL_FIX\r\n#include <stdio.h>\r\n#include <fstream>\r\n#include <istream>\r\n#include <string>\r\n#endif\r\n\r\n#if defined(_WIN32) || defined(__EMSCRIPTEN__) || defined(_LINUX) || defined(__linux)\r\n// #include <string>\r\n// #include <stdio.h>\r\n// #include <fstream>\r\n#else\r\n#include <core/ResourceManager.h>\r\n#include <android_native_app_glue.h>\r\n#include <android/asset_manager.h>\r\n#include <android/asset_manager_jni.h>\r\n#endif\r\n\r\n// #include <stdlib.h>\r\n// #include <core/Utils.h>\r\n\r\nnamespace engine\r\n{\r\n\tnamespace io\r\n\t{\r\n#if defined(_WIN32) || defined(__EMSCRIPTEN__) ||  defined(_LINUX)\r\n\t\tchar* ReadEntireFile(const char* path)\r\n\t\t{\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfseek(file, 0, SEEK_END);\r\n\t\t\t\tsize_t fileSize = ftell(file);\r\n\t\t\t\tfseek(file, 0, SEEK_SET);\r\n\r\n\t\t\t\tresult = (char *)malloc(fileSize + 1);\r\n\t\t\t\tfread(result, fileSize, 1, file);\r\n\t\t\t\tresult[fileSize] = '\\0';\r\n\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\r\n\t\t\t\tprintf(\"failed  %s path \\n\", path);\r\n\t\t\t\tASSERT(false);\r\n\t\t\t\t// logging\r\n\t\t\t}\r\n\t\t\tprintf(\"%s\\n\", result);\r\n\t\t\treturn result;\r\n\r\n\t\t\t// size_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t}\r\n\r\n\t\tchar* ReadEntireFile(const char* path, int* size)\r\n\t\t{\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfseek(file, 0, SEEK_END);\r\n\t\t\t\tsize_t fileSize = ftell(file);\r\n\t\t\t\tfseek(file, 0, SEEK_SET);\r\n\r\n\t\t\t\tresult = (char *)malloc(fileSize + 1);\r\n\t\t\t\tfread(result, fileSize, 1, file);\r\n\t\t\t\tresult[fileSize] = '\\0';\r\n\r\n\t\t\t\t*size = (int)fileSize;\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tprintf(\"failed  %s path \\n\", path);\r\n\t\t\t\tASSERT(false);\r\n\t\t\t\t// logging\r\n\t\t\t}\r\n\t\t\t// printf(\"%s\\n\", result);\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\r\n\r\n#ifndef DLL_FIX\r\n\t\tstd::string ReadEntireFileToString(const char* path)\r\n\t\t{\r\n#if 0\r\n\t\t\tchar* buffer;\r\n\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfseek(file, 0, SEEK_END);\r\n\t\t\t\tsize_t fileSize = ftell(file);\r\n\t\t\t\tfseek(file, 0, SEEK_SET);\r\n\r\n\t\t\t\tbuffer = (char *)malloc(fileSize + 1);\r\n\t\t\t\tfread(buffer, fileSize, 1, file);\r\n\t\t\t\tbuffer[fileSize] = '\\0';\r\n\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tASSERT(false);\r\n\t\t\t\t// logging\r\n\t\t\t\treturn {};\r\n\t\t\t}\r\n\r\n\t\t\tstd::string result(buffer);\r\n\t\t\tfree(buffer);\r\n\t\t\treturn result;\r\n#else\r\n\t\t\tstd::ifstream ifile(path);\r\n\t\t\t// std::string filetext;\r\n\t\t\t//while (ifile.good()) {\r\n\t\t\t//\tstd::string line;\r\n\t\t\t//\tstd::getline(ifile, line);\r\n\t\t\t//\tfiletext.append(line + \"\\n\");\r\n\t\t\t//}\r\n\r\n\t\t\tstd::FILE *fp = std::fopen(path, \"rb\");\r\n\t\t\tif (fp)\r\n\t\t\t{\r\n\t\t\t\tstd::string contents;\r\n\t\t\t\tstd::fseek(fp, 0, SEEK_END);\r\n\t\t\t\tcontents.resize(std::ftell(fp));\r\n\t\t\t\tstd::rewind(fp);\r\n\t\t\t\tstd::fread(&contents[0], 1, contents.size(), fp);\r\n\t\t\t\tstd::fclose(fp);\r\n\t\t\t\treturn(contents);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLOGI(\"CAN'T read file %s \\n\", path);\r\n\t\t\t\tASSERT(false);\r\n\t\t\t}\r\n\t\t\treturn { \"lol\" };\r\n#endif\r\n\t\t}\r\n#endif\r\n\r\n\r\n\t\tvoid WriteBufferToFile(const char* path, const char* buffer, size_t bufferSize)\r\n\t\t{\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"w\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfwrite(buffer, bufferSize, 1, file);\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tASSERT(false);\r\n\t\t\t}\r\n\r\n\t\t\t// Resource\r\n\t\t}\r\n\r\n#else // _WIN32 android\r\n\t\tchar* ReadEntireFile(const char* path)\r\n\t\t{\r\n\t\t\tAAssetManager* mgr = ResourceManager::assetManager;\r\n\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\r\n\t\t\t// AAsset* file = AssetManager_open(mgr, path, )\r\n\r\n\r\n\t\t\tAAsset* assetDescriptor = AAssetManager_open(mgr,\r\n\t\t\t\tpath,\r\n\t\t\t\tAASSET_MODE_BUFFER);\r\n\r\n\t\t\t// ASSERT(assetDescriptor, \"%s does not exist in %s\",\r\n\t\t\t//\t   assetName.c_str(), __FUNCTION__);\r\n\r\n\t\t\tsize_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t\tresult = (char*)malloc(fileLength * sizeof(char));\r\n\r\n\t\t\t// buf.resize(fileLength);\r\n\t\t\tint64_t readSize = AAsset_read(assetDescriptor, result, fileLength);\r\n\r\n\t\t\tAAsset_close(assetDescriptor);\r\n\r\n\t\t\t// TODO: ASSERT\r\n\t\t\t// return (readSize == buf.size());\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t// TODO: optimiointi mahdollisuuus\r\n\t\tstd::string ReadEntireFileToString(const char* path)\r\n\t\t{\r\n\t\t\tchar* file = ReadEntireFile(path);\r\n\t\t\tstd::string result(file);\r\n\t\t\tfree(file);\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tchar* ReadEntireFile(const char* path, int* sizeOut)\r\n\t\t{\r\n\t\t\tAAssetManager* mgr = ResourceManager::assetManager;\r\n\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\r\n\t\t\t// AAsset* file = AssetManager_open(mgr, path, )\r\n\r\n\r\n\t\t\tAAsset* assetDescriptor = AAssetManager_open(mgr,\r\n\t\t\t\tpath,\r\n\t\t\t\tAASSET_MODE_BUFFER);\r\n\r\n\t\t\t// ASSERT(assetDescriptor, \"%s does not exist in %s\",\r\n\t\t\t//\t   assetName.c_str(), __FUNCTION__);\r\n\r\n\t\t\tsize_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t\tresult = (char*)malloc(fileLength * sizeof(char));\r\n\r\n\t\t\t// buf.resize(fileLength);\r\n\t\t\tint64_t readSize = AAsset_read(assetDescriptor, result, fileLength);\r\n\r\n\t\t\tAAsset_close(assetDescriptor);\r\n\t\t\t*sizeOut = fileLength;\r\n\t\t\t// TODO: ASSERT\r\n\t\t\t// return (readSize == buf.size());\r\n\t\t\treturn result;\r\n\t\t\t}\r\n#endif\r\n\t\t}\r\n\t}\r\n","// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n#endif\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    FILE* __file_;\n    const codecvt<char_type, char, state_type>* __cv_;\n    state_type __st_;\n    state_type __st_last_;\n    ios_base::openmode __om_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    bool __read_mode();\n    void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const char* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = \"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = \"a\";\n            break;\n        case ios_base::in:\n            __mdstr = \"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = \"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = \"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = \"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = \"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = \"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = \"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = \"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = fopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if defined(_WIN32) || defined(_NEWLIB_VERSION)\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if defined(_WIN32) || defined(_NEWLIB_VERSION)\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if defined(_WIN32) || defined(_NEWLIB_VERSION)\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream(basic_ifstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ifstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream();\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream(basic_ofstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ofstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream(basic_fstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_fstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FSTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===--------------------------- istream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ISTREAM\n#define _LIBCPP_ISTREAM\n\n/*\n    istream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_istream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream(basic_istream&& rhs);\n    virtual ~basic_istream();\n\n    // 27.7.1.1.2 Assign/swap:\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream& operator>>(bool& n);\n    basic_istream& operator>>(short& n);\n    basic_istream& operator>>(unsigned short& n);\n    basic_istream& operator>>(int& n);\n    basic_istream& operator>>(unsigned int& n);\n    basic_istream& operator>>(long& n);\n    basic_istream& operator>>(unsigned long& n);\n    basic_istream& operator>>(long long& n);\n    basic_istream& operator>>(unsigned long long& n);\n    basic_istream& operator>>(float& f);\n    basic_istream& operator>>(double& f);\n    basic_istream& operator>>(long double& f);\n    basic_istream& operator>>(void*& p);\n\n    // 27.7.1.3 Unformatted input:\n    streamsize gcount() const;\n    int_type get();\n    basic_istream& get(char_type& c);\n    basic_istream& get(char_type* s, streamsize n);\n    basic_istream& get(char_type* s, streamsize n, char_type delim);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);\n\n    basic_istream& getline(char_type* s, streamsize n);\n    basic_istream& getline(char_type* s, streamsize n, char_type delim);\n\n    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* s, streamsize n);\n    streamsize readsome(char_type* s, streamsize n);\n\n    basic_istream& putback(char_type c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type);\n    basic_istream& seekg(off_type, ios_base::seekdir);\nprotected:\n    basic_istream(const basic_istream& rhs) = delete;\n    basic_istream(basic_istream&& rhs);\n    // 27.7.2.1.2 Assign/swap:\n    basic_istream& operator=(const basic_istream& rhs) = delete;\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n};\n\n// 27.7.1.2.3 character extraction templates:\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);\n\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);\n\ntypedef basic_istream<char> istream;\ntypedef basic_istream<wchar_t> wistream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_iostream :\n    public basic_istream<charT,traits>,\n    public basic_ostream<charT,traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);\n    basic_iostream(basic_iostream&& rhs);\n    virtual ~basic_iostream();\n\n    // assign/swap\n    basic_iostream& operator=(basic_iostream&& rhs);\n    void swap(basic_iostream& rhs);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);\n\ntypedef basic_iostream<char> iostream;\ntypedef basic_iostream<wchar_t> wiostream;\n\ntemplate <class charT, class traits>\n  basic_istream<charT,traits>&\n  ws(basic_istream<charT,traits>& is);\n\ntemplate <class charT, class traits, class T>\n  basic_istream<charT, traits>&\n  operator>>(basic_istream<charT, traits>&& is, T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istream\n    : virtual public basic_ios<_CharT, _Traits>\n{\n    streamsize __gc_;\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_istream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream(basic_istream&& __rhs);\n#endif\n    // 27.7.1.1.2 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream& operator=(basic_istream&& __rhs);\n#endif\n    void swap(basic_istream& __rhs);\n\n#if _LIBCPP_STD_VER > 11\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    basic_istream           (const basic_istream& __rhs) = delete;\n    basic_istream& operator=(const basic_istream& __rhs) = delete;\n#else\n    basic_istream           (const basic_istream& __rhs); // not defined\n    basic_istream& operator=(const basic_istream& __rhs); // not defined\n#endif\n#endif\npublic:\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*__pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);\n    basic_istream& operator>>(bool& __n);\n    basic_istream& operator>>(short& __n);\n    basic_istream& operator>>(unsigned short& __n);\n    basic_istream& operator>>(int& __n);\n    basic_istream& operator>>(unsigned int& __n);\n    basic_istream& operator>>(long& __n);\n    basic_istream& operator>>(unsigned long& __n);\n    basic_istream& operator>>(long long& __n);\n    basic_istream& operator>>(unsigned long long& __n);\n    basic_istream& operator>>(float& __f);\n    basic_istream& operator>>(double& __f);\n    basic_istream& operator>>(long double& __f);\n    basic_istream& operator>>(void*& __p);\n\n    // 27.7.1.3 Unformatted input:\n    _LIBCPP_INLINE_VISIBILITY\n    streamsize gcount() const {return __gc_;}\n    int_type get();\n    basic_istream& get(char_type& __c);\n    basic_istream& get(char_type* __s, streamsize __n);\n    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb);\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);\n\n    basic_istream& getline(char_type* __s, streamsize __n);\n    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);\n\n    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* __s, streamsize __n);\n    streamsize readsome(char_type* __s, streamsize __n);\n\n    basic_istream& putback(char_type __c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type __pos);\n    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n//    ~sentry() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,\n                                               bool __noskipws)\n    : __ok_(false)\n{\n    if (__is.good())\n    {\n        if (__is.tie())\n            __is.tie()->flush();\n        if (!__noskipws && (__is.flags() & ios_base::skipws))\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            _Ip __i(__is);\n            _Ip __eof;\n            for (; __i != __eof; ++__i)\n                if (!__ct.is(__ct.space, *__i))\n                    break;\n            if (__i == __eof)\n                __is.setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        __ok_ = __is.good();\n    }\n    else\n        __is.setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>::basic_istream(basic_streambuf<char_type, traits_type>* __sb)\n    : __gc_(0)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)\n    : __gc_(__rhs.__gc_)\n{\n    __rhs.__gc_ = 0;\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::~basic_istream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istream<_CharT, _Traits>::swap(basic_istream& __rhs)\n{\n    _VSTD::swap(__gc_, __rhs.__gc_);\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(float& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<short>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::min();\n            }\n            else if (__temp > numeric_limits<short>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::max();\n            }\n            else\n                __n = static_cast<short>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<int>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::min();\n            }\n            else if (__temp > numeric_limits<int>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::max();\n            }\n            else\n                __n = static_cast<int>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_istream& (*__pf)(basic_istream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type, traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n-1)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                *__s++ = __ch;\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            *__s = _CharT();\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n            if (_Traits::eq_int_type(__i, _Traits::eof()))\n                __is.setstate(ios_base::eofbit | ios_base::failbit);\n            else\n                __c = _Traits::to_char_type(__i);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    ios_base::iostate __err = ios_base::goodbit;\n                    while (true)\n                    {\n                        typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                        if (traits_type::eq_int_type(__i, _Traits::eof()))\n                        {\n                           __err |= ios_base::eofbit;\n                           break;\n                        }\n                        if (traits_type::eq_int_type(\n                                __sb->sputc(traits_type::to_char_type(__i)),\n                                traits_type::eof()))\n                            break;\n                        ++__gc_;\n                        this->rdbuf()->sbumpc();\n                    }\n                    if (__gc_ == 0)\n                       __err |= ios_base::failbit;\n                    this->setstate(__err);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    if (__gc_ == 0)\n                        this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::get()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            __r = this->rdbuf()->sbumpc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n               this->setstate(ios_base::failbit | ios_base::eofbit);\n            else\n                __gc_ = 1;\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type& __c)\n{\n    int_type __ch = get();\n    if (__ch != traits_type::eof())\n        __c = traits_type::to_char_type(__ch);\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (__n > 0)\n            {\n                ios_base::iostate __err = ios_base::goodbit;\n                while (__gc_ < __n-1)\n                {\n                    int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    *__s++ = __ch;\n                    ++__gc_;\n                     this->rdbuf()->sbumpc();\n                }\n                *__s = char_type();\n                if (__gc_ == 0)\n                   __err |= ios_base::failbit;\n                this->setstate(__err);\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n)\n{\n    return get(__s, __n, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,\n                                    char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))\n                        break;\n                    ++__gc_;\n                    this->rdbuf()->sbumpc();\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb)\n{\n    return get(__sb, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            while (true)\n            {\n                typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                if (traits_type::eq_int_type(__i, traits_type::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                char_type __ch = traits_type::to_char_type(__i);\n                if (traits_type::eq(__ch, __dlm))\n                {\n                    this->rdbuf()->sbumpc();\n                    ++__gc_;\n                    break;\n                }\n                if (__gc_ >= __n-1)\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n                *__s++ = __ch;\n                this->rdbuf()->sbumpc();\n                ++__gc_;\n            }\n            if (__n > 0)\n                *__s = char_type();\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n)\n{\n    return getline(__s, __n, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            if (__n == numeric_limits<streamsize>::max())\n            {\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            else\n            {\n                while (__gc_ < __n)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::peek()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __r = this->rdbuf()->sgetc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n                this->setstate(ios_base::eofbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __gc_ = this->rdbuf()->sgetn(__s, __n);\n            if (__gc_ != __n)\n                this->setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nstreamsize\nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n    streamsize __c = this->rdbuf()->in_avail();\n    switch (__c)\n    {\n    case -1:\n        this->setstate(ios_base::eofbit);\n        break;\n    case 0:\n        break;\n    default:\n        read(__s, _VSTD::min(__c, __n));\n        break;\n    }\n    return __gc_;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::putback(char_type __c)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::unget()\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nint\nbasic_istream<_CharT, _Traits>::sync()\n{\n    int __r = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0)\n                return -1;\n            if (this->rdbuf()->pubsync() == -1)\n            {\n                this->setstate(ios_base::badbit);\n                return -1;\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::pos_type\nbasic_istream<_CharT, _Traits>::tellg()\n{\n    pos_type __r(-1);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nws(basic_istream<_CharT, _Traits>& __is)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __is.setstate(ios_base::eofbit);\n                   break;\n                }\n                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))\n                    break;\n                __is.rdbuf()->sbumpc();\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)\n{\n    __is >> __x;\n    return __is;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_iostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_iostream(basic_iostream&& __rhs);\n#endif\n\n    // assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_iostream& operator=(basic_iostream&& __rhs);\n#endif\n    void swap(basic_iostream& __rhs);\npublic:\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_streambuf<char_type, traits_type>* __sb)\n    : basic_istream<_CharT, _Traits>(__sb)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>&\nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::~basic_iostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_iostream<_CharT, _Traits>::swap(basic_iostream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            __str.clear();\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = __str.max_size();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max();\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            __str.clear();\n            ios_base::iostate __err = ios_base::goodbit;\n            streamsize __extr = 0;\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                ++__extr;\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (_Traits::eq(__ch, __dlm))\n                    break;\n                __str.push_back(__ch);\n                if (__str.size() == __str.max_size())\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n            }\n            if (__extr == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n    return getline(__is, __str, __dlm);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            basic_string<_CharT, _Traits> __str;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            streamsize __c = 0;\n            ios_base::iostate __err = ios_base::goodbit;\n            _CharT __zero = __ct.widen('0');\n            _CharT __one = __ct.widen('1');\n            while (__c < _Size)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __x = bitset<_Size>(__str);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_istream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_istream<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_iostream<char>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ISTREAM\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());             \n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? 0 : memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return __n == 0 ? NULL : (const char_type*) memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return __n == 0 ? NULL : (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag()).first;\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value\n             || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n\tbasic_string __temp (__first, __last, __alloc());\n\tappend(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n          && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n#include <__undef___deallocate>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            throw bad_alloc();\n#else\n            assert(!\"allocator<T>::allocate::bad_alloc\");\n#endif\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            throw bad_alloc();\n#else\n            assert(!\"allocator<const T>::allocate::bad_alloc\");\n#endif\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n            {\n                __e->__weak_this_.__ptr_ = const_cast<_Yp*>(static_cast<const _Yp*>(__e));\n                __e->__weak_this_.__cntrl_ = __cntrl_;\n                __cntrl_->__add_weak();\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY pair;\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TYPE_VIS_ONLY __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#if __has_builtin(__builtin_addressof)\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#endif // __has_builtin(__builtin_addressof)\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : std::integral_constant<bool,\n    !std::is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<const _T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2 {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n    typedef typename common_type<\n        typename common_type<_Tp, _Up>::type, _Vp...\n    >::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(_VSTD::__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TYPE_VIS_ONLY is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TYPE_VIS_ONLY is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    typedef decltype(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>())) __swap1;\n    typedef decltype(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>())) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = std::is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS_ONLY char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS_ONLY allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS_ONLY fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n#if defined(_NEWLIB_VERSION)\n// On newlib, off_t is 'long int'\ntypedef long int streamoff;         // for char_traits in <string>\n#else\ntypedef long long streamoff;        // for char_traits in <string>\n#endif\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n\n// Include other forward declarations here\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","#include <graphics/Shader.h>\r\n\r\n#include <fstream>\r\n\r\nnamespace engine {\r\n}\r\n\r\nvoid checkCompileErrors(unsigned shader, std::string type, const char* shaderName)\r\n{\r\n\tint success;\r\n\tchar infoLog[1024];\r\n\tif (type != \"PROGRAM\")\r\n\t{\r\n\t\tglGetShaderiv(shader, GL_COMPILE_STATUS, &success);\r\n\t\tif (!success)\r\n\t\t{\r\n\t\t\tglGetShaderInfoLog(shader, 1024, NULL, infoLog);\r\n\t\t\tLOGI(\"ERROR::SHADER_COMPILATION_ERROR of type: %s \\n %s \\n\", type.c_str(), infoLog);\r\n            LOGI(\"In shader %s\\n\", shaderName);\r\n\t\t\tASSERT(false);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tglGetProgramiv(shader, GL_LINK_STATUS, &success);\r\n\t\tif (!success)\r\n\t\t{\r\n\t\t\tglGetProgramInfoLog(shader, 1024, NULL, infoLog);\r\n\t\t\tLOGI(\"ERROR::PROGRAM_LINKING_ERROR of type: %s \\n %s \\n\", type.c_str(), infoLog);\r\n            LOGI(\"In shader %s\\n\", shaderName);\r\n\t\t\tASSERT(false);\r\n\t\t}\r\n\t}\r\n}\r\n","#pragma once\r\n\r\n#include <chrono>\r\n#include \"../platform.h\"\r\n#include \"graphicsF.h\"\r\n#include \"shader.cpp\"\r\n\r\nconstexpr int MAX_SPRITES = 500001;\r\nstruct VertexData\r\n{\r\n\tfloat pos[MAX_SPRITES * 16];\r\n\tfloat uvs[MAX_SPRITES * 8];\r\n\tfloat ids[MAX_SPRITES * 4];\r\n\tfloat rot[MAX_SPRITES * 4];\r\n\tunsigned int colors[MAX_SPRITES * 4];\r\n\tint textureSlots[32];\r\n\tunsigned int slotCount;\r\n\tunsigned int indicesCount;\r\n};\r\n\r\nstruct SpriteBatch\r\n{\r\n\tunsigned int VAO;\r\n\tunsigned int buffers[6];\r\n\tengine::Shader shader;\r\n\tVertexData vertexData;\r\n};\r\n\r\nstruct Camera2D\r\n{\r\n\tglm::mat4 cameraMatrix;\r\n\tglm::mat4 orthoMatrix;\r\n};\r\n\r\nEXPORT INIT_GAME(initGraphics);\r\nEXPORT UPDATE_GAME(updateGraphics);\r\nEXPORT DRAW_GAME(drawGraphics);\r\n\r\n\r\n#define _DEBUG 0\r\n#if defined(_DEBUG)\r\n#define glCheckError()  glCheckError__(__FILE__, __LINE__) \r\n#else\r\n#define glCheckError()\r\n#endif\r\n\r\nGLenum glCheckError__(const char *file, int line)\r\n{\r\n\tGLenum errorCode;\r\n\twhile ((errorCode = glGetError()) != GL_NO_ERROR)\r\n\t{\r\n\t\tstd::string error;\r\n\t\tswitch (errorCode)\r\n\t\t{\r\n\t\tcase GL_INVALID_ENUM:                  error = \"INVALID_ENUM\"; break;\r\n\t\tcase GL_INVALID_VALUE:                 error = \"INVALID_VALUE\"; break;\r\n\t\tcase GL_INVALID_OPERATION:             error = \"INVALID_OPERATION\"; break;\r\n\t\t\t// case GL_STACK_OVERFLOW:                error = \"STACK_OVERFLOW\"; break;\r\n\t\t\t// case GL_STACK_UNDERFLOW:               error = \"STACK_UNDERFLOW\"; break;\r\n\t\tcase GL_OUT_OF_MEMORY:                 error = \"OUT_OF_MEMORY\"; break;\r\n\t\tcase GL_INVALID_FRAMEBUFFER_OPERATION: error = \"INVALID_FRAMEBUFFER_OPERATION\"; break;\r\n\t\t}\r\n\t\tLOGI(\"%s | %s (%i)\\n\", error.c_str(), file, line);\r\n\t}\r\n\treturn errorCode;\r\n}\r\n","/* stb_image - v2.16 - public domain image loader - http://nothings.org/stb_image.h\r\n                                     no warranty implied; use at your own risk\r\n\r\n   Do this:\r\n      #define STB_IMAGE_IMPLEMENTATION\r\n   before you include this file in *one* C or C++ file to create the implementation.\r\n\r\n   // i.e. it should look like this:\r\n   #include ...\r\n   #include ...\r\n   #include ...\r\n   #define STB_IMAGE_IMPLEMENTATION\r\n   #include \"stb_image.h\"\r\n\r\n   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.\r\n   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free\r\n\r\n\r\n   QUICK NOTES:\r\n      Primarily of interest to game developers and other people who can\r\n          avoid problematic images and only need the trivial interface\r\n\r\n      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)\r\n      PNG 1/2/4/8/16-bit-per-channel\r\n\r\n      TGA (not sure what subset, if a subset)\r\n      BMP non-1bpp, non-RLE\r\n      PSD (composited view only, no extra channels, 8/16 bit-per-channel)\r\n\r\n      GIF (*comp always reports as 4-channel)\r\n      HDR (radiance rgbE format)\r\n      PIC (Softimage PIC)\r\n      PNM (PPM and PGM binary only)\r\n\r\n      Animated GIF still needs a proper API, but here's one way to do it:\r\n          http://gist.github.com/urraka/685d9a6340b26b830d49\r\n\r\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\r\n      - decode from arbitrary I/O callbacks\r\n      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)\r\n\r\n   Full documentation under \"DOCUMENTATION\" below.\r\n\r\n\r\nLICENSE\r\n\r\n  See end of file for license information.\r\n\r\nRECENT REVISION HISTORY:\r\n\r\n      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes\r\n      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC\r\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\r\n      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes\r\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\r\n      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64\r\n                         RGB-format JPEG; remove white matting in PSD;\r\n                         allocate large structures on the stack;\r\n                         correct channel count for PNG & BMP\r\n      2.10  (2016-01-22) avoid warning introduced in 2.09\r\n      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED\r\n\r\n   See end of file for full revision history.\r\n\r\n\r\n ============================    Contributors    =========================\r\n\r\n Image formats                          Extensions, features\r\n    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)\r\n    Nicolas Schulz (hdr, psd)              Martin \"SpartanJ\" Golini (stbi_info)\r\n    Jonathan Dummer (tga)                  James \"moose2000\" Brown (iPhone PNG)\r\n    Jean-Marc Lienher (gif)                Ben \"Disch\" Wenger (io callbacks)\r\n    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)\r\n    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)\r\n    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)\r\n    github:urraka (animated gif)           Junggon Kim (PNM comments)\r\n                                           Daniel Gibson (16-bit TGA)\r\n                                           socks-the-fox (16-bit PNG)\r\n                                           Jeremy Sawicki (handle all ImageNet JPGs)\r\n Optimizations & bugfixes\r\n    Fabian \"ryg\" Giesen\r\n    Arseny Kapoulkine\r\n    John-Mark Allen\r\n\r\n Bug & warning fixes\r\n    Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko\r\n    Christpher Lloyd        Jerry Jansson      Joseph Thomson     Phil Jordan\r\n    Dave Moore              Roy Eltham         Hayaki Saito       Nathan Reed\r\n    Won Chun                Luke Graham        Johan Duparc       Nick Verigakis\r\n    the Horde3D community   Thomas Ruf         Ronny Chevalier    Baldur Karlsson\r\n    Janez Zemva             John Bartholomew   Michal Cichon      github:rlyeh\r\n    Jonathan Blow           Ken Hamada         Tero Hanninen      github:romigrou\r\n    Laurent Gomila          Cort Stratton      Sergio Gonzalez    github:svdijk\r\n    Aruelien Pocheville     Thibault Reuille   Cass Everitt       github:snagar\r\n    Ryamond Barbiero        Paul Du Bois       Engin Manap        github:Zelex\r\n    Michaelangel007@github  Philipp Wiesemann  Dale Weiler        github:grim210\r\n    Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:sammyhw\r\n    Blazej Dariusz Roszkowski                  Gregory Mullen     github:phprus\r\n    Christian Floisand      Kevin Schmidt                         github:poppolopoppo\r\n*/\r\n\r\n#ifndef STBI_INCLUDE_STB_IMAGE_H\r\n#define STBI_INCLUDE_STB_IMAGE_H\r\n\r\n// DOCUMENTATION\r\n//\r\n// Limitations:\r\n//    - no 16-bit-per-channel PNG\r\n//    - no 12-bit-per-channel JPEG\r\n//    - no JPEGs with arithmetic coding\r\n//    - no 1-bit BMP\r\n//    - GIF always returns *comp=4\r\n//\r\n// Basic usage (see HDR discussion below for HDR usage):\r\n//    int x,y,n;\r\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\r\n//    // ... process data if not NULL ...\r\n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\r\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\r\n//    // ... but 'n' will always be the number that it would have been if you said 0\r\n//    stbi_image_free(data)\r\n//\r\n// Standard parameters:\r\n//    int *x                 -- outputs image width in pixels\r\n//    int *y                 -- outputs image height in pixels\r\n//    int *channels_in_file  -- outputs # of image components in image file\r\n//    int desired_channels   -- if non-zero, # of image components requested in result\r\n//\r\n// The return value from an image loader is an 'unsigned char *' which points\r\n// to the pixel data, or NULL on an allocation failure or if the image is\r\n// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,\r\n// with each pixel consisting of N interleaved 8-bit components; the first\r\n// pixel pointed to is top-left-most in the image. There is no padding between\r\n// image scanlines or between pixels, regardless of format. The number of\r\n// components N is 'desired_channels' if desired_channels is non-zero, or\r\n// *channels_in_file otherwise. If desired_channels is non-zero,\r\n// *channels_in_file has the number of components that _would_ have been\r\n// output otherwise. E.g. if you set desired_channels to 4, you will always\r\n// get RGBA output, but you can check *channels_in_file to see if it's trivially\r\n// opaque because e.g. there were only 3 channels in the source image.\r\n//\r\n// An output image with N components has the following components interleaved\r\n// in this order in each pixel:\r\n//\r\n//     N=#comp     components\r\n//       1           grey\r\n//       2           grey, alpha\r\n//       3           red, green, blue\r\n//       4           red, green, blue, alpha\r\n//\r\n// If image loading fails for any reason, the return value will be NULL,\r\n// and *x, *y, *channels_in_file will be unchanged. The function\r\n// stbi_failure_reason() can be queried for an extremely brief, end-user\r\n// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS\r\n// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\r\n// more user-friendly ones.\r\n//\r\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\r\n//\r\n// ===========================================================================\r\n//\r\n// Philosophy\r\n//\r\n// stb libraries are designed with the following priorities:\r\n//\r\n//    1. easy to use\r\n//    2. easy to maintain\r\n//    3. good performance\r\n//\r\n// Sometimes I let \"good performance\" creep up in priority over \"easy to maintain\",\r\n// and for best performance I may provide less-easy-to-use APIs that give higher\r\n// performance, in addition to the easy to use ones. Nevertheless, it's important\r\n// to keep in mind that from the standpoint of you, a client of this library,\r\n// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.\r\n//\r\n// Some secondary priorities arise directly from the first two, some of which\r\n// make more explicit reasons why performance can't be emphasized.\r\n//\r\n//    - Portable (\"ease of use\")\r\n//    - Small source code footprint (\"easy to maintain\")\r\n//    - No dependencies (\"ease of use\")\r\n//\r\n// ===========================================================================\r\n//\r\n// I/O callbacks\r\n//\r\n// I/O callbacks allow you to read from arbitrary sources, like packaged\r\n// files or some other source. Data read from callbacks are processed\r\n// through a small internal buffer (currently 128 bytes) to try to reduce\r\n// overhead.\r\n//\r\n// The three functions you must define are \"read\" (reads some bytes of data),\r\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\r\n//\r\n// ===========================================================================\r\n//\r\n// SIMD support\r\n//\r\n// The JPEG decoder will try to automatically use SIMD kernels on x86 when\r\n// supported by the compiler. For ARM Neon support, you must explicitly\r\n// request it.\r\n//\r\n// (The old do-it-yourself SIMD API is no longer supported in the current\r\n// code.)\r\n//\r\n// On x86, SSE2 will automatically be used when available based on a run-time\r\n// test; if not, the generic C versions are used as a fall-back. On ARM targets,\r\n// the typical path is to have separate builds for NEON and non-NEON devices\r\n// (at least this is true for iOS and Android). Therefore, the NEON support is\r\n// toggled by a build flag: define STBI_NEON to get NEON loops.\r\n//\r\n// If for some reason you do not want to use any of SIMD code, or if\r\n// you have issues compiling it, you can disable it entirely by\r\n// defining STBI_NO_SIMD.\r\n//\r\n// ===========================================================================\r\n//\r\n// HDR image support   (disable by defining STBI_NO_HDR)\r\n//\r\n// stb_image now supports loading HDR images in general, and currently\r\n// the Radiance .HDR file format, although the support is provided\r\n// generically. You can still load any file through the existing interface;\r\n// if you attempt to load an HDR file, it will be automatically remapped to\r\n// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\r\n// both of these constants can be reconfigured through this interface:\r\n//\r\n//     stbi_hdr_to_ldr_gamma(2.2f);\r\n//     stbi_hdr_to_ldr_scale(1.0f);\r\n//\r\n// (note, do not use _inverse_ constants; stbi_image will invert them\r\n// appropriately).\r\n//\r\n// Additionally, there is a new, parallel interface for loading files as\r\n// (linear) floats to preserve the full dynamic range:\r\n//\r\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\r\n//\r\n// If you load LDR images through this interface, those images will\r\n// be promoted to floating point values, run through the inverse of\r\n// constants corresponding to the above:\r\n//\r\n//     stbi_ldr_to_hdr_scale(1.0f);\r\n//     stbi_ldr_to_hdr_gamma(2.2f);\r\n//\r\n// Finally, given a filename (or an open file or memory block--see header\r\n// file for details) containing image data, you can query for the \"most\r\n// appropriate\" interface to use (that is, whether the image is HDR or\r\n// not), using:\r\n//\r\n//     stbi_is_hdr(char *filename);\r\n//\r\n// ===========================================================================\r\n//\r\n// iPhone PNG support:\r\n//\r\n// By default we convert iphone-formatted PNGs back to RGB, even though\r\n// they are internally encoded differently. You can disable this conversion\r\n// by by calling stbi_convert_iphone_png_to_rgb(0), in which case\r\n// you will always just get the native iphone \"format\" through (which\r\n// is BGR stored in RGB).\r\n//\r\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\r\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\r\n// says there's premultiplied data (currently only happens in iPhone images,\r\n// and only if iPhone convert-to-rgb processing is on).\r\n//\r\n// ===========================================================================\r\n//\r\n// ADDITIONAL CONFIGURATION\r\n//\r\n//  - You can suppress implementation of any of the decoders to reduce\r\n//    your code footprint by #defining one or more of the following\r\n//    symbols before creating the implementation.\r\n//\r\n//        STBI_NO_JPEG\r\n//        STBI_NO_PNG\r\n//        STBI_NO_BMP\r\n//        STBI_NO_PSD\r\n//        STBI_NO_TGA\r\n//        STBI_NO_GIF\r\n//        STBI_NO_HDR\r\n//        STBI_NO_PIC\r\n//        STBI_NO_PNM   (.ppm and .pgm)\r\n//\r\n//  - You can request *only* certain decoders and suppress all other ones\r\n//    (this will be more forward-compatible, as addition of new decoders\r\n//    doesn't require you to disable them explicitly):\r\n//\r\n//        STBI_ONLY_JPEG\r\n//        STBI_ONLY_PNG\r\n//        STBI_ONLY_BMP\r\n//        STBI_ONLY_PSD\r\n//        STBI_ONLY_TGA\r\n//        STBI_ONLY_GIF\r\n//        STBI_ONLY_HDR\r\n//        STBI_ONLY_PIC\r\n//        STBI_ONLY_PNM   (.ppm and .pgm)\r\n//\r\n//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still\r\n//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB\r\n//\r\n\r\n\r\n#ifndef STBI_NO_STDIO\r\n#include <stdio.h>\r\n#endif // STBI_NO_STDIO\r\n\r\n#define STBI_VERSION 1\r\n\r\nenum\r\n{\r\n   STBI_default = 0, // only used for desired_channels\r\n\r\n   STBI_grey       = 1,\r\n   STBI_grey_alpha = 2,\r\n   STBI_rgb        = 3,\r\n   STBI_rgb_alpha  = 4\r\n};\r\n\r\ntypedef unsigned char stbi_uc;\r\ntypedef unsigned short stbi_us;\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifdef STB_IMAGE_STATIC\r\n#define STBIDEF static\r\n#else\r\n#define STBIDEF extern\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// PRIMARY API - works on images of any type\r\n//\r\n\r\n//\r\n// load image by filename, open file, or memory buffer\r\n//\r\n\r\ntypedef struct\r\n{\r\n   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read\r\n   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\r\n   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data\r\n} stbi_io_callbacks;\r\n\r\n////////////////////////////////////\r\n//\r\n// 8-bits-per-channel interface\r\n//\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\r\n// for stbi_load_from_file, file pointer is left pointing immediately after image\r\n#endif\r\n\r\n////////////////////////////////////\r\n//\r\n// 16-bits-per-channel interface\r\n//\r\n\r\nSTBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\r\n#endif\r\n\r\n////////////////////////////////////\r\n//\r\n// float-per-channel interface\r\n//\r\n#ifndef STBI_NO_LINEAR\r\n   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\r\n   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);\r\n\r\n   #ifndef STBI_NO_STDIO\r\n   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\r\n   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\r\n   #endif\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\r\n   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\r\n#endif // STBI_NO_HDR\r\n\r\n#ifndef STBI_NO_LINEAR\r\n   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\r\n   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\r\n#endif // STBI_NO_LINEAR\r\n\r\n// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR\r\nSTBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);\r\nSTBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_is_hdr          (char const *filename);\r\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f);\r\n#endif // STBI_NO_STDIO\r\n\r\n\r\n// get a VERY brief reason for failure\r\n// NOT THREADSAFE\r\nSTBIDEF const char *stbi_failure_reason  (void);\r\n\r\n// free the loaded image -- this is just free()\r\nSTBIDEF void     stbi_image_free      (void *retval_from_stbi_load);\r\n\r\n// get image dimensions & components without fully decoding\r\nSTBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);\r\nSTBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_info            (char const *filename,     int *x, int *y, int *comp);\r\nSTBIDEF int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);\r\n\r\n#endif\r\n\r\n\r\n\r\n// for image formats that explicitly notate that they have premultiplied alpha,\r\n// we just return the colors as stored in the file. set this flag to force\r\n// unpremultiplication. results are undefined if the unpremultiply overflow.\r\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\r\n\r\n// indicate whether we should process iphone images back to canonical format,\r\n// or just pass them through \"as-is\"\r\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\r\n\r\n// flip the image vertically, so the first pixel in the output array is the bottom left\r\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);\r\n\r\n// ZLIB client - used by PNG, available for other purposes\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);\r\nSTBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);\r\nSTBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\r\n\r\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);\r\nSTBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n//\r\n//\r\n////   end header file   /////////////////////////////////////////////////////\r\n#endif // STBI_INCLUDE_STB_IMAGE_H\r\n\r\n#ifdef STB_IMAGE_IMPLEMENTATION\r\n\r\n#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \\\r\n  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \\\r\n  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \\\r\n  || defined(STBI_ONLY_ZLIB)\r\n   #ifndef STBI_ONLY_JPEG\r\n   #define STBI_NO_JPEG\r\n   #endif\r\n   #ifndef STBI_ONLY_PNG\r\n   #define STBI_NO_PNG\r\n   #endif\r\n   #ifndef STBI_ONLY_BMP\r\n   #define STBI_NO_BMP\r\n   #endif\r\n   #ifndef STBI_ONLY_PSD\r\n   #define STBI_NO_PSD\r\n   #endif\r\n   #ifndef STBI_ONLY_TGA\r\n   #define STBI_NO_TGA\r\n   #endif\r\n   #ifndef STBI_ONLY_GIF\r\n   #define STBI_NO_GIF\r\n   #endif\r\n   #ifndef STBI_ONLY_HDR\r\n   #define STBI_NO_HDR\r\n   #endif\r\n   #ifndef STBI_ONLY_PIC\r\n   #define STBI_NO_PIC\r\n   #endif\r\n   #ifndef STBI_ONLY_PNM\r\n   #define STBI_NO_PNM\r\n   #endif\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)\r\n#define STBI_NO_ZLIB\r\n#endif\r\n\r\n\r\n#include <stdarg.h>\r\n#include <stddef.h> // ptrdiff_t on osx\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n\r\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)\r\n#include <math.h>  // ldexp\r\n#endif\r\n\r\n#ifndef STBI_NO_STDIO\r\n#include <stdio.h>\r\n#endif\r\n\r\n#ifndef STBI_ASSERT\r\n#include <assert.h>\r\n#define STBI_ASSERT(x) assert(x)\r\n#endif\r\n\r\n\r\n#ifndef _MSC_VER\r\n   #ifdef __cplusplus\r\n   #define stbi_inline inline\r\n   #else\r\n   #define stbi_inline\r\n   #endif\r\n#else\r\n   #define stbi_inline __forceinline\r\n#endif\r\n\r\n\r\n#ifdef _MSC_VER\r\ntypedef unsigned short stbi__uint16;\r\ntypedef   signed short stbi__int16;\r\ntypedef unsigned int   stbi__uint32;\r\ntypedef   signed int   stbi__int32;\r\n#else\r\n#include <stdint.h>\r\ntypedef uint16_t stbi__uint16;\r\ntypedef int16_t  stbi__int16;\r\ntypedef uint32_t stbi__uint32;\r\ntypedef int32_t  stbi__int32;\r\n#endif\r\n\r\n// should produce compiler error if size is wrong\r\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];\r\n\r\n#ifdef _MSC_VER\r\n#define STBI_NOTUSED(v)  (void)(v)\r\n#else\r\n#define STBI_NOTUSED(v)  (void)sizeof(v)\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#define STBI_HAS_LROTL\r\n#endif\r\n\r\n#ifdef STBI_HAS_LROTL\r\n   #define stbi_lrot(x,y)  _lrotl(x,y)\r\n#else\r\n   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))\r\n#endif\r\n\r\n#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))\r\n// ok\r\n#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)\r\n// ok\r\n#else\r\n#error \"Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED).\"\r\n#endif\r\n\r\n#ifndef STBI_MALLOC\r\n#define STBI_MALLOC(sz)           malloc(sz)\r\n#define STBI_REALLOC(p,newsz)     realloc(p,newsz)\r\n#define STBI_FREE(p)              free(p)\r\n#endif\r\n\r\n#ifndef STBI_REALLOC_SIZED\r\n#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)\r\n#endif\r\n\r\n// x86/x64 detection\r\n#if defined(__x86_64__) || defined(_M_X64)\r\n#define STBI__X64_TARGET\r\n#elif defined(__i386) || defined(_M_IX86)\r\n#define STBI__X86_TARGET\r\n#endif\r\n\r\n#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)\r\n// gcc doesn't support sse2 intrinsics unless you compile with -msse2,\r\n// which in turn means it gets to use SSE2 everywhere. This is unfortunate,\r\n// but previous attempts to provide the SSE2 functions with runtime\r\n// detection caused numerous issues. The way architecture extensions are\r\n// exposed in GCC/Clang is, sadly, not really suited for one-file libs.\r\n// New behavior: if compiled with -msse2, we use SSE2 without any\r\n// detection; if not, we don't use it at all.\r\n#define STBI_NO_SIMD\r\n#endif\r\n\r\n#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)\r\n// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET\r\n//\r\n// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the\r\n// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.\r\n// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not\r\n// simultaneously enabling \"-mstackrealign\".\r\n//\r\n// See https://github.com/nothings/stb/issues/81 for more information.\r\n//\r\n// So default to no SSE2 on 32-bit MinGW. If you've read this far and added\r\n// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.\r\n#define STBI_NO_SIMD\r\n#endif\r\n\r\n#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))\r\n#define STBI_SSE2\r\n#include <emmintrin.h>\r\n\r\n#ifdef _MSC_VER\r\n\r\n#if _MSC_VER >= 1400  // not VC6\r\n#include <intrin.h> // __cpuid\r\nstatic int stbi__cpuid3(void)\r\n{\r\n   int info[4];\r\n   __cpuid(info,1);\r\n   return info[3];\r\n}\r\n#else\r\nstatic int stbi__cpuid3(void)\r\n{\r\n   int res;\r\n   __asm {\r\n      mov  eax,1\r\n      cpuid\r\n      mov  res,edx\r\n   }\r\n   return res;\r\n}\r\n#endif\r\n\r\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\r\n\r\nstatic int stbi__sse2_available(void)\r\n{\r\n   int info3 = stbi__cpuid3();\r\n   return ((info3 >> 26) & 1) != 0;\r\n}\r\n#else // assume GCC-style if not VC++\r\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\r\n\r\nstatic int stbi__sse2_available(void)\r\n{\r\n   // If we're even attempting to compile this on GCC/Clang, that means\r\n   // -msse2 is on, which means the compiler is allowed to use SSE2\r\n   // instructions at will, and so are we.\r\n   return 1;\r\n}\r\n#endif\r\n#endif\r\n\r\n// ARM NEON\r\n#if defined(STBI_NO_SIMD) && defined(STBI_NEON)\r\n#undef STBI_NEON\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n#include <arm_neon.h>\r\n// assume GCC or Clang on ARM targets\r\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\r\n#endif\r\n\r\n#ifndef STBI_SIMD_ALIGN\r\n#define STBI_SIMD_ALIGN(type, name) type name\r\n#endif\r\n\r\n///////////////////////////////////////////////\r\n//\r\n//  stbi__context struct and start_xxx functions\r\n\r\n// stbi__context structure is our basic context used by all images, so it\r\n// contains all the IO context, plus some basic image information\r\ntypedef struct\r\n{\r\n   stbi__uint32 img_x, img_y;\r\n   int img_n, img_out_n;\r\n\r\n   stbi_io_callbacks io;\r\n   void *io_user_data;\r\n\r\n   int read_from_callbacks;\r\n   int buflen;\r\n   stbi_uc buffer_start[128];\r\n\r\n   stbi_uc *img_buffer, *img_buffer_end;\r\n   stbi_uc *img_buffer_original, *img_buffer_original_end;\r\n} stbi__context;\r\n\r\n\r\nstatic void stbi__refill_buffer(stbi__context *s);\r\n\r\n// initialize a memory-decode context\r\nstatic void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)\r\n{\r\n   s->io.read = NULL;\r\n   s->read_from_callbacks = 0;\r\n   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;\r\n   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;\r\n}\r\n\r\n// initialize a callback-based context\r\nstatic void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)\r\n{\r\n   s->io = *c;\r\n   s->io_user_data = user;\r\n   s->buflen = sizeof(s->buffer_start);\r\n   s->read_from_callbacks = 1;\r\n   s->img_buffer_original = s->buffer_start;\r\n   stbi__refill_buffer(s);\r\n   s->img_buffer_original_end = s->img_buffer_end;\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\n\r\nstatic int stbi__stdio_read(void *user, char *data, int size)\r\n{\r\n   return (int) fread(data,1,size,(FILE*) user);\r\n}\r\n\r\nstatic void stbi__stdio_skip(void *user, int n)\r\n{\r\n   fseek((FILE*) user, n, SEEK_CUR);\r\n}\r\n\r\nstatic int stbi__stdio_eof(void *user)\r\n{\r\n   return feof((FILE*) user);\r\n}\r\n\r\nstatic stbi_io_callbacks stbi__stdio_callbacks =\r\n{\r\n   stbi__stdio_read,\r\n   stbi__stdio_skip,\r\n   stbi__stdio_eof,\r\n};\r\n\r\nstatic void stbi__start_file(stbi__context *s, FILE *f)\r\n{\r\n   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);\r\n}\r\n\r\n//static void stop_file(stbi__context *s) { }\r\n\r\n#endif // !STBI_NO_STDIO\r\n\r\nstatic void stbi__rewind(stbi__context *s)\r\n{\r\n   // conceptually rewind SHOULD rewind to the beginning of the stream,\r\n   // but we just rewind to the beginning of the initial buffer, because\r\n   // we only use it after doing 'test', which only ever looks at at most 92 bytes\r\n   s->img_buffer = s->img_buffer_original;\r\n   s->img_buffer_end = s->img_buffer_original_end;\r\n}\r\n\r\nenum\r\n{\r\n   STBI_ORDER_RGB,\r\n   STBI_ORDER_BGR\r\n};\r\n\r\ntypedef struct\r\n{\r\n   int bits_per_channel;\r\n   int num_channels;\r\n   int channel_order;\r\n} stbi__result_info;\r\n\r\n#ifndef STBI_NO_JPEG\r\nstatic int      stbi__jpeg_test(stbi__context *s);\r\nstatic void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PNG\r\nstatic int      stbi__png_test(stbi__context *s);\r\nstatic void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int      stbi__bmp_test(stbi__context *s);\r\nstatic void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_TGA\r\nstatic int      stbi__tga_test(stbi__context *s);\r\nstatic void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int      stbi__psd_test(stbi__context *s);\r\nstatic void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);\r\nstatic int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic int      stbi__hdr_test(stbi__context *s);\r\nstatic float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int      stbi__pic_test(stbi__context *s);\r\nstatic void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_GIF\r\nstatic int      stbi__gif_test(stbi__context *s);\r\nstatic void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PNM\r\nstatic int      stbi__pnm_test(stbi__context *s);\r\nstatic void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n// this is not threadsafe\r\nstatic const char *stbi__g_failure_reason;\r\n\r\nSTBIDEF const char *stbi_failure_reason(void)\r\n{\r\n   return stbi__g_failure_reason;\r\n}\r\n\r\nstatic int stbi__err(const char *str)\r\n{\r\n   stbi__g_failure_reason = str;\r\n   return 0;\r\n}\r\n\r\nstatic void *stbi__malloc(size_t size)\r\n{\r\n    return STBI_MALLOC(size);\r\n}\r\n\r\n// stb_image uses ints pervasively, including for offset calculations.\r\n// therefore the largest decoded image size we can support with the\r\n// current code, even on 64-bit targets, is INT_MAX. this is not a\r\n// significant limitation for the intended use case.\r\n//\r\n// we do, however, need to make sure our size calculations don't\r\n// overflow. hence a few helper functions for size calculations that\r\n// multiply integers together, making sure that they're non-negative\r\n// and no overflow occurs.\r\n\r\n// return 1 if the sum is valid, 0 on overflow.\r\n// negative terms are considered invalid.\r\nstatic int stbi__addsizes_valid(int a, int b)\r\n{\r\n   if (b < 0) return 0;\r\n   // now 0 <= b <= INT_MAX, hence also\r\n   // 0 <= INT_MAX - b <= INTMAX.\r\n   // And \"a + b <= INT_MAX\" (which might overflow) is the\r\n   // same as a <= INT_MAX - b (no overflow)\r\n   return a <= INT_MAX - b;\r\n}\r\n\r\n// returns 1 if the product is valid, 0 on overflow.\r\n// negative factors are considered invalid.\r\nstatic int stbi__mul2sizes_valid(int a, int b)\r\n{\r\n   if (a < 0 || b < 0) return 0;\r\n   if (b == 0) return 1; // mul-by-0 is always safe\r\n   // portable way to check for no overflows in a*b\r\n   return a <= INT_MAX/b;\r\n}\r\n\r\n// returns 1 if \"a*b + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad2sizes_valid(int a, int b, int add)\r\n{\r\n   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);\r\n}\r\n\r\n// returns 1 if \"a*b*c + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad3sizes_valid(int a, int b, int c, int add)\r\n{\r\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\r\n      stbi__addsizes_valid(a*b*c, add);\r\n}\r\n\r\n// returns 1 if \"a*b*c*d + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)\r\n{\r\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\r\n      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);\r\n}\r\n\r\n// mallocs with size overflow checking\r\nstatic void *stbi__malloc_mad2(int a, int b, int add)\r\n{\r\n   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;\r\n   return stbi__malloc(a*b + add);\r\n}\r\n\r\nstatic void *stbi__malloc_mad3(int a, int b, int c, int add)\r\n{\r\n   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\r\n   return stbi__malloc(a*b*c + add);\r\n}\r\n\r\nstatic void *stbi__malloc_mad4(int a, int b, int c, int d, int add)\r\n{\r\n   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;\r\n   return stbi__malloc(a*b*c*d + add);\r\n}\r\n\r\n// stbi__err - error\r\n// stbi__errpf - error returning pointer to float\r\n// stbi__errpuc - error returning pointer to unsigned char\r\n\r\n#ifdef STBI_NO_FAILURE_STRINGS\r\n   #define stbi__err(x,y)  0\r\n#elif defined(STBI_FAILURE_USERMSG)\r\n   #define stbi__err(x,y)  stbi__err(y)\r\n#else\r\n   #define stbi__err(x,y)  stbi__err(x)\r\n#endif\r\n\r\n#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))\r\n#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))\r\n\r\nSTBIDEF void stbi_image_free(void *retval_from_stbi_load)\r\n{\r\n   STBI_FREE(retval_from_stbi_load);\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);\r\n#endif\r\n\r\nstatic int stbi__vertically_flip_on_load = 0;\r\n\r\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)\r\n{\r\n    stbi__vertically_flip_on_load = flag_true_if_should_flip;\r\n}\r\n\r\nstatic void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\r\n{\r\n   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields\r\n   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed\r\n   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order\r\n   ri->num_channels = 0;\r\n\r\n   #ifndef STBI_NO_JPEG\r\n   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_PNG\r\n   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_BMP\r\n   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_GIF\r\n   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_PSD\r\n   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);\r\n   #endif\r\n   #ifndef STBI_NO_PIC\r\n   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_PNM\r\n   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n\r\n   #ifndef STBI_NO_HDR\r\n   if (stbi__hdr_test(s)) {\r\n      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);\r\n      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\r\n   }\r\n   #endif\r\n\r\n   #ifndef STBI_NO_TGA\r\n   // test tga last because it's a crappy test!\r\n   if (stbi__tga_test(s))\r\n      return stbi__tga_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n\r\n   return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nstatic stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)\r\n{\r\n   int i;\r\n   int img_len = w * h * channels;\r\n   stbi_uc *reduced;\r\n\r\n   reduced = (stbi_uc *) stbi__malloc(img_len);\r\n   if (reduced == NULL) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   for (i = 0; i < img_len; ++i)\r\n      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling\r\n\r\n   STBI_FREE(orig);\r\n   return reduced;\r\n}\r\n\r\nstatic stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)\r\n{\r\n   int i;\r\n   int img_len = w * h * channels;\r\n   stbi__uint16 *enlarged;\r\n\r\n   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);\r\n   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   for (i = 0; i < img_len; ++i)\r\n      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff\r\n\r\n   STBI_FREE(orig);\r\n   return enlarged;\r\n}\r\n\r\nstatic void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)\r\n{\r\n   int row;\r\n   size_t bytes_per_row = (size_t)w * bytes_per_pixel;\r\n   stbi_uc temp[2048];\r\n   stbi_uc *bytes = (stbi_uc *)image;\r\n\r\n   for (row = 0; row < (h>>1); row++) {\r\n      stbi_uc *row0 = bytes + row*bytes_per_row;\r\n      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;\r\n      // swap row0 with row1\r\n      size_t bytes_left = bytes_per_row;\r\n      while (bytes_left) {\r\n         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);\r\n         memcpy(temp, row0, bytes_copy);\r\n         memcpy(row0, row1, bytes_copy);\r\n         memcpy(row1, temp, bytes_copy);\r\n         row0 += bytes_copy;\r\n         row1 += bytes_copy;\r\n         bytes_left -= bytes_copy;\r\n      }\r\n   }\r\n}\r\n\r\nstatic unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__result_info ri;\r\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);\r\n\r\n   if (result == NULL)\r\n      return NULL;\r\n\r\n   if (ri.bits_per_channel != 8) {\r\n      STBI_ASSERT(ri.bits_per_channel == 16);\r\n      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\r\n      ri.bits_per_channel = 8;\r\n   }\r\n\r\n   // @TODO: move stbi__convert_format to here\r\n\r\n   if (stbi__vertically_flip_on_load) {\r\n      int channels = req_comp ? req_comp : *comp;\r\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));\r\n   }\r\n\r\n   return (unsigned char *) result;\r\n}\r\n\r\nstatic stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__result_info ri;\r\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);\r\n\r\n   if (result == NULL)\r\n      return NULL;\r\n\r\n   if (ri.bits_per_channel != 16) {\r\n      STBI_ASSERT(ri.bits_per_channel == 8);\r\n      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\r\n      ri.bits_per_channel = 16;\r\n   }\r\n\r\n   // @TODO: move stbi__convert_format16 to here\r\n   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision\r\n\r\n   if (stbi__vertically_flip_on_load) {\r\n      int channels = req_comp ? req_comp : *comp;\r\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));\r\n   }\r\n\r\n   return (stbi__uint16 *) result;\r\n}\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   if (stbi__vertically_flip_on_load && result != NULL) {\r\n      int channels = req_comp ? req_comp : *comp;\r\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));\r\n   }\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_STDIO\r\n\r\nstatic FILE *stbi__fopen(char const *filename, char const *mode)\r\n{\r\n   FILE *f;\r\n#if defined(_MSC_VER) && _MSC_VER >= 1400\r\n   if (0 != fopen_s(&f, filename, mode))\r\n      f=0;\r\n#else\r\n   f = fopen(filename, mode);\r\n#endif\r\n   return f;\r\n}\r\n\r\n\r\nSTBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   unsigned char *result;\r\n   if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\r\n   result = stbi_load_from_file(f,x,y,comp,req_comp);\r\n   fclose(f);\r\n   return result;\r\n}\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   unsigned char *result;\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\r\n   if (result) {\r\n      // need to 'unget' all the characters in the IO buffer\r\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\r\n   }\r\n   return result;\r\n}\r\n\r\nSTBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__uint16 *result;\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);\r\n   if (result) {\r\n      // need to 'unget' all the characters in the IO buffer\r\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\r\n   }\r\n   return result;\r\n}\r\n\r\nSTBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   stbi__uint16 *result;\r\n   if (!f) return (stbi_us *) stbi__errpuc(\"can't fopen\", \"Unable to open file\");\r\n   result = stbi_load_from_file_16(f,x,y,comp,req_comp);\r\n   fclose(f);\r\n   return result;\r\n}\r\n\r\n\r\n#endif //!STBI_NO_STDIO\r\n\r\nSTBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\r\n}\r\n\r\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);\r\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\r\n}\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\r\n}\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\r\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   unsigned char *data;\r\n   #ifndef STBI_NO_HDR\r\n   if (stbi__hdr_test(s)) {\r\n      stbi__result_info ri;\r\n      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);\r\n      if (hdr_data)\r\n         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);\r\n      return hdr_data;\r\n   }\r\n   #endif\r\n   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);\r\n   if (data)\r\n      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\r\n   return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nSTBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\r\n}\r\n\r\nSTBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\r\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   float *result;\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\r\n   result = stbi_loadf_from_file(f,x,y,comp,req_comp);\r\n   fclose(f);\r\n   return result;\r\n}\r\n\r\nSTBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\n#endif // !STBI_NO_LINEAR\r\n\r\n// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is\r\n// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always\r\n// reports false!\r\n\r\nSTBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)\r\n{\r\n   #ifndef STBI_NO_HDR\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__hdr_test(&s);\r\n   #else\r\n   STBI_NOTUSED(buffer);\r\n   STBI_NOTUSED(len);\r\n   return 0;\r\n   #endif\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_is_hdr          (char const *filename)\r\n{\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   int result=0;\r\n   if (f) {\r\n      result = stbi_is_hdr_from_file(f);\r\n      fclose(f);\r\n   }\r\n   return result;\r\n}\r\n\r\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f)\r\n{\r\n   #ifndef STBI_NO_HDR\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   return stbi__hdr_test(&s);\r\n   #else\r\n   STBI_NOTUSED(f);\r\n   return 0;\r\n   #endif\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)\r\n{\r\n   #ifndef STBI_NO_HDR\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\r\n   return stbi__hdr_test(&s);\r\n   #else\r\n   STBI_NOTUSED(clbk);\r\n   STBI_NOTUSED(user);\r\n   return 0;\r\n   #endif\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;\r\n\r\nSTBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\r\nSTBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\r\n#endif\r\n\r\nstatic float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;\r\n\r\nSTBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }\r\nSTBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Common code used by all image loaders\r\n//\r\n\r\nenum\r\n{\r\n   STBI__SCAN_load=0,\r\n   STBI__SCAN_type,\r\n   STBI__SCAN_header\r\n};\r\n\r\nstatic void stbi__refill_buffer(stbi__context *s)\r\n{\r\n   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);\r\n   if (n == 0) {\r\n      // at end of file, treat same as if from memory, but need to handle case\r\n      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\r\n      s->read_from_callbacks = 0;\r\n      s->img_buffer = s->buffer_start;\r\n      s->img_buffer_end = s->buffer_start+1;\r\n      *s->img_buffer = 0;\r\n   } else {\r\n      s->img_buffer = s->buffer_start;\r\n      s->img_buffer_end = s->buffer_start + n;\r\n   }\r\n}\r\n\r\nstbi_inline static stbi_uc stbi__get8(stbi__context *s)\r\n{\r\n   if (s->img_buffer < s->img_buffer_end)\r\n      return *s->img_buffer++;\r\n   if (s->read_from_callbacks) {\r\n      stbi__refill_buffer(s);\r\n      return *s->img_buffer++;\r\n   }\r\n   return 0;\r\n}\r\n\r\nstbi_inline static int stbi__at_eof(stbi__context *s)\r\n{\r\n   if (s->io.read) {\r\n      if (!(s->io.eof)(s->io_user_data)) return 0;\r\n      // if feof() is true, check if buffer = end\r\n      // special case: we've only got the special 0 character at the end\r\n      if (s->read_from_callbacks == 0) return 1;\r\n   }\r\n\r\n   return s->img_buffer >= s->img_buffer_end;\r\n}\r\n\r\nstatic void stbi__skip(stbi__context *s, int n)\r\n{\r\n   if (n < 0) {\r\n      s->img_buffer = s->img_buffer_end;\r\n      return;\r\n   }\r\n   if (s->io.read) {\r\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\r\n      if (blen < n) {\r\n         s->img_buffer = s->img_buffer_end;\r\n         (s->io.skip)(s->io_user_data, n - blen);\r\n         return;\r\n      }\r\n   }\r\n   s->img_buffer += n;\r\n}\r\n\r\nstatic int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\r\n{\r\n   if (s->io.read) {\r\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\r\n      if (blen < n) {\r\n         int res, count;\r\n\r\n         memcpy(buffer, s->img_buffer, blen);\r\n\r\n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\r\n         res = (count == (n-blen));\r\n         s->img_buffer = s->img_buffer_end;\r\n         return res;\r\n      }\r\n   }\r\n\r\n   if (s->img_buffer+n <= s->img_buffer_end) {\r\n      memcpy(buffer, s->img_buffer, n);\r\n      s->img_buffer += n;\r\n      return 1;\r\n   } else\r\n      return 0;\r\n}\r\n\r\nstatic int stbi__get16be(stbi__context *s)\r\n{\r\n   int z = stbi__get8(s);\r\n   return (z << 8) + stbi__get8(s);\r\n}\r\n\r\nstatic stbi__uint32 stbi__get32be(stbi__context *s)\r\n{\r\n   stbi__uint32 z = stbi__get16be(s);\r\n   return (z << 16) + stbi__get16be(s);\r\n}\r\n\r\n#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)\r\n// nothing\r\n#else\r\nstatic int stbi__get16le(stbi__context *s)\r\n{\r\n   int z = stbi__get8(s);\r\n   return z + (stbi__get8(s) << 8);\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic stbi__uint32 stbi__get32le(stbi__context *s)\r\n{\r\n   stbi__uint32 z = stbi__get16le(s);\r\n   return z + (stbi__get16le(s) << 16);\r\n}\r\n#endif\r\n\r\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  generic converter from built-in img_n to req_comp\r\n//    individual types do this automatically as much as possible (e.g. jpeg\r\n//    does all cases internally since it needs to colorspace convert anyway,\r\n//    and it never has alpha, so very few cases ). png can automatically\r\n//    interleave an alpha=255 channel, but falls back to this for other cases\r\n//\r\n//  assume data buffer is malloced, so malloc a new one and free that one\r\n//  only failure mode is malloc failing\r\n\r\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\r\n{\r\n   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);\r\n}\r\n\r\nstatic unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)\r\n{\r\n   int i,j;\r\n   unsigned char *good;\r\n\r\n   if (req_comp == img_n) return data;\r\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\r\n\r\n   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);\r\n   if (good == NULL) {\r\n      STBI_FREE(data);\r\n      return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   }\r\n\r\n   for (j=0; j < (int) y; ++j) {\r\n      unsigned char *src  = data + j * x * img_n   ;\r\n      unsigned char *dest = good + j * x * req_comp;\r\n\r\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\r\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\r\n      // convert source image with img_n components to one with req_comp components;\r\n      // avoid switch per pixel, so use switch per scanline and massive macros\r\n      switch (STBI__COMBO(img_n, req_comp)) {\r\n         STBI__CASE(1,2) { dest[0]=src[0], dest[1]=255;                                     } break;\r\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\r\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=255;                     } break;\r\n         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;\r\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\r\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                  } break;\r\n         STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255;        } break;\r\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255;    } break;\r\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; } break;\r\n         STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                    } break;\r\n         default: STBI_ASSERT(0);\r\n      }\r\n      #undef STBI__CASE\r\n   }\r\n\r\n   STBI_FREE(data);\r\n   return good;\r\n}\r\n\r\nstatic stbi__uint16 stbi__compute_y_16(int r, int g, int b)\r\n{\r\n   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);\r\n}\r\n\r\nstatic stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)\r\n{\r\n   int i,j;\r\n   stbi__uint16 *good;\r\n\r\n   if (req_comp == img_n) return data;\r\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\r\n\r\n   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);\r\n   if (good == NULL) {\r\n      STBI_FREE(data);\r\n      return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   }\r\n\r\n   for (j=0; j < (int) y; ++j) {\r\n      stbi__uint16 *src  = data + j * x * img_n   ;\r\n      stbi__uint16 *dest = good + j * x * req_comp;\r\n\r\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\r\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\r\n      // convert source image with img_n components to one with req_comp components;\r\n      // avoid switch per pixel, so use switch per scanline and massive macros\r\n      switch (STBI__COMBO(img_n, req_comp)) {\r\n         STBI__CASE(1,2) { dest[0]=src[0], dest[1]=0xffff;                                     } break;\r\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\r\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=0xffff;                     } break;\r\n         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;\r\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\r\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                     } break;\r\n         STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=0xffff;        } break;\r\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = 0xffff; } break;\r\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = src[3]; } break;\r\n         STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                       } break;\r\n         default: STBI_ASSERT(0);\r\n      }\r\n      #undef STBI__CASE\r\n   }\r\n\r\n   STBI_FREE(data);\r\n   return good;\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)\r\n{\r\n   int i,k,n;\r\n   float *output;\r\n   if (!data) return NULL;\r\n   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);\r\n   if (output == NULL) { STBI_FREE(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\r\n   // compute number of non-alpha components\r\n   if (comp & 1) n = comp; else n = comp-1;\r\n   for (i=0; i < x*y; ++i) {\r\n      for (k=0; k < n; ++k) {\r\n         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\r\n      }\r\n      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;\r\n   }\r\n   STBI_FREE(data);\r\n   return output;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n#define stbi__float2int(x)   ((int) (x))\r\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)\r\n{\r\n   int i,k,n;\r\n   stbi_uc *output;\r\n   if (!data) return NULL;\r\n   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);\r\n   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n   // compute number of non-alpha components\r\n   if (comp & 1) n = comp; else n = comp-1;\r\n   for (i=0; i < x*y; ++i) {\r\n      for (k=0; k < n; ++k) {\r\n         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\r\n         if (z < 0) z = 0;\r\n         if (z > 255) z = 255;\r\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\r\n      }\r\n      if (k < comp) {\r\n         float z = data[i*comp+k] * 255 + 0.5f;\r\n         if (z < 0) z = 0;\r\n         if (z > 255) z = 255;\r\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\r\n      }\r\n   }\r\n   STBI_FREE(data);\r\n   return output;\r\n}\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  \"baseline\" JPEG/JFIF decoder\r\n//\r\n//    simple implementation\r\n//      - doesn't support delayed output of y-dimension\r\n//      - simple interface (only one output format: 8-bit interleaved RGB)\r\n//      - doesn't try to recover corrupt jpegs\r\n//      - doesn't allow partial loading, loading multiple at once\r\n//      - still fast on x86 (copying globals into locals doesn't help x86)\r\n//      - allocates lots of intermediate memory (full size of all components)\r\n//        - non-interleaved case requires this anyway\r\n//        - allows good upsampling (see next)\r\n//    high-quality\r\n//      - upsampled channels are bilinearly interpolated, even across blocks\r\n//      - quality integer IDCT derived from IJG's 'slow'\r\n//    performance\r\n//      - fast huffman; reasonable integer IDCT\r\n//      - some SIMD kernels for common paths on targets with SSE2/NEON\r\n//      - uses a lot of intermediate memory, could cache poorly\r\n\r\n#ifndef STBI_NO_JPEG\r\n\r\n// huffman decoding acceleration\r\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\r\n\r\ntypedef struct\r\n{\r\n   stbi_uc  fast[1 << FAST_BITS];\r\n   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\r\n   stbi__uint16 code[256];\r\n   stbi_uc  values[256];\r\n   stbi_uc  size[257];\r\n   unsigned int maxcode[18];\r\n   int    delta[17];   // old 'firstsymbol' - old 'firstcode'\r\n} stbi__huffman;\r\n\r\ntypedef struct\r\n{\r\n   stbi__context *s;\r\n   stbi__huffman huff_dc[4];\r\n   stbi__huffman huff_ac[4];\r\n   stbi__uint16 dequant[4][64];\r\n   stbi__int16 fast_ac[4][1 << FAST_BITS];\r\n\r\n// sizes for components, interleaved MCUs\r\n   int img_h_max, img_v_max;\r\n   int img_mcu_x, img_mcu_y;\r\n   int img_mcu_w, img_mcu_h;\r\n\r\n// definition of jpeg image component\r\n   struct\r\n   {\r\n      int id;\r\n      int h,v;\r\n      int tq;\r\n      int hd,ha;\r\n      int dc_pred;\r\n\r\n      int x,y,w2,h2;\r\n      stbi_uc *data;\r\n      void *raw_data, *raw_coeff;\r\n      stbi_uc *linebuf;\r\n      short   *coeff;   // progressive only\r\n      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks\r\n   } img_comp[4];\r\n\r\n   stbi__uint32   code_buffer; // jpeg entropy-coded buffer\r\n   int            code_bits;   // number of valid bits\r\n   unsigned char  marker;      // marker seen while filling entropy buffer\r\n   int            nomore;      // flag if we saw a marker so must stop\r\n\r\n   int            progressive;\r\n   int            spec_start;\r\n   int            spec_end;\r\n   int            succ_high;\r\n   int            succ_low;\r\n   int            eob_run;\r\n   int            jfif;\r\n   int            app14_color_transform; // Adobe APP14 tag\r\n   int            rgb;\r\n\r\n   int scan_n, order[4];\r\n   int restart_interval, todo;\r\n\r\n// kernels\r\n   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);\r\n   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);\r\n   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);\r\n} stbi__jpeg;\r\n\r\nstatic int stbi__build_huffman(stbi__huffman *h, int *count)\r\n{\r\n   int i,j,k=0,code;\r\n   // build size list for each symbol (from JPEG spec)\r\n   for (i=0; i < 16; ++i)\r\n      for (j=0; j < count[i]; ++j)\r\n         h->size[k++] = (stbi_uc) (i+1);\r\n   h->size[k] = 0;\r\n\r\n   // compute actual symbols (from jpeg spec)\r\n   code = 0;\r\n   k = 0;\r\n   for(j=1; j <= 16; ++j) {\r\n      // compute delta to add to code to compute symbol id\r\n      h->delta[j] = k - code;\r\n      if (h->size[k] == j) {\r\n         while (h->size[k] == j)\r\n            h->code[k++] = (stbi__uint16) (code++);\r\n         if (code-1 >= (1 << j)) return stbi__err(\"bad code lengths\",\"Corrupt JPEG\");\r\n      }\r\n      // compute largest code + 1 for this size, preshifted as needed later\r\n      h->maxcode[j] = code << (16-j);\r\n      code <<= 1;\r\n   }\r\n   h->maxcode[j] = 0xffffffff;\r\n\r\n   // build non-spec acceleration table; 255 is flag for not-accelerated\r\n   memset(h->fast, 255, 1 << FAST_BITS);\r\n   for (i=0; i < k; ++i) {\r\n      int s = h->size[i];\r\n      if (s <= FAST_BITS) {\r\n         int c = h->code[i] << (FAST_BITS-s);\r\n         int m = 1 << (FAST_BITS-s);\r\n         for (j=0; j < m; ++j) {\r\n            h->fast[c+j] = (stbi_uc) i;\r\n         }\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\n// build a table that decodes both magnitude and value of small ACs in\r\n// one go.\r\nstatic void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)\r\n{\r\n   int i;\r\n   for (i=0; i < (1 << FAST_BITS); ++i) {\r\n      stbi_uc fast = h->fast[i];\r\n      fast_ac[i] = 0;\r\n      if (fast < 255) {\r\n         int rs = h->values[fast];\r\n         int run = (rs >> 4) & 15;\r\n         int magbits = rs & 15;\r\n         int len = h->size[fast];\r\n\r\n         if (magbits && len + magbits <= FAST_BITS) {\r\n            // magnitude code followed by receive_extend code\r\n            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);\r\n            int m = 1 << (magbits - 1);\r\n            if (k < m) k += (~0U << magbits) + 1;\r\n            // if the result is small enough, we can fit it in fast_ac table\r\n            if (k >= -128 && k <= 127)\r\n               fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg *j)\r\n{\r\n   do {\r\n      int b = j->nomore ? 0 : stbi__get8(j->s);\r\n      if (b == 0xff) {\r\n         int c = stbi__get8(j->s);\r\n         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes\r\n         if (c != 0) {\r\n            j->marker = (unsigned char) c;\r\n            j->nomore = 1;\r\n            return;\r\n         }\r\n      }\r\n      j->code_buffer |= b << (24 - j->code_bits);\r\n      j->code_bits += 8;\r\n   } while (j->code_bits <= 24);\r\n}\r\n\r\n// (1 << n) - 1\r\nstatic stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};\r\n\r\n// decode a jpeg huffman value from the bitstream\r\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)\r\n{\r\n   unsigned int temp;\r\n   int c,k;\r\n\r\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n\r\n   // look at the top FAST_BITS and determine what symbol ID it is,\r\n   // if the code is <= FAST_BITS\r\n   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\r\n   k = h->fast[c];\r\n   if (k < 255) {\r\n      int s = h->size[k];\r\n      if (s > j->code_bits)\r\n         return -1;\r\n      j->code_buffer <<= s;\r\n      j->code_bits -= s;\r\n      return h->values[k];\r\n   }\r\n\r\n   // naive test is to shift the code_buffer down so k bits are\r\n   // valid, then test against maxcode. To speed this up, we've\r\n   // preshifted maxcode left so that it has (16-k) 0s at the\r\n   // end; in other words, regardless of the number of bits, it\r\n   // wants to be compared against something shifted to have 16;\r\n   // that way we don't need to shift inside the loop.\r\n   temp = j->code_buffer >> 16;\r\n   for (k=FAST_BITS+1 ; ; ++k)\r\n      if (temp < h->maxcode[k])\r\n         break;\r\n   if (k == 17) {\r\n      // error! code not found\r\n      j->code_bits -= 16;\r\n      return -1;\r\n   }\r\n\r\n   if (k > j->code_bits)\r\n      return -1;\r\n\r\n   // convert the huffman code to the symbol id\r\n   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\r\n   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\r\n\r\n   // convert the id to a symbol\r\n   j->code_bits -= k;\r\n   j->code_buffer <<= k;\r\n   return h->values[c];\r\n}\r\n\r\n// bias[n] = (-1<<n) + 1\r\nstatic int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};\r\n\r\n// combined JPEG 'receive' and JPEG 'extend', since baseline\r\n// always extends everything it receives.\r\nstbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\r\n{\r\n   unsigned int k;\r\n   int sgn;\r\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\r\n\r\n   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB\r\n   k = stbi_lrot(j->code_buffer, n);\r\n   STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));\r\n   j->code_buffer = k & ~stbi__bmask[n];\r\n   k &= stbi__bmask[n];\r\n   j->code_bits -= n;\r\n   return k + (stbi__jbias[n] & ~sgn);\r\n}\r\n\r\n// get some unsigned bits\r\nstbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)\r\n{\r\n   unsigned int k;\r\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\r\n   k = stbi_lrot(j->code_buffer, n);\r\n   j->code_buffer = k & ~stbi__bmask[n];\r\n   k &= stbi__bmask[n];\r\n   j->code_bits -= n;\r\n   return k;\r\n}\r\n\r\nstbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)\r\n{\r\n   unsigned int k;\r\n   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);\r\n   k = j->code_buffer;\r\n   j->code_buffer <<= 1;\r\n   --j->code_bits;\r\n   return k & 0x80000000;\r\n}\r\n\r\n// given a value that's at position X in the zigzag stream,\r\n// where does it appear in the 8x8 matrix coded as row-major?\r\nstatic stbi_uc stbi__jpeg_dezigzag[64+15] =\r\n{\r\n    0,  1,  8, 16,  9,  2,  3, 10,\r\n   17, 24, 32, 25, 18, 11,  4,  5,\r\n   12, 19, 26, 33, 40, 48, 41, 34,\r\n   27, 20, 13,  6,  7, 14, 21, 28,\r\n   35, 42, 49, 56, 57, 50, 43, 36,\r\n   29, 22, 15, 23, 30, 37, 44, 51,\r\n   58, 59, 52, 45, 38, 31, 39, 46,\r\n   53, 60, 61, 54, 47, 55, 62, 63,\r\n   // let corrupt input sample past end\r\n   63, 63, 63, 63, 63, 63, 63, 63,\r\n   63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\n// decode one 64-entry block--\r\nstatic int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)\r\n{\r\n   int diff,dc,k;\r\n   int t;\r\n\r\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n   t = stbi__jpeg_huff_decode(j, hdc);\r\n   if (t < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n\r\n   // 0 all the ac values now so we can do it 32-bits at a time\r\n   memset(data,0,64*sizeof(data[0]));\r\n\r\n   diff = t ? stbi__extend_receive(j, t) : 0;\r\n   dc = j->img_comp[b].dc_pred + diff;\r\n   j->img_comp[b].dc_pred = dc;\r\n   data[0] = (short) (dc * dequant[0]);\r\n\r\n   // decode AC components, see JPEG spec\r\n   k = 1;\r\n   do {\r\n      unsigned int zig;\r\n      int c,r,s;\r\n      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\r\n      r = fac[c];\r\n      if (r) { // fast-AC path\r\n         k += (r >> 4) & 15; // run\r\n         s = r & 15; // combined length\r\n         j->code_buffer <<= s;\r\n         j->code_bits -= s;\r\n         // decode into unzigzag'd location\r\n         zig = stbi__jpeg_dezigzag[k++];\r\n         data[zig] = (short) ((r >> 8) * dequant[zig]);\r\n      } else {\r\n         int rs = stbi__jpeg_huff_decode(j, hac);\r\n         if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n         s = rs & 15;\r\n         r = rs >> 4;\r\n         if (s == 0) {\r\n            if (rs != 0xf0) break; // end block\r\n            k += 16;\r\n         } else {\r\n            k += r;\r\n            // decode into unzigzag'd location\r\n            zig = stbi__jpeg_dezigzag[k++];\r\n            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);\r\n         }\r\n      }\r\n   } while (k < 64);\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)\r\n{\r\n   int diff,dc;\r\n   int t;\r\n   if (j->spec_end != 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n\r\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n\r\n   if (j->succ_high == 0) {\r\n      // first scan for DC coefficient, must be first\r\n      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now\r\n      t = stbi__jpeg_huff_decode(j, hdc);\r\n      diff = t ? stbi__extend_receive(j, t) : 0;\r\n\r\n      dc = j->img_comp[b].dc_pred + diff;\r\n      j->img_comp[b].dc_pred = dc;\r\n      data[0] = (short) (dc << j->succ_low);\r\n   } else {\r\n      // refinement scan for DC coefficient\r\n      if (stbi__jpeg_get_bit(j))\r\n         data[0] += (short) (1 << j->succ_low);\r\n   }\r\n   return 1;\r\n}\r\n\r\n// @OPTIMIZE: store non-zigzagged during the decode passes,\r\n// and only de-zigzag when dequantizing\r\nstatic int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)\r\n{\r\n   int k;\r\n   if (j->spec_start == 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n\r\n   if (j->succ_high == 0) {\r\n      int shift = j->succ_low;\r\n\r\n      if (j->eob_run) {\r\n         --j->eob_run;\r\n         return 1;\r\n      }\r\n\r\n      k = j->spec_start;\r\n      do {\r\n         unsigned int zig;\r\n         int c,r,s;\r\n         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\r\n         r = fac[c];\r\n         if (r) { // fast-AC path\r\n            k += (r >> 4) & 15; // run\r\n            s = r & 15; // combined length\r\n            j->code_buffer <<= s;\r\n            j->code_bits -= s;\r\n            zig = stbi__jpeg_dezigzag[k++];\r\n            data[zig] = (short) ((r >> 8) << shift);\r\n         } else {\r\n            int rs = stbi__jpeg_huff_decode(j, hac);\r\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n            s = rs & 15;\r\n            r = rs >> 4;\r\n            if (s == 0) {\r\n               if (r < 15) {\r\n                  j->eob_run = (1 << r);\r\n                  if (r)\r\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\r\n                  --j->eob_run;\r\n                  break;\r\n               }\r\n               k += 16;\r\n            } else {\r\n               k += r;\r\n               zig = stbi__jpeg_dezigzag[k++];\r\n               data[zig] = (short) (stbi__extend_receive(j,s) << shift);\r\n            }\r\n         }\r\n      } while (k <= j->spec_end);\r\n   } else {\r\n      // refinement scan for these AC coefficients\r\n\r\n      short bit = (short) (1 << j->succ_low);\r\n\r\n      if (j->eob_run) {\r\n         --j->eob_run;\r\n         for (k = j->spec_start; k <= j->spec_end; ++k) {\r\n            short *p = &data[stbi__jpeg_dezigzag[k]];\r\n            if (*p != 0)\r\n               if (stbi__jpeg_get_bit(j))\r\n                  if ((*p & bit)==0) {\r\n                     if (*p > 0)\r\n                        *p += bit;\r\n                     else\r\n                        *p -= bit;\r\n                  }\r\n         }\r\n      } else {\r\n         k = j->spec_start;\r\n         do {\r\n            int r,s;\r\n            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh\r\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n            s = rs & 15;\r\n            r = rs >> 4;\r\n            if (s == 0) {\r\n               if (r < 15) {\r\n                  j->eob_run = (1 << r) - 1;\r\n                  if (r)\r\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\r\n                  r = 64; // force end of block\r\n               } else {\r\n                  // r=15 s=0 should write 16 0s, so we just do\r\n                  // a run of 15 0s and then write s (which is 0),\r\n                  // so we don't have to do anything special here\r\n               }\r\n            } else {\r\n               if (s != 1) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n               // sign bit\r\n               if (stbi__jpeg_get_bit(j))\r\n                  s = bit;\r\n               else\r\n                  s = -bit;\r\n            }\r\n\r\n            // advance by r\r\n            while (k <= j->spec_end) {\r\n               short *p = &data[stbi__jpeg_dezigzag[k++]];\r\n               if (*p != 0) {\r\n                  if (stbi__jpeg_get_bit(j))\r\n                     if ((*p & bit)==0) {\r\n                        if (*p > 0)\r\n                           *p += bit;\r\n                        else\r\n                           *p -= bit;\r\n                     }\r\n               } else {\r\n                  if (r == 0) {\r\n                     *p = (short) s;\r\n                     break;\r\n                  }\r\n                  --r;\r\n               }\r\n            }\r\n         } while (k <= j->spec_end);\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\n// take a -128..127 value and stbi__clamp it and convert to 0..255\r\nstbi_inline static stbi_uc stbi__clamp(int x)\r\n{\r\n   // trick to use a single test to catch both cases\r\n   if ((unsigned int) x > 255) {\r\n      if (x < 0) return 0;\r\n      if (x > 255) return 255;\r\n   }\r\n   return (stbi_uc) x;\r\n}\r\n\r\n#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))\r\n#define stbi__fsh(x)  ((x) << 12)\r\n\r\n// derived from jidctint -- DCT_ISLOW\r\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \\\r\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\r\n   p2 = s2;                                    \\\r\n   p3 = s6;                                    \\\r\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \\\r\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \\\r\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \\\r\n   p2 = s0;                                    \\\r\n   p3 = s4;                                    \\\r\n   t0 = stbi__fsh(p2+p3);                      \\\r\n   t1 = stbi__fsh(p2-p3);                      \\\r\n   x0 = t0+t3;                                 \\\r\n   x3 = t0-t3;                                 \\\r\n   x1 = t1+t2;                                 \\\r\n   x2 = t1-t2;                                 \\\r\n   t0 = s7;                                    \\\r\n   t1 = s5;                                    \\\r\n   t2 = s3;                                    \\\r\n   t3 = s1;                                    \\\r\n   p3 = t0+t2;                                 \\\r\n   p4 = t1+t3;                                 \\\r\n   p1 = t0+t3;                                 \\\r\n   p2 = t1+t2;                                 \\\r\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \\\r\n   t0 = t0*stbi__f2f( 0.298631336f);           \\\r\n   t1 = t1*stbi__f2f( 2.053119869f);           \\\r\n   t2 = t2*stbi__f2f( 3.072711026f);           \\\r\n   t3 = t3*stbi__f2f( 1.501321110f);           \\\r\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \\\r\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \\\r\n   p3 = p3*stbi__f2f(-1.961570560f);           \\\r\n   p4 = p4*stbi__f2f(-0.390180644f);           \\\r\n   t3 += p1+p4;                                \\\r\n   t2 += p2+p3;                                \\\r\n   t1 += p2+p4;                                \\\r\n   t0 += p1+p3;\r\n\r\nstatic void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])\r\n{\r\n   int i,val[64],*v=val;\r\n   stbi_uc *o;\r\n   short *d = data;\r\n\r\n   // columns\r\n   for (i=0; i < 8; ++i,++d, ++v) {\r\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\r\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\r\n           && d[40]==0 && d[48]==0 && d[56]==0) {\r\n         //    no shortcut                 0     seconds\r\n         //    (1|2|3|4|5|6|7)==0          0     seconds\r\n         //    all separate               -0.047 seconds\r\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\r\n         int dcterm = d[0] << 2;\r\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\r\n      } else {\r\n         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])\r\n         // constants scaled things up by 1<<12; let's bring them back\r\n         // down, but keep 2 extra bits of precision\r\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\r\n         v[ 0] = (x0+t3) >> 10;\r\n         v[56] = (x0-t3) >> 10;\r\n         v[ 8] = (x1+t2) >> 10;\r\n         v[48] = (x1-t2) >> 10;\r\n         v[16] = (x2+t1) >> 10;\r\n         v[40] = (x2-t1) >> 10;\r\n         v[24] = (x3+t0) >> 10;\r\n         v[32] = (x3-t0) >> 10;\r\n      }\r\n   }\r\n\r\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\r\n      // no fast case since the first 1D IDCT spread components out\r\n      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\r\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\r\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\r\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\r\n      // so we want to round that, which means adding 0.5 * 1<<17,\r\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\r\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\r\n      x0 += 65536 + (128<<17);\r\n      x1 += 65536 + (128<<17);\r\n      x2 += 65536 + (128<<17);\r\n      x3 += 65536 + (128<<17);\r\n      // tried computing the shifts into temps, or'ing the temps to see\r\n      // if any were out of range, but that was slower\r\n      o[0] = stbi__clamp((x0+t3) >> 17);\r\n      o[7] = stbi__clamp((x0-t3) >> 17);\r\n      o[1] = stbi__clamp((x1+t2) >> 17);\r\n      o[6] = stbi__clamp((x1-t2) >> 17);\r\n      o[2] = stbi__clamp((x2+t1) >> 17);\r\n      o[5] = stbi__clamp((x2-t1) >> 17);\r\n      o[3] = stbi__clamp((x3+t0) >> 17);\r\n      o[4] = stbi__clamp((x3-t0) >> 17);\r\n   }\r\n}\r\n\r\n#ifdef STBI_SSE2\r\n// sse2 integer IDCT. not the fastest possible implementation but it\r\n// produces bit-identical results to the generic C version so it's\r\n// fully \"transparent\".\r\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\r\n{\r\n   // This is constructed to match our regular (generic) integer IDCT exactly.\r\n   __m128i row0, row1, row2, row3, row4, row5, row6, row7;\r\n   __m128i tmp;\r\n\r\n   // dot product constant: even elems=x, odd elems=y\r\n   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))\r\n\r\n   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)\r\n   // out(1) = c1[even]*x + c1[odd]*y\r\n   #define dct_rot(out0,out1, x,y,c0,c1) \\\r\n      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \\\r\n      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \\\r\n      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \\\r\n      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \\\r\n      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \\\r\n      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)\r\n\r\n   // out = in << 12  (in 16-bit, out 32-bit)\r\n   #define dct_widen(out, in) \\\r\n      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \\\r\n      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)\r\n\r\n   // wide add\r\n   #define dct_wadd(out, a, b) \\\r\n      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \\\r\n      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)\r\n\r\n   // wide sub\r\n   #define dct_wsub(out, a, b) \\\r\n      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \\\r\n      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)\r\n\r\n   // butterfly a/b, add bias, then shift by \"s\" and pack\r\n   #define dct_bfly32o(out0, out1, a,b,bias,s) \\\r\n      { \\\r\n         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \\\r\n         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \\\r\n         dct_wadd(sum, abiased, b); \\\r\n         dct_wsub(dif, abiased, b); \\\r\n         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \\\r\n         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \\\r\n      }\r\n\r\n   // 8-bit interleave step (for transposes)\r\n   #define dct_interleave8(a, b) \\\r\n      tmp = a; \\\r\n      a = _mm_unpacklo_epi8(a, b); \\\r\n      b = _mm_unpackhi_epi8(tmp, b)\r\n\r\n   // 16-bit interleave step (for transposes)\r\n   #define dct_interleave16(a, b) \\\r\n      tmp = a; \\\r\n      a = _mm_unpacklo_epi16(a, b); \\\r\n      b = _mm_unpackhi_epi16(tmp, b)\r\n\r\n   #define dct_pass(bias,shift) \\\r\n      { \\\r\n         /* even part */ \\\r\n         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \\\r\n         __m128i sum04 = _mm_add_epi16(row0, row4); \\\r\n         __m128i dif04 = _mm_sub_epi16(row0, row4); \\\r\n         dct_widen(t0e, sum04); \\\r\n         dct_widen(t1e, dif04); \\\r\n         dct_wadd(x0, t0e, t3e); \\\r\n         dct_wsub(x3, t0e, t3e); \\\r\n         dct_wadd(x1, t1e, t2e); \\\r\n         dct_wsub(x2, t1e, t2e); \\\r\n         /* odd part */ \\\r\n         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \\\r\n         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \\\r\n         __m128i sum17 = _mm_add_epi16(row1, row7); \\\r\n         __m128i sum35 = _mm_add_epi16(row3, row5); \\\r\n         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \\\r\n         dct_wadd(x4, y0o, y4o); \\\r\n         dct_wadd(x5, y1o, y5o); \\\r\n         dct_wadd(x6, y2o, y5o); \\\r\n         dct_wadd(x7, y3o, y4o); \\\r\n         dct_bfly32o(row0,row7, x0,x7,bias,shift); \\\r\n         dct_bfly32o(row1,row6, x1,x6,bias,shift); \\\r\n         dct_bfly32o(row2,row5, x2,x5,bias,shift); \\\r\n         dct_bfly32o(row3,row4, x3,x4,bias,shift); \\\r\n      }\r\n\r\n   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));\r\n   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));\r\n   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));\r\n   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));\r\n   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));\r\n   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));\r\n   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));\r\n   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));\r\n\r\n   // rounding biases in column/row passes, see stbi__idct_block for explanation.\r\n   __m128i bias_0 = _mm_set1_epi32(512);\r\n   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));\r\n\r\n   // load\r\n   row0 = _mm_load_si128((const __m128i *) (data + 0*8));\r\n   row1 = _mm_load_si128((const __m128i *) (data + 1*8));\r\n   row2 = _mm_load_si128((const __m128i *) (data + 2*8));\r\n   row3 = _mm_load_si128((const __m128i *) (data + 3*8));\r\n   row4 = _mm_load_si128((const __m128i *) (data + 4*8));\r\n   row5 = _mm_load_si128((const __m128i *) (data + 5*8));\r\n   row6 = _mm_load_si128((const __m128i *) (data + 6*8));\r\n   row7 = _mm_load_si128((const __m128i *) (data + 7*8));\r\n\r\n   // column pass\r\n   dct_pass(bias_0, 10);\r\n\r\n   {\r\n      // 16bit 8x8 transpose pass 1\r\n      dct_interleave16(row0, row4);\r\n      dct_interleave16(row1, row5);\r\n      dct_interleave16(row2, row6);\r\n      dct_interleave16(row3, row7);\r\n\r\n      // transpose pass 2\r\n      dct_interleave16(row0, row2);\r\n      dct_interleave16(row1, row3);\r\n      dct_interleave16(row4, row6);\r\n      dct_interleave16(row5, row7);\r\n\r\n      // transpose pass 3\r\n      dct_interleave16(row0, row1);\r\n      dct_interleave16(row2, row3);\r\n      dct_interleave16(row4, row5);\r\n      dct_interleave16(row6, row7);\r\n   }\r\n\r\n   // row pass\r\n   dct_pass(bias_1, 17);\r\n\r\n   {\r\n      // pack\r\n      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7\r\n      __m128i p1 = _mm_packus_epi16(row2, row3);\r\n      __m128i p2 = _mm_packus_epi16(row4, row5);\r\n      __m128i p3 = _mm_packus_epi16(row6, row7);\r\n\r\n      // 8bit 8x8 transpose pass 1\r\n      dct_interleave8(p0, p2); // a0e0a1e1...\r\n      dct_interleave8(p1, p3); // c0g0c1g1...\r\n\r\n      // transpose pass 2\r\n      dct_interleave8(p0, p1); // a0c0e0g0...\r\n      dct_interleave8(p2, p3); // b0d0f0h0...\r\n\r\n      // transpose pass 3\r\n      dct_interleave8(p0, p2); // a0b0c0d0...\r\n      dct_interleave8(p1, p3); // a4b4c4d4...\r\n\r\n      // store\r\n      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));\r\n   }\r\n\r\n#undef dct_const\r\n#undef dct_rot\r\n#undef dct_widen\r\n#undef dct_wadd\r\n#undef dct_wsub\r\n#undef dct_bfly32o\r\n#undef dct_interleave8\r\n#undef dct_interleave16\r\n#undef dct_pass\r\n}\r\n\r\n#endif // STBI_SSE2\r\n\r\n#ifdef STBI_NEON\r\n\r\n// NEON integer IDCT. should produce bit-identical\r\n// results to the generic C version.\r\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\r\n{\r\n   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;\r\n\r\n   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));\r\n   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));\r\n   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));\r\n   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));\r\n   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));\r\n   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));\r\n   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));\r\n   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));\r\n   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));\r\n   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));\r\n   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));\r\n   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));\r\n\r\n#define dct_long_mul(out, inq, coeff) \\\r\n   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \\\r\n   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)\r\n\r\n#define dct_long_mac(out, acc, inq, coeff) \\\r\n   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \\\r\n   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)\r\n\r\n#define dct_widen(out, inq) \\\r\n   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \\\r\n   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)\r\n\r\n// wide add\r\n#define dct_wadd(out, a, b) \\\r\n   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \\\r\n   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)\r\n\r\n// wide sub\r\n#define dct_wsub(out, a, b) \\\r\n   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \\\r\n   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)\r\n\r\n// butterfly a/b, then shift using \"shiftop\" by \"s\" and pack\r\n#define dct_bfly32o(out0,out1, a,b,shiftop,s) \\\r\n   { \\\r\n      dct_wadd(sum, a, b); \\\r\n      dct_wsub(dif, a, b); \\\r\n      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \\\r\n      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \\\r\n   }\r\n\r\n#define dct_pass(shiftop, shift) \\\r\n   { \\\r\n      /* even part */ \\\r\n      int16x8_t sum26 = vaddq_s16(row2, row6); \\\r\n      dct_long_mul(p1e, sum26, rot0_0); \\\r\n      dct_long_mac(t2e, p1e, row6, rot0_1); \\\r\n      dct_long_mac(t3e, p1e, row2, rot0_2); \\\r\n      int16x8_t sum04 = vaddq_s16(row0, row4); \\\r\n      int16x8_t dif04 = vsubq_s16(row0, row4); \\\r\n      dct_widen(t0e, sum04); \\\r\n      dct_widen(t1e, dif04); \\\r\n      dct_wadd(x0, t0e, t3e); \\\r\n      dct_wsub(x3, t0e, t3e); \\\r\n      dct_wadd(x1, t1e, t2e); \\\r\n      dct_wsub(x2, t1e, t2e); \\\r\n      /* odd part */ \\\r\n      int16x8_t sum15 = vaddq_s16(row1, row5); \\\r\n      int16x8_t sum17 = vaddq_s16(row1, row7); \\\r\n      int16x8_t sum35 = vaddq_s16(row3, row5); \\\r\n      int16x8_t sum37 = vaddq_s16(row3, row7); \\\r\n      int16x8_t sumodd = vaddq_s16(sum17, sum35); \\\r\n      dct_long_mul(p5o, sumodd, rot1_0); \\\r\n      dct_long_mac(p1o, p5o, sum17, rot1_1); \\\r\n      dct_long_mac(p2o, p5o, sum35, rot1_2); \\\r\n      dct_long_mul(p3o, sum37, rot2_0); \\\r\n      dct_long_mul(p4o, sum15, rot2_1); \\\r\n      dct_wadd(sump13o, p1o, p3o); \\\r\n      dct_wadd(sump24o, p2o, p4o); \\\r\n      dct_wadd(sump23o, p2o, p3o); \\\r\n      dct_wadd(sump14o, p1o, p4o); \\\r\n      dct_long_mac(x4, sump13o, row7, rot3_0); \\\r\n      dct_long_mac(x5, sump24o, row5, rot3_1); \\\r\n      dct_long_mac(x6, sump23o, row3, rot3_2); \\\r\n      dct_long_mac(x7, sump14o, row1, rot3_3); \\\r\n      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \\\r\n      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \\\r\n      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \\\r\n      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \\\r\n   }\r\n\r\n   // load\r\n   row0 = vld1q_s16(data + 0*8);\r\n   row1 = vld1q_s16(data + 1*8);\r\n   row2 = vld1q_s16(data + 2*8);\r\n   row3 = vld1q_s16(data + 3*8);\r\n   row4 = vld1q_s16(data + 4*8);\r\n   row5 = vld1q_s16(data + 5*8);\r\n   row6 = vld1q_s16(data + 6*8);\r\n   row7 = vld1q_s16(data + 7*8);\r\n\r\n   // add DC bias\r\n   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));\r\n\r\n   // column pass\r\n   dct_pass(vrshrn_n_s32, 10);\r\n\r\n   // 16bit 8x8 transpose\r\n   {\r\n// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.\r\n// whether compilers actually get this is another story, sadly.\r\n#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }\r\n#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }\r\n#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }\r\n\r\n      // pass 1\r\n      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6\r\n      dct_trn16(row2, row3);\r\n      dct_trn16(row4, row5);\r\n      dct_trn16(row6, row7);\r\n\r\n      // pass 2\r\n      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4\r\n      dct_trn32(row1, row3);\r\n      dct_trn32(row4, row6);\r\n      dct_trn32(row5, row7);\r\n\r\n      // pass 3\r\n      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0\r\n      dct_trn64(row1, row5);\r\n      dct_trn64(row2, row6);\r\n      dct_trn64(row3, row7);\r\n\r\n#undef dct_trn16\r\n#undef dct_trn32\r\n#undef dct_trn64\r\n   }\r\n\r\n   // row pass\r\n   // vrshrn_n_s32 only supports shifts up to 16, we need\r\n   // 17. so do a non-rounding shift of 16 first then follow\r\n   // up with a rounding shift by 1.\r\n   dct_pass(vshrn_n_s32, 16);\r\n\r\n   {\r\n      // pack and round\r\n      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);\r\n      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);\r\n      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);\r\n      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);\r\n      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);\r\n      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);\r\n      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);\r\n      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);\r\n\r\n      // again, these can translate into one instruction, but often don't.\r\n#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }\r\n#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }\r\n#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }\r\n\r\n      // sadly can't use interleaved stores here since we only write\r\n      // 8 bytes to each scan line!\r\n\r\n      // 8x8 8-bit transpose pass 1\r\n      dct_trn8_8(p0, p1);\r\n      dct_trn8_8(p2, p3);\r\n      dct_trn8_8(p4, p5);\r\n      dct_trn8_8(p6, p7);\r\n\r\n      // pass 2\r\n      dct_trn8_16(p0, p2);\r\n      dct_trn8_16(p1, p3);\r\n      dct_trn8_16(p4, p6);\r\n      dct_trn8_16(p5, p7);\r\n\r\n      // pass 3\r\n      dct_trn8_32(p0, p4);\r\n      dct_trn8_32(p1, p5);\r\n      dct_trn8_32(p2, p6);\r\n      dct_trn8_32(p3, p7);\r\n\r\n      // store\r\n      vst1_u8(out, p0); out += out_stride;\r\n      vst1_u8(out, p1); out += out_stride;\r\n      vst1_u8(out, p2); out += out_stride;\r\n      vst1_u8(out, p3); out += out_stride;\r\n      vst1_u8(out, p4); out += out_stride;\r\n      vst1_u8(out, p5); out += out_stride;\r\n      vst1_u8(out, p6); out += out_stride;\r\n      vst1_u8(out, p7);\r\n\r\n#undef dct_trn8_8\r\n#undef dct_trn8_16\r\n#undef dct_trn8_32\r\n   }\r\n\r\n#undef dct_long_mul\r\n#undef dct_long_mac\r\n#undef dct_widen\r\n#undef dct_wadd\r\n#undef dct_wsub\r\n#undef dct_bfly32o\r\n#undef dct_pass\r\n}\r\n\r\n#endif // STBI_NEON\r\n\r\n#define STBI__MARKER_none  0xff\r\n// if there's a pending marker from the entropy stream, return that\r\n// otherwise, fetch from the stream and get a marker. if there's no\r\n// marker, return 0xff, which is never a valid marker value\r\nstatic stbi_uc stbi__get_marker(stbi__jpeg *j)\r\n{\r\n   stbi_uc x;\r\n   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\r\n   x = stbi__get8(j->s);\r\n   if (x != 0xff) return STBI__MARKER_none;\r\n   while (x == 0xff)\r\n      x = stbi__get8(j->s); // consume repeated 0xff fill bytes\r\n   return x;\r\n}\r\n\r\n// in each scan, we'll have scan_n components, and the order\r\n// of the components is specified by order[]\r\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\r\n\r\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\r\n// the dc prediction\r\nstatic void stbi__jpeg_reset(stbi__jpeg *j)\r\n{\r\n   j->code_bits = 0;\r\n   j->code_buffer = 0;\r\n   j->nomore = 0;\r\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;\r\n   j->marker = STBI__MARKER_none;\r\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\r\n   j->eob_run = 0;\r\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\r\n   // since we don't even allow 1<<30 pixels\r\n}\r\n\r\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg *z)\r\n{\r\n   stbi__jpeg_reset(z);\r\n   if (!z->progressive) {\r\n      if (z->scan_n == 1) {\r\n         int i,j;\r\n         STBI_SIMD_ALIGN(short, data[64]);\r\n         int n = z->order[0];\r\n         // non-interleaved data, we just need to process one block at a time,\r\n         // in trivial scanline order\r\n         // number of blocks to do just depends on how many actual \"pixels\" this\r\n         // component has, independent of interleaved MCU blocking and such\r\n         int w = (z->img_comp[n].x+7) >> 3;\r\n         int h = (z->img_comp[n].y+7) >> 3;\r\n         for (j=0; j < h; ++j) {\r\n            for (i=0; i < w; ++i) {\r\n               int ha = z->img_comp[n].ha;\r\n               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\r\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\r\n               // every data block is an MCU, so countdown the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  // if it's NOT a restart, then just bail, so we get corrupt data\r\n                  // rather than no data\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      } else { // interleaved\r\n         int i,j,k,x,y;\r\n         STBI_SIMD_ALIGN(short, data[64]);\r\n         for (j=0; j < z->img_mcu_y; ++j) {\r\n            for (i=0; i < z->img_mcu_x; ++i) {\r\n               // scan an interleaved mcu... process scan_n components in order\r\n               for (k=0; k < z->scan_n; ++k) {\r\n                  int n = z->order[k];\r\n                  // scan out an mcu's worth of this component; that's just determined\r\n                  // by the basic H and V specified for the component\r\n                  for (y=0; y < z->img_comp[n].v; ++y) {\r\n                     for (x=0; x < z->img_comp[n].h; ++x) {\r\n                        int x2 = (i*z->img_comp[n].h + x)*8;\r\n                        int y2 = (j*z->img_comp[n].v + y)*8;\r\n                        int ha = z->img_comp[n].ha;\r\n                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\r\n                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);\r\n                     }\r\n                  }\r\n               }\r\n               // after all interleaved components, that's an interleaved MCU,\r\n               // so now count down the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      }\r\n   } else {\r\n      if (z->scan_n == 1) {\r\n         int i,j;\r\n         int n = z->order[0];\r\n         // non-interleaved data, we just need to process one block at a time,\r\n         // in trivial scanline order\r\n         // number of blocks to do just depends on how many actual \"pixels\" this\r\n         // component has, independent of interleaved MCU blocking and such\r\n         int w = (z->img_comp[n].x+7) >> 3;\r\n         int h = (z->img_comp[n].y+7) >> 3;\r\n         for (j=0; j < h; ++j) {\r\n            for (i=0; i < w; ++i) {\r\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\r\n               if (z->spec_start == 0) {\r\n                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\r\n                     return 0;\r\n               } else {\r\n                  int ha = z->img_comp[n].ha;\r\n                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))\r\n                     return 0;\r\n               }\r\n               // every data block is an MCU, so countdown the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      } else { // interleaved\r\n         int i,j,k,x,y;\r\n         for (j=0; j < z->img_mcu_y; ++j) {\r\n            for (i=0; i < z->img_mcu_x; ++i) {\r\n               // scan an interleaved mcu... process scan_n components in order\r\n               for (k=0; k < z->scan_n; ++k) {\r\n                  int n = z->order[k];\r\n                  // scan out an mcu's worth of this component; that's just determined\r\n                  // by the basic H and V specified for the component\r\n                  for (y=0; y < z->img_comp[n].v; ++y) {\r\n                     for (x=0; x < z->img_comp[n].h; ++x) {\r\n                        int x2 = (i*z->img_comp[n].h + x);\r\n                        int y2 = (j*z->img_comp[n].v + y);\r\n                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);\r\n                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\r\n                           return 0;\r\n                     }\r\n                  }\r\n               }\r\n               // after all interleaved components, that's an interleaved MCU,\r\n               // so now count down the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)\r\n{\r\n   int i;\r\n   for (i=0; i < 64; ++i)\r\n      data[i] *= dequant[i];\r\n}\r\n\r\nstatic void stbi__jpeg_finish(stbi__jpeg *z)\r\n{\r\n   if (z->progressive) {\r\n      // dequantize and idct the data\r\n      int i,j,n;\r\n      for (n=0; n < z->s->img_n; ++n) {\r\n         int w = (z->img_comp[n].x+7) >> 3;\r\n         int h = (z->img_comp[n].y+7) >> 3;\r\n         for (j=0; j < h; ++j) {\r\n            for (i=0; i < w; ++i) {\r\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\r\n               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);\r\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\r\n            }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic int stbi__process_marker(stbi__jpeg *z, int m)\r\n{\r\n   int L;\r\n   switch (m) {\r\n      case STBI__MARKER_none: // no marker found\r\n         return stbi__err(\"expected marker\",\"Corrupt JPEG\");\r\n\r\n      case 0xDD: // DRI - specify restart interval\r\n         if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\",\"Corrupt JPEG\");\r\n         z->restart_interval = stbi__get16be(z->s);\r\n         return 1;\r\n\r\n      case 0xDB: // DQT - define quantization table\r\n         L = stbi__get16be(z->s)-2;\r\n         while (L > 0) {\r\n            int q = stbi__get8(z->s);\r\n            int p = q >> 4, sixteen = (p != 0);\r\n            int t = q & 15,i;\r\n            if (p != 0 && p != 1) return stbi__err(\"bad DQT type\",\"Corrupt JPEG\");\r\n            if (t > 3) return stbi__err(\"bad DQT table\",\"Corrupt JPEG\");\r\n\r\n            for (i=0; i < 64; ++i)\r\n               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));\r\n            L -= (sixteen ? 129 : 65);\r\n         }\r\n         return L==0;\r\n\r\n      case 0xC4: // DHT - define huffman table\r\n         L = stbi__get16be(z->s)-2;\r\n         while (L > 0) {\r\n            stbi_uc *v;\r\n            int sizes[16],i,n=0;\r\n            int q = stbi__get8(z->s);\r\n            int tc = q >> 4;\r\n            int th = q & 15;\r\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\");\r\n            for (i=0; i < 16; ++i) {\r\n               sizes[i] = stbi__get8(z->s);\r\n               n += sizes[i];\r\n            }\r\n            L -= 17;\r\n            if (tc == 0) {\r\n               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;\r\n               v = z->huff_dc[th].values;\r\n            } else {\r\n               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;\r\n               v = z->huff_ac[th].values;\r\n            }\r\n            for (i=0; i < n; ++i)\r\n               v[i] = stbi__get8(z->s);\r\n            if (tc != 0)\r\n               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);\r\n            L -= n;\r\n         }\r\n         return L==0;\r\n   }\r\n\r\n   // check for comment block or APP blocks\r\n   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\r\n      L = stbi__get16be(z->s);\r\n      if (L < 2) {\r\n         if (m == 0xFE)\r\n            return stbi__err(\"bad COM len\",\"Corrupt JPEG\");\r\n         else\r\n            return stbi__err(\"bad APP len\",\"Corrupt JPEG\");\r\n      }\r\n      L -= 2;\r\n\r\n      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment\r\n         static const unsigned char tag[5] = {'J','F','I','F','\\0'};\r\n         int ok = 1;\r\n         int i;\r\n         for (i=0; i < 5; ++i)\r\n            if (stbi__get8(z->s) != tag[i])\r\n               ok = 0;\r\n         L -= 5;\r\n         if (ok)\r\n            z->jfif = 1;\r\n      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment\r\n         static const unsigned char tag[6] = {'A','d','o','b','e','\\0'};\r\n         int ok = 1;\r\n         int i;\r\n         for (i=0; i < 6; ++i)\r\n            if (stbi__get8(z->s) != tag[i])\r\n               ok = 0;\r\n         L -= 6;\r\n         if (ok) {\r\n            stbi__get8(z->s); // version\r\n            stbi__get16be(z->s); // flags0\r\n            stbi__get16be(z->s); // flags1\r\n            z->app14_color_transform = stbi__get8(z->s); // color transform\r\n            L -= 6;\r\n         }\r\n      }\r\n\r\n      stbi__skip(z->s, L);\r\n      return 1;\r\n   }\r\n\r\n   return stbi__err(\"unknown marker\",\"Corrupt JPEG\");\r\n}\r\n\r\n// after we see SOS\r\nstatic int stbi__process_scan_header(stbi__jpeg *z)\r\n{\r\n   int i;\r\n   int Ls = stbi__get16be(z->s);\r\n   z->scan_n = stbi__get8(z->s);\r\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(\"bad SOS component count\",\"Corrupt JPEG\");\r\n   if (Ls != 6+2*z->scan_n) return stbi__err(\"bad SOS len\",\"Corrupt JPEG\");\r\n   for (i=0; i < z->scan_n; ++i) {\r\n      int id = stbi__get8(z->s), which;\r\n      int q = stbi__get8(z->s);\r\n      for (which = 0; which < z->s->img_n; ++which)\r\n         if (z->img_comp[which].id == id)\r\n            break;\r\n      if (which == z->s->img_n) return 0; // no match\r\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\",\"Corrupt JPEG\");\r\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\",\"Corrupt JPEG\");\r\n      z->order[i] = which;\r\n   }\r\n\r\n   {\r\n      int aa;\r\n      z->spec_start = stbi__get8(z->s);\r\n      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0\r\n      aa = stbi__get8(z->s);\r\n      z->succ_high = (aa >> 4);\r\n      z->succ_low  = (aa & 15);\r\n      if (z->progressive) {\r\n         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)\r\n            return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\r\n      } else {\r\n         if (z->spec_start != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\r\n         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\r\n         z->spec_end = 63;\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)\r\n{\r\n   int i;\r\n   for (i=0; i < ncomp; ++i) {\r\n      if (z->img_comp[i].raw_data) {\r\n         STBI_FREE(z->img_comp[i].raw_data);\r\n         z->img_comp[i].raw_data = NULL;\r\n         z->img_comp[i].data = NULL;\r\n      }\r\n      if (z->img_comp[i].raw_coeff) {\r\n         STBI_FREE(z->img_comp[i].raw_coeff);\r\n         z->img_comp[i].raw_coeff = 0;\r\n         z->img_comp[i].coeff = 0;\r\n      }\r\n      if (z->img_comp[i].linebuf) {\r\n         STBI_FREE(z->img_comp[i].linebuf);\r\n         z->img_comp[i].linebuf = NULL;\r\n      }\r\n   }\r\n   return why;\r\n}\r\n\r\nstatic int stbi__process_frame_header(stbi__jpeg *z, int scan)\r\n{\r\n   stbi__context *s = z->s;\r\n   int Lf,p,i,q, h_max=1,v_max=1,c;\r\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\"); // JPEG\r\n   p  = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\r\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\r\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\r\n   c = stbi__get8(s);\r\n   if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\",\"Corrupt JPEG\");\r\n   s->img_n = c;\r\n   for (i=0; i < c; ++i) {\r\n      z->img_comp[i].data = NULL;\r\n      z->img_comp[i].linebuf = NULL;\r\n   }\r\n\r\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\");\r\n\r\n   z->rgb = 0;\r\n   for (i=0; i < s->img_n; ++i) {\r\n      static unsigned char rgb[3] = { 'R', 'G', 'B' };\r\n      z->img_comp[i].id = stbi__get8(s);\r\n      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\r\n         ++z->rgb;\r\n      q = stbi__get8(s);\r\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\r\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\r\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\r\n   }\r\n\r\n   if (scan != STBI__SCAN_load) return 1;\r\n\r\n   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\r\n\r\n   for (i=0; i < s->img_n; ++i) {\r\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\r\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\r\n   }\r\n\r\n   // compute interleaved mcu info\r\n   z->img_h_max = h_max;\r\n   z->img_v_max = v_max;\r\n   z->img_mcu_w = h_max * 8;\r\n   z->img_mcu_h = v_max * 8;\r\n   // these sizes can't be more than 17 bits\r\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\r\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\r\n\r\n   for (i=0; i < s->img_n; ++i) {\r\n      // number of effective pixels (e.g. for non-interleaved MCU)\r\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\r\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\r\n      // to simplify generation, we'll allocate enough memory to decode\r\n      // the bogus oversized data from using interleaved MCUs and their\r\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\r\n      // discard the extra data until colorspace conversion\r\n      //\r\n      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\r\n      // so these muls can't overflow with 32-bit ints (which we require)\r\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\r\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\r\n      z->img_comp[i].coeff = 0;\r\n      z->img_comp[i].raw_coeff = 0;\r\n      z->img_comp[i].linebuf = NULL;\r\n      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\r\n      if (z->img_comp[i].raw_data == NULL)\r\n         return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\r\n      // align blocks for idct using mmx/sse\r\n      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);\r\n      if (z->progressive) {\r\n         // w2, h2 are multiples of 8 (see above)\r\n         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\r\n         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\r\n         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\r\n         if (z->img_comp[i].raw_coeff == NULL)\r\n            return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\r\n         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n// use comparisons since in some cases we handle more than one case (e.g. SOF)\r\n#define stbi__DNL(x)         ((x) == 0xdc)\r\n#define stbi__SOI(x)         ((x) == 0xd8)\r\n#define stbi__EOI(x)         ((x) == 0xd9)\r\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)\r\n#define stbi__SOS(x)         ((x) == 0xda)\r\n\r\n#define stbi__SOF_progressive(x)   ((x) == 0xc2)\r\n\r\nstatic int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)\r\n{\r\n   int m;\r\n   z->jfif = 0;\r\n   z->app14_color_transform = -1; // valid values are 0,1,2\r\n   z->marker = STBI__MARKER_none; // initialize cached marker to empty\r\n   m = stbi__get_marker(z);\r\n   if (!stbi__SOI(m)) return stbi__err(\"no SOI\",\"Corrupt JPEG\");\r\n   if (scan == STBI__SCAN_type) return 1;\r\n   m = stbi__get_marker(z);\r\n   while (!stbi__SOF(m)) {\r\n      if (!stbi__process_marker(z,m)) return 0;\r\n      m = stbi__get_marker(z);\r\n      while (m == STBI__MARKER_none) {\r\n         // some files have extra padding after their blocks, so ok, we'll scan\r\n         if (stbi__at_eof(z->s)) return stbi__err(\"no SOF\", \"Corrupt JPEG\");\r\n         m = stbi__get_marker(z);\r\n      }\r\n   }\r\n   z->progressive = stbi__SOF_progressive(m);\r\n   if (!stbi__process_frame_header(z, scan)) return 0;\r\n   return 1;\r\n}\r\n\r\n// decode image to YCbCr format\r\nstatic int stbi__decode_jpeg_image(stbi__jpeg *j)\r\n{\r\n   int m;\r\n   for (m = 0; m < 4; m++) {\r\n      j->img_comp[m].raw_data = NULL;\r\n      j->img_comp[m].raw_coeff = NULL;\r\n   }\r\n   j->restart_interval = 0;\r\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;\r\n   m = stbi__get_marker(j);\r\n   while (!stbi__EOI(m)) {\r\n      if (stbi__SOS(m)) {\r\n         if (!stbi__process_scan_header(j)) return 0;\r\n         if (!stbi__parse_entropy_coded_data(j)) return 0;\r\n         if (j->marker == STBI__MARKER_none ) {\r\n            // handle 0s at the end of image data from IP Kamera 9060\r\n            while (!stbi__at_eof(j->s)) {\r\n               int x = stbi__get8(j->s);\r\n               if (x == 255) {\r\n                  j->marker = stbi__get8(j->s);\r\n                  break;\r\n               }\r\n            }\r\n            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\r\n         }\r\n      } else if (stbi__DNL(m)) {\r\n         int Ld = stbi__get16be(j->s);\r\n         stbi__uint32 NL = stbi__get16be(j->s);\r\n         if (Ld != 4) stbi__err(\"bad DNL len\", \"Corrupt JPEG\");\r\n         if (NL != j->s->img_y) stbi__err(\"bad DNL height\", \"Corrupt JPEG\");\r\n      } else {\r\n         if (!stbi__process_marker(j, m)) return 0;\r\n      }\r\n      m = stbi__get_marker(j);\r\n   }\r\n   if (j->progressive)\r\n      stbi__jpeg_finish(j);\r\n   return 1;\r\n}\r\n\r\n// static jfif-centered resampling (across block boundaries)\r\n\r\ntypedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\r\n                                    int w, int hs);\r\n\r\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\r\n\r\nstatic stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   STBI_NOTUSED(out);\r\n   STBI_NOTUSED(in_far);\r\n   STBI_NOTUSED(w);\r\n   STBI_NOTUSED(hs);\r\n   return in_near;\r\n}\r\n\r\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate two samples vertically for every one in input\r\n   int i;\r\n   STBI_NOTUSED(hs);\r\n   for (i=0; i < w; ++i)\r\n      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);\r\n   return out;\r\n}\r\n\r\nstatic stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate two samples horizontally for every one in input\r\n   int i;\r\n   stbi_uc *input = in_near;\r\n\r\n   if (w == 1) {\r\n      // if only one sample, can't do any interpolation\r\n      out[0] = out[1] = input[0];\r\n      return out;\r\n   }\r\n\r\n   out[0] = input[0];\r\n   out[1] = stbi__div4(input[0]*3 + input[1] + 2);\r\n   for (i=1; i < w-1; ++i) {\r\n      int n = 3*input[i]+2;\r\n      out[i*2+0] = stbi__div4(n+input[i-1]);\r\n      out[i*2+1] = stbi__div4(n+input[i+1]);\r\n   }\r\n   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);\r\n   out[i*2+1] = input[w-1];\r\n\r\n   STBI_NOTUSED(in_far);\r\n   STBI_NOTUSED(hs);\r\n\r\n   return out;\r\n}\r\n\r\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\r\n\r\nstatic stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate 2x2 samples for every one in input\r\n   int i,t0,t1;\r\n   if (w == 1) {\r\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\r\n      return out;\r\n   }\r\n\r\n   t1 = 3*in_near[0] + in_far[0];\r\n   out[0] = stbi__div4(t1+2);\r\n   for (i=1; i < w; ++i) {\r\n      t0 = t1;\r\n      t1 = 3*in_near[i]+in_far[i];\r\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\r\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\r\n   }\r\n   out[w*2-1] = stbi__div4(t1+2);\r\n\r\n   STBI_NOTUSED(hs);\r\n\r\n   return out;\r\n}\r\n\r\n#if defined(STBI_SSE2) || defined(STBI_NEON)\r\nstatic stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate 2x2 samples for every one in input\r\n   int i=0,t0,t1;\r\n\r\n   if (w == 1) {\r\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\r\n      return out;\r\n   }\r\n\r\n   t1 = 3*in_near[0] + in_far[0];\r\n   // process groups of 8 pixels for as long as we can.\r\n   // note we can't handle the last pixel in a row in this loop\r\n   // because we need to handle the filter boundary conditions.\r\n   for (; i < ((w-1) & ~7); i += 8) {\r\n#if defined(STBI_SSE2)\r\n      // load and perform the vertical filtering pass\r\n      // this uses 3*x + y = 4*x + (y - x)\r\n      __m128i zero  = _mm_setzero_si128();\r\n      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));\r\n      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));\r\n      __m128i farw  = _mm_unpacklo_epi8(farb, zero);\r\n      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);\r\n      __m128i diff  = _mm_sub_epi16(farw, nearw);\r\n      __m128i nears = _mm_slli_epi16(nearw, 2);\r\n      __m128i curr  = _mm_add_epi16(nears, diff); // current row\r\n\r\n      // horizontal filter works the same based on shifted vers of current\r\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\r\n      // insert the previous pixel value (from t1).\r\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\r\n      // of next block of 8 pixels added in.\r\n      __m128i prv0 = _mm_slli_si128(curr, 2);\r\n      __m128i nxt0 = _mm_srli_si128(curr, 2);\r\n      __m128i prev = _mm_insert_epi16(prv0, t1, 0);\r\n      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);\r\n\r\n      // horizontal filter, polyphase implementation since it's convenient:\r\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\r\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\r\n      // note the shared term.\r\n      __m128i bias  = _mm_set1_epi16(8);\r\n      __m128i curs = _mm_slli_epi16(curr, 2);\r\n      __m128i prvd = _mm_sub_epi16(prev, curr);\r\n      __m128i nxtd = _mm_sub_epi16(next, curr);\r\n      __m128i curb = _mm_add_epi16(curs, bias);\r\n      __m128i even = _mm_add_epi16(prvd, curb);\r\n      __m128i odd  = _mm_add_epi16(nxtd, curb);\r\n\r\n      // interleave even and odd pixels, then undo scaling.\r\n      __m128i int0 = _mm_unpacklo_epi16(even, odd);\r\n      __m128i int1 = _mm_unpackhi_epi16(even, odd);\r\n      __m128i de0  = _mm_srli_epi16(int0, 4);\r\n      __m128i de1  = _mm_srli_epi16(int1, 4);\r\n\r\n      // pack and write output\r\n      __m128i outv = _mm_packus_epi16(de0, de1);\r\n      _mm_storeu_si128((__m128i *) (out + i*2), outv);\r\n#elif defined(STBI_NEON)\r\n      // load and perform the vertical filtering pass\r\n      // this uses 3*x + y = 4*x + (y - x)\r\n      uint8x8_t farb  = vld1_u8(in_far + i);\r\n      uint8x8_t nearb = vld1_u8(in_near + i);\r\n      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));\r\n      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));\r\n      int16x8_t curr  = vaddq_s16(nears, diff); // current row\r\n\r\n      // horizontal filter works the same based on shifted vers of current\r\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\r\n      // insert the previous pixel value (from t1).\r\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\r\n      // of next block of 8 pixels added in.\r\n      int16x8_t prv0 = vextq_s16(curr, curr, 7);\r\n      int16x8_t nxt0 = vextq_s16(curr, curr, 1);\r\n      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);\r\n      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);\r\n\r\n      // horizontal filter, polyphase implementation since it's convenient:\r\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\r\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\r\n      // note the shared term.\r\n      int16x8_t curs = vshlq_n_s16(curr, 2);\r\n      int16x8_t prvd = vsubq_s16(prev, curr);\r\n      int16x8_t nxtd = vsubq_s16(next, curr);\r\n      int16x8_t even = vaddq_s16(curs, prvd);\r\n      int16x8_t odd  = vaddq_s16(curs, nxtd);\r\n\r\n      // undo scaling and round, then store with even/odd phases interleaved\r\n      uint8x8x2_t o;\r\n      o.val[0] = vqrshrun_n_s16(even, 4);\r\n      o.val[1] = vqrshrun_n_s16(odd,  4);\r\n      vst2_u8(out + i*2, o);\r\n#endif\r\n\r\n      // \"previous\" value for next iter\r\n      t1 = 3*in_near[i+7] + in_far[i+7];\r\n   }\r\n\r\n   t0 = t1;\r\n   t1 = 3*in_near[i] + in_far[i];\r\n   out[i*2] = stbi__div16(3*t1 + t0 + 8);\r\n\r\n   for (++i; i < w; ++i) {\r\n      t0 = t1;\r\n      t1 = 3*in_near[i]+in_far[i];\r\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\r\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\r\n   }\r\n   out[w*2-1] = stbi__div4(t1+2);\r\n\r\n   STBI_NOTUSED(hs);\r\n\r\n   return out;\r\n}\r\n#endif\r\n\r\nstatic stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // resample with nearest-neighbor\r\n   int i,j;\r\n   STBI_NOTUSED(in_far);\r\n   for (i=0; i < w; ++i)\r\n      for (j=0; j < hs; ++j)\r\n         out[i*hs+j] = in_near[i];\r\n   return out;\r\n}\r\n\r\n// this is a reduced-precision calculation of YCbCr-to-RGB introduced\r\n// to make sure the code produces the same results in both SIMD and scalar\r\n#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)\r\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)\r\n{\r\n   int i;\r\n   for (i=0; i < count; ++i) {\r\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\r\n      int r,g,b;\r\n      int cr = pcr[i] - 128;\r\n      int cb = pcb[i] - 128;\r\n      r = y_fixed +  cr* stbi__float2fixed(1.40200f);\r\n      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\r\n      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);\r\n      r >>= 20;\r\n      g >>= 20;\r\n      b >>= 20;\r\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\r\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\r\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\r\n      out[0] = (stbi_uc)r;\r\n      out[1] = (stbi_uc)g;\r\n      out[2] = (stbi_uc)b;\r\n      out[3] = 255;\r\n      out += step;\r\n   }\r\n}\r\n\r\n#if defined(STBI_SSE2) || defined(STBI_NEON)\r\nstatic void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)\r\n{\r\n   int i = 0;\r\n\r\n#ifdef STBI_SSE2\r\n   // step == 3 is pretty ugly on the final interleave, and i'm not convinced\r\n   // it's useful in practice (you wouldn't use it for textures, for example).\r\n   // so just accelerate step == 4 case.\r\n   if (step == 4) {\r\n      // this is a fairly straightforward implementation and not super-optimized.\r\n      __m128i signflip  = _mm_set1_epi8(-0x80);\r\n      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));\r\n      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));\r\n      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));\r\n      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));\r\n      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);\r\n      __m128i xw = _mm_set1_epi16(255); // alpha channel\r\n\r\n      for (; i+7 < count; i += 8) {\r\n         // load\r\n         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));\r\n         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));\r\n         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));\r\n         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128\r\n         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128\r\n\r\n         // unpack to short (and left-shift cr, cb by 8)\r\n         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);\r\n         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);\r\n         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);\r\n\r\n         // color transform\r\n         __m128i yws = _mm_srli_epi16(yw, 4);\r\n         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);\r\n         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);\r\n         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);\r\n         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);\r\n         __m128i rws = _mm_add_epi16(cr0, yws);\r\n         __m128i gwt = _mm_add_epi16(cb0, yws);\r\n         __m128i bws = _mm_add_epi16(yws, cb1);\r\n         __m128i gws = _mm_add_epi16(gwt, cr1);\r\n\r\n         // descale\r\n         __m128i rw = _mm_srai_epi16(rws, 4);\r\n         __m128i bw = _mm_srai_epi16(bws, 4);\r\n         __m128i gw = _mm_srai_epi16(gws, 4);\r\n\r\n         // back to byte, set up for transpose\r\n         __m128i brb = _mm_packus_epi16(rw, bw);\r\n         __m128i gxb = _mm_packus_epi16(gw, xw);\r\n\r\n         // transpose to interleave channels\r\n         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);\r\n         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);\r\n         __m128i o0 = _mm_unpacklo_epi16(t0, t1);\r\n         __m128i o1 = _mm_unpackhi_epi16(t0, t1);\r\n\r\n         // store\r\n         _mm_storeu_si128((__m128i *) (out + 0), o0);\r\n         _mm_storeu_si128((__m128i *) (out + 16), o1);\r\n         out += 32;\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n   // in this version, step=3 support would be easy to add. but is there demand?\r\n   if (step == 4) {\r\n      // this is a fairly straightforward implementation and not super-optimized.\r\n      uint8x8_t signflip = vdup_n_u8(0x80);\r\n      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));\r\n      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));\r\n      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));\r\n      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));\r\n\r\n      for (; i+7 < count; i += 8) {\r\n         // load\r\n         uint8x8_t y_bytes  = vld1_u8(y + i);\r\n         uint8x8_t cr_bytes = vld1_u8(pcr + i);\r\n         uint8x8_t cb_bytes = vld1_u8(pcb + i);\r\n         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));\r\n         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));\r\n\r\n         // expand to s16\r\n         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));\r\n         int16x8_t crw = vshll_n_s8(cr_biased, 7);\r\n         int16x8_t cbw = vshll_n_s8(cb_biased, 7);\r\n\r\n         // color transform\r\n         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);\r\n         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);\r\n         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);\r\n         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);\r\n         int16x8_t rws = vaddq_s16(yws, cr0);\r\n         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);\r\n         int16x8_t bws = vaddq_s16(yws, cb1);\r\n\r\n         // undo scaling, round, convert to byte\r\n         uint8x8x4_t o;\r\n         o.val[0] = vqrshrun_n_s16(rws, 4);\r\n         o.val[1] = vqrshrun_n_s16(gws, 4);\r\n         o.val[2] = vqrshrun_n_s16(bws, 4);\r\n         o.val[3] = vdup_n_u8(255);\r\n\r\n         // store, interleaving r/g/b/a\r\n         vst4_u8(out, o);\r\n         out += 8*4;\r\n      }\r\n   }\r\n#endif\r\n\r\n   for (; i < count; ++i) {\r\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\r\n      int r,g,b;\r\n      int cr = pcr[i] - 128;\r\n      int cb = pcb[i] - 128;\r\n      r = y_fixed + cr* stbi__float2fixed(1.40200f);\r\n      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\r\n      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);\r\n      r >>= 20;\r\n      g >>= 20;\r\n      b >>= 20;\r\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\r\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\r\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\r\n      out[0] = (stbi_uc)r;\r\n      out[1] = (stbi_uc)g;\r\n      out[2] = (stbi_uc)b;\r\n      out[3] = 255;\r\n      out += step;\r\n   }\r\n}\r\n#endif\r\n\r\n// set up the kernels\r\nstatic void stbi__setup_jpeg(stbi__jpeg *j)\r\n{\r\n   j->idct_block_kernel = stbi__idct_block;\r\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;\r\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;\r\n\r\n#ifdef STBI_SSE2\r\n   if (stbi__sse2_available()) {\r\n      j->idct_block_kernel = stbi__idct_simd;\r\n      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\r\n      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\r\n   }\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n   j->idct_block_kernel = stbi__idct_simd;\r\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\r\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\r\n#endif\r\n}\r\n\r\n// clean up the temporary component buffers\r\nstatic void stbi__cleanup_jpeg(stbi__jpeg *j)\r\n{\r\n   stbi__free_jpeg_components(j, j->s->img_n, 0);\r\n}\r\n\r\ntypedef struct\r\n{\r\n   resample_row_func resample;\r\n   stbi_uc *line0,*line1;\r\n   int hs,vs;   // expansion factor in each axis\r\n   int w_lores; // horizontal pixels pre-expansion\r\n   int ystep;   // how far through vertical expansion we are\r\n   int ypos;    // which pre-expansion row we're on\r\n} stbi__resample;\r\n\r\n// fast 0..255 * 0..255 => 0..255 rounded multiplication\r\nstatic stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)\r\n{\r\n   unsigned int t = x*y + 128;\r\n   return (stbi_uc) ((t + (t >>8)) >> 8);\r\n}\r\n\r\nstatic stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)\r\n{\r\n   int n, decode_n, is_rgb;\r\n   z->s->img_n = 0; // make stbi__cleanup_jpeg safe\r\n\r\n   // validate req_comp\r\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\r\n\r\n   // load a jpeg image from whichever source, but leave in YCbCr format\r\n   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\r\n\r\n   // determine actual number of components to generate\r\n   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;\r\n\r\n   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));\r\n\r\n   if (z->s->img_n == 3 && n < 3 && !is_rgb)\r\n      decode_n = 1;\r\n   else\r\n      decode_n = z->s->img_n;\r\n\r\n   // resample and color-convert\r\n   {\r\n      int k;\r\n      unsigned int i,j;\r\n      stbi_uc *output;\r\n      stbi_uc *coutput[4];\r\n\r\n      stbi__resample res_comp[4];\r\n\r\n      for (k=0; k < decode_n; ++k) {\r\n         stbi__resample *r = &res_comp[k];\r\n\r\n         // allocate line buffer big enough for upsampling off the edges\r\n         // with upsample factor of 4\r\n         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);\r\n         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n\r\n         r->hs      = z->img_h_max / z->img_comp[k].h;\r\n         r->vs      = z->img_v_max / z->img_comp[k].v;\r\n         r->ystep   = r->vs >> 1;\r\n         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;\r\n         r->ypos    = 0;\r\n         r->line0   = r->line1 = z->img_comp[k].data;\r\n\r\n         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\r\n         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\r\n         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\r\n         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;\r\n         else                               r->resample = stbi__resample_row_generic;\r\n      }\r\n\r\n      // can't error after this so, this is safe\r\n      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);\r\n      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n\r\n      // now go ahead and resample\r\n      for (j=0; j < z->s->img_y; ++j) {\r\n         stbi_uc *out = output + n * z->s->img_x * j;\r\n         for (k=0; k < decode_n; ++k) {\r\n            stbi__resample *r = &res_comp[k];\r\n            int y_bot = r->ystep >= (r->vs >> 1);\r\n            coutput[k] = r->resample(z->img_comp[k].linebuf,\r\n                                     y_bot ? r->line1 : r->line0,\r\n                                     y_bot ? r->line0 : r->line1,\r\n                                     r->w_lores, r->hs);\r\n            if (++r->ystep >= r->vs) {\r\n               r->ystep = 0;\r\n               r->line0 = r->line1;\r\n               if (++r->ypos < z->img_comp[k].y)\r\n                  r->line1 += z->img_comp[k].w2;\r\n            }\r\n         }\r\n         if (n >= 3) {\r\n            stbi_uc *y = coutput[0];\r\n            if (z->s->img_n == 3) {\r\n               if (is_rgb) {\r\n                  for (i=0; i < z->s->img_x; ++i) {\r\n                     out[0] = y[i];\r\n                     out[1] = coutput[1][i];\r\n                     out[2] = coutput[2][i];\r\n                     out[3] = 255;\r\n                     out += n;\r\n                  }\r\n               } else {\r\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n               }\r\n            } else if (z->s->img_n == 4) {\r\n               if (z->app14_color_transform == 0) { // CMYK\r\n                  for (i=0; i < z->s->img_x; ++i) {\r\n                     stbi_uc m = coutput[3][i];\r\n                     out[0] = stbi__blinn_8x8(coutput[0][i], m);\r\n                     out[1] = stbi__blinn_8x8(coutput[1][i], m);\r\n                     out[2] = stbi__blinn_8x8(coutput[2][i], m);\r\n                     out[3] = 255;\r\n                     out += n;\r\n                  }\r\n               } else if (z->app14_color_transform == 2) { // YCCK\r\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n                  for (i=0; i < z->s->img_x; ++i) {\r\n                     stbi_uc m = coutput[3][i];\r\n                     out[0] = stbi__blinn_8x8(255 - out[0], m);\r\n                     out[1] = stbi__blinn_8x8(255 - out[1], m);\r\n                     out[2] = stbi__blinn_8x8(255 - out[2], m);\r\n                     out += n;\r\n                  }\r\n               } else { // YCbCr + alpha?  Ignore the fourth channel for now\r\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n               }\r\n            } else\r\n               for (i=0; i < z->s->img_x; ++i) {\r\n                  out[0] = out[1] = out[2] = y[i];\r\n                  out[3] = 255; // not used if n==3\r\n                  out += n;\r\n               }\r\n         } else {\r\n            if (is_rgb) {\r\n               if (n == 1)\r\n                  for (i=0; i < z->s->img_x; ++i)\r\n                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\r\n               else {\r\n                  for (i=0; i < z->s->img_x; ++i, out += 2) {\r\n                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\r\n                     out[1] = 255;\r\n                  }\r\n               }\r\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {\r\n               for (i=0; i < z->s->img_x; ++i) {\r\n                  stbi_uc m = coutput[3][i];\r\n                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);\r\n                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);\r\n                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);\r\n                  out[0] = stbi__compute_y(r, g, b);\r\n                  out[1] = 255;\r\n                  out += n;\r\n               }\r\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {\r\n               for (i=0; i < z->s->img_x; ++i) {\r\n                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);\r\n                  out[1] = 255;\r\n                  out += n;\r\n               }\r\n            } else {\r\n               stbi_uc *y = coutput[0];\r\n               if (n == 1)\r\n                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];\r\n               else\r\n                  for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;\r\n            }\r\n         }\r\n      }\r\n      stbi__cleanup_jpeg(z);\r\n      *out_x = z->s->img_x;\r\n      *out_y = z->s->img_y;\r\n      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output\r\n      return output;\r\n   }\r\n}\r\n\r\nstatic void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   unsigned char* result;\r\n   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));\r\n   STBI_NOTUSED(ri);\r\n   j->s = s;\r\n   stbi__setup_jpeg(j);\r\n   result = load_jpeg_image(j, x,y,comp,req_comp);\r\n   STBI_FREE(j);\r\n   return result;\r\n}\r\n\r\nstatic int stbi__jpeg_test(stbi__context *s)\r\n{\r\n   int r;\r\n   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\r\n   j->s = s;\r\n   stbi__setup_jpeg(j);\r\n   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);\r\n   stbi__rewind(s);\r\n   STBI_FREE(j);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)\r\n{\r\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {\r\n      stbi__rewind( j->s );\r\n      return 0;\r\n   }\r\n   if (x) *x = j->s->img_x;\r\n   if (y) *y = j->s->img_y;\r\n   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int result;\r\n   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));\r\n   j->s = s;\r\n   result = stbi__jpeg_info_raw(j, x, y, comp);\r\n   STBI_FREE(j);\r\n   return result;\r\n}\r\n#endif\r\n\r\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\r\n//    simple implementation\r\n//      - all input must be provided in an upfront buffer\r\n//      - all output is written to a single output buffer (can malloc/realloc)\r\n//    performance\r\n//      - fast huffman\r\n\r\n#ifndef STBI_NO_ZLIB\r\n\r\n// fast-way is faster to check than jpeg huffman, but slow way is slower\r\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\r\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\r\n\r\n// zlib-style huffman encoding\r\n// (jpegs packs from left, zlib from right, so can't share code)\r\ntypedef struct\r\n{\r\n   stbi__uint16 fast[1 << STBI__ZFAST_BITS];\r\n   stbi__uint16 firstcode[16];\r\n   int maxcode[17];\r\n   stbi__uint16 firstsymbol[16];\r\n   stbi_uc  size[288];\r\n   stbi__uint16 value[288];\r\n} stbi__zhuffman;\r\n\r\nstbi_inline static int stbi__bitreverse16(int n)\r\n{\r\n  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);\r\n  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);\r\n  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);\r\n  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);\r\n  return n;\r\n}\r\n\r\nstbi_inline static int stbi__bit_reverse(int v, int bits)\r\n{\r\n   STBI_ASSERT(bits <= 16);\r\n   // to bit reverse n bits, reverse 16 and shift\r\n   // e.g. 11 bits, bit reverse and shift away 5\r\n   return stbi__bitreverse16(v) >> (16-bits);\r\n}\r\n\r\nstatic int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)\r\n{\r\n   int i,k=0;\r\n   int code, next_code[16], sizes[17];\r\n\r\n   // DEFLATE spec for generating codes\r\n   memset(sizes, 0, sizeof(sizes));\r\n   memset(z->fast, 0, sizeof(z->fast));\r\n   for (i=0; i < num; ++i)\r\n      ++sizes[sizelist[i]];\r\n   sizes[0] = 0;\r\n   for (i=1; i < 16; ++i)\r\n      if (sizes[i] > (1 << i))\r\n         return stbi__err(\"bad sizes\", \"Corrupt PNG\");\r\n   code = 0;\r\n   for (i=1; i < 16; ++i) {\r\n      next_code[i] = code;\r\n      z->firstcode[i] = (stbi__uint16) code;\r\n      z->firstsymbol[i] = (stbi__uint16) k;\r\n      code = (code + sizes[i]);\r\n      if (sizes[i])\r\n         if (code-1 >= (1 << i)) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\r\n      z->maxcode[i] = code << (16-i); // preshift for inner loop\r\n      code <<= 1;\r\n      k += sizes[i];\r\n   }\r\n   z->maxcode[16] = 0x10000; // sentinel\r\n   for (i=0; i < num; ++i) {\r\n      int s = sizelist[i];\r\n      if (s) {\r\n         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\r\n         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);\r\n         z->size [c] = (stbi_uc     ) s;\r\n         z->value[c] = (stbi__uint16) i;\r\n         if (s <= STBI__ZFAST_BITS) {\r\n            int j = stbi__bit_reverse(next_code[s],s);\r\n            while (j < (1 << STBI__ZFAST_BITS)) {\r\n               z->fast[j] = fastv;\r\n               j += (1 << s);\r\n            }\r\n         }\r\n         ++next_code[s];\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\n// zlib-from-memory implementation for PNG reading\r\n//    because PNG allows splitting the zlib stream arbitrarily,\r\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\r\n//    we require PNG read all the IDATs and combine them into a single\r\n//    memory buffer\r\n\r\ntypedef struct\r\n{\r\n   stbi_uc *zbuffer, *zbuffer_end;\r\n   int num_bits;\r\n   stbi__uint32 code_buffer;\r\n\r\n   char *zout;\r\n   char *zout_start;\r\n   char *zout_end;\r\n   int   z_expandable;\r\n\r\n   stbi__zhuffman z_length, z_distance;\r\n} stbi__zbuf;\r\n\r\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)\r\n{\r\n   if (z->zbuffer >= z->zbuffer_end) return 0;\r\n   return *z->zbuffer++;\r\n}\r\n\r\nstatic void stbi__fill_bits(stbi__zbuf *z)\r\n{\r\n   do {\r\n      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));\r\n      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;\r\n      z->num_bits += 8;\r\n   } while (z->num_bits <= 24);\r\n}\r\n\r\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)\r\n{\r\n   unsigned int k;\r\n   if (z->num_bits < n) stbi__fill_bits(z);\r\n   k = z->code_buffer & ((1 << n) - 1);\r\n   z->code_buffer >>= n;\r\n   z->num_bits -= n;\r\n   return k;\r\n}\r\n\r\nstatic int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)\r\n{\r\n   int b,s,k;\r\n   // not resolved by fast table, so compute it the slow way\r\n   // use jpeg approach, which requires MSbits at top\r\n   k = stbi__bit_reverse(a->code_buffer, 16);\r\n   for (s=STBI__ZFAST_BITS+1; ; ++s)\r\n      if (k < z->maxcode[s])\r\n         break;\r\n   if (s == 16) return -1; // invalid code!\r\n   // code size is s, so:\r\n   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];\r\n   STBI_ASSERT(z->size[b] == s);\r\n   a->code_buffer >>= s;\r\n   a->num_bits -= s;\r\n   return z->value[b];\r\n}\r\n\r\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)\r\n{\r\n   int b,s;\r\n   if (a->num_bits < 16) stbi__fill_bits(a);\r\n   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\r\n   if (b) {\r\n      s = b >> 9;\r\n      a->code_buffer >>= s;\r\n      a->num_bits -= s;\r\n      return b & 511;\r\n   }\r\n   return stbi__zhuffman_decode_slowpath(a, z);\r\n}\r\n\r\nstatic int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes\r\n{\r\n   char *q;\r\n   int cur, limit, old_limit;\r\n   z->zout = zout;\r\n   if (!z->z_expandable) return stbi__err(\"output buffer limit\",\"Corrupt PNG\");\r\n   cur   = (int) (z->zout     - z->zout_start);\r\n   limit = old_limit = (int) (z->zout_end - z->zout_start);\r\n   while (cur + n > limit)\r\n      limit *= 2;\r\n   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);\r\n   STBI_NOTUSED(old_limit);\r\n   if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n   z->zout_start = q;\r\n   z->zout       = q + cur;\r\n   z->zout_end   = q + limit;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__zlength_base[31] = {\r\n   3,4,5,6,7,8,9,10,11,13,\r\n   15,17,19,23,27,31,35,43,51,59,\r\n   67,83,99,115,131,163,195,227,258,0,0 };\r\n\r\nstatic int stbi__zlength_extra[31]=\r\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\r\n\r\nstatic int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\r\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\r\n\r\nstatic int stbi__zdist_extra[32] =\r\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\r\n\r\nstatic int stbi__parse_huffman_block(stbi__zbuf *a)\r\n{\r\n   char *zout = a->zout;\r\n   for(;;) {\r\n      int z = stbi__zhuffman_decode(a, &a->z_length);\r\n      if (z < 256) {\r\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // error in huffman codes\r\n         if (zout >= a->zout_end) {\r\n            if (!stbi__zexpand(a, zout, 1)) return 0;\r\n            zout = a->zout;\r\n         }\r\n         *zout++ = (char) z;\r\n      } else {\r\n         stbi_uc *p;\r\n         int len,dist;\r\n         if (z == 256) {\r\n            a->zout = zout;\r\n            return 1;\r\n         }\r\n         z -= 257;\r\n         len = stbi__zlength_base[z];\r\n         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\r\n         z = stbi__zhuffman_decode(a, &a->z_distance);\r\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\");\r\n         dist = stbi__zdist_base[z];\r\n         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\r\n         if (zout - a->zout_start < dist) return stbi__err(\"bad dist\",\"Corrupt PNG\");\r\n         if (zout + len > a->zout_end) {\r\n            if (!stbi__zexpand(a, zout, len)) return 0;\r\n            zout = a->zout;\r\n         }\r\n         p = (stbi_uc *) (zout - dist);\r\n         if (dist == 1) { // run of one byte; common in images.\r\n            stbi_uc v = *p;\r\n            if (len) { do *zout++ = v; while (--len); }\r\n         } else {\r\n            if (len) { do *zout++ = *p++; while (--len); }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic int stbi__compute_huffman_codes(stbi__zbuf *a)\r\n{\r\n   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\r\n   stbi__zhuffman z_codelength;\r\n   stbi_uc lencodes[286+32+137];//padding for maximum single op\r\n   stbi_uc codelength_sizes[19];\r\n   int i,n;\r\n\r\n   int hlit  = stbi__zreceive(a,5) + 257;\r\n   int hdist = stbi__zreceive(a,5) + 1;\r\n   int hclen = stbi__zreceive(a,4) + 4;\r\n   int ntot  = hlit + hdist;\r\n\r\n   memset(codelength_sizes, 0, sizeof(codelength_sizes));\r\n   for (i=0; i < hclen; ++i) {\r\n      int s = stbi__zreceive(a,3);\r\n      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;\r\n   }\r\n   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\r\n\r\n   n = 0;\r\n   while (n < ntot) {\r\n      int c = stbi__zhuffman_decode(a, &z_codelength);\r\n      if (c < 0 || c >= 19) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n      if (c < 16)\r\n         lencodes[n++] = (stbi_uc) c;\r\n      else {\r\n         stbi_uc fill = 0;\r\n         if (c == 16) {\r\n            c = stbi__zreceive(a,2)+3;\r\n            if (n == 0) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n            fill = lencodes[n-1];\r\n         } else if (c == 17)\r\n            c = stbi__zreceive(a,3)+3;\r\n         else {\r\n            STBI_ASSERT(c == 18);\r\n            c = stbi__zreceive(a,7)+11;\r\n         }\r\n         if (ntot - n < c) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n         memset(lencodes+n, fill, c);\r\n         n += c;\r\n      }\r\n   }\r\n   if (n != ntot) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\r\n   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\r\n   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__parse_uncompressed_block(stbi__zbuf *a)\r\n{\r\n   stbi_uc header[4];\r\n   int len,nlen,k;\r\n   if (a->num_bits & 7)\r\n      stbi__zreceive(a, a->num_bits & 7); // discard\r\n   // drain the bit-packed data into header\r\n   k = 0;\r\n   while (a->num_bits > 0) {\r\n      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check\r\n      a->code_buffer >>= 8;\r\n      a->num_bits -= 8;\r\n   }\r\n   STBI_ASSERT(a->num_bits == 0);\r\n   // now fill header the normal way\r\n   while (k < 4)\r\n      header[k++] = stbi__zget8(a);\r\n   len  = header[1] * 256 + header[0];\r\n   nlen = header[3] * 256 + header[2];\r\n   if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\r\n   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\",\"Corrupt PNG\");\r\n   if (a->zout + len > a->zout_end)\r\n      if (!stbi__zexpand(a, a->zout, len)) return 0;\r\n   memcpy(a->zout, a->zbuffer, len);\r\n   a->zbuffer += len;\r\n   a->zout += len;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__parse_zlib_header(stbi__zbuf *a)\r\n{\r\n   int cmf   = stbi__zget8(a);\r\n   int cm    = cmf & 15;\r\n   /* int cinfo = cmf >> 4; */\r\n   int flg   = stbi__zget8(a);\r\n   if ((cmf*256+flg) % 31 != 0) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\r\n   if (flg & 32) return stbi__err(\"no preset dict\",\"Corrupt PNG\"); // preset dictionary not allowed in png\r\n   if (cm != 8) return stbi__err(\"bad compression\",\"Corrupt PNG\"); // DEFLATE required for png\r\n   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\r\n   return 1;\r\n}\r\n\r\nstatic const stbi_uc stbi__zdefault_length[288] =\r\n{\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8\r\n};\r\nstatic const stbi_uc stbi__zdefault_distance[32] =\r\n{\r\n   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\r\n};\r\n/*\r\nInit algorithm:\r\n{\r\n   int i;   // use <= to match clearly with spec\r\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\r\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\r\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\r\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\r\n\r\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\r\n}\r\n*/\r\n\r\nstatic int stbi__parse_zlib(stbi__zbuf *a, int parse_header)\r\n{\r\n   int final, type;\r\n   if (parse_header)\r\n      if (!stbi__parse_zlib_header(a)) return 0;\r\n   a->num_bits = 0;\r\n   a->code_buffer = 0;\r\n   do {\r\n      final = stbi__zreceive(a,1);\r\n      type = stbi__zreceive(a,2);\r\n      if (type == 0) {\r\n         if (!stbi__parse_uncompressed_block(a)) return 0;\r\n      } else if (type == 3) {\r\n         return 0;\r\n      } else {\r\n         if (type == 1) {\r\n            // use fixed code lengths\r\n            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;\r\n            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;\r\n         } else {\r\n            if (!stbi__compute_huffman_codes(a)) return 0;\r\n         }\r\n         if (!stbi__parse_huffman_block(a)) return 0;\r\n      }\r\n   } while (!final);\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)\r\n{\r\n   a->zout_start = obuf;\r\n   a->zout       = obuf;\r\n   a->zout_end   = obuf + olen;\r\n   a->z_expandable = exp;\r\n\r\n   return stbi__parse_zlib(a, parse_header);\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)\r\n{\r\n   stbi__zbuf a;\r\n   char *p = (char *) stbi__malloc(initial_size);\r\n   if (p == NULL) return NULL;\r\n   a.zbuffer = (stbi_uc *) buffer;\r\n   a.zbuffer_end = (stbi_uc *) buffer + len;\r\n   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\r\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\r\n      return a.zout_start;\r\n   } else {\r\n      STBI_FREE(a.zout_start);\r\n      return NULL;\r\n   }\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)\r\n{\r\n   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)\r\n{\r\n   stbi__zbuf a;\r\n   char *p = (char *) stbi__malloc(initial_size);\r\n   if (p == NULL) return NULL;\r\n   a.zbuffer = (stbi_uc *) buffer;\r\n   a.zbuffer_end = (stbi_uc *) buffer + len;\r\n   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\r\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\r\n      return a.zout_start;\r\n   } else {\r\n      STBI_FREE(a.zout_start);\r\n      return NULL;\r\n   }\r\n}\r\n\r\nSTBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)\r\n{\r\n   stbi__zbuf a;\r\n   a.zbuffer = (stbi_uc *) ibuffer;\r\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\r\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\r\n      return (int) (a.zout - a.zout_start);\r\n   else\r\n      return -1;\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)\r\n{\r\n   stbi__zbuf a;\r\n   char *p = (char *) stbi__malloc(16384);\r\n   if (p == NULL) return NULL;\r\n   a.zbuffer = (stbi_uc *) buffer;\r\n   a.zbuffer_end = (stbi_uc *) buffer+len;\r\n   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\r\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\r\n      return a.zout_start;\r\n   } else {\r\n      STBI_FREE(a.zout_start);\r\n      return NULL;\r\n   }\r\n}\r\n\r\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)\r\n{\r\n   stbi__zbuf a;\r\n   a.zbuffer = (stbi_uc *) ibuffer;\r\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\r\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\r\n      return (int) (a.zout - a.zout_start);\r\n   else\r\n      return -1;\r\n}\r\n#endif\r\n\r\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\r\n//    simple implementation\r\n//      - only 8-bit samples\r\n//      - no CRC checking\r\n//      - allocates lots of intermediate memory\r\n//        - avoids problem of streaming data between subsystems\r\n//        - avoids explicit window management\r\n//    performance\r\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\r\n\r\n#ifndef STBI_NO_PNG\r\ntypedef struct\r\n{\r\n   stbi__uint32 length;\r\n   stbi__uint32 type;\r\n} stbi__pngchunk;\r\n\r\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context *s)\r\n{\r\n   stbi__pngchunk c;\r\n   c.length = stbi__get32be(s);\r\n   c.type   = stbi__get32be(s);\r\n   return c;\r\n}\r\n\r\nstatic int stbi__check_png_header(stbi__context *s)\r\n{\r\n   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\r\n   int i;\r\n   for (i=0; i < 8; ++i)\r\n      if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\",\"Not a PNG\");\r\n   return 1;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   stbi__context *s;\r\n   stbi_uc *idata, *expanded, *out;\r\n   int depth;\r\n} stbi__png;\r\n\r\n\r\nenum {\r\n   STBI__F_none=0,\r\n   STBI__F_sub=1,\r\n   STBI__F_up=2,\r\n   STBI__F_avg=3,\r\n   STBI__F_paeth=4,\r\n   // synthetic filters used for first scanline to avoid needing a dummy row of 0s\r\n   STBI__F_avg_first,\r\n   STBI__F_paeth_first\r\n};\r\n\r\nstatic stbi_uc first_row_filter[5] =\r\n{\r\n   STBI__F_none,\r\n   STBI__F_sub,\r\n   STBI__F_none,\r\n   STBI__F_avg_first,\r\n   STBI__F_paeth_first\r\n};\r\n\r\nstatic int stbi__paeth(int a, int b, int c)\r\n{\r\n   int p = a + b - c;\r\n   int pa = abs(p-a);\r\n   int pb = abs(p-b);\r\n   int pc = abs(p-c);\r\n   if (pa <= pb && pa <= pc) return a;\r\n   if (pb <= pc) return b;\r\n   return c;\r\n}\r\n\r\nstatic stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };\r\n\r\n// create the png data from post-deflated data\r\nstatic int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)\r\n{\r\n   int bytes = (depth == 16? 2 : 1);\r\n   stbi__context *s = a->s;\r\n   stbi__uint32 i,j,stride = x*out_n*bytes;\r\n   stbi__uint32 img_len, img_width_bytes;\r\n   int k;\r\n   int img_n = s->img_n; // copy it into a local for later\r\n\r\n   int output_bytes = out_n*bytes;\r\n   int filter_bytes = img_n*bytes;\r\n   int width = x;\r\n\r\n   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);\r\n   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into\r\n   if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\r\n\r\n   img_width_bytes = (((img_n * x * depth) + 7) >> 3);\r\n   img_len = (img_width_bytes + 1) * y;\r\n   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,\r\n   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),\r\n   // so just check for raw_len < img_len always.\r\n   if (raw_len < img_len) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\r\n\r\n   for (j=0; j < y; ++j) {\r\n      stbi_uc *cur = a->out + stride*j;\r\n      stbi_uc *prior;\r\n      int filter = *raw++;\r\n\r\n      if (filter > 4)\r\n         return stbi__err(\"invalid filter\",\"Corrupt PNG\");\r\n\r\n      if (depth < 8) {\r\n         STBI_ASSERT(img_width_bytes <= x);\r\n         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place\r\n         filter_bytes = 1;\r\n         width = img_width_bytes;\r\n      }\r\n      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above\r\n\r\n      // if first row, use special filter that doesn't sample previous row\r\n      if (j == 0) filter = first_row_filter[filter];\r\n\r\n      // handle first byte explicitly\r\n      for (k=0; k < filter_bytes; ++k) {\r\n         switch (filter) {\r\n            case STBI__F_none       : cur[k] = raw[k]; break;\r\n            case STBI__F_sub        : cur[k] = raw[k]; break;\r\n            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\r\n            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;\r\n            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;\r\n            case STBI__F_avg_first  : cur[k] = raw[k]; break;\r\n            case STBI__F_paeth_first: cur[k] = raw[k]; break;\r\n         }\r\n      }\r\n\r\n      if (depth == 8) {\r\n         if (img_n != out_n)\r\n            cur[img_n] = 255; // first pixel\r\n         raw += img_n;\r\n         cur += out_n;\r\n         prior += out_n;\r\n      } else if (depth == 16) {\r\n         if (img_n != out_n) {\r\n            cur[filter_bytes]   = 255; // first pixel top byte\r\n            cur[filter_bytes+1] = 255; // first pixel bottom byte\r\n         }\r\n         raw += filter_bytes;\r\n         cur += output_bytes;\r\n         prior += output_bytes;\r\n      } else {\r\n         raw += 1;\r\n         cur += 1;\r\n         prior += 1;\r\n      }\r\n\r\n      // this is a little gross, so that we don't switch per-pixel or per-component\r\n      if (depth < 8 || img_n == out_n) {\r\n         int nk = (width - 1)*filter_bytes;\r\n         #define STBI__CASE(f) \\\r\n             case f:     \\\r\n                for (k=0; k < nk; ++k)\r\n         switch (filter) {\r\n            // \"none\" filter turns into a memcpy here; make that explicit.\r\n            case STBI__F_none:         memcpy(cur, raw, nk); break;\r\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;\r\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\r\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;\r\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;\r\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;\r\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;\r\n         }\r\n         #undef STBI__CASE\r\n         raw += nk;\r\n      } else {\r\n         STBI_ASSERT(img_n+1 == out_n);\r\n         #define STBI__CASE(f) \\\r\n             case f:     \\\r\n                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \\\r\n                   for (k=0; k < filter_bytes; ++k)\r\n         switch (filter) {\r\n            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;\r\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;\r\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\r\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;\r\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;\r\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;\r\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;\r\n         }\r\n         #undef STBI__CASE\r\n\r\n         // the loop above sets the high byte of the pixels' alpha, but for\r\n         // 16 bit png files we also need the low byte set. we'll do that here.\r\n         if (depth == 16) {\r\n            cur = a->out + stride*j; // start at the beginning of the row again\r\n            for (i=0; i < x; ++i,cur+=output_bytes) {\r\n               cur[filter_bytes+1] = 255;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // we make a separate pass to expand bits to pixels; for performance,\r\n   // this could run two scanlines behind the above code, so it won't\r\n   // intefere with filtering but will still be in the cache.\r\n   if (depth < 8) {\r\n      for (j=0; j < y; ++j) {\r\n         stbi_uc *cur = a->out + stride*j;\r\n         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;\r\n         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit\r\n         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop\r\n         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range\r\n\r\n         // note that the final byte might overshoot and write more data than desired.\r\n         // we can allocate enough data that this never writes out of memory, but it\r\n         // could also overwrite the next scanline. can it overwrite non-empty data\r\n         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.\r\n         // so we need to explicitly clamp the final ones\r\n\r\n         if (depth == 4) {\r\n            for (k=x*img_n; k >= 2; k-=2, ++in) {\r\n               *cur++ = scale * ((*in >> 4)       );\r\n               *cur++ = scale * ((*in     ) & 0x0f);\r\n            }\r\n            if (k > 0) *cur++ = scale * ((*in >> 4)       );\r\n         } else if (depth == 2) {\r\n            for (k=x*img_n; k >= 4; k-=4, ++in) {\r\n               *cur++ = scale * ((*in >> 6)       );\r\n               *cur++ = scale * ((*in >> 4) & 0x03);\r\n               *cur++ = scale * ((*in >> 2) & 0x03);\r\n               *cur++ = scale * ((*in     ) & 0x03);\r\n            }\r\n            if (k > 0) *cur++ = scale * ((*in >> 6)       );\r\n            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);\r\n            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);\r\n         } else if (depth == 1) {\r\n            for (k=x*img_n; k >= 8; k-=8, ++in) {\r\n               *cur++ = scale * ((*in >> 7)       );\r\n               *cur++ = scale * ((*in >> 6) & 0x01);\r\n               *cur++ = scale * ((*in >> 5) & 0x01);\r\n               *cur++ = scale * ((*in >> 4) & 0x01);\r\n               *cur++ = scale * ((*in >> 3) & 0x01);\r\n               *cur++ = scale * ((*in >> 2) & 0x01);\r\n               *cur++ = scale * ((*in >> 1) & 0x01);\r\n               *cur++ = scale * ((*in     ) & 0x01);\r\n            }\r\n            if (k > 0) *cur++ = scale * ((*in >> 7)       );\r\n            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);\r\n            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);\r\n            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);\r\n            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);\r\n            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);\r\n            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);\r\n         }\r\n         if (img_n != out_n) {\r\n            int q;\r\n            // insert alpha = 255\r\n            cur = a->out + stride*j;\r\n            if (img_n == 1) {\r\n               for (q=x-1; q >= 0; --q) {\r\n                  cur[q*2+1] = 255;\r\n                  cur[q*2+0] = cur[q];\r\n               }\r\n            } else {\r\n               STBI_ASSERT(img_n == 3);\r\n               for (q=x-1; q >= 0; --q) {\r\n                  cur[q*4+3] = 255;\r\n                  cur[q*4+2] = cur[q*3+2];\r\n                  cur[q*4+1] = cur[q*3+1];\r\n                  cur[q*4+0] = cur[q*3+0];\r\n               }\r\n            }\r\n         }\r\n      }\r\n   } else if (depth == 16) {\r\n      // force the image data from big-endian to platform-native.\r\n      // this is done in a separate pass due to the decoding relying\r\n      // on the data being untouched, but could probably be done\r\n      // per-line during decode if care is taken.\r\n      stbi_uc *cur = a->out;\r\n      stbi__uint16 *cur16 = (stbi__uint16*)cur;\r\n\r\n      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {\r\n         *cur16 = (cur[0] << 8) | cur[1];\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)\r\n{\r\n   int bytes = (depth == 16 ? 2 : 1);\r\n   int out_bytes = out_n * bytes;\r\n   stbi_uc *final;\r\n   int p;\r\n   if (!interlaced)\r\n      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);\r\n\r\n   // de-interlacing\r\n   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);\r\n   for (p=0; p < 7; ++p) {\r\n      int xorig[] = { 0,4,0,2,0,1,0 };\r\n      int yorig[] = { 0,0,4,0,2,0,1 };\r\n      int xspc[]  = { 8,8,4,4,2,2,1 };\r\n      int yspc[]  = { 8,8,8,4,4,2,2 };\r\n      int i,j,x,y;\r\n      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\r\n      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];\r\n      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];\r\n      if (x && y) {\r\n         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;\r\n         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {\r\n            STBI_FREE(final);\r\n            return 0;\r\n         }\r\n         for (j=0; j < y; ++j) {\r\n            for (i=0; i < x; ++i) {\r\n               int out_y = j*yspc[p]+yorig[p];\r\n               int out_x = i*xspc[p]+xorig[p];\r\n               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,\r\n                      a->out + (j*x+i)*out_bytes, out_bytes);\r\n            }\r\n         }\r\n         STBI_FREE(a->out);\r\n         image_data += img_len;\r\n         image_data_len -= img_len;\r\n      }\r\n   }\r\n   a->out = final;\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)\r\n{\r\n   stbi__context *s = z->s;\r\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n   stbi_uc *p = z->out;\r\n\r\n   // compute color-based transparency, assuming we've\r\n   // already got 255 as the alpha value in the output\r\n   STBI_ASSERT(out_n == 2 || out_n == 4);\r\n\r\n   if (out_n == 2) {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         p[1] = (p[0] == tc[0] ? 0 : 255);\r\n         p += 2;\r\n      }\r\n   } else {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\r\n            p[3] = 0;\r\n         p += 4;\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)\r\n{\r\n   stbi__context *s = z->s;\r\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n   stbi__uint16 *p = (stbi__uint16*) z->out;\r\n\r\n   // compute color-based transparency, assuming we've\r\n   // already got 65535 as the alpha value in the output\r\n   STBI_ASSERT(out_n == 2 || out_n == 4);\r\n\r\n   if (out_n == 2) {\r\n      for (i = 0; i < pixel_count; ++i) {\r\n         p[1] = (p[0] == tc[0] ? 0 : 65535);\r\n         p += 2;\r\n      }\r\n   } else {\r\n      for (i = 0; i < pixel_count; ++i) {\r\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\r\n            p[3] = 0;\r\n         p += 4;\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)\r\n{\r\n   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\r\n   stbi_uc *p, *temp_out, *orig = a->out;\r\n\r\n   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);\r\n   if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n\r\n   // between here and free(out) below, exitting would leak\r\n   temp_out = p;\r\n\r\n   if (pal_img_n == 3) {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         int n = orig[i]*4;\r\n         p[0] = palette[n  ];\r\n         p[1] = palette[n+1];\r\n         p[2] = palette[n+2];\r\n         p += 3;\r\n      }\r\n   } else {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         int n = orig[i]*4;\r\n         p[0] = palette[n  ];\r\n         p[1] = palette[n+1];\r\n         p[2] = palette[n+2];\r\n         p[3] = palette[n+3];\r\n         p += 4;\r\n      }\r\n   }\r\n   STBI_FREE(a->out);\r\n   a->out = temp_out;\r\n\r\n   STBI_NOTUSED(len);\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__unpremultiply_on_load = 0;\r\nstatic int stbi__de_iphone_flag = 0;\r\n\r\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\r\n{\r\n   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;\r\n}\r\n\r\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\r\n{\r\n   stbi__de_iphone_flag = flag_true_if_should_convert;\r\n}\r\n\r\nstatic void stbi__de_iphone(stbi__png *z)\r\n{\r\n   stbi__context *s = z->s;\r\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n   stbi_uc *p = z->out;\r\n\r\n   if (s->img_out_n == 3) {  // convert bgr to rgb\r\n      for (i=0; i < pixel_count; ++i) {\r\n         stbi_uc t = p[0];\r\n         p[0] = p[2];\r\n         p[2] = t;\r\n         p += 3;\r\n      }\r\n   } else {\r\n      STBI_ASSERT(s->img_out_n == 4);\r\n      if (stbi__unpremultiply_on_load) {\r\n         // convert bgr to rgb and unpremultiply\r\n         for (i=0; i < pixel_count; ++i) {\r\n            stbi_uc a = p[3];\r\n            stbi_uc t = p[0];\r\n            if (a) {\r\n               stbi_uc half = a / 2;\r\n               p[0] = (p[2] * 255 + half) / a;\r\n               p[1] = (p[1] * 255 + half) / a;\r\n               p[2] = ( t   * 255 + half) / a;\r\n            } else {\r\n               p[0] = p[2];\r\n               p[2] = t;\r\n            }\r\n            p += 4;\r\n         }\r\n      } else {\r\n         // convert bgr to rgb\r\n         for (i=0; i < pixel_count; ++i) {\r\n            stbi_uc t = p[0];\r\n            p[0] = p[2];\r\n            p[2] = t;\r\n            p += 4;\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\n#define STBI__PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))\r\n\r\nstatic int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)\r\n{\r\n   stbi_uc palette[1024], pal_img_n=0;\r\n   stbi_uc has_trans=0, tc[3];\r\n   stbi__uint16 tc16[3];\r\n   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;\r\n   int first=1,k,interlace=0, color=0, is_iphone=0;\r\n   stbi__context *s = z->s;\r\n\r\n   z->expanded = NULL;\r\n   z->idata = NULL;\r\n   z->out = NULL;\r\n\r\n   if (!stbi__check_png_header(s)) return 0;\r\n\r\n   if (scan == STBI__SCAN_type) return 1;\r\n\r\n   for (;;) {\r\n      stbi__pngchunk c = stbi__get_chunk_header(s);\r\n      switch (c.type) {\r\n         case STBI__PNG_TYPE('C','g','B','I'):\r\n            is_iphone = 1;\r\n            stbi__skip(s, c.length);\r\n            break;\r\n         case STBI__PNG_TYPE('I','H','D','R'): {\r\n            int comp,filter;\r\n            if (!first) return stbi__err(\"multiple IHDR\",\"Corrupt PNG\");\r\n            first = 0;\r\n            if (c.length != 13) return stbi__err(\"bad IHDR len\",\"Corrupt PNG\");\r\n            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\r\n            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\r\n            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(\"1/2/4/8/16-bit only\",\"PNG not supported: 1/2/4/8/16-bit only\");\r\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\",\"Corrupt PNG\");\r\n            if (color == 3 && z->depth == 16)                  return stbi__err(\"bad ctype\",\"Corrupt PNG\");\r\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\",\"Corrupt PNG\");\r\n            comp  = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\",\"Corrupt PNG\");\r\n            filter= stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\",\"Corrupt PNG\");\r\n            interlace = stbi__get8(s); if (interlace>1) return stbi__err(\"bad interlace method\",\"Corrupt PNG\");\r\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\",\"Corrupt PNG\");\r\n            if (!pal_img_n) {\r\n               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\r\n               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\r\n               if (scan == STBI__SCAN_header) return 1;\r\n            } else {\r\n               // if paletted, then pal_n is our final components, and\r\n               // img_n is # components to decompress/filter.\r\n               s->img_n = 1;\r\n               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\",\"Corrupt PNG\");\r\n               // if SCAN_header, have to scan to see if we have a tRNS\r\n            }\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('P','L','T','E'):  {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (c.length > 256*3) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\r\n            pal_len = c.length / 3;\r\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\r\n            for (i=0; i < pal_len; ++i) {\r\n               palette[i*4+0] = stbi__get8(s);\r\n               palette[i*4+1] = stbi__get8(s);\r\n               palette[i*4+2] = stbi__get8(s);\r\n               palette[i*4+3] = 255;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('t','R','N','S'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (z->idata) return stbi__err(\"tRNS after IDAT\",\"Corrupt PNG\");\r\n            if (pal_img_n) {\r\n               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }\r\n               if (pal_len == 0) return stbi__err(\"tRNS before PLTE\",\"Corrupt PNG\");\r\n               if (c.length > pal_len) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\r\n               pal_img_n = 4;\r\n               for (i=0; i < c.length; ++i)\r\n                  palette[i*4+3] = stbi__get8(s);\r\n            } else {\r\n               if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\",\"Corrupt PNG\");\r\n               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\r\n               has_trans = 1;\r\n               if (z->depth == 16) {\r\n                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is\r\n               } else {\r\n                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('I','D','A','T'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\",\"Corrupt PNG\");\r\n            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }\r\n            if ((int)(ioff + c.length) < (int)ioff) return 0;\r\n            if (ioff + c.length > idata_limit) {\r\n               stbi__uint32 idata_limit_old = idata_limit;\r\n               stbi_uc *p;\r\n               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\r\n               while (ioff + c.length > idata_limit)\r\n                  idata_limit *= 2;\r\n               STBI_NOTUSED(idata_limit_old);\r\n               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n               z->idata = p;\r\n            }\r\n            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(\"outofdata\",\"Corrupt PNG\");\r\n            ioff += c.length;\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('I','E','N','D'): {\r\n            stbi__uint32 raw_len, bpl;\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (scan != STBI__SCAN_load) return 1;\r\n            if (z->idata == NULL) return stbi__err(\"no IDAT\",\"Corrupt PNG\");\r\n            // initial guess for decoded data size to avoid unnecessary reallocs\r\n            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component\r\n            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;\r\n            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);\r\n            if (z->expanded == NULL) return 0; // zlib should set error\r\n            STBI_FREE(z->idata); z->idata = NULL;\r\n            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)\r\n               s->img_out_n = s->img_n+1;\r\n            else\r\n               s->img_out_n = s->img_n;\r\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;\r\n            if (has_trans) {\r\n               if (z->depth == 16) {\r\n                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;\r\n               } else {\r\n                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\r\n               }\r\n            }\r\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\r\n               stbi__de_iphone(z);\r\n            if (pal_img_n) {\r\n               // pal_img_n == 3 or 4\r\n               s->img_n = pal_img_n; // record the actual colors we had\r\n               s->img_out_n = pal_img_n;\r\n               if (req_comp >= 3) s->img_out_n = req_comp;\r\n               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\r\n                  return 0;\r\n            } else if (has_trans) {\r\n               // non-paletted image with tRNS -> source image has (constant) alpha\r\n               ++s->img_n;\r\n            }\r\n            STBI_FREE(z->expanded); z->expanded = NULL;\r\n            return 1;\r\n         }\r\n\r\n         default:\r\n            // if critical, fail\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if ((c.type & (1 << 29)) == 0) {\r\n               #ifndef STBI_NO_FAILURE_STRINGS\r\n               // not threadsafe\r\n               static char invalid_chunk[] = \"XXXX PNG chunk not known\";\r\n               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\r\n               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\r\n               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);\r\n               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);\r\n               #endif\r\n               return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\r\n            }\r\n            stbi__skip(s, c.length);\r\n            break;\r\n      }\r\n      // end of PNG chunk, read and skip CRC\r\n      stbi__get32be(s);\r\n   }\r\n}\r\n\r\nstatic void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)\r\n{\r\n   void *result=NULL;\r\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\r\n   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {\r\n      if (p->depth < 8)\r\n         ri->bits_per_channel = 8;\r\n      else\r\n         ri->bits_per_channel = p->depth;\r\n      result = p->out;\r\n      p->out = NULL;\r\n      if (req_comp && req_comp != p->s->img_out_n) {\r\n         if (ri->bits_per_channel == 8)\r\n            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\r\n         else\r\n            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\r\n         p->s->img_out_n = req_comp;\r\n         if (result == NULL) return result;\r\n      }\r\n      *x = p->s->img_x;\r\n      *y = p->s->img_y;\r\n      if (n) *n = p->s->img_n;\r\n   }\r\n   STBI_FREE(p->out);      p->out      = NULL;\r\n   STBI_FREE(p->expanded); p->expanded = NULL;\r\n   STBI_FREE(p->idata);    p->idata    = NULL;\r\n\r\n   return result;\r\n}\r\n\r\nstatic void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi__png p;\r\n   p.s = s;\r\n   return stbi__do_png(&p, x,y,comp,req_comp, ri);\r\n}\r\n\r\nstatic int stbi__png_test(stbi__context *s)\r\n{\r\n   int r;\r\n   r = stbi__check_png_header(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)\r\n{\r\n   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {\r\n      stbi__rewind( p->s );\r\n      return 0;\r\n   }\r\n   if (x) *x = p->s->img_x;\r\n   if (y) *y = p->s->img_y;\r\n   if (comp) *comp = p->s->img_n;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   stbi__png p;\r\n   p.s = s;\r\n   return stbi__png_info_raw(&p, x, y, comp);\r\n}\r\n#endif\r\n\r\n// Microsoft/Windows BMP image\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int stbi__bmp_test_raw(stbi__context *s)\r\n{\r\n   int r;\r\n   int sz;\r\n   if (stbi__get8(s) != 'B') return 0;\r\n   if (stbi__get8(s) != 'M') return 0;\r\n   stbi__get32le(s); // discard filesize\r\n   stbi__get16le(s); // discard reserved\r\n   stbi__get16le(s); // discard reserved\r\n   stbi__get32le(s); // discard data offset\r\n   sz = stbi__get32le(s);\r\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__bmp_test(stbi__context *s)\r\n{\r\n   int r = stbi__bmp_test_raw(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\n\r\n// returns 0..31 for the highest set bit\r\nstatic int stbi__high_bit(unsigned int z)\r\n{\r\n   int n=0;\r\n   if (z == 0) return -1;\r\n   if (z >= 0x10000) n += 16, z >>= 16;\r\n   if (z >= 0x00100) n +=  8, z >>=  8;\r\n   if (z >= 0x00010) n +=  4, z >>=  4;\r\n   if (z >= 0x00004) n +=  2, z >>=  2;\r\n   if (z >= 0x00002) n +=  1, z >>=  1;\r\n   return n;\r\n}\r\n\r\nstatic int stbi__bitcount(unsigned int a)\r\n{\r\n   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2\r\n   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4\r\n   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\r\n   a = (a + (a >> 8)); // max 16 per 8 bits\r\n   a = (a + (a >> 16)); // max 32 per 8 bits\r\n   return a & 0xff;\r\n}\r\n\r\nstatic int stbi__shiftsigned(int v, int shift, int bits)\r\n{\r\n   int result;\r\n   int z=0;\r\n\r\n   if (shift < 0) v <<= -shift;\r\n   else v >>= shift;\r\n   result = v;\r\n\r\n   z = bits;\r\n   while (z < 8) {\r\n      result += v >> z;\r\n      z += bits;\r\n   }\r\n   return result;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   int bpp, offset, hsz;\r\n   unsigned int mr,mg,mb,ma, all_a;\r\n} stbi__bmp_data;\r\n\r\nstatic void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)\r\n{\r\n   int hsz;\r\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\r\n   stbi__get32le(s); // discard filesize\r\n   stbi__get16le(s); // discard reserved\r\n   stbi__get16le(s); // discard reserved\r\n   info->offset = stbi__get32le(s);\r\n   info->hsz = hsz = stbi__get32le(s);\r\n   info->mr = info->mg = info->mb = info->ma = 0;\r\n\r\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\r\n   if (hsz == 12) {\r\n      s->img_x = stbi__get16le(s);\r\n      s->img_y = stbi__get16le(s);\r\n   } else {\r\n      s->img_x = stbi__get32le(s);\r\n      s->img_y = stbi__get32le(s);\r\n   }\r\n   if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n   info->bpp = stbi__get16le(s);\r\n   if (info->bpp == 1) return stbi__errpuc(\"monochrome\", \"BMP type not supported: 1-bit\");\r\n   if (hsz != 12) {\r\n      int compress = stbi__get32le(s);\r\n      if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\r\n      stbi__get32le(s); // discard sizeof\r\n      stbi__get32le(s); // discard hres\r\n      stbi__get32le(s); // discard vres\r\n      stbi__get32le(s); // discard colorsused\r\n      stbi__get32le(s); // discard max important\r\n      if (hsz == 40 || hsz == 56) {\r\n         if (hsz == 56) {\r\n            stbi__get32le(s);\r\n            stbi__get32le(s);\r\n            stbi__get32le(s);\r\n            stbi__get32le(s);\r\n         }\r\n         if (info->bpp == 16 || info->bpp == 32) {\r\n            if (compress == 0) {\r\n               if (info->bpp == 32) {\r\n                  info->mr = 0xffu << 16;\r\n                  info->mg = 0xffu <<  8;\r\n                  info->mb = 0xffu <<  0;\r\n                  info->ma = 0xffu << 24;\r\n                  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0\r\n               } else {\r\n                  info->mr = 31u << 10;\r\n                  info->mg = 31u <<  5;\r\n                  info->mb = 31u <<  0;\r\n               }\r\n            } else if (compress == 3) {\r\n               info->mr = stbi__get32le(s);\r\n               info->mg = stbi__get32le(s);\r\n               info->mb = stbi__get32le(s);\r\n               // not documented, but generated by photoshop and handled by mspaint\r\n               if (info->mr == info->mg && info->mg == info->mb) {\r\n                  // ?!?!?\r\n                  return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n               }\r\n            } else\r\n               return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n         }\r\n      } else {\r\n         int i;\r\n         if (hsz != 108 && hsz != 124)\r\n            return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n         info->mr = stbi__get32le(s);\r\n         info->mg = stbi__get32le(s);\r\n         info->mb = stbi__get32le(s);\r\n         info->ma = stbi__get32le(s);\r\n         stbi__get32le(s); // discard color space\r\n         for (i=0; i < 12; ++i)\r\n            stbi__get32le(s); // discard color space parameters\r\n         if (hsz == 124) {\r\n            stbi__get32le(s); // discard rendering intent\r\n            stbi__get32le(s); // discard offset of profile data\r\n            stbi__get32le(s); // discard size of profile data\r\n            stbi__get32le(s); // discard reserved\r\n         }\r\n      }\r\n   }\r\n   return (void *) 1;\r\n}\r\n\r\n\r\nstatic void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *out;\r\n   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;\r\n   stbi_uc pal[256][4];\r\n   int psize=0,i,j,width;\r\n   int flip_vertically, pad, target;\r\n   stbi__bmp_data info;\r\n   STBI_NOTUSED(ri);\r\n\r\n   info.all_a = 255;\r\n   if (stbi__bmp_parse_header(s, &info) == NULL)\r\n      return NULL; // error code already set\r\n\r\n   flip_vertically = ((int) s->img_y) > 0;\r\n   s->img_y = abs((int) s->img_y);\r\n\r\n   mr = info.mr;\r\n   mg = info.mg;\r\n   mb = info.mb;\r\n   ma = info.ma;\r\n   all_a = info.all_a;\r\n\r\n   if (info.hsz == 12) {\r\n      if (info.bpp < 24)\r\n         psize = (info.offset - 14 - 24) / 3;\r\n   } else {\r\n      if (info.bpp < 16)\r\n         psize = (info.offset - 14 - info.hsz) >> 2;\r\n   }\r\n\r\n   s->img_n = ma ? 4 : 3;\r\n   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\r\n      target = req_comp;\r\n   else\r\n      target = s->img_n; // if they want monochrome, we'll post-convert\r\n\r\n   // sanity-check size\r\n   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))\r\n      return stbi__errpuc(\"too large\", \"Corrupt BMP\");\r\n\r\n   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);\r\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   if (info.bpp < 16) {\r\n      int z=0;\r\n      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\r\n      for (i=0; i < psize; ++i) {\r\n         pal[i][2] = stbi__get8(s);\r\n         pal[i][1] = stbi__get8(s);\r\n         pal[i][0] = stbi__get8(s);\r\n         if (info.hsz != 12) stbi__get8(s);\r\n         pal[i][3] = 255;\r\n      }\r\n      stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));\r\n      if (info.bpp == 4) width = (s->img_x + 1) >> 1;\r\n      else if (info.bpp == 8) width = s->img_x;\r\n      else { STBI_FREE(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\r\n      pad = (-width)&3;\r\n      for (j=0; j < (int) s->img_y; ++j) {\r\n         for (i=0; i < (int) s->img_x; i += 2) {\r\n            int v=stbi__get8(s),v2=0;\r\n            if (info.bpp == 4) {\r\n               v2 = v & 15;\r\n               v >>= 4;\r\n            }\r\n            out[z++] = pal[v][0];\r\n            out[z++] = pal[v][1];\r\n            out[z++] = pal[v][2];\r\n            if (target == 4) out[z++] = 255;\r\n            if (i+1 == (int) s->img_x) break;\r\n            v = (info.bpp == 8) ? stbi__get8(s) : v2;\r\n            out[z++] = pal[v][0];\r\n            out[z++] = pal[v][1];\r\n            out[z++] = pal[v][2];\r\n            if (target == 4) out[z++] = 255;\r\n         }\r\n         stbi__skip(s, pad);\r\n      }\r\n   } else {\r\n      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;\r\n      int z = 0;\r\n      int easy=0;\r\n      stbi__skip(s, info.offset - 14 - info.hsz);\r\n      if (info.bpp == 24) width = 3 * s->img_x;\r\n      else if (info.bpp == 16) width = 2*s->img_x;\r\n      else /* bpp = 32 and pad = 0 */ width=0;\r\n      pad = (-width) & 3;\r\n      if (info.bpp == 24) {\r\n         easy = 1;\r\n      } else if (info.bpp == 32) {\r\n         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\r\n            easy = 2;\r\n      }\r\n      if (!easy) {\r\n         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\r\n         // right shift amt to put high bit in position #7\r\n         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);\r\n         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);\r\n         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);\r\n         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);\r\n      }\r\n      for (j=0; j < (int) s->img_y; ++j) {\r\n         if (easy) {\r\n            for (i=0; i < (int) s->img_x; ++i) {\r\n               unsigned char a;\r\n               out[z+2] = stbi__get8(s);\r\n               out[z+1] = stbi__get8(s);\r\n               out[z+0] = stbi__get8(s);\r\n               z += 3;\r\n               a = (easy == 2 ? stbi__get8(s) : 255);\r\n               all_a |= a;\r\n               if (target == 4) out[z++] = a;\r\n            }\r\n         } else {\r\n            int bpp = info.bpp;\r\n            for (i=0; i < (int) s->img_x; ++i) {\r\n               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));\r\n               int a;\r\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\r\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\r\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\r\n               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\r\n               all_a |= a;\r\n               if (target == 4) out[z++] = STBI__BYTECAST(a);\r\n            }\r\n         }\r\n         stbi__skip(s, pad);\r\n      }\r\n   }\r\n\r\n   // if alpha channel is all 0s, replace with all 255s\r\n   if (target == 4 && all_a == 0)\r\n      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)\r\n         out[i] = 255;\r\n\r\n   if (flip_vertically) {\r\n      stbi_uc t;\r\n      for (j=0; j < (int) s->img_y>>1; ++j) {\r\n         stbi_uc *p1 = out +      j     *s->img_x*target;\r\n         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;\r\n         for (i=0; i < (int) s->img_x*target; ++i) {\r\n            t = p1[i], p1[i] = p2[i], p2[i] = t;\r\n         }\r\n      }\r\n   }\r\n\r\n   if (req_comp && req_comp != target) {\r\n      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\r\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n   }\r\n\r\n   *x = s->img_x;\r\n   *y = s->img_y;\r\n   if (comp) *comp = s->img_n;\r\n   return out;\r\n}\r\n#endif\r\n\r\n// Targa Truevision - TGA\r\n// by Jonathan Dummer\r\n#ifndef STBI_NO_TGA\r\n// returns STBI_rgb or whatever, 0 on error\r\nstatic int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)\r\n{\r\n   // only RGB or RGBA (incl. 16bit) or grey allowed\r\n   if(is_rgb16) *is_rgb16 = 0;\r\n   switch(bits_per_pixel) {\r\n      case 8:  return STBI_grey;\r\n      case 16: if(is_grey) return STBI_grey_alpha;\r\n            // else: fall-through\r\n      case 15: if(is_rgb16) *is_rgb16 = 1;\r\n            return STBI_rgb;\r\n      case 24: // fall-through\r\n      case 32: return bits_per_pixel/8;\r\n      default: return 0;\r\n   }\r\n}\r\n\r\nstatic int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;\r\n    int sz, tga_colormap_type;\r\n    stbi__get8(s);                   // discard Offset\r\n    tga_colormap_type = stbi__get8(s); // colormap type\r\n    if( tga_colormap_type > 1 ) {\r\n        stbi__rewind(s);\r\n        return 0;      // only RGB or indexed allowed\r\n    }\r\n    tga_image_type = stbi__get8(s); // image type\r\n    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image\r\n        if (tga_image_type != 1 && tga_image_type != 9) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        stbi__skip(s,4);       // skip index of first colormap entry and number of entries\r\n        sz = stbi__get8(s);    //   check bits per palette color entry\r\n        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        stbi__skip(s,4);       // skip image x and y origin\r\n        tga_colormap_bpp = sz;\r\n    } else { // \"normal\" image w/o colormap - only RGB or grey allowed, +/- RLE\r\n        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {\r\n            stbi__rewind(s);\r\n            return 0; // only RGB or grey allowed, +/- RLE\r\n        }\r\n        stbi__skip(s,9); // skip colormap specification and image x/y origin\r\n        tga_colormap_bpp = 0;\r\n    }\r\n    tga_w = stbi__get16le(s);\r\n    if( tga_w < 1 ) {\r\n        stbi__rewind(s);\r\n        return 0;   // test width\r\n    }\r\n    tga_h = stbi__get16le(s);\r\n    if( tga_h < 1 ) {\r\n        stbi__rewind(s);\r\n        return 0;   // test height\r\n    }\r\n    tga_bits_per_pixel = stbi__get8(s); // bits per pixel\r\n    stbi__get8(s); // ignore alpha bits\r\n    if (tga_colormap_bpp != 0) {\r\n        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {\r\n            // when using a colormap, tga_bits_per_pixel is the size of the indexes\r\n            // I don't think anything but 8 or 16bit indexes makes sense\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);\r\n    } else {\r\n        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);\r\n    }\r\n    if(!tga_comp) {\r\n      stbi__rewind(s);\r\n      return 0;\r\n    }\r\n    if (x) *x = tga_w;\r\n    if (y) *y = tga_h;\r\n    if (comp) *comp = tga_comp;\r\n    return 1;                   // seems to have passed everything\r\n}\r\n\r\nstatic int stbi__tga_test(stbi__context *s)\r\n{\r\n   int res = 0;\r\n   int sz, tga_color_type;\r\n   stbi__get8(s);      //   discard Offset\r\n   tga_color_type = stbi__get8(s);   //   color type\r\n   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed\r\n   sz = stbi__get8(s);   //   image type\r\n   if ( tga_color_type == 1 ) { // colormapped (paletted) image\r\n      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9\r\n      stbi__skip(s,4);       // skip index of first colormap entry and number of entries\r\n      sz = stbi__get8(s);    //   check bits per palette color entry\r\n      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\r\n      stbi__skip(s,4);       // skip image x and y origin\r\n   } else { // \"normal\" image w/o colormap\r\n      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE\r\n      stbi__skip(s,9); // skip colormap specification and image x/y origin\r\n   }\r\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width\r\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height\r\n   sz = stbi__get8(s);   //   bits per pixel\r\n   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index\r\n   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\r\n\r\n   res = 1; // if we got this far, everything's good and we can return 1 instead of 0\r\n\r\nerrorEnd:\r\n   stbi__rewind(s);\r\n   return res;\r\n}\r\n\r\n// read 16bit value and convert to 24bit RGB\r\nstatic void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)\r\n{\r\n   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);\r\n   stbi__uint16 fiveBitMask = 31;\r\n   // we have 3 channels with 5bits each\r\n   int r = (px >> 10) & fiveBitMask;\r\n   int g = (px >> 5) & fiveBitMask;\r\n   int b = px & fiveBitMask;\r\n   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later\r\n   out[0] = (stbi_uc)((r * 255)/31);\r\n   out[1] = (stbi_uc)((g * 255)/31);\r\n   out[2] = (stbi_uc)((b * 255)/31);\r\n\r\n   // some people claim that the most significant bit might be used for alpha\r\n   // (possibly if an alpha-bit is set in the \"image descriptor byte\")\r\n   // but that only made 16bit test images completely translucent..\r\n   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.\r\n}\r\n\r\nstatic void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   //   read in the TGA header stuff\r\n   int tga_offset = stbi__get8(s);\r\n   int tga_indexed = stbi__get8(s);\r\n   int tga_image_type = stbi__get8(s);\r\n   int tga_is_RLE = 0;\r\n   int tga_palette_start = stbi__get16le(s);\r\n   int tga_palette_len = stbi__get16le(s);\r\n   int tga_palette_bits = stbi__get8(s);\r\n   int tga_x_origin = stbi__get16le(s);\r\n   int tga_y_origin = stbi__get16le(s);\r\n   int tga_width = stbi__get16le(s);\r\n   int tga_height = stbi__get16le(s);\r\n   int tga_bits_per_pixel = stbi__get8(s);\r\n   int tga_comp, tga_rgb16=0;\r\n   int tga_inverted = stbi__get8(s);\r\n   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)\r\n   //   image data\r\n   unsigned char *tga_data;\r\n   unsigned char *tga_palette = NULL;\r\n   int i, j;\r\n   unsigned char raw_data[4] = {0};\r\n   int RLE_count = 0;\r\n   int RLE_repeating = 0;\r\n   int read_next_pixel = 1;\r\n   STBI_NOTUSED(ri);\r\n\r\n   //   do a tiny bit of precessing\r\n   if ( tga_image_type >= 8 )\r\n   {\r\n      tga_image_type -= 8;\r\n      tga_is_RLE = 1;\r\n   }\r\n   tga_inverted = 1 - ((tga_inverted >> 5) & 1);\r\n\r\n   //   If I'm paletted, then I'll use the number of bits from the palette\r\n   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);\r\n   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);\r\n\r\n   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency\r\n      return stbi__errpuc(\"bad format\", \"Can't find out TGA pixelformat\");\r\n\r\n   //   tga info\r\n   *x = tga_width;\r\n   *y = tga_height;\r\n   if (comp) *comp = tga_comp;\r\n\r\n   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))\r\n      return stbi__errpuc(\"too large\", \"Corrupt TGA\");\r\n\r\n   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);\r\n   if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   // skip to the data's starting position (offset usually = 0)\r\n   stbi__skip(s, tga_offset );\r\n\r\n   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {\r\n      for (i=0; i < tga_height; ++i) {\r\n         int row = tga_inverted ? tga_height -i - 1 : i;\r\n         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;\r\n         stbi__getn(s, tga_row, tga_width * tga_comp);\r\n      }\r\n   } else  {\r\n      //   do I need to load a palette?\r\n      if ( tga_indexed)\r\n      {\r\n         //   any data to skip? (offset usually = 0)\r\n         stbi__skip(s, tga_palette_start );\r\n         //   load the palette\r\n         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);\r\n         if (!tga_palette) {\r\n            STBI_FREE(tga_data);\r\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n         }\r\n         if (tga_rgb16) {\r\n            stbi_uc *pal_entry = tga_palette;\r\n            STBI_ASSERT(tga_comp == STBI_rgb);\r\n            for (i=0; i < tga_palette_len; ++i) {\r\n               stbi__tga_read_rgb16(s, pal_entry);\r\n               pal_entry += tga_comp;\r\n            }\r\n         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {\r\n               STBI_FREE(tga_data);\r\n               STBI_FREE(tga_palette);\r\n               return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\r\n         }\r\n      }\r\n      //   load the data\r\n      for (i=0; i < tga_width * tga_height; ++i)\r\n      {\r\n         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\r\n         if ( tga_is_RLE )\r\n         {\r\n            if ( RLE_count == 0 )\r\n            {\r\n               //   yep, get the next byte as a RLE command\r\n               int RLE_cmd = stbi__get8(s);\r\n               RLE_count = 1 + (RLE_cmd & 127);\r\n               RLE_repeating = RLE_cmd >> 7;\r\n               read_next_pixel = 1;\r\n            } else if ( !RLE_repeating )\r\n            {\r\n               read_next_pixel = 1;\r\n            }\r\n         } else\r\n         {\r\n            read_next_pixel = 1;\r\n         }\r\n         //   OK, if I need to read a pixel, do it now\r\n         if ( read_next_pixel )\r\n         {\r\n            //   load however much data we did have\r\n            if ( tga_indexed )\r\n            {\r\n               // read in index, then perform the lookup\r\n               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);\r\n               if ( pal_idx >= tga_palette_len ) {\r\n                  // invalid index\r\n                  pal_idx = 0;\r\n               }\r\n               pal_idx *= tga_comp;\r\n               for (j = 0; j < tga_comp; ++j) {\r\n                  raw_data[j] = tga_palette[pal_idx+j];\r\n               }\r\n            } else if(tga_rgb16) {\r\n               STBI_ASSERT(tga_comp == STBI_rgb);\r\n               stbi__tga_read_rgb16(s, raw_data);\r\n            } else {\r\n               //   read in the data raw\r\n               for (j = 0; j < tga_comp; ++j) {\r\n                  raw_data[j] = stbi__get8(s);\r\n               }\r\n            }\r\n            //   clear the reading flag for the next pixel\r\n            read_next_pixel = 0;\r\n         } // end of reading a pixel\r\n\r\n         // copy data\r\n         for (j = 0; j < tga_comp; ++j)\r\n           tga_data[i*tga_comp+j] = raw_data[j];\r\n\r\n         //   in case we're in RLE mode, keep counting down\r\n         --RLE_count;\r\n      }\r\n      //   do I need to invert the image?\r\n      if ( tga_inverted )\r\n      {\r\n         for (j = 0; j*2 < tga_height; ++j)\r\n         {\r\n            int index1 = j * tga_width * tga_comp;\r\n            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\r\n            for (i = tga_width * tga_comp; i > 0; --i)\r\n            {\r\n               unsigned char temp = tga_data[index1];\r\n               tga_data[index1] = tga_data[index2];\r\n               tga_data[index2] = temp;\r\n               ++index1;\r\n               ++index2;\r\n            }\r\n         }\r\n      }\r\n      //   clear my palette, if I had one\r\n      if ( tga_palette != NULL )\r\n      {\r\n         STBI_FREE( tga_palette );\r\n      }\r\n   }\r\n\r\n   // swap RGB - if the source data was RGB16, it already is in the right order\r\n   if (tga_comp >= 3 && !tga_rgb16)\r\n   {\r\n      unsigned char* tga_pixel = tga_data;\r\n      for (i=0; i < tga_width * tga_height; ++i)\r\n      {\r\n         unsigned char temp = tga_pixel[0];\r\n         tga_pixel[0] = tga_pixel[2];\r\n         tga_pixel[2] = temp;\r\n         tga_pixel += tga_comp;\r\n      }\r\n   }\r\n\r\n   // convert to target component count\r\n   if (req_comp && req_comp != tga_comp)\r\n      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\r\n\r\n   //   the things I do to get rid of an error message, and yet keep\r\n   //   Microsoft's C compilers happy... [8^(\r\n   tga_palette_start = tga_palette_len = tga_palette_bits =\r\n         tga_x_origin = tga_y_origin = 0;\r\n   //   OK, done\r\n   return tga_data;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int stbi__psd_test(stbi__context *s)\r\n{\r\n   int r = (stbi__get32be(s) == 0x38425053);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)\r\n{\r\n   int count, nleft, len;\r\n\r\n   count = 0;\r\n   while ((nleft = pixelCount - count) > 0) {\r\n      len = stbi__get8(s);\r\n      if (len == 128) {\r\n         // No-op.\r\n      } else if (len < 128) {\r\n         // Copy next len+1 bytes literally.\r\n         len++;\r\n         if (len > nleft) return 0; // corrupt data\r\n         count += len;\r\n         while (len) {\r\n            *p = stbi__get8(s);\r\n            p += 4;\r\n            len--;\r\n         }\r\n      } else if (len > 128) {\r\n         stbi_uc   val;\r\n         // Next -len+1 bytes in the dest are replicated from next source byte.\r\n         // (Interpret len as a negative 8-bit int.)\r\n         len = 257 - len;\r\n         if (len > nleft) return 0; // corrupt data\r\n         val = stbi__get8(s);\r\n         count += len;\r\n         while (len) {\r\n            *p = val;\r\n            p += 4;\r\n            len--;\r\n         }\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\r\n{\r\n   int pixelCount;\r\n   int channelCount, compression;\r\n   int channel, i;\r\n   int bitdepth;\r\n   int w,h;\r\n   stbi_uc *out;\r\n   STBI_NOTUSED(ri);\r\n\r\n   // Check identifier\r\n   if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\r\n      return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\r\n\r\n   // Check file type version.\r\n   if (stbi__get16be(s) != 1)\r\n      return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\r\n\r\n   // Skip 6 reserved bytes.\r\n   stbi__skip(s, 6 );\r\n\r\n   // Read the number of channels (R, G, B, A, etc).\r\n   channelCount = stbi__get16be(s);\r\n   if (channelCount < 0 || channelCount > 16)\r\n      return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\r\n\r\n   // Read the rows and columns of the image.\r\n   h = stbi__get32be(s);\r\n   w = stbi__get32be(s);\r\n\r\n   // Make sure the depth is 8 bits.\r\n   bitdepth = stbi__get16be(s);\r\n   if (bitdepth != 8 && bitdepth != 16)\r\n      return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 or 16 bit\");\r\n\r\n   // Make sure the color mode is RGB.\r\n   // Valid options are:\r\n   //   0: Bitmap\r\n   //   1: Grayscale\r\n   //   2: Indexed color\r\n   //   3: RGB color\r\n   //   4: CMYK color\r\n   //   7: Multichannel\r\n   //   8: Duotone\r\n   //   9: Lab color\r\n   if (stbi__get16be(s) != 3)\r\n      return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\r\n\r\n   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\r\n   stbi__skip(s,stbi__get32be(s) );\r\n\r\n   // Skip the image resources.  (resolution, pen tool paths, etc)\r\n   stbi__skip(s, stbi__get32be(s) );\r\n\r\n   // Skip the reserved data.\r\n   stbi__skip(s, stbi__get32be(s) );\r\n\r\n   // Find out if the data is compressed.\r\n   // Known values:\r\n   //   0: no compression\r\n   //   1: RLE compressed\r\n   compression = stbi__get16be(s);\r\n   if (compression > 1)\r\n      return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\r\n\r\n   // Check size\r\n   if (!stbi__mad3sizes_valid(4, w, h, 0))\r\n      return stbi__errpuc(\"too large\", \"Corrupt PSD\");\r\n\r\n   // Create the destination image.\r\n\r\n   if (!compression && bitdepth == 16 && bpc == 16) {\r\n      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);\r\n      ri->bits_per_channel = 16;\r\n   } else\r\n      out = (stbi_uc *) stbi__malloc(4 * w*h);\r\n\r\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   pixelCount = w*h;\r\n\r\n   // Initialize the data to zero.\r\n   //memset( out, 0, pixelCount * 4 );\r\n\r\n   // Finally, the image data.\r\n   if (compression) {\r\n      // RLE as used by .PSD and .TIFF\r\n      // Loop until you get the number of unpacked bytes you are expecting:\r\n      //     Read the next source byte into n.\r\n      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\r\n      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\r\n      //     Else if n is 128, noop.\r\n      // Endloop\r\n\r\n      // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,\r\n      // which we're going to just skip.\r\n      stbi__skip(s, h * channelCount * 2 );\r\n\r\n      // Read the RLE data by channel.\r\n      for (channel = 0; channel < 4; channel++) {\r\n         stbi_uc *p;\r\n\r\n         p = out+channel;\r\n         if (channel >= channelCount) {\r\n            // Fill this channel with default data.\r\n            for (i = 0; i < pixelCount; i++, p += 4)\r\n               *p = (channel == 3 ? 255 : 0);\r\n         } else {\r\n            // Read the RLE data.\r\n            if (!stbi__psd_decode_rle(s, p, pixelCount)) {\r\n               STBI_FREE(out);\r\n               return stbi__errpuc(\"corrupt\", \"bad RLE data\");\r\n            }\r\n         }\r\n      }\r\n\r\n   } else {\r\n      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\r\n      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.\r\n\r\n      // Read the data by channel.\r\n      for (channel = 0; channel < 4; channel++) {\r\n         if (channel >= channelCount) {\r\n            // Fill this channel with default data.\r\n            if (bitdepth == 16 && bpc == 16) {\r\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\r\n               stbi__uint16 val = channel == 3 ? 65535 : 0;\r\n               for (i = 0; i < pixelCount; i++, q += 4)\r\n                  *q = val;\r\n            } else {\r\n               stbi_uc *p = out+channel;\r\n               stbi_uc val = channel == 3 ? 255 : 0;\r\n               for (i = 0; i < pixelCount; i++, p += 4)\r\n                  *p = val;\r\n            }\r\n         } else {\r\n            if (ri->bits_per_channel == 16) {    // output bpc\r\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\r\n               for (i = 0; i < pixelCount; i++, q += 4)\r\n                  *q = (stbi__uint16) stbi__get16be(s);\r\n            } else {\r\n               stbi_uc *p = out+channel;\r\n               if (bitdepth == 16) {  // input bpc\r\n                  for (i = 0; i < pixelCount; i++, p += 4)\r\n                     *p = (stbi_uc) (stbi__get16be(s) >> 8);\r\n               } else {\r\n                  for (i = 0; i < pixelCount; i++, p += 4)\r\n                     *p = stbi__get8(s);\r\n               }\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // remove weird white matte from PSD\r\n   if (channelCount >= 4) {\r\n      if (ri->bits_per_channel == 16) {\r\n         for (i=0; i < w*h; ++i) {\r\n            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;\r\n            if (pixel[3] != 0 && pixel[3] != 65535) {\r\n               float a = pixel[3] / 65535.0f;\r\n               float ra = 1.0f / a;\r\n               float inv_a = 65535.0f * (1 - ra);\r\n               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);\r\n               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);\r\n               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);\r\n            }\r\n         }\r\n      } else {\r\n         for (i=0; i < w*h; ++i) {\r\n            unsigned char *pixel = out + 4*i;\r\n            if (pixel[3] != 0 && pixel[3] != 255) {\r\n               float a = pixel[3] / 255.0f;\r\n               float ra = 1.0f / a;\r\n               float inv_a = 255.0f * (1 - ra);\r\n               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);\r\n               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);\r\n               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // convert to desired output format\r\n   if (req_comp && req_comp != 4) {\r\n      if (ri->bits_per_channel == 16)\r\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);\r\n      else\r\n         out = stbi__convert_format(out, 4, req_comp, w, h);\r\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n   }\r\n\r\n   if (comp) *comp = 4;\r\n   *y = h;\r\n   *x = w;\r\n\r\n   return out;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Softimage PIC loader\r\n// by Tom Seddon\r\n//\r\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\r\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int stbi__pic_is4(stbi__context *s,const char *str)\r\n{\r\n   int i;\r\n   for (i=0; i<4; ++i)\r\n      if (stbi__get8(s) != (stbi_uc)str[i])\r\n         return 0;\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__pic_test_core(stbi__context *s)\r\n{\r\n   int i;\r\n\r\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\"))\r\n      return 0;\r\n\r\n   for(i=0;i<84;++i)\r\n      stbi__get8(s);\r\n\r\n   if (!stbi__pic_is4(s,\"PICT\"))\r\n      return 0;\r\n\r\n   return 1;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   stbi_uc size,type,channel;\r\n} stbi__pic_packet;\r\n\r\nstatic stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)\r\n{\r\n   int mask=0x80, i;\r\n\r\n   for (i=0; i<4; ++i, mask>>=1) {\r\n      if (channel & mask) {\r\n         if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\",\"PIC file too short\");\r\n         dest[i]=stbi__get8(s);\r\n      }\r\n   }\r\n\r\n   return dest;\r\n}\r\n\r\nstatic void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)\r\n{\r\n   int mask=0x80,i;\r\n\r\n   for (i=0;i<4; ++i, mask>>=1)\r\n      if (channel&mask)\r\n         dest[i]=src[i];\r\n}\r\n\r\nstatic stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)\r\n{\r\n   int act_comp=0,num_packets=0,y,chained;\r\n   stbi__pic_packet packets[10];\r\n\r\n   // this will (should...) cater for even some bizarre stuff like having data\r\n    // for the same channel in multiple packets.\r\n   do {\r\n      stbi__pic_packet *packet;\r\n\r\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\r\n         return stbi__errpuc(\"bad format\",\"too many packets\");\r\n\r\n      packet = &packets[num_packets++];\r\n\r\n      chained = stbi__get8(s);\r\n      packet->size    = stbi__get8(s);\r\n      packet->type    = stbi__get8(s);\r\n      packet->channel = stbi__get8(s);\r\n\r\n      act_comp |= packet->channel;\r\n\r\n      if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\",\"file too short (reading packets)\");\r\n      if (packet->size != 8)  return stbi__errpuc(\"bad format\",\"packet isn't 8bpp\");\r\n   } while (chained);\r\n\r\n   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\r\n\r\n   for(y=0; y<height; ++y) {\r\n      int packet_idx;\r\n\r\n      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {\r\n         stbi__pic_packet *packet = &packets[packet_idx];\r\n         stbi_uc *dest = result+y*width*4;\r\n\r\n         switch (packet->type) {\r\n            default:\r\n               return stbi__errpuc(\"bad format\",\"packet has bad compression type\");\r\n\r\n            case 0: {//uncompressed\r\n               int x;\r\n\r\n               for(x=0;x<width;++x, dest+=4)\r\n                  if (!stbi__readval(s,packet->channel,dest))\r\n                     return 0;\r\n               break;\r\n            }\r\n\r\n            case 1://Pure RLE\r\n               {\r\n                  int left=width, i;\r\n\r\n                  while (left>0) {\r\n                     stbi_uc count,value[4];\r\n\r\n                     count=stbi__get8(s);\r\n                     if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\",\"file too short (pure read count)\");\r\n\r\n                     if (count > left)\r\n                        count = (stbi_uc) left;\r\n\r\n                     if (!stbi__readval(s,packet->channel,value))  return 0;\r\n\r\n                     for(i=0; i<count; ++i,dest+=4)\r\n                        stbi__copyval(packet->channel,dest,value);\r\n                     left -= count;\r\n                  }\r\n               }\r\n               break;\r\n\r\n            case 2: {//Mixed RLE\r\n               int left=width;\r\n               while (left>0) {\r\n                  int count = stbi__get8(s), i;\r\n                  if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (mixed read count)\");\r\n\r\n                  if (count >= 128) { // Repeated\r\n                     stbi_uc value[4];\r\n\r\n                     if (count==128)\r\n                        count = stbi__get16be(s);\r\n                     else\r\n                        count -= 127;\r\n                     if (count > left)\r\n                        return stbi__errpuc(\"bad file\",\"scanline overrun\");\r\n\r\n                     if (!stbi__readval(s,packet->channel,value))\r\n                        return 0;\r\n\r\n                     for(i=0;i<count;++i, dest += 4)\r\n                        stbi__copyval(packet->channel,dest,value);\r\n                  } else { // Raw\r\n                     ++count;\r\n                     if (count>left) return stbi__errpuc(\"bad file\",\"scanline overrun\");\r\n\r\n                     for(i=0;i<count;++i, dest+=4)\r\n                        if (!stbi__readval(s,packet->channel,dest))\r\n                           return 0;\r\n                  }\r\n                  left-=count;\r\n               }\r\n               break;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\nstatic void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *result;\r\n   int i, x,y, internal_comp;\r\n   STBI_NOTUSED(ri);\r\n\r\n   if (!comp) comp = &internal_comp;\r\n\r\n   for (i=0; i<92; ++i)\r\n      stbi__get8(s);\r\n\r\n   x = stbi__get16be(s);\r\n   y = stbi__get16be(s);\r\n   if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (pic header)\");\r\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\"too large\", \"PIC image too large to decode\");\r\n\r\n   stbi__get32be(s); //skip `ratio'\r\n   stbi__get16be(s); //skip `fields'\r\n   stbi__get16be(s); //skip `pad'\r\n\r\n   // intermediate buffer is RGBA\r\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\r\n   memset(result, 0xff, x*y*4);\r\n\r\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\r\n      STBI_FREE(result);\r\n      result=0;\r\n   }\r\n   *px = x;\r\n   *py = y;\r\n   if (req_comp == 0) req_comp = *comp;\r\n   result=stbi__convert_format(result,4,req_comp,x,y);\r\n\r\n   return result;\r\n}\r\n\r\nstatic int stbi__pic_test(stbi__context *s)\r\n{\r\n   int r = stbi__pic_test_core(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\r\n\r\n#ifndef STBI_NO_GIF\r\ntypedef struct\r\n{\r\n   stbi__int16 prefix;\r\n   stbi_uc first;\r\n   stbi_uc suffix;\r\n} stbi__gif_lzw;\r\n\r\ntypedef struct\r\n{\r\n   int w,h;\r\n   stbi_uc *out, *old_out;             // output buffer (always 4 components)\r\n   int flags, bgindex, ratio, transparent, eflags, delay;\r\n   stbi_uc  pal[256][4];\r\n   stbi_uc lpal[256][4];\r\n   stbi__gif_lzw codes[4096];\r\n   stbi_uc *color_table;\r\n   int parse, step;\r\n   int lflags;\r\n   int start_x, start_y;\r\n   int max_x, max_y;\r\n   int cur_x, cur_y;\r\n   int line_size;\r\n} stbi__gif;\r\n\r\nstatic int stbi__gif_test_raw(stbi__context *s)\r\n{\r\n   int sz;\r\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\r\n   sz = stbi__get8(s);\r\n   if (sz != '9' && sz != '7') return 0;\r\n   if (stbi__get8(s) != 'a') return 0;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__gif_test(stbi__context *s)\r\n{\r\n   int r = stbi__gif_test_raw(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\nstatic void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)\r\n{\r\n   int i;\r\n   for (i=0; i < num_entries; ++i) {\r\n      pal[i][2] = stbi__get8(s);\r\n      pal[i][1] = stbi__get8(s);\r\n      pal[i][0] = stbi__get8(s);\r\n      pal[i][3] = transp == i ? 0 : 255;\r\n   }\r\n}\r\n\r\nstatic int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)\r\n{\r\n   stbi_uc version;\r\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\r\n      return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n\r\n   version = stbi__get8(s);\r\n   if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n   if (stbi__get8(s) != 'a')                return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n\r\n   stbi__g_failure_reason = \"\";\r\n   g->w = stbi__get16le(s);\r\n   g->h = stbi__get16le(s);\r\n   g->flags = stbi__get8(s);\r\n   g->bgindex = stbi__get8(s);\r\n   g->ratio = stbi__get8(s);\r\n   g->transparent = -1;\r\n\r\n   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\r\n\r\n   if (is_info) return 1;\r\n\r\n   if (g->flags & 0x80)\r\n      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\r\n   if (!stbi__gif_header(s, g, comp, 1)) {\r\n      STBI_FREE(g);\r\n      stbi__rewind( s );\r\n      return 0;\r\n   }\r\n   if (x) *x = g->w;\r\n   if (y) *y = g->h;\r\n   STBI_FREE(g);\r\n   return 1;\r\n}\r\n\r\nstatic void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)\r\n{\r\n   stbi_uc *p, *c;\r\n\r\n   // recurse to decode the prefixes, since the linked-list is backwards,\r\n   // and working backwards through an interleaved image would be nasty\r\n   if (g->codes[code].prefix >= 0)\r\n      stbi__out_gif_code(g, g->codes[code].prefix);\r\n\r\n   if (g->cur_y >= g->max_y) return;\r\n\r\n   p = &g->out[g->cur_x + g->cur_y];\r\n   c = &g->color_table[g->codes[code].suffix * 4];\r\n\r\n   if (c[3] >= 128) {\r\n      p[0] = c[2];\r\n      p[1] = c[1];\r\n      p[2] = c[0];\r\n      p[3] = c[3];\r\n   }\r\n   g->cur_x += 4;\r\n\r\n   if (g->cur_x >= g->max_x) {\r\n      g->cur_x = g->start_x;\r\n      g->cur_y += g->step;\r\n\r\n      while (g->cur_y >= g->max_y && g->parse > 0) {\r\n         g->step = (1 << g->parse) * g->line_size;\r\n         g->cur_y = g->start_y + (g->step >> 1);\r\n         --g->parse;\r\n      }\r\n   }\r\n}\r\n\r\nstatic stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)\r\n{\r\n   stbi_uc lzw_cs;\r\n   stbi__int32 len, init_code;\r\n   stbi__uint32 first;\r\n   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\r\n   stbi__gif_lzw *p;\r\n\r\n   lzw_cs = stbi__get8(s);\r\n   if (lzw_cs > 12) return NULL;\r\n   clear = 1 << lzw_cs;\r\n   first = 1;\r\n   codesize = lzw_cs + 1;\r\n   codemask = (1 << codesize) - 1;\r\n   bits = 0;\r\n   valid_bits = 0;\r\n   for (init_code = 0; init_code < clear; init_code++) {\r\n      g->codes[init_code].prefix = -1;\r\n      g->codes[init_code].first = (stbi_uc) init_code;\r\n      g->codes[init_code].suffix = (stbi_uc) init_code;\r\n   }\r\n\r\n   // support no starting clear code\r\n   avail = clear+2;\r\n   oldcode = -1;\r\n\r\n   len = 0;\r\n   for(;;) {\r\n      if (valid_bits < codesize) {\r\n         if (len == 0) {\r\n            len = stbi__get8(s); // start new block\r\n            if (len == 0)\r\n               return g->out;\r\n         }\r\n         --len;\r\n         bits |= (stbi__int32) stbi__get8(s) << valid_bits;\r\n         valid_bits += 8;\r\n      } else {\r\n         stbi__int32 code = bits & codemask;\r\n         bits >>= codesize;\r\n         valid_bits -= codesize;\r\n         // @OPTIMIZE: is there some way we can accelerate the non-clear path?\r\n         if (code == clear) {  // clear code\r\n            codesize = lzw_cs + 1;\r\n            codemask = (1 << codesize) - 1;\r\n            avail = clear + 2;\r\n            oldcode = -1;\r\n            first = 0;\r\n         } else if (code == clear + 1) { // end of stream code\r\n            stbi__skip(s, len);\r\n            while ((len = stbi__get8(s)) > 0)\r\n               stbi__skip(s,len);\r\n            return g->out;\r\n         } else if (code <= avail) {\r\n            if (first) return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\r\n\r\n            if (oldcode >= 0) {\r\n               p = &g->codes[avail++];\r\n               if (avail > 4096)        return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\r\n               p->prefix = (stbi__int16) oldcode;\r\n               p->first = g->codes[oldcode].first;\r\n               p->suffix = (code == avail) ? p->first : g->codes[code].first;\r\n            } else if (code == avail)\r\n               return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\r\n\r\n            stbi__out_gif_code(g, (stbi__uint16) code);\r\n\r\n            if ((avail & codemask) == 0 && avail <= 0x0FFF) {\r\n               codesize++;\r\n               codemask = (1 << codesize) - 1;\r\n            }\r\n\r\n            oldcode = code;\r\n         } else {\r\n            return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbi__fill_gif_background(stbi__gif *g, int x0, int y0, int x1, int y1)\r\n{\r\n   int x, y;\r\n   stbi_uc *c = g->pal[g->bgindex];\r\n   for (y = y0; y < y1; y += 4 * g->w) {\r\n      for (x = x0; x < x1; x += 4) {\r\n         stbi_uc *p  = &g->out[y + x];\r\n         p[0] = c[2];\r\n         p[1] = c[1];\r\n         p[2] = c[0];\r\n         p[3] = 0;\r\n      }\r\n   }\r\n}\r\n\r\n// this function is designed to support animated gifs, although stb_image doesn't support it\r\nstatic stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)\r\n{\r\n   int i;\r\n   stbi_uc *prev_out = 0;\r\n\r\n   if (g->out == 0 && !stbi__gif_header(s, g, comp,0))\r\n      return 0; // stbi__g_failure_reason set by stbi__gif_header\r\n\r\n   if (!stbi__mad3sizes_valid(g->w, g->h, 4, 0))\r\n      return stbi__errpuc(\"too large\", \"GIF too large\");\r\n\r\n   prev_out = g->out;\r\n   g->out = (stbi_uc *) stbi__malloc_mad3(4, g->w, g->h, 0);\r\n   if (g->out == 0) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   switch ((g->eflags & 0x1C) >> 2) {\r\n      case 0: // unspecified (also always used on 1st frame)\r\n         stbi__fill_gif_background(g, 0, 0, 4 * g->w, 4 * g->w * g->h);\r\n         break;\r\n      case 1: // do not dispose\r\n         if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);\r\n         g->old_out = prev_out;\r\n         break;\r\n      case 2: // dispose to background\r\n         if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);\r\n         stbi__fill_gif_background(g, g->start_x, g->start_y, g->max_x, g->max_y);\r\n         break;\r\n      case 3: // dispose to previous\r\n         if (g->old_out) {\r\n            for (i = g->start_y; i < g->max_y; i += 4 * g->w)\r\n               memcpy(&g->out[i + g->start_x], &g->old_out[i + g->start_x], g->max_x - g->start_x);\r\n         }\r\n         break;\r\n   }\r\n\r\n   for (;;) {\r\n      switch (stbi__get8(s)) {\r\n         case 0x2C: /* Image Descriptor */\r\n         {\r\n            int prev_trans = -1;\r\n            stbi__int32 x, y, w, h;\r\n            stbi_uc *o;\r\n\r\n            x = stbi__get16le(s);\r\n            y = stbi__get16le(s);\r\n            w = stbi__get16le(s);\r\n            h = stbi__get16le(s);\r\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\r\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\r\n\r\n            g->line_size = g->w * 4;\r\n            g->start_x = x * 4;\r\n            g->start_y = y * g->line_size;\r\n            g->max_x   = g->start_x + w * 4;\r\n            g->max_y   = g->start_y + h * g->line_size;\r\n            g->cur_x   = g->start_x;\r\n            g->cur_y   = g->start_y;\r\n\r\n            g->lflags = stbi__get8(s);\r\n\r\n            if (g->lflags & 0x40) {\r\n               g->step = 8 * g->line_size; // first interlaced spacing\r\n               g->parse = 3;\r\n            } else {\r\n               g->step = g->line_size;\r\n               g->parse = 0;\r\n            }\r\n\r\n            if (g->lflags & 0x80) {\r\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\r\n               g->color_table = (stbi_uc *) g->lpal;\r\n            } else if (g->flags & 0x80) {\r\n               if (g->transparent >= 0 && (g->eflags & 0x01)) {\r\n                  prev_trans = g->pal[g->transparent][3];\r\n                  g->pal[g->transparent][3] = 0;\r\n               }\r\n               g->color_table = (stbi_uc *) g->pal;\r\n            } else\r\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\r\n\r\n            o = stbi__process_gif_raster(s, g);\r\n            if (o == NULL) return NULL;\r\n\r\n            if (prev_trans != -1)\r\n               g->pal[g->transparent][3] = (stbi_uc) prev_trans;\r\n\r\n            return o;\r\n         }\r\n\r\n         case 0x21: // Comment Extension.\r\n         {\r\n            int len;\r\n            if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.\r\n               len = stbi__get8(s);\r\n               if (len == 4) {\r\n                  g->eflags = stbi__get8(s);\r\n                  g->delay = stbi__get16le(s);\r\n                  g->transparent = stbi__get8(s);\r\n               } else {\r\n                  stbi__skip(s, len);\r\n                  break;\r\n               }\r\n            }\r\n            while ((len = stbi__get8(s)) != 0)\r\n               stbi__skip(s, len);\r\n            break;\r\n         }\r\n\r\n         case 0x3B: // gif stream termination code\r\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\r\n\r\n         default:\r\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\r\n      }\r\n   }\r\n\r\n   STBI_NOTUSED(req_comp);\r\n}\r\n\r\nstatic void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *u = 0;\r\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\r\n   memset(g, 0, sizeof(*g));\r\n   STBI_NOTUSED(ri);\r\n\r\n   u = stbi__gif_load_next(s, g, comp, req_comp);\r\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\r\n   if (u) {\r\n      *x = g->w;\r\n      *y = g->h;\r\n      if (req_comp && req_comp != 4)\r\n         u = stbi__convert_format(u, 4, req_comp, g->w, g->h);\r\n   }\r\n   else if (g->out)\r\n      STBI_FREE(g->out);\r\n   STBI_FREE(g);\r\n   return u;\r\n}\r\n\r\nstatic int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   return stbi__gif_info_raw(s,x,y,comp);\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Radiance RGBE HDR loader\r\n// originally by Nicolas Schulz\r\n#ifndef STBI_NO_HDR\r\nstatic int stbi__hdr_test_core(stbi__context *s, const char *signature)\r\n{\r\n   int i;\r\n   for (i=0; signature[i]; ++i)\r\n      if (stbi__get8(s) != signature[i])\r\n          return 0;\r\n   stbi__rewind(s);\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__hdr_test(stbi__context* s)\r\n{\r\n   int r = stbi__hdr_test_core(s, \"#?RADIANCE\\n\");\r\n   stbi__rewind(s);\r\n   if(!r) {\r\n       r = stbi__hdr_test_core(s, \"#?RGBE\\n\");\r\n       stbi__rewind(s);\r\n   }\r\n   return r;\r\n}\r\n\r\n#define STBI__HDR_BUFLEN  1024\r\nstatic char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\r\n{\r\n   int len=0;\r\n   char c = '\\0';\r\n\r\n   c = (char) stbi__get8(z);\r\n\r\n   while (!stbi__at_eof(z) && c != '\\n') {\r\n      buffer[len++] = c;\r\n      if (len == STBI__HDR_BUFLEN-1) {\r\n         // flush to end of line\r\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\r\n            ;\r\n         break;\r\n      }\r\n      c = (char) stbi__get8(z);\r\n   }\r\n\r\n   buffer[len] = 0;\r\n   return buffer;\r\n}\r\n\r\nstatic void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)\r\n{\r\n   if ( input[3] != 0 ) {\r\n      float f1;\r\n      // Exponent\r\n      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));\r\n      if (req_comp <= 2)\r\n         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\r\n      else {\r\n         output[0] = input[0] * f1;\r\n         output[1] = input[1] * f1;\r\n         output[2] = input[2] * f1;\r\n      }\r\n      if (req_comp == 2) output[1] = 1;\r\n      if (req_comp == 4) output[3] = 1;\r\n   } else {\r\n      switch (req_comp) {\r\n         case 4: output[3] = 1; /* fallthrough */\r\n         case 3: output[0] = output[1] = output[2] = 0;\r\n                 break;\r\n         case 2: output[1] = 1; /* fallthrough */\r\n         case 1: output[0] = 0;\r\n                 break;\r\n      }\r\n   }\r\n}\r\n\r\nstatic float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   char buffer[STBI__HDR_BUFLEN];\r\n   char *token;\r\n   int valid = 0;\r\n   int width, height;\r\n   stbi_uc *scanline;\r\n   float *hdr_data;\r\n   int len;\r\n   unsigned char count, value;\r\n   int i, j, k, c1,c2, z;\r\n   const char *headerToken;\r\n   STBI_NOTUSED(ri);\r\n\r\n   // Check identifier\r\n   headerToken = stbi__hdr_gettoken(s,buffer);\r\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\r\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\r\n\r\n   // Parse header\r\n   for(;;) {\r\n      token = stbi__hdr_gettoken(s,buffer);\r\n      if (token[0] == 0) break;\r\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\r\n   }\r\n\r\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\r\n\r\n   // Parse width and height\r\n   // can't use sscanf() if we're not using stdio!\r\n   token = stbi__hdr_gettoken(s,buffer);\r\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\r\n   token += 3;\r\n   height = (int) strtol(token, &token, 10);\r\n   while (*token == ' ') ++token;\r\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\r\n   token += 3;\r\n   width = (int) strtol(token, NULL, 10);\r\n\r\n   *x = width;\r\n   *y = height;\r\n\r\n   if (comp) *comp = 3;\r\n   if (req_comp == 0) req_comp = 3;\r\n\r\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\r\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\r\n\r\n   // Read data\r\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\r\n   if (!hdr_data)\r\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\r\n\r\n   // Load image data\r\n   // image data is stored as some number of sca\r\n   if ( width < 8 || width >= 32768) {\r\n      // Read flat data\r\n      for (j=0; j < height; ++j) {\r\n         for (i=0; i < width; ++i) {\r\n            stbi_uc rgbe[4];\r\n           main_decode_loop:\r\n            stbi__getn(s, rgbe, 4);\r\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\r\n         }\r\n      }\r\n   } else {\r\n      // Read RLE-encoded data\r\n      scanline = NULL;\r\n\r\n      for (j = 0; j < height; ++j) {\r\n         c1 = stbi__get8(s);\r\n         c2 = stbi__get8(s);\r\n         len = stbi__get8(s);\r\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\r\n            // not run-length encoded, so we have to actually use THIS data as a decoded\r\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\r\n            stbi_uc rgbe[4];\r\n            rgbe[0] = (stbi_uc) c1;\r\n            rgbe[1] = (stbi_uc) c2;\r\n            rgbe[2] = (stbi_uc) len;\r\n            rgbe[3] = (stbi_uc) stbi__get8(s);\r\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\r\n            i = 1;\r\n            j = 0;\r\n            STBI_FREE(scanline);\r\n            goto main_decode_loop; // yes, this makes no sense\r\n         }\r\n         len <<= 8;\r\n         len |= stbi__get8(s);\r\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\r\n         if (scanline == NULL) {\r\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\r\n            if (!scanline) {\r\n               STBI_FREE(hdr_data);\r\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\r\n            }\r\n         }\r\n\r\n         for (k = 0; k < 4; ++k) {\r\n            int nleft;\r\n            i = 0;\r\n            while ((nleft = width - i) > 0) {\r\n               count = stbi__get8(s);\r\n               if (count > 128) {\r\n                  // Run\r\n                  value = stbi__get8(s);\r\n                  count -= 128;\r\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\r\n                  for (z = 0; z < count; ++z)\r\n                     scanline[i++ * 4 + k] = value;\r\n               } else {\r\n                  // Dump\r\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\r\n                  for (z = 0; z < count; ++z)\r\n                     scanline[i++ * 4 + k] = stbi__get8(s);\r\n               }\r\n            }\r\n         }\r\n         for (i=0; i < width; ++i)\r\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\r\n      }\r\n      if (scanline)\r\n         STBI_FREE(scanline);\r\n   }\r\n\r\n   return hdr_data;\r\n}\r\n\r\nstatic int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   char buffer[STBI__HDR_BUFLEN];\r\n   char *token;\r\n   int valid = 0;\r\n   int dummy;\r\n\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n\r\n   if (stbi__hdr_test(s) == 0) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n\r\n   for(;;) {\r\n      token = stbi__hdr_gettoken(s,buffer);\r\n      if (token[0] == 0) break;\r\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\r\n   }\r\n\r\n   if (!valid) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   token = stbi__hdr_gettoken(s,buffer);\r\n   if (strncmp(token, \"-Y \", 3)) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   token += 3;\r\n   *y = (int) strtol(token, &token, 10);\r\n   while (*token == ' ') ++token;\r\n   if (strncmp(token, \"+X \", 3)) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   token += 3;\r\n   *x = (int) strtol(token, NULL, 10);\r\n   *comp = 3;\r\n   return 1;\r\n}\r\n#endif // STBI_NO_HDR\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   void *p;\r\n   stbi__bmp_data info;\r\n\r\n   info.all_a = 255;\r\n   p = stbi__bmp_parse_header(s, &info);\r\n   stbi__rewind( s );\r\n   if (p == NULL)\r\n      return 0;\r\n   if (x) *x = s->img_x;\r\n   if (y) *y = s->img_y;\r\n   if (comp) *comp = info.ma ? 4 : 3;\r\n   return 1;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int channelCount, dummy;\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n   if (stbi__get32be(s) != 0x38425053) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   if (stbi__get16be(s) != 1) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   stbi__skip(s, 6);\r\n   channelCount = stbi__get16be(s);\r\n   if (channelCount < 0 || channelCount > 16) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   *y = stbi__get32be(s);\r\n   *x = stbi__get32be(s);\r\n   if (stbi__get16be(s) != 8) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   if (stbi__get16be(s) != 3) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   *comp = 4;\r\n   return 1;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int act_comp=0,num_packets=0,chained,dummy;\r\n   stbi__pic_packet packets[10];\r\n\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n\r\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\")) {\r\n      stbi__rewind(s);\r\n      return 0;\r\n   }\r\n\r\n   stbi__skip(s, 88);\r\n\r\n   *x = stbi__get16be(s);\r\n   *y = stbi__get16be(s);\r\n   if (stbi__at_eof(s)) {\r\n      stbi__rewind( s);\r\n      return 0;\r\n   }\r\n   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {\r\n      stbi__rewind( s );\r\n      return 0;\r\n   }\r\n\r\n   stbi__skip(s, 8);\r\n\r\n   do {\r\n      stbi__pic_packet *packet;\r\n\r\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\r\n         return 0;\r\n\r\n      packet = &packets[num_packets++];\r\n      chained = stbi__get8(s);\r\n      packet->size    = stbi__get8(s);\r\n      packet->type    = stbi__get8(s);\r\n      packet->channel = stbi__get8(s);\r\n      act_comp |= packet->channel;\r\n\r\n      if (stbi__at_eof(s)) {\r\n          stbi__rewind( s );\r\n          return 0;\r\n      }\r\n      if (packet->size != 8) {\r\n          stbi__rewind( s );\r\n          return 0;\r\n      }\r\n   } while (chained);\r\n\r\n   *comp = (act_comp & 0x10 ? 4 : 3);\r\n\r\n   return 1;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Portable Gray Map and Portable Pixel Map loader\r\n// by Ken Miller\r\n//\r\n// PGM: http://netpbm.sourceforge.net/doc/pgm.html\r\n// PPM: http://netpbm.sourceforge.net/doc/ppm.html\r\n//\r\n// Known limitations:\r\n//    Does not support comments in the header section\r\n//    Does not support ASCII image data (formats P2 and P3)\r\n//    Does not support 16-bit-per-channel\r\n\r\n#ifndef STBI_NO_PNM\r\n\r\nstatic int      stbi__pnm_test(stbi__context *s)\r\n{\r\n   char p, t;\r\n   p = (char) stbi__get8(s);\r\n   t = (char) stbi__get8(s);\r\n   if (p != 'P' || (t != '5' && t != '6')) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *out;\r\n   STBI_NOTUSED(ri);\r\n\r\n   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))\r\n      return 0;\r\n\r\n   *x = s->img_x;\r\n   *y = s->img_y;\r\n   if (comp) *comp = s->img_n;\r\n\r\n   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))\r\n      return stbi__errpuc(\"too large\", \"PNM too large\");\r\n\r\n   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);\r\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);\r\n\r\n   if (req_comp && req_comp != s->img_n) {\r\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\r\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n   }\r\n   return out;\r\n}\r\n\r\nstatic int      stbi__pnm_isspace(char c)\r\n{\r\n   return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\r\n}\r\n\r\nstatic void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)\r\n{\r\n   for (;;) {\r\n      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))\r\n         *c = (char) stbi__get8(s);\r\n\r\n      if (stbi__at_eof(s) || *c != '#')\r\n         break;\r\n\r\n      while (!stbi__at_eof(s) && *c != '\\n' && *c != '\\r' )\r\n         *c = (char) stbi__get8(s);\r\n   }\r\n}\r\n\r\nstatic int      stbi__pnm_isdigit(char c)\r\n{\r\n   return c >= '0' && c <= '9';\r\n}\r\n\r\nstatic int      stbi__pnm_getinteger(stbi__context *s, char *c)\r\n{\r\n   int value = 0;\r\n\r\n   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {\r\n      value = value*10 + (*c - '0');\r\n      *c = (char) stbi__get8(s);\r\n   }\r\n\r\n   return value;\r\n}\r\n\r\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int maxv, dummy;\r\n   char c, p, t;\r\n\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n\r\n   stbi__rewind(s);\r\n\r\n   // Get identifier\r\n   p = (char) stbi__get8(s);\r\n   t = (char) stbi__get8(s);\r\n   if (p != 'P' || (t != '5' && t != '6')) {\r\n       stbi__rewind(s);\r\n       return 0;\r\n   }\r\n\r\n   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm\r\n\r\n   c = (char) stbi__get8(s);\r\n   stbi__pnm_skip_whitespace(s, &c);\r\n\r\n   *x = stbi__pnm_getinteger(s, &c); // read width\r\n   stbi__pnm_skip_whitespace(s, &c);\r\n\r\n   *y = stbi__pnm_getinteger(s, &c); // read height\r\n   stbi__pnm_skip_whitespace(s, &c);\r\n\r\n   maxv = stbi__pnm_getinteger(s, &c);  // read max value\r\n\r\n   if (maxv > 255)\r\n      return stbi__err(\"max value > 255\", \"PPM image not 8-bit\");\r\n   else\r\n      return 1;\r\n}\r\n#endif\r\n\r\nstatic int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   #ifndef STBI_NO_JPEG\r\n   if (stbi__jpeg_info(s, x, y, comp)) return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PNG\r\n   if (stbi__png_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_GIF\r\n   if (stbi__gif_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_BMP\r\n   if (stbi__bmp_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PSD\r\n   if (stbi__psd_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PIC\r\n   if (stbi__pic_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PNM\r\n   if (stbi__pnm_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_HDR\r\n   if (stbi__hdr_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   // test tga last because it's a crappy test!\r\n   #ifndef STBI_NO_TGA\r\n   if (stbi__tga_info(s, x, y, comp))\r\n       return 1;\r\n   #endif\r\n   return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)\r\n{\r\n    FILE *f = stbi__fopen(filename, \"rb\");\r\n    int result;\r\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_info_from_file(f, x, y, comp);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\nSTBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)\r\n{\r\n   int r;\r\n   stbi__context s;\r\n   long pos = ftell(f);\r\n   stbi__start_file(&s, f);\r\n   r = stbi__info_main(&s,x,y,comp);\r\n   fseek(f,pos,SEEK_SET);\r\n   return r;\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\nSTBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__info_main(&s,x,y,comp);\r\n}\r\n\r\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\r\n   return stbi__info_main(&s,x,y,comp);\r\n}\r\n\r\n#endif // STB_IMAGE_IMPLEMENTATION\r\n\r\n/*\r\n   revision history:\r\n      2.16  (2017-07-23) all functions have 16-bit variants;\r\n                         STBI_NO_STDIO works again;\r\n                         compilation fixes;\r\n                         fix rounding in unpremultiply;\r\n                         optimize vertical flip;\r\n                         disable raw_len validation;\r\n                         documentation fixes\r\n      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;\r\n                         warning fixes; disable run-time SSE detection on gcc;\r\n                         uniform handling of optional \"return\" values;\r\n                         thread-safe initialization of zlib tables\r\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\r\n      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now\r\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\r\n      2.11  (2016-04-02) allocate large structures on the stack\r\n                         remove white matting for transparent PSD\r\n                         fix reported channel count for PNG & BMP\r\n                         re-enable SSE2 in non-gcc 64-bit\r\n                         support RGB-formatted JPEG\r\n                         read 16-bit PNGs (only as 8-bit)\r\n      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED\r\n      2.09  (2016-01-16) allow comments in PNM files\r\n                         16-bit-per-pixel TGA (not bit-per-component)\r\n                         info() for TGA could break due to .hdr handling\r\n                         info() for BMP to shares code instead of sloppy parse\r\n                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc\r\n                         code cleanup\r\n      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA\r\n      2.07  (2015-09-13) fix compiler warnings\r\n                         partial animated GIF support\r\n                         limited 16-bpc PSD support\r\n                         #ifdef unused functions\r\n                         bug with < 92 byte PIC,PNM,HDR,TGA\r\n      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value\r\n      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning\r\n      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit\r\n      2.03  (2015-04-12) extra corruption checking (mmozeiko)\r\n                         stbi_set_flip_vertically_on_load (nguillemot)\r\n                         fix NEON support; fix mingw support\r\n      2.02  (2015-01-19) fix incorrect assert, fix warning\r\n      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2\r\n      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG\r\n      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)\r\n                         progressive JPEG (stb)\r\n                         PGM/PPM support (Ken Miller)\r\n                         STBI_MALLOC,STBI_REALLOC,STBI_FREE\r\n                         GIF bugfix -- seemingly never worked\r\n                         STBI_NO_*, STBI_ONLY_*\r\n      1.48  (2014-12-14) fix incorrectly-named assert()\r\n      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)\r\n                         optimize PNG (ryg)\r\n                         fix bug in interlaced PNG with user-specified channel count (stb)\r\n      1.46  (2014-08-26)\r\n              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\r\n      1.45  (2014-08-16)\r\n              fix MSVC-ARM internal compiler error by wrapping malloc\r\n      1.44  (2014-08-07)\r\n              various warning fixes from Ronny Chevalier\r\n      1.43  (2014-07-15)\r\n              fix MSVC-only compiler problem in code changed in 1.42\r\n      1.42  (2014-07-09)\r\n              don't define _CRT_SECURE_NO_WARNINGS (affects user code)\r\n              fixes to stbi__cleanup_jpeg path\r\n              added STBI_ASSERT to avoid requiring assert.h\r\n      1.41  (2014-06-25)\r\n              fix search&replace from 1.36 that messed up comments/error messages\r\n      1.40  (2014-06-22)\r\n              fix gcc struct-initialization warning\r\n      1.39  (2014-06-15)\r\n              fix to TGA optimization when req_comp != number of components in TGA;\r\n              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\r\n              add support for BMP version 5 (more ignored fields)\r\n      1.38  (2014-06-06)\r\n              suppress MSVC warnings on integer casts truncating values\r\n              fix accidental rename of 'skip' field of I/O\r\n      1.37  (2014-06-04)\r\n              remove duplicate typedef\r\n      1.36  (2014-06-03)\r\n              convert to header file single-file library\r\n              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\r\n      1.35  (2014-05-27)\r\n              various warnings\r\n              fix broken STBI_SIMD path\r\n              fix bug where stbi_load_from_file no longer left file pointer in correct place\r\n              fix broken non-easy path for 32-bit BMP (possibly never used)\r\n              TGA optimization by Arseny Kapoulkine\r\n      1.34  (unknown)\r\n              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\r\n      1.33  (2011-07-14)\r\n              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\r\n      1.32  (2011-07-13)\r\n              support for \"info\" function for all supported filetypes (SpartanJ)\r\n      1.31  (2011-06-20)\r\n              a few more leak fixes, bug in PNG handling (SpartanJ)\r\n      1.30  (2011-06-11)\r\n              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\r\n              removed deprecated format-specific test/load functions\r\n              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\r\n              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\r\n              fix inefficiency in decoding 32-bit BMP (David Woo)\r\n      1.29  (2010-08-16)\r\n              various warning fixes from Aurelien Pocheville\r\n      1.28  (2010-08-01)\r\n              fix bug in GIF palette transparency (SpartanJ)\r\n      1.27  (2010-08-01)\r\n              cast-to-stbi_uc to fix warnings\r\n      1.26  (2010-07-24)\r\n              fix bug in file buffering for PNG reported by SpartanJ\r\n      1.25  (2010-07-17)\r\n              refix trans_data warning (Won Chun)\r\n      1.24  (2010-07-12)\r\n              perf improvements reading from files on platforms with lock-heavy fgetc()\r\n              minor perf improvements for jpeg\r\n              deprecated type-specific functions so we'll get feedback if they're needed\r\n              attempt to fix trans_data warning (Won Chun)\r\n      1.23    fixed bug in iPhone support\r\n      1.22  (2010-07-10)\r\n              removed image *writing* support\r\n              stbi_info support from Jetro Lauha\r\n              GIF support from Jean-Marc Lienher\r\n              iPhone PNG-extensions from James Brown\r\n              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\r\n      1.21    fix use of 'stbi_uc' in header (reported by jon blow)\r\n      1.20    added support for Softimage PIC, by Tom Seddon\r\n      1.19    bug in interlaced PNG corruption check (found by ryg)\r\n      1.18  (2008-08-02)\r\n              fix a threading bug (local mutable static)\r\n      1.17    support interlaced PNG\r\n      1.16    major bugfix - stbi__convert_format converted one too many pixels\r\n      1.15    initialize some fields for thread safety\r\n      1.14    fix threadsafe conversion bug\r\n              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\r\n      1.13    threadsafe\r\n      1.12    const qualifiers in the API\r\n      1.11    Support installable IDCT, colorspace conversion routines\r\n      1.10    Fixes for 64-bit (don't use \"unsigned long\")\r\n              optimized upsampling by Fabian \"ryg\" Giesen\r\n      1.09    Fix format-conversion for PSD code (bad global variables!)\r\n      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz\r\n      1.07    attempt to fix C++ warning/errors again\r\n      1.06    attempt to fix C++ warning/errors again\r\n      1.05    fix TGA loading to return correct *comp and use good luminance calc\r\n      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free\r\n      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR\r\n      1.02    support for (subset of) HDR files, float interface for preferred access to them\r\n      1.01    fix bug: possible bug in handling right-side up bmps... not sure\r\n              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\r\n      1.00    interface to zlib that skips zlib header\r\n      0.99    correct handling of alpha in palette\r\n      0.98    TGA loader by lonesock; dynamically add loaders (untested)\r\n      0.97    jpeg errors on too large a file; also catch another malloc failure\r\n      0.96    fix detection of invalid v value - particleman@mollyrocket forum\r\n      0.95    during header scan, seek to markers in case of padding\r\n      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same\r\n      0.93    handle jpegtran output; verbose errors\r\n      0.92    read 4,8,16,24,32-bit BMP files of several formats\r\n      0.91    output 24-bit Windows 3.0 BMP files\r\n      0.90    fix a few more warnings; bump version number to approach 1.0\r\n      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd\r\n      0.60    fix compiling as c++\r\n      0.59    fix warnings: merge Dave Moore's -Wall fixes\r\n      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian\r\n      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\r\n      0.56    fix bug: zlib uncompressed mode len vs. nlen\r\n      0.55    fix bug: restart_interval not initialized to 0\r\n      0.54    allow NULL for 'int *comp'\r\n      0.53    fix bug in png 3->4; speedup png decoding\r\n      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments\r\n      0.51    obey req_comp requests, 1-component jpegs return as 1-component,\r\n              on 'test' only check type, not whether we support this variant\r\n      0.50  (2006-11-19)\r\n              first released version\r\n*/\r\n\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\nof the Software, and to permit persons to whom the Software is furnished to do\r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\r\nsoftware, either in source code form or as a compiled binary, for any purpose,\r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this\r\nsoftware dedicate any and all copyright interest in the software to the public\r\ndomain. We make this dedication for the benefit of the public at large and to\r\nthe detriment of our heirs and successors. We intend this dedication to be an\r\novert act of relinquishment in perpetuity of all present and future rights to\r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/","#define _CRT_SECURE_NO_WARNINGS 1\r\n#include \"graphics.h\"\r\n\r\n#ifndef __EMSCRIPTEN__\r\n#include <glad/glad.h>\r\n#include \"../glad.c\"\r\n#endif\r\n\r\n#include <glm/glm.hpp>\r\n#include <glm/gtc/matrix_transform.hpp>\r\n\r\n#include \"../Imgui/imgui.h\"\r\n#include \"../Imgui/imgui_impl_sdl_gl3.cpp\"\r\n\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include \"3rdparty/stb_image.h\"\r\n\r\nstatic SpriteBatch spriteBatch;\r\nstatic Camera2D camera;\r\n\r\nconstexpr int POS = 0;\r\nconstexpr int UVS = 1;\r\nconstexpr int ID = 2;\r\nconstexpr int COLOR = 3;\r\nconstexpr int ROTATION = 4;\r\nconstexpr int INDEX = 5;\r\nconstexpr int MAX_TEXTURES = 8;\r\n\r\nvoid initSpriteBatch(SpriteBatch* sb)\r\n{\r\n\tglGenVertexArrays(1, &sb->VAO);\r\n\tglGenBuffers(ArrayCount(SpriteBatch::buffers), sb->buffers);\r\n\r\n\tglBindVertexArray(sb->VAO);\r\n\r\n\tglEnableVertexAttribArray(0);\r\n\tglEnableVertexAttribArray(1);\r\n\tglEnableVertexAttribArray(2);\r\n\tglEnableVertexAttribArray(3);\r\n\tglEnableVertexAttribArray(4);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[POS]);\r\n\tglVertexAttribPointer(0, 4, GL_FLOAT, false, 0, 0);\r\n\tglBufferData(GL_ARRAY_BUFFER, MAX_SPRITES * sizeof(float) * 4 * 4, NULL, GL_DYNAMIC_DRAW); // 3 neli�t�    4    pistett�            3     positionia      floatteina\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[UVS]);\r\n\tglVertexAttribPointer(1, 2, GL_FLOAT, false, 0, 0);\r\n\tglBufferData(GL_ARRAY_BUFFER, MAX_SPRITES * sizeof(float) * 4 * 2, NULL, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[ID]);\r\n\tglVertexAttribPointer(2, 1, GL_FLOAT, false, 0, 0);\r\n\tglBufferData(GL_ARRAY_BUFFER, MAX_SPRITES * sizeof(float) * 4 * 1, NULL, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[COLOR]);\r\n\tglVertexAttribPointer(3, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, 0);\r\n\tglBufferData(GL_ARRAY_BUFFER, MAX_SPRITES * sizeof(unsigned int) * 4 * 1, NULL, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[ROTATION]);\r\n\tglVertexAttribPointer(4, 1, GL_FLOAT, GL_FALSE, 0, 0);\r\n\tglBufferData(GL_ARRAY_BUFFER, MAX_SPRITES * sizeof(float) * 4 * 1, NULL, GL_DYNAMIC_DRAW);\r\n\r\n\r\n\tint indexBufferSize = MAX_SPRITES * 6 * sizeof(float);\r\n\tunsigned int* indices = (unsigned int*)malloc(indexBufferSize);\r\n\tint index = 0;\r\n\tfor (int i = 0; i < MAX_SPRITES * 6; i += 6)\r\n\t{\r\n\t\tindices[i] = index + 0;\r\n\t\tindices[i + 1] = index + 1;\r\n\t\tindices[i + 2] = index + 2;\r\n\t\tindices[i + 3] = index + 2;\r\n\t\tindices[i + 4] = index + 3;\r\n\t\tindices[i + 5] = index + 0;\r\n\t\tindex += 4;\r\n\t}\r\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sb->buffers[INDEX]);\r\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, MAX_SPRITES * sizeof(GLuint) * 6, indices, GL_STATIC_DRAW);\r\n\tfree(indices); // you should use gl_map_buffer for this\r\n\r\n\tglBindVertexArray(0);\r\n\r\n\tsb->shader.compileShaderFromFile(\r\n\t\t\"assets/shaders/spriteVert.txt\",\r\n\t\t\"assets/shaders/spriteFrag.txt\");\r\n\r\n\tglCheckError();\r\n\r\n\tsb->shader.use();\r\n\tint values[8]{ 0, 1, 2, 3, 4, 5, 6, 7 };\r\n\tsb->shader.setInts(\"textures\", 8, values);\r\n\r\n\tglCheckError();\r\n}\r\n\r\nstatic inline Vec2 rotate(Vec2 pos, float angle)\r\n{\r\n\tVec2 result;\r\n\tresult.x = pos.x * cos(angle) - pos.y * sin(angle);\r\n\tresult.y = pos.x * sin(angle) + pos.y * cos(angle);\r\n\treturn result;\r\n}\r\n\r\nvoid prepareBatch(Sprites* sprites, SpriteBatch* sb)\r\n{\r\n\tint count = sprites->count;\r\n\tVertexData* vertexData = &sb->vertexData;\r\n\tvertexData->indicesCount = 6 * sprites->count;\r\n\r\n\t{\r\n\t\tfloat* positions = vertexData->pos;\r\n\t\tVec2* __restrict pos = sprites->positions;\r\n\t\tVec2* __restrict size = sprites->sizes;\r\n\r\n\t\tfloat* __restrict angle = sprites->rotation;\r\n\r\n\t\tfor (int i = 0; i < count * 16; i += 16)\r\n\t\t{\r\n#if 0\r\n\t\t\tVec2 half = *size / 2.f;\r\n\r\n\t\t\tVec2 tl = { -half.x, half.y };\r\n\t\t\tVec2 bl = { -half.x, -half.y };\r\n\t\t\tVec2 br = { half.x, -half.y };\r\n\t\t\tVec2 tr = { half.x, half.y };\r\n\r\n\t\t\ttl = rotate(tl, *angle) + half;\r\n\t\t\tbl = rotate(bl, *angle) + half;\r\n\t\t\tbr = rotate(br, *angle) + half;\r\n\t\t\ttr = rotate(tr, *angle) + half;\r\n\r\n\r\n\t\t\t*(positions + i + 0) = pos->x + tl.x;\r\n\t\t\t*(positions + i + 1) = pos->y + tl.y;\r\n\t\t\t*(positions + i + 2) = 0.0f;\r\n\t\t\t// 3\r\n\r\n\t\t\t*(positions + i + 4) = pos->x + bl.x;\r\n\t\t\t*(positions + i + 5) = pos->y + bl.y;\r\n\t\t\t*(positions + i + 6) = 0.0f;\r\n\t\t\t// 7\r\n\r\n\t\t\t*(positions + i + 8) = pos->x + br.x;\r\n\t\t\t*(positions + i + 9) = pos->y + br.y;\r\n\t\t\t*(positions + i + 10) = 0.0f;\r\n\t\t\t// 11\r\n\r\n\t\t\t*(positions + i + 12)  = pos->x + tr.x;\r\n\t\t\t*(positions + i + 13) = pos->y + tr.y;\r\n\t\t\t*(positions + i + 14) = 0.0f;\r\n\t\t\t//  15\r\n\r\n\t\t\t++angle;\r\n#elif 0\r\n\r\n\t\t\t*(positions + i + 0) = pos->x;\r\n\t\t\t*(positions + i + 1) = pos->y + size->y;\r\n\t\t\t*(positions + i + 2) = 0.0f;\r\n\r\n\t\t\t*(positions + i + 4) = pos->x;\r\n\t\t\t*(positions + i + 5) = pos->y;\r\n\t\t\t*(positions + i + 5) = 0.0f;\r\n\r\n\t\t\t*(positions + i + 8) = pos->x + size->x;\r\n\t\t\t*(positions + i + 9) = pos->y;\r\n\t\t\t*(positions + i + 8) = 0.0f;\r\n\r\n\t\t\t*(positions + i + 12) = pos->x + size->x;\r\n\t\t\t*(positions + i + 13) = pos->y + size->y;\r\n\t\t\t*(positions + i + 11) = 0.0f;\r\n#else\r\n\t\t\tVec2 half = *size / 2.f;\r\n\t\t\t*(positions + i + 0) = pos->x;\r\n\t\t\t*(positions + i + 1) = pos->y; // +size->y;\r\n\t\t\t*(positions + i + 2) = -half.x;\r\n\t\t\t*(positions + i + 3) = half.y;\r\n\r\n\t\t\t*(positions + i + 4) = pos->x;\r\n\t\t\t*(positions + i + 5) = pos->y;\r\n\t\t\t*(positions + i + 6) = -half.x;\r\n\t\t\t*(positions + i + 7) = -half.y;\r\n\r\n\t\t\t*(positions + i + 8) = pos->x; // +size->x;\r\n\t\t\t*(positions + i + 9) = pos->y;\r\n\t\t\t*(positions + i + 10) = half.x;\r\n\t\t\t*(positions + i + 11) = -half.y;\r\n\r\n\t\t\t*(positions + i + 12) = pos->x; // +size->x;\r\n\t\t\t*(positions + i + 13) = pos->y; // +size->y;\r\n\t\t\t*(positions + i + 14) = half.x;\r\n\t\t\t*(positions + i + 15) = half.y;\r\n#endif\r\n\t\t\t++pos;\r\n\t\t\t++size;\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tvec4* __restrict uvs = sprites->uvs;\r\n\t\tfloat* __restrict uvsOut = vertexData->uvs;\r\n\r\n\t\tfor (int i = 0; i < count * 8; i += 8)\r\n\t\t{\r\n\t\t\t*(uvsOut + i + 0) = uvs->x;\r\n\t\t\t*(uvsOut + i + 1) = uvs->y;\r\n\r\n\t\t\t*(uvsOut + i + 2) = uvs->x;\r\n\t\t\t*(uvsOut + i + 3) = uvs->y + uvs->h;\r\n\r\n\t\t\t*(uvsOut + i + 4) = uvs->x + uvs->w;\r\n\t\t\t*(uvsOut + i + 5) = uvs->y + uvs->h;\r\n\r\n\t\t\t*(uvsOut + i + 6) = uvs->x + uvs->w;\r\n\t\t\t*(uvsOut + i + 7) = uvs->y;\r\n\r\n\t\t\t++uvs;\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tvec4* __restrict color = sprites->colors;\r\n\t\tunsigned int* colorOut = vertexData->colors;\r\n\r\n\t\tfor (int i = 0; i < count * 4; i += 4)\r\n\t\t{\r\n\t\t\tint r = int(color->x * 255.0f);\r\n\t\t\tint g = int(color->y * 255.0f);\r\n\t\t\tint b = int(color->w * 255.0f);\r\n\t\t\tint a = int(color->h * 255.0f);\r\n\r\n\t\t\tunsigned int c = (a << 24 | b << 16 | g << 8 | r);\r\n\r\n\t\t\t*(colorOut + i + 0) = c;\r\n\t\t\t*(colorOut + i + 1) = c;\r\n\t\t\t*(colorOut + i + 2) = c;\r\n\t\t\t*(colorOut + i + 3) = c;\r\n\r\n\t\t\t++color;\r\n\t\t}\r\n\t}\r\n\r\n\t{\r\n\t\tfloat* rot = vertexData->rot;\r\n\t\tfloat* s_rots = sprites->rotation;\r\n\r\n\t\tfor (int i = 0; i < count * 4; i += 4)\r\n\t\t{\r\n\t\t\t*(rot + i + 0) = *s_rots;\r\n\t\t\t*(rot + i + 1) = *s_rots;\r\n\t\t\t*(rot + i + 2) = *s_rots;\r\n\t\t\t*(rot + i + 3) = *s_rots;\r\n\t\t\t ++s_rots;\r\n\t\t\t// memcpy(rot + i, s_rots, 4 * sizeof(float));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t{\r\n\t\tfloat* __restrict idsOut = vertexData->ids;\r\n\t\tint* __restrict ids = sprites->ids;\r\n\r\n\t\tfor (int i = 0; i < ArrayCount(VertexData::textureSlots); ++i)\r\n\t\t{\r\n\t\t\tvertexData->textureSlots[i] = -1;\r\n\t\t}\r\n\r\n\t\tvertexData->slotCount = 0;\r\n\r\n\t\tfor (int i = 0; i < count * 4; i += 4)\r\n\t\t{\r\n\t\t\t// get texture id\r\n\t\t\tfloat ts;\r\n\t\t\tbool found = false;\r\n\t\t\tfor (int i = 0; i < MAX_TEXTURES; i++)\r\n\t\t\t{\r\n\t\t\t\tif (vertexData->textureSlots[i] == *ids)\r\n\t\t\t\t{\r\n\t\t\t\t\tts = (float)(i + 1);\r\n\t\t\t\t\tfound = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!found)\r\n\t\t\t{\r\n\t\t\t\tvertexData->textureSlots[vertexData->slotCount] = *ids;\r\n\t\t\t\t(vertexData->slotCount)++;\r\n\t\t\t\tts = (float)(vertexData->slotCount);\r\n\t\t\t}\r\n\r\n\t\t\t*(idsOut + i + 0) = ts;\r\n\t\t\t*(idsOut + i + 1) = ts;\r\n\t\t\t*(idsOut + i + 2) = ts;\r\n\t\t\t*(idsOut + i + 3) = ts;\r\n\r\n\t\t\t++ids;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid renderBatch(Sprites* sprites, SpriteBatch* sb, glm::mat4* cam)\r\n{\r\n\tint count = sprites->count;\r\n\tVertexData* vertexData = &sb->vertexData;\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[POS]);\r\n\tglBufferData(GL_ARRAY_BUFFER, count * sizeof(float) * 4 * 4, vertexData->pos, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[UVS]);\r\n\tglBufferData(GL_ARRAY_BUFFER, count * sizeof(float) * 2 * 4, vertexData->uvs, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[ID]);\r\n\tglBufferData(GL_ARRAY_BUFFER, count * sizeof(float) * 4, vertexData->ids, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[COLOR]);\r\n\tglBufferData(GL_ARRAY_BUFFER, count * sizeof(unsigned int) * 4, vertexData->colors, GL_DYNAMIC_DRAW);\r\n\r\n\tglBindBuffer(GL_ARRAY_BUFFER, sb->buffers[ROTATION]);\r\n\tglBufferData(GL_ARRAY_BUFFER, count * sizeof(float) * 4, vertexData->rot, GL_DYNAMIC_DRAW);\r\n\tglCheckError();\r\n\r\n\tsb->shader.use();\r\n\tsb->shader.setMat4(\"position\", *cam);\r\n\r\n\tglBindVertexArray(sb->VAO);\r\n\r\n\tfor (int i = 0; i < MAX_TEXTURES; i++)\r\n\t{\r\n\t\tif (vertexData->textureSlots[i] == -1)\r\n\t\t\tbreak;\r\n\r\n\t\tglActiveTexture(GL_TEXTURE0 + i);\r\n\t\tglBindTexture(GL_TEXTURE_2D, vertexData->textureSlots[i]);\r\n\t}\r\n\r\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sb->buffers[INDEX]);\r\n\tglDrawElements(GL_TRIANGLES, vertexData->indicesCount, GL_UNSIGNED_INT, 0);\r\n\r\n}\r\n\r\nstruct Texture2D\r\n{\r\n\tint width, height;\r\n\tunsigned int ID;\r\n\tuint64_t writeTime;\r\n};\r\n\r\nstatic bool IsPowerOfTwo(unsigned long x)\r\n{\r\n\treturn (x & (x - 1)) == 0;\r\n}\r\n\r\nstatic Texture2D loadTexture(int width, int height, int bytesPerPixel, const unsigned char* pixels,\r\n\tbool clampToEdge = false, bool nearest = true)\r\n{\r\n\tTexture2D value;\r\n\r\n\tASSERT(bytesPerPixel == 3 || bytesPerPixel == 4);\r\n\tvalue.width = width;\r\n\tvalue.height = height;\r\n\r\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\r\n\r\n\tglGenTextures(1, &value.ID);\r\n\tglBindTexture(GL_TEXTURE_2D, value.ID);\r\n\r\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\r\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\r\n\r\n\tif (clampToEdge)\r\n\t{\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\r\n\t}\r\n\r\n\tGLuint fmt = bytesPerPixel == 3 ? GL_RGB : GL_RGBA;\r\n\tglTexImage2D(GL_TEXTURE_2D, 0, fmt, width, height, 0, fmt, GL_UNSIGNED_BYTE, pixels);\r\n\r\n\tif (IsPowerOfTwo(width) && IsPowerOfTwo(height))\r\n\t\tglGenerateMipmap(GL_TEXTURE_2D);              // webGL wants power of two textures \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t  // for mipmaps.\r\n\treturn value;\r\n}\r\n\r\nstatic Texture2D testTexture()\r\n{\r\n\tunsigned char pixels[3] = {\r\n\t\t255, 0, 255,\r\n\t};\r\n\treturn loadTexture(1, 1, 3, pixels, false, false);\r\n}\r\n\r\n//enum TextureEnum\r\n//{\r\n//\tTexture_infantry,\r\n//\tTexture_circle,\r\n//\tTexture_box,\r\n//\tTexture_count,\r\n//};\r\n\r\n//constexpr const char* texturePathBase = \"assets/textures/\";\r\n//#define TEXTURES \\\r\n//(const char* const[Texture_count]) { \\\r\n//\t[Texture_infantry] = \"infantry.png\", \\\r\n//\t[Texture_circle]   = \"circle.png\", \\\r\n//\t[Texture_box]      = \"box\", \\\r\n// }\r\n\r\n\r\n#define TEXTURE_ENUM(DO) \\\r\n\tDO(infantry) \\\r\n\tDO(circle)\\\r\n\tDO(box)\\\r\n\tDO(awesomeface)\\\r\n\tDO(noise)\\\r\n\tDO(count)\r\n\r\n#define MAKE_ENUM(VAR) Texture_##VAR,\r\nenum TextureEnum {\r\n\tTEXTURE_ENUM(MAKE_ENUM)\r\n};\r\n\r\n#define MAKE_STRINGS(VAR) #VAR,\r\nconst char* const TextureEnumToStr[] = {\r\n\tTEXTURE_ENUM(MAKE_STRINGS)\r\n};\r\n\r\n#define MAKE_MACRO_ENUM(VAR) #VAR,\r\n\r\n#define NAMES  \\\r\n(const char*[]) { \\\r\n\tTEXTURE_ENUM(MAKE_MACRO_ENUM) \\\r\n}\r\n\r\n\r\n#undef TEXTURE_ENUM\r\n#undef MAKE_STRINGS\r\n#undef MAKE_ENUM\r\n\r\n\r\nconst char* baseTexturePath = \"assets/textures/\";\r\n\r\nstatic Texture2D loadTexture(TextureEnum texture)\r\n{\r\n\tconst char* path = TextureEnumToStr[texture];\r\n\tchar buffer[256];\r\n\tASSERT(strlen(baseTexturePath) + strlen(path) < 256);\r\n\tstrcpy(buffer, baseTexturePath);\r\n\tstrcat(buffer, path);\r\n\tstrcat(buffer, \".png\");\r\n\r\n\tint w, h, nrChannels;\r\n\tunsigned char* data = stbi_load(buffer, &w, &h, &nrChannels, 0);\r\n\tif (data)\r\n\t{\r\n\t\treturn loadTexture(w, h, nrChannels, data);\r\n\t\tstbi_image_free(data);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLOGI(\"failed to load image %s \\n\", buffer);\r\n\t\tASSERT(false);\r\n\t\treturn testTexture();\r\n\t}\r\n}\r\n\r\n// can you implement sorter XD\r\n// shame that it 'leaks' and can't handle hotreloading textures XD\r\nstatic Texture2D* getTexture(TextureEnum texture)\r\n{\r\n\tstatic Texture2D textureCache[Texture_count] = { 0 };\r\n\tstatic bool loaded[Texture_count] = { 0 };\r\n\r\n\tif (!loaded[texture])\r\n\t{\r\n\t\ttextureCache[texture] = loadTexture(texture);\r\n\t\tloaded[texture] = true;\r\n\t}\r\n\r\n\treturn &textureCache[texture];\r\n}\r\n\r\nvoid initCamera(Camera2D* cam, int screenW, int screenH);\r\nEXPORT INIT_GAME(initGraphics)\r\n{\r\n\tGraphicsContext* c = &engine->context;\r\n\tif (!engine->context.initted)\r\n\t{\r\n\t\tLOGI(\"Graphics init\\n\");\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tif (!gladLoadGL())\r\n\t\t{\r\n\t\t\tprintf(\"failed to initaliaze GLAD\\n\");\r\n\t\t\tASSERT(false);\r\n\t\t}\r\n#endif\r\n\r\n\t\tglViewport(0, 0, engine->windowDims.x, engine->windowDims.y);\r\n\t\tglEnable(GL_BLEND);\r\n\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\tglClearColor(114.f / 255.0f, 144.f / 255.0f, 154.f / 255.0f, 1.0f);\r\n\r\n\t\t// init sprite batch\r\n\t\tinitSpriteBatch(&spriteBatch);\r\n\r\n\t\t//ImGui::StyleColorsClassic();\r\n\t\tinitCamera(&camera, (int)engine->windowDims.x, (int)engine->windowDims.y);\r\n\r\n\t\tstbi_set_flip_vertically_on_load(false);\r\n\r\n\t\tengine->context.initted = true;\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tImGui::SetCurrentContext((ImGuiContext*)engine->imguiContext);\r\n#endif\r\n\t}\r\n}\r\n\r\nEXPORT UPDATE_GAME(updateGraphics)\r\n{\r\n\tauto* c = &engine->context;\r\n\r\n}\r\n\r\nvoid initCamera(Camera2D* cam, int screenW, int screenH)\r\n{\r\n\tcam->orthoMatrix = glm::ortho(0.0f, (float)screenW, 0.0f, (float)screenH);\r\n}\r\n\r\nvoid updateCamera(Camera2D* cam, CameraState* state, Vec2* screen)\r\n{\r\n\tif (state->needUpdate)\r\n\t{\r\n\t\tglm::vec3 translate(-state->position.x + screen->x / 2, -state->position.y + screen->y / 2, 0.0f);  //centeroi cameran my�s�\r\n\t\tcam->cameraMatrix = glm::translate(cam->orthoMatrix, translate);\r\n\r\n\t\t//glm::mat4 matRoll = glm::mat4(1.0f);\r\n\t\t//glm::mat4 matPitch = glm::mat4(1.0f);\r\n\t\t//glm::mat4 matYaw = glm::mat4(1.0f);\r\n\r\n\t\t//matRoll  = glm::rotate(matRoll, angle, glm::vec3(0.f, 0.f, 1.0f));\r\n\t\t//matPitch = glm::rotate(matPitch, pitch, glm::vec3(1.0f, 0.0f, 0.0f));\r\n\t\t//matYaw   = glm::rotate(matYaw, yaw, glm::vec3(0.0f, 1.0f, 0.0f));\r\n\r\n\t\t// glm::mat4 rotate = matRoll * matPitch * matYaw;\r\n\r\n\t\t// kun yksi niin normaali eli kerrotaan yhdell� | jos 0.5 zoomattu ulos ja 2.o niiin zoom in\r\n\t\tglm::vec3 scale(state->scale, state->scale, 0.0f);\r\n\t\tcam->cameraMatrix = /* rotate * */ glm::scale(glm::mat4(1.0f), scale) * cam->cameraMatrix;\r\n\t\t//camera scale^^\r\n\t\tstate->needUpdate = false;\r\n\t}\r\n}\r\n\r\nconstexpr int BENCH_COUNT = 300000;\r\nstruct Entitys\r\n{\r\n\tVec2 pos[BENCH_COUNT];\r\n\tVec2 size[BENCH_COUNT];\r\n\tVec2 vel[BENCH_COUNT];\r\n\tint textureId[BENCH_COUNT];\r\n\tvec4 uvs[BENCH_COUNT];\r\n\tvec4 colors[BENCH_COUNT];\r\n\tfloat rotation[BENCH_COUNT];\r\n\tunsigned int count;\r\n\r\n\tvec4 bounds{};\r\n};\r\n\r\nEXPORT DRAW_GAME(drawGraphics)\r\n{\r\n\tauto* c = &engine->context;\r\n\tif (c->updateViewPort)\r\n\t{\r\n\t\tglViewport(0, 0, engine->windowDims.x, engine->windowDims.y);\r\n\t}\r\n\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\r\n\tstatic bool init = false;\r\n\tstatic Entitys* test = 0;\r\n\tstatic Texture2D* testTextures[] = {\r\n\t\tgetTexture(Texture_infantry),\r\n\t\tgetTexture(Texture_box),\r\n\t\tgetTexture(Texture_circle),\r\n\t\t// getTexture(Texture_noise),\r\n\t\tgetTexture(Texture_awesomeface),\r\n\t};\r\n\r\n\r\n\tif (!init)\r\n\t{\r\n\t\ttest = new Entitys;\r\n\t\tinit = true;\r\n\r\n\t\tint count = ArrayCount(Entitys::pos);\r\n\t\tconst int RNG_MAX = 0xFFFFFFFF;\r\n\t\tfor (int i = 0; i < count; ++i)\r\n\t\t{\r\n\t\t\ttest->pos[i].x = rand() % (int)engine->windowDims.x;\r\n\t\t\ttest->pos[i].y = rand() % (int)engine->windowDims.y;\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < count; ++i)\r\n\t\t{\r\n\t\t\ttest->size[i] = { 14.f, 14.f };\r\n\t\t\ttest->uvs[i] = { 0.f, 0.f, 1.f, 1.f };\r\n\t\t\ttest->colors[i] = { 1.f, 1.f, 1.f, 1.f };\r\n\t\t\ttest->rotation[i] = i / 10.f;\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < count; ++i)\r\n\t\t{\r\n\t\t\tint r = rand() % ArrayCount(testTextures);\r\n\t\t\ttest->textureId[i] = testTextures[r]->ID;\r\n\t\t\tif (r == Texture_box || r == Texture_circle)\r\n\t\t\t{\r\n\t\t\t\tvec4 randomColor{ (rand() % 255) / 255.f , (rand() % 255) / 255.f, (rand() % 255) / 255.f };\r\n\t\t\t\trandomColor.h = rand() % 120 / 255.f + 0.2f;\r\n\t\t\t\ttest->colors[i] = randomColor;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < count; ++i)\r\n\t\t{\r\n\t\t\ttest->vel[i].x = (rand() % 100) / 100.f;\r\n\t\t\ttest->vel[i].y = (rand() % 100) / 100.f;\r\n\t\t}\r\n\r\n\t\t// c->sprites.\r\n\r\n\t\tc->sprites.colors = test->colors;\r\n\t\tc->sprites.ids = test->textureId;\r\n\t\tc->sprites.positions = test->pos;\r\n\t\tc->sprites.sizes = test->size;\r\n\t\tc->sprites.uvs = test->uvs;\r\n\t\tc->sprites.rotation = test->rotation;\r\n\t\tc->sprites.count = count;\r\n\r\n\t\ttest->bounds.x = 0.f;\r\n\t\ttest->bounds.y = 0.f;\r\n\t\ttest->bounds.w = engine->windowDims.x;\r\n\t\ttest->bounds.h = engine->windowDims.y;\r\n\t}\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\tImGui::DragFloat2(\"bounds x, y\", (&test->bounds.x));\r\n\tImGui::DragFloat2(\"bounds w, h\", (&test->bounds.w));\r\n#endif\r\n\r\n\tVec2 vel = {};\r\n\tfloat speed = 40.f * engine->dt;\r\n\tauto* controller = &engine->controller;\r\n\tif (controller->cameraMovement[Controller::ctrl])\r\n\t{\r\n\t\tspeed *= 5.f;\r\n\t}\r\n\tif (controller->cameraMovement[Controller::w])\r\n\t{\r\n\t\tvel.y += speed;\r\n\t}\r\n\tif (controller->cameraMovement[Controller::s])\r\n\t{\r\n\t\tvel.y -= speed;\r\n\t}\r\n\tif (controller->cameraMovement[Controller::d])\r\n\t{\r\n\t\tvel.x += speed;\r\n\t}\r\n\tif (controller->cameraMovement[Controller::a])\r\n\t{\r\n\t\tvel.x -= speed;\r\n\t}\r\n\tif (controller->cameraMovement[Controller::q])\r\n\t{\r\n\t\tzoom(&c->camera, 0.33f * engine->dt);\r\n\t}\r\n\tif (controller->cameraMovement[Controller::e])\r\n\t{\r\n\t\tzoom(&c->camera, -0.33f * engine->dt);\r\n\t}\r\n\ttranslate(&c->camera, vel);\r\n\r\n\tfloat unitSpeed = 100 * engine->dt;\r\n\tfor (int i = 0; i < BENCH_COUNT; ++i)\r\n\t{\r\n\t\ttest->pos[i].x += test->vel[i].x * unitSpeed;\r\n\t\ttest->pos[i].y += test->vel[i].y * unitSpeed;\r\n\t}\r\n\r\n\tfor (int i = 0; i < BENCH_COUNT; ++i)\r\n\t{\r\n\t\tif (test->pos[i].x < test->bounds.x | test->pos[i].x > test->bounds.w)\r\n\t\t{\r\n\t\t\ttest->vel[i].x = -test->vel[i].x; // *unitSpeed;\r\n//\t\t\ttest->pos[i].x += test->vel[i].x * unitSpeed;\r\n\t\t\ttest->pos[i].x = test->pos[i].x < test->bounds.x ? test->bounds.x : test->bounds.w - 1.f;\r\n\t\t}\r\n\r\n\t\tif (test->pos[i].y < test->bounds.y | test->pos[i].y > test->bounds.h)\r\n\t\t{\r\n\t\t\ttest->vel[i].y = -test->vel[i].y; // *unitSpeed;\r\n\t\t\ttest->pos[i].y = test->pos[i].y < test->bounds.y ? test->bounds.y : test->bounds.h - 1.f;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < BENCH_COUNT / 2; ++i)\r\n\t{\r\n\t\ttest->rotation[i] += test->vel[i].x;\r\n\t}\r\n\tfor (int i = BENCH_COUNT / 2; i < BENCH_COUNT; ++i)\r\n\t{\r\n\t\ttest->rotation[i] -= test->vel[i].x;\r\n\t}\r\n\r\n\t\r\n\ttest->textureId[0] = testTextures[0]->ID;\r\n\ttest->pos[0].x = 0.f;\r\n\ttest->pos[0].y = 0.f;\r\n\t// test->pos[0].x += 0.0001f;\r\n\ttest->rotation[0] += 0.001f;\r\n\r\n\ttest->textureId[1] = testTextures[0]->ID;\r\n\ttest->pos[1].x = 10.f;\r\n\ttest->pos[1].y = 10.f;\r\n\t// test->pos[1].x += 0.0001f;\r\n\ttest->rotation[1] += 0.001f;\r\n\r\n\r\n\tprepareBatch(&c->sprites, &spriteBatch);\r\n\r\n\tupdateCamera(&camera, &c->camera, &engine->windowDims);\r\n\trenderBatch(&c->sprites, &spriteBatch, &camera.cameraMatrix);\r\n}\r\n","#pragma once\r\n#include <string>\r\n\r\n// #include <GLES2/gl.h>\r\n#if defined(__EMSCRIPTEN__)\r\n// #include <SDL2/SDL_opengles2.h>\r\n#else\r\n#include <glad/glad.h>\r\n#endif\r\n\r\n// #include <GLES3/gl3.h>\r\n// #include <core/IO.h>\r\n// #include <core/Log.h>\r\n\r\n#include \"../src/IO.cpp\"\r\n\r\n#include <glm/glm.hpp>\r\n#include <glm/gtc/type_ptr.hpp>\r\n\r\nvoid checkCompileErrors(unsigned int shader, std::string type, const char* shaderName);\r\n\r\nnamespace engine {\r\n\r\n\tclass Shader\r\n\t{\r\n\tpublic:\r\n\t\tunsigned int ID;\r\n\r\n\t\tShader() = default;\r\n\r\n\t\tShader(const char* vertexPath, const char* fragmentPath)\r\n\t\t{\r\n\t\t\tif (vertexPath == 0 && fragmentPath == 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// compileShaderFromFile(vertexPath, fragmentPath);\r\n\t\t}\r\n\r\n\t\tvoid SetVector3f(const char* name, const glm::vec3 &value)\r\n\t\t{\r\n\t\t\tglUniform3f(glGetUniformLocation(this->ID, name), value.x, value.y, value.z);\r\n\t\t}\r\n\r\n\t\tvoid SetVector4f(const char* name, const vec4 &value)\r\n\t\t{\r\n\t\t\tglUniform4f(glGetUniformLocation(this->ID, name), value.x, value.y, value.w, value.h);\r\n\t\t}\r\n#if 1\r\n\t\tvoid compileShaderFromFile(const char* vertexFilepath, const char* fragmentFilepath, bool modernVersion = false)\r\n\t\t{\r\n\t\t\tstd::string vertexCode;\r\n\t\t\tstd::string fragmentCode;\r\n\r\n#if !__EMSCRIPTEN__\r\n            if (modernVersion)\r\n            {\r\n                const int additionalLen = 20;\r\n                ASSERT(strlen(vertexFilepath) + additionalLen   < 256); // overflow :(\r\n                ASSERT(strlen(fragmentFilepath) + additionalLen < 256);\r\n                char fragbuf[256];\r\n                char verbuf[256];\r\n\r\n                sprintf(verbuf, \"%s_43\", vertexFilepath);\r\n                sprintf(fragbuf, \"%s_43\", fragmentFilepath);\r\n\r\n                vertexCode = engine::io::ReadEntireFileToString(verbuf);\r\n                fragmentCode = engine::io::ReadEntireFileToString(fragbuf);\r\n            }\r\n            else\r\n#endif\r\n            {\r\n                vertexCode = engine::io::ReadEntireFileToString(vertexFilepath);\r\n                fragmentCode = engine::io::ReadEntireFileToString(fragmentFilepath);\r\n            }\r\n\r\n\r\n\t\t\tconst char* vShaderCode = vertexCode.c_str();\r\n\t\t\tconst char* fShaderCode = fragmentCode.c_str();\r\n\r\n\t\t\tcompileShadersFromSource(vShaderCode, fShaderCode, vertexFilepath, fragmentFilepath);\r\n\t\t}\r\n#endif\r\n\r\n\t\tvoid compileShadersFromSource(const char * vertexSrc, const char * fragmentSrc,\r\n                const char* vertexName, const char* fragmentName)\r\n\t\t{\r\n\t\t\tunsigned int vertex, fragment;\r\n\r\n\t\t\tvertex = glCreateShader(GL_VERTEX_SHADER);\r\n\t\t\tglShaderSource(vertex, 1, &vertexSrc, NULL);\r\n\t\t\tglCompileShader(vertex);\r\n\t\t\tcheckCompileErrors(vertex, \"VERTEX\", vertexName);\r\n\r\n\t\t\t// fragment Shader\r\n\t\t\tfragment = glCreateShader(GL_FRAGMENT_SHADER);\r\n\t\t\tglShaderSource(fragment, 1, &fragmentSrc, NULL);\r\n\t\t\tglCompileShader(fragment);\r\n\t\t\tcheckCompileErrors(fragment, \"FRAGMENT\", fragmentName);\r\n\r\n\t\t\t// shader Program\r\n\t\t\tID = glCreateProgram();\r\n\t\t\tglAttachShader(ID, vertex);\r\n\t\t\tglAttachShader(ID, fragment);\r\n\t\t\tglLinkProgram(ID);\r\n\t\t\tcheckCompileErrors(ID, \"PROGRAM\", fragmentName);\r\n\r\n\t\t\t// delete the shaders as they're linked into our program now and no longer necessary\r\n\t\t\tglDeleteShader(vertex);\r\n\t\t\tglDeleteShader(fragment);\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// activate the shader\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid use()\r\n\t\t{\r\n\t\t\tglUseProgram(ID);\r\n\t\t}\r\n\t\t// utility uniform functions\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid setBool(const std::string &name, bool value) const\r\n\t\t{\r\n\t\t\tglUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);\r\n\t\t}\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid setInt(const std::string &name, int value) const\r\n\t\t{\r\n\t\t\tglUniform1i(glGetUniformLocation(ID, name.c_str()), value);\r\n\t\t}\r\n\r\n\t\tvoid setInts(const std::string &name, int count, int* values) const\r\n\t\t{\r\n\t\t\tglUniform1iv(glGetUniformLocation(ID, name.c_str()), count, values);\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid setFloat(const std::string &name, float value) const\r\n\t\t{\r\n\t\t\tglUniform1f(glGetUniformLocation(ID, name.c_str()), value);\r\n\t\t}\r\n\r\n\t\tvoid setFloat2(const std::string &name, glm::vec2& value) const\r\n\t\t{\r\n\t\t\tglUniform2f(glGetUniformLocation(ID, name.c_str()), value.x, value.y);\r\n\t\t}\r\n\r\n\t\tvoid setMat4(const std::string &name, glm::mat4 value) const\r\n\t\t{\r\n            float* ptr = glm::value_ptr(value);\r\n            GLuint id = glGetUniformLocation(ID, name.c_str());\r\n\t\t\tglUniformMatrix4fv(id, 1, GL_FALSE, ptr);\r\n\t\t}\r\n\r\n\t\tvoid setMat4(const unsigned int ID, glm::mat4 value) const\r\n\t\t{\r\n\t\t\tglUniformMatrix4fv(ID, 1, GL_FALSE, glm::value_ptr(value));\r\n\t\t}\r\n\r\n\r\n\t\tunsigned int getLocation(const char* name)\r\n\t\t{\r\n\t\t\treturn glGetUniformLocation(ID, name);\r\n\t\t}\r\n\r\n\t\tvoid setFloat4(const char* name, const glm::vec4& vec4)\r\n\t\t{\r\n\t\t\tglUniform4f(glGetUniformLocation(ID, name), vec4.x, vec4.y, vec4.z, vec4.w);\r\n\t\t}\r\n\r\n\tprivate:\r\n\t\t// utility function for checking shader compilation/linking errors.\r\n\t\t// ------------------------------------------------------------------------\r\n\t};\r\n}\r\n","/// @ref gtc_matrix_transform\n/// @file glm/gtc/matrix_transform.inl\n\n#include \"../geometric.hpp\"\n#include \"../trigonometric.hpp\"\n#include \"../matrix.hpp\"\n\nnamespace glm\n{\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> translate(tmat4x4<T, P> const & m, tvec3<T, P> const & v)\n\t{\n\t\ttmat4x4<T, P> Result(m);\n\t\tResult[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];\n\t\treturn Result;\n\t}\n\t\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> rotate(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)\n\t{\n\t\tT const a = angle;\n\t\tT const c = cos(a);\n\t\tT const s = sin(a);\n\n\t\ttvec3<T, P> axis(normalize(v));\n\t\ttvec3<T, P> temp((T(1) - c) * axis);\n\n\t\ttmat4x4<T, P> Rotate(uninitialize);\n\t\tRotate[0][0] = c + temp[0] * axis[0];\n\t\tRotate[0][1] = temp[0] * axis[1] + s * axis[2];\n\t\tRotate[0][2] = temp[0] * axis[2] - s * axis[1];\n\n\t\tRotate[1][0] = temp[1] * axis[0] - s * axis[2];\n\t\tRotate[1][1] = c + temp[1] * axis[1];\n\t\tRotate[1][2] = temp[1] * axis[2] + s * axis[0];\n\n\t\tRotate[2][0] = temp[2] * axis[0] + s * axis[1];\n\t\tRotate[2][1] = temp[2] * axis[1] - s * axis[0];\n\t\tRotate[2][2] = c + temp[2] * axis[2];\n\n\t\ttmat4x4<T, P> Result(uninitialize);\n\t\tResult[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];\n\t\tResult[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];\n\t\tResult[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];\n\t\tResult[3] = m[3];\n\t\treturn Result;\n\t}\n\t\t\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> rotate_slow(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)\n\t{\n\t\tT const a = angle;\n\t\tT const c = cos(a);\n\t\tT const s = sin(a);\n\t\ttmat4x4<T, P> Result;\n\n\t\ttvec3<T, P> axis = normalize(v);\n\n\t\tResult[0][0] = c + (static_cast<T>(1) - c)      * axis.x     * axis.x;\n\t\tResult[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;\n\t\tResult[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;\n\t\tResult[0][3] = static_cast<T>(0);\n\n\t\tResult[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;\n\t\tResult[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;\n\t\tResult[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;\n\t\tResult[1][3] = static_cast<T>(0);\n\n\t\tResult[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;\n\t\tResult[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;\n\t\tResult[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;\n\t\tResult[2][3] = static_cast<T>(0);\n\n\t\tResult[3] = tvec4<T, P>(0, 0, 0, 1);\n\t\treturn m * Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> scale(tmat4x4<T, P> const & m, tvec3<T, P> const & v)\n\t{\n\t\ttmat4x4<T, P> Result(uninitialize);\n\t\tResult[0] = m[0] * v[0];\n\t\tResult[1] = m[1] * v[1];\n\t\tResult[2] = m[2] * v[2];\n\t\tResult[3] = m[3];\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> scale_slow(tmat4x4<T, P> const & m, tvec3<T, P> const & v)\n\t{\n\t\ttmat4x4<T, P> Result(T(1));\n\t\tResult[0][0] = v.x;\n\t\tResult[1][1] = v.y;\n\t\tResult[2][2] = v.z;\n\t\treturn m * Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> ortho\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top,\n\t\tT zNear, T zFar\n\t)\n\t{\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\n\t\t\treturn orthoLH(left, right, bottom, top, zNear, zFar);\n#\t\telse\n\t\t\treturn orthoRH(left, right, bottom, top, zNear, zFar);\n#\t\tendif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> orthoLH\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top,\n\t\tT zNear, T zFar\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(1);\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\n\t\tResult[3][0] = - (right + left) / (right - left);\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = static_cast<T>(1) / (zFar - zNear);\n\t\t\tResult[3][2] = - zNear / (zFar - zNear);\n#\t\telse\n\t\t\tResult[2][2] = static_cast<T>(2) / (zFar - zNear);\n\t\t\tResult[3][2] = - (zFar + zNear) / (zFar - zNear);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> orthoRH\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top,\n\t\tT zNear, T zFar\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(1);\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\n\t\tResult[3][0] = - (right + left) / (right - left);\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = - static_cast<T>(1) / (zFar - zNear);\n\t\t\tResult[3][2] = - zNear / (zFar - zNear);\n#\t\telse\n\t\t\tResult[2][2] = - static_cast<T>(2) / (zFar - zNear);\n\t\t\tResult[3][2] = - (zFar + zNear) / (zFar - zNear);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> ortho\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(1));\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\n\t\tResult[2][2] = - static_cast<T>(1);\n\t\tResult[3][0] = - (right + left) / (right - left);\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustum\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top,\n\t\tT nearVal, T farVal\n\t)\n\t{\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\n\t\t\treturn frustumLH(left, right, bottom, top, nearVal, farVal);\n#\t\telse\n\t\t\treturn frustumRH(left, right, bottom, top, nearVal, farVal);\n#\t\tendif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustumLH\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top,\n\t\tT nearVal, T farVal\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(0);\n\t\tResult[0][0] = (static_cast<T>(2) * nearVal) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);\n\t\tResult[2][0] = (right + left) / (right - left);\n\t\tResult[2][1] = (top + bottom) / (top - bottom);\n\t\tResult[2][3] = static_cast<T>(1);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = farVal / (farVal - nearVal);\n\t\t\tResult[3][2] = -(farVal * nearVal) / (farVal - nearVal);\n#\t\telse\n\t\t\tResult[2][2] = (farVal + nearVal) / (farVal - nearVal);\n\t\t\tResult[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustumRH\n\t(\n\t\tT left, T right,\n\t\tT bottom, T top,\n\t\tT nearVal, T farVal\n\t)\n\t{\n\t\ttmat4x4<T, defaultp> Result(0);\n\t\tResult[0][0] = (static_cast<T>(2) * nearVal) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);\n\t\tResult[2][0] = (right + left) / (right - left);\n\t\tResult[2][1] = (top + bottom) / (top - bottom);\n\t\tResult[2][3] = static_cast<T>(-1);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = farVal / (nearVal - farVal);\n\t\t\tResult[3][2] = -(farVal * nearVal) / (farVal - nearVal);\n#\t\telse\n\t\t\tResult[2][2] = - (farVal + nearVal) / (farVal - nearVal);\n\t\t\tResult[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)\n\t{\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\n\t\t\treturn perspectiveLH(fovy, aspect, zNear, zFar);\n#\t\telse\n\t\t\treturn perspectiveRH(fovy, aspect, zNear, zFar);\n#\t\tendif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)\n\t{\n\t\tassert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));\n\n\t\tT const tanHalfFovy = tan(fovy / static_cast<T>(2));\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);\n\t\tResult[1][1] = static_cast<T>(1) / (tanHalfFovy);\n\t\tResult[2][3] = - static_cast<T>(1);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = zFar / (zNear - zFar);\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\n#\t\telse\n\t\t\tResult[2][2] = - (zFar + zNear) / (zFar - zNear);\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\t\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)\n\t{\n\t\tassert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));\n\n\t\tT const tanHalfFovy = tan(fovy / static_cast<T>(2));\n\t\t\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);\n\t\tResult[1][1] = static_cast<T>(1) / (tanHalfFovy);\n\t\tResult[2][3] = static_cast<T>(1);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = zFar / (zFar - zNear);\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\n#\t\telse\n\t\t\tResult[2][2] = (zFar + zNear) / (zFar - zNear);\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)\n\t{\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\n\t\t\treturn perspectiveFovLH(fov, width, height, zNear, zFar);\n#\t\telse\n\t\t\treturn perspectiveFovRH(fov, width, height, zNear, zFar);\n#\t\tendif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)\n\t{\n\t\tassert(width > static_cast<T>(0));\n\t\tassert(height > static_cast<T>(0));\n\t\tassert(fov > static_cast<T>(0));\n\t\n\t\tT const rad = fov;\n\t\tT const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);\n\t\tT const w = h * height / width; ///todo max(width , Height) / min(width , Height)?\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = w;\n\t\tResult[1][1] = h;\n\t\tResult[2][3] = - static_cast<T>(1);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = zFar / (zNear - zFar);\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\n#\t\telse\n\t\t\tResult[2][2] = - (zFar + zNear) / (zFar - zNear);\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)\n\t{\n\t\tassert(width > static_cast<T>(0));\n\t\tassert(height > static_cast<T>(0));\n\t\tassert(fov > static_cast<T>(0));\n\t\n\t\tT const rad = fov;\n\t\tT const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);\n\t\tT const w = h * height / width; ///todo max(width , Height) / min(width , Height)?\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = w;\n\t\tResult[1][1] = h;\n\t\tResult[2][3] = static_cast<T>(1);\n\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\tResult[2][2] = zFar / (zFar - zNear);\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\n#\t\telse\n\t\t\tResult[2][2] = (zFar + zNear) / (zFar - zNear);\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\n#\t\tendif\n\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)\n\t{\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\n\t\t\treturn infinitePerspectiveLH(fovy, aspect, zNear);\n#\t\telse\n\t\t\treturn infinitePerspectiveRH(fovy, aspect, zNear);\n#\t\tendif\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)\n\t{\n\t\tT const range = tan(fovy / static_cast<T>(2)) * zNear;\n\t\tT const left = -range * aspect;\n\t\tT const right = range * aspect;\n\t\tT const bottom = -range;\n\t\tT const top = range;\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\n\t\tResult[2][2] = - static_cast<T>(1);\n\t\tResult[2][3] = - static_cast<T>(1);\n\t\tResult[3][2] = - static_cast<T>(2) * zNear;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)\n\t{\n\t\tT const range = tan(fovy / static_cast<T>(2)) * zNear;\n\t\tT const left = -range * aspect;\n\t\tT const right = range * aspect;\n\t\tT const bottom = -range;\n\t\tT const top = range;\n\n\t\ttmat4x4<T, defaultp> Result(T(0));\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\n\t\tResult[2][2] = static_cast<T>(1);\n\t\tResult[2][3] = static_cast<T>(1);\n\t\tResult[3][2] = - static_cast<T>(2) * zNear;\n\t\treturn Result;\n\t}\n\n\t// Infinite projection matrix: http://www.terathon.com/gdc07_lengyel.pdf\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)\n\t{\n\t\tT const range = tan(fovy / static_cast<T>(2)) * zNear;\t\n\t\tT const left = -range * aspect;\n\t\tT const right = range * aspect;\n\t\tT const bottom = -range;\n\t\tT const top = range;\n\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\n\t\tResult[2][2] = ep - static_cast<T>(1);\n\t\tResult[2][3] = static_cast<T>(-1);\n\t\tResult[3][2] = (ep - static_cast<T>(2)) * zNear;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)\n\t{\n\t\treturn tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());\n\t}\n\n\ttemplate <typename T, typename U, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> project\n\t(\n\t\ttvec3<T, P> const & obj,\n\t\ttmat4x4<T, P> const & model,\n\t\ttmat4x4<T, P> const & proj,\n\t\ttvec4<U, P> const & viewport\n\t)\n\t{\n\t\ttvec4<T, P> tmp = tvec4<T, P>(obj, static_cast<T>(1));\n\t\ttmp = model * tmp;\n\t\ttmp = proj * tmp;\n\n\t\ttmp /= tmp.w;\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\ttmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);\n\t\t\ttmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);\n#\t\telse\n\t\t\ttmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);\n#\t\tendif\n\t\ttmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);\n\t\ttmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);\n\n\t\treturn tvec3<T, P>(tmp);\n\t}\n\n\ttemplate <typename T, typename U, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> unProject\n\t(\n\t\ttvec3<T, P> const & win,\n\t\ttmat4x4<T, P> const & model,\n\t\ttmat4x4<T, P> const & proj,\n\t\ttvec4<U, P> const & viewport\n\t)\n\t{\n\t\ttmat4x4<T, P> Inverse = inverse(proj * model);\n\n\t\ttvec4<T, P> tmp = tvec4<T, P>(win, T(1));\n\t\ttmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);\n\t\ttmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\n\t\t\ttmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);\n\t\t\ttmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);\n#\t\telse\n\t\t\ttmp = tmp * static_cast<T>(2) - static_cast<T>(1);\n#\t\tendif\n\n\t\ttvec4<T, P> obj = Inverse * tmp;\n\t\tobj /= obj.w;\n\n\t\treturn tvec3<T, P>(obj);\n\t}\n\n\ttemplate <typename T, precision P, typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> pickMatrix(tvec2<T, P> const & center, tvec2<T, P> const & delta, tvec4<U, P> const & viewport)\n\t{\n\t\tassert(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0));\n\t\ttmat4x4<T, P> Result(static_cast<T>(1));\n\n\t\tif(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))\n\t\t\treturn Result; // Error\n\n\t\ttvec3<T, P> Temp(\n\t\t\t(static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,\n\t\t\t(static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,\n\t\t\tstatic_cast<T>(0));\n\n\t\t// Translate and scale the picked region to the entire window\n\t\tResult = translate(Result, Temp);\n\t\treturn scale(Result, tvec3<T, P>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAt(tvec3<T, P> const & eye, tvec3<T, P> const & center, tvec3<T, P> const & up)\n\t{\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\n\t\t\treturn lookAtLH(eye, center, up);\n#\t\telse\n\t\t\treturn lookAtRH(eye, center, up);\n#\t\tendif\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAtRH\n\t(\n\t\ttvec3<T, P> const & eye,\n\t\ttvec3<T, P> const & center,\n\t\ttvec3<T, P> const & up\n\t)\n\t{\n\t\ttvec3<T, P> const f(normalize(center - eye));\n\t\ttvec3<T, P> const s(normalize(cross(f, up)));\n\t\ttvec3<T, P> const u(cross(s, f));\n\n\t\ttmat4x4<T, P> Result(1);\n\t\tResult[0][0] = s.x;\n\t\tResult[1][0] = s.y;\n\t\tResult[2][0] = s.z;\n\t\tResult[0][1] = u.x;\n\t\tResult[1][1] = u.y;\n\t\tResult[2][1] = u.z;\n\t\tResult[0][2] =-f.x;\n\t\tResult[1][2] =-f.y;\n\t\tResult[2][2] =-f.z;\n\t\tResult[3][0] =-dot(s, eye);\n\t\tResult[3][1] =-dot(u, eye);\n\t\tResult[3][2] = dot(f, eye);\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAtLH\n\t(\n\t\ttvec3<T, P> const & eye,\n\t\ttvec3<T, P> const & center,\n\t\ttvec3<T, P> const & up\n\t)\n\t{\n\t\ttvec3<T, P> const f(normalize(center - eye));\n\t\ttvec3<T, P> const s(normalize(cross(up, f)));\n\t\ttvec3<T, P> const u(cross(f, s));\n\n\t\ttmat4x4<T, P> Result(1);\n\t\tResult[0][0] = s.x;\n\t\tResult[1][0] = s.y;\n\t\tResult[2][0] = s.z;\n\t\tResult[0][1] = u.x;\n\t\tResult[1][1] = u.y;\n\t\tResult[2][1] = u.z;\n\t\tResult[0][2] = f.x;\n\t\tResult[1][2] = f.y;\n\t\tResult[2][2] = f.z;\n\t\tResult[3][0] = -dot(s, eye);\n\t\tResult[3][1] = -dot(u, eye);\n\t\tResult[3][2] = -dot(f, eye);\n\t\treturn Result;\n\t}\n}//namespace glm\n","/// @ref core\n/// @file glm/detail/type_tvec3.inl\n\nnamespace glm\n{\n\n#\tifdef GLM_STATIC_CONST_MEMBERS\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::ZERO(static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::X(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::Y(static_cast<T>(0), static_cast<T>(1), static_cast<T>(0));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::Z(static_cast<T>(0), static_cast<T>(0), static_cast<T>(1));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::XY(static_cast<T>(1), static_cast<T>(1), static_cast<T>(0));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::XZ(static_cast<T>(1), static_cast<T>(0), static_cast<T>(1));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::YZ(static_cast<T>(0), static_cast<T>(1), static_cast<T>(1));\n\n\ttemplate <typename T, precision P>\n\tconst tvec3<T, P> tvec3<T, P>::XYZ(static_cast<T>(1), static_cast<T>(1), static_cast<T>(1));\n#\tendif\n\t// -- Implicit basic constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3()\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \n\t\t\t\t: x(0), y(0), z(0)\n#\t\t\tendif\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec3<T, P> const & v)\n\t\t\t: x(v.x), y(v.y), z(v.z)\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec3<T, Q> const & v)\n\t\t: x(v.x), y(v.y), z(v.z)\n\t{}\n\n\t// -- Explicit basic constructors --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(T scalar)\n\t\t: x(scalar), y(scalar), z(scalar)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(T a, T b, T c)\n\t\t: x(a), y(b), z(c)\n\t{}\n\n\t// -- Conversion scalar constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(A a, B b, C c) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b)),\n\t\tz(static_cast<T>(c))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b)),\n\t\tz(static_cast<T>(c))\n\t{}\n\n\t// -- Conversion vector constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(A a, tvec2<B, Q> const & b) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :\n\t\tx(static_cast<T>(v.x)),\n\t\ty(static_cast<T>(v.y)),\n\t\tz(static_cast<T>(v.z))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :\n\t\tx(static_cast<T>(v.x)),\n\t\ty(static_cast<T>(v.y)),\n\t\tz(static_cast<T>(v.z))\n\t{}\n\n\t// -- Component accesses --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)\n\t{\n\t\tassert(i >= 0 && i < this->length());\n\t\treturn (&x)[i];\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const\n\t{\n\t\tassert(i >= 0 && i < this->length());\n\t\treturn (&x)[i];\n\t}\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)\n\t\t{\n\t\t\tthis->x = v.x;\n\t\t\tthis->y = v.y;\n\t\t\tthis->z = v.z;\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x = static_cast<T>(v.x);\n\t\tthis->y = static_cast<T>(v.y);\n\t\tthis->z = static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)\n\t{\n\t\tthis->x += static_cast<T>(scalar);\n\t\tthis->y += static_cast<T>(scalar);\n\t\tthis->z += static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.x);\n\t\tthis->z += static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x += static_cast<T>(v.x);\n\t\tthis->y += static_cast<T>(v.y);\n\t\tthis->z += static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)\n\t{\n\t\tthis->x -= static_cast<T>(scalar);\n\t\tthis->y -= static_cast<T>(scalar);\n\t\tthis->z -= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.x);\n\t\tthis->z -= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x -= static_cast<T>(v.x);\n\t\tthis->y -= static_cast<T>(v.y);\n\t\tthis->z -= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)\n\t{\n\t\tthis->x *= static_cast<T>(scalar);\n\t\tthis->y *= static_cast<T>(scalar);\n\t\tthis->z *= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.x);\n\t\tthis->z *= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x *= static_cast<T>(v.x);\n\t\tthis->y *= static_cast<T>(v.y);\n\t\tthis->z *= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(U v)\n\t{\n\t\tthis->x /= static_cast<T>(v);\n\t\tthis->y /= static_cast<T>(v);\n\t\tthis->z /= static_cast<T>(v);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.x);\n\t\tthis->z /= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x /= static_cast<T>(v.x);\n\t\tthis->y /= static_cast<T>(v.y);\n\t\tthis->z /= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator++()\n\t{\n\t\t++this->x;\n\t\t++this->y;\n\t\t++this->z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator--()\n\t{\n\t\t--this->x;\n\t\t--this->y;\n\t\t--this->z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator++(int)\n\t{\n\t\ttvec3<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator--(int)\n\t{\n\t\ttvec3<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary bit operators --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)\n\t{\n\t\tthis->x %= scalar;\n\t\tthis->y %= scalar;\n\t\tthis->z %= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x %= v.x;\n\t\tthis->y %= v.x;\n\t\tthis->z %= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x %= v.x;\n\t\tthis->y %= v.y;\n\t\tthis->z %= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)\n\t{\n\t\tthis->x &= scalar;\n\t\tthis->y &= scalar;\n\t\tthis->z &= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x &= v.x;\n\t\tthis->y &= v.x;\n\t\tthis->z &= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x &= v.x;\n\t\tthis->y &= v.y;\n\t\tthis->z &= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)\n\t{\n\t\tthis->x |= scalar;\n\t\tthis->y |= scalar;\n\t\tthis->z |= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x |= v.x;\n\t\tthis->y |= v.x;\n\t\tthis->z |= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x |= v.x;\n\t\tthis->y |= v.y;\n\t\tthis->z |= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)\n\t{\n\t\tthis->x ^= scalar;\n\t\tthis->y ^= scalar;\n\t\tthis->z ^= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x ^= v.x;\n\t\tthis->y ^= v.x;\n\t\tthis->z ^= v.x;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x ^= v.x;\n\t\tthis->y ^= v.y;\n\t\tthis->z ^= v.z;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)\n\t{\n\t\tthis->x <<= scalar;\n\t\tthis->y <<= scalar;\n\t\tthis->z <<= scalar;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.x);\n\t\tthis->z <<= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x <<= static_cast<T>(v.x);\n\t\tthis->y <<= static_cast<T>(v.y);\n\t\tthis->z <<= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)\n\t{\n\t\tthis->x >>= static_cast<T>(scalar);\n\t\tthis->y >>= static_cast<T>(scalar);\n\t\tthis->z >>= static_cast<T>(scalar);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.x);\n\t\tthis->z >>= static_cast<T>(v.x);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)\n\t{\n\t\tthis->x >>= static_cast<T>(v.x);\n\t\tthis->y >>= static_cast<T>(v.y);\n\t\tthis->z >>= static_cast<T>(v.z);\n\t\treturn *this;\n\t}\n\n\t// -- Unary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v)\n\t{\n\t\treturn v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\t-v.x, \n\t\t\t-v.y, \n\t\t\t-v.z);\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x + scalar,\n\t\t\tv.y + scalar,\n\t\t\tv.z + scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x + scalar.x,\n\t\t\tv.y + scalar.x,\n\t\t\tv.z + scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar + v.x,\n\t\t\tscalar + v.y,\n\t\t\tscalar + v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x + v.x,\n\t\t\tscalar.x + v.y,\n\t\t\tscalar.x + v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x + v2.x,\n\t\t\tv1.y + v2.y,\n\t\t\tv1.z + v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x - scalar,\n\t\t\tv.y - scalar,\n\t\t\tv.z - scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x - scalar.x,\n\t\t\tv.y - scalar.x,\n\t\t\tv.z - scalar.x);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar - v.x,\n\t\t\tscalar - v.y,\n\t\t\tscalar - v.z);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x - v.x,\n\t\t\tscalar.x - v.y,\n\t\t\tscalar.x - v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x - v2.x,\n\t\t\tv1.y - v2.y,\n\t\t\tv1.z - v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x * scalar,\n\t\t\tv.y * scalar,\n\t\t\tv.z * scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x * scalar.x,\n\t\t\tv.y * scalar.x,\n\t\t\tv.z * scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar * v.x,\n\t\t\tscalar * v.y,\n\t\t\tscalar * v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x * v.x,\n\t\t\tscalar.x * v.y,\n\t\t\tscalar.x * v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x * v2.x,\n\t\t\tv1.y * v2.y,\n\t\t\tv1.z * v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x / scalar,\n\t\t\tv.y / scalar,\n\t\t\tv.z / scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x / scalar.x,\n\t\t\tv.y / scalar.x,\n\t\t\tv.z / scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar / v.x,\n\t\t\tscalar / v.y,\n\t\t\tscalar / v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x / v.x,\n\t\t\tscalar.x / v.y,\n\t\t\tscalar.x / v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x / v2.x,\n\t\t\tv1.y / v2.y,\n\t\t\tv1.z / v2.z);\n\t}\n\n\t// -- Binary bit operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x % scalar,\n\t\t\tv.y % scalar,\n\t\t\tv.z % scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x % scalar.x,\n\t\t\tv.y % scalar.x,\n\t\t\tv.z % scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar % v.x,\n\t\t\tscalar % v.y,\n\t\t\tscalar % v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x % v.x,\n\t\t\tscalar.x % v.y,\n\t\t\tscalar.x % v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x % v2.x,\n\t\t\tv1.y % v2.y,\n\t\t\tv1.z % v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x & scalar,\n\t\t\tv.y & scalar,\n\t\t\tv.z & scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x & scalar.x,\n\t\t\tv.y & scalar.x,\n\t\t\tv.z & scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar & v.x,\n\t\t\tscalar & v.y,\n\t\t\tscalar & v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x & v.x,\n\t\t\tscalar.x & v.y,\n\t\t\tscalar.x & v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x & v2.x,\n\t\t\tv1.y & v2.y,\n\t\t\tv1.z & v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x | scalar,\n\t\t\tv.y | scalar,\n\t\t\tv.z | scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x | scalar.x,\n\t\t\tv.y | scalar.x,\n\t\t\tv.z | scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar | v.x,\n\t\t\tscalar | v.y,\n\t\t\tscalar | v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x | v.x,\n\t\t\tscalar.x | v.y,\n\t\t\tscalar.x | v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x | v2.x,\n\t\t\tv1.y | v2.y,\n\t\t\tv1.z | v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x ^ scalar,\n\t\t\tv.y ^ scalar,\n\t\t\tv.z ^ scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x ^ scalar.x,\n\t\t\tv.y ^ scalar.x,\n\t\t\tv.z ^ scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar ^ v.x,\n\t\t\tscalar ^ v.y,\n\t\t\tscalar ^ v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x ^ v.x,\n\t\t\tscalar.x ^ v.y,\n\t\t\tscalar.x ^ v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x ^ v2.x,\n\t\t\tv1.y ^ v2.y,\n\t\t\tv1.z ^ v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x << scalar,\n\t\t\tv.y << scalar,\n\t\t\tv.z << scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x << scalar.x,\n\t\t\tv.y << scalar.x,\n\t\t\tv.z << scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar << v.x,\n\t\t\tscalar << v.y,\n\t\t\tscalar << v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x << v.x,\n\t\t\tscalar.x << v.y,\n\t\t\tscalar.x << v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x << v2.x,\n\t\t\tv1.y << v2.y,\n\t\t\tv1.z << v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x >> scalar,\n\t\t\tv.y >> scalar,\n\t\t\tv.z >> scalar);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv.x >> scalar.x,\n\t\t\tv.y >> scalar.x,\n\t\t\tv.z >> scalar.x);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar >> v.x,\n\t\t\tscalar >> v.y,\n\t\t\tscalar >> v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tscalar.x >> v.x,\n\t\t\tscalar.x >> v.y,\n\t\t\tscalar.x >> v.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\tv1.x >> v2.x,\n\t\t\tv1.y >> v2.y,\n\t\t\tv1.z >> v2.z);\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator~(tvec3<T, P> const & v)\n\t{\n\t\treturn tvec3<T, P>(\n\t\t\t~v.x,\n\t\t\t~v.y,\n\t\t\t~v.z);\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\n\t{\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);\n\t}\n\n\ttemplate <precision P>\n\tGLM_FUNC_QUALIFIER tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)\n\t{\n\t\treturn tvec3<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);\n\t}\n\n\ttemplate <precision P>\n\tGLM_FUNC_QUALIFIER tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)\n\t{\n\t\treturn tvec3<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);\n\t}\n}//namespace glm\n","/// @ref core\n/// @file glm/detail/type_mat4x4.inl\n\n#include \"func_matrix.hpp\"\n\nnamespace glm\n{\n\t// -- Constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4()\n\t\t{\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \n\t\t\t\tthis->value[0] = col_type(1, 0, 0, 0);\n\t\t\t\tthis->value[1] = col_type(0, 1, 0, 0);\n\t\t\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\t\t\tthis->value[3] = col_type(0, 0, 0, 1);\n#\t\t\tendif\n\t\t}\n#\tendif\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> const & m)\n\t\t{\n\t\t\tthis->value[0] = m[0];\n\t\t\tthis->value[1] = m[1];\n\t\t\tthis->value[2] = m[2];\n\t\t\tthis->value[3] = m[3];\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)\n\t{\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = m[2];\n\t\tthis->value[3] = m[3];\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(T const & s)\n\t{\n\t\tthis->value[0] = col_type(s, 0, 0, 0);\n\t\tthis->value[1] = col_type(0, s, 0, 0);\n\t\tthis->value[2] = col_type(0, 0, s, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\tT const & x0, T const & y0, T const & z0, T const & w0,\n\t\tT const & x1, T const & y1, T const & z1, T const & w1,\n\t\tT const & x2, T const & y2, T const & z2, T const & w2,\n\t\tT const & x3, T const & y3, T const & z3, T const & w3\n\t)\n\t{\n\t\tthis->value[0] = col_type(x0, y0, z0, w0);\n\t\tthis->value[1] = col_type(x1, y1, z1, w1);\n\t\tthis->value[2] = col_type(x2, y2, z2, w2);\n\t\tthis->value[3] = col_type(x3, y3, z3, w3);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\tcol_type const & v0,\n\t\tcol_type const & v1,\n\t\tcol_type const & v2,\n\t\tcol_type const & v3\n\t)\n\t{\n\t\tthis->value[0] = v0;\n\t\tthis->value[1] = v1;\n\t\tthis->value[2] = v2;\n\t\tthis->value[3] = v3;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\ttmat4x4<U, Q> const & m\n\t)\n\t{\n\t\tthis->value[0] = col_type(m[0]);\n\t\tthis->value[1] = col_type(m[1]);\n\t\tthis->value[2] = col_type(m[2]);\n\t\tthis->value[3] = col_type(m[3]);\n\t}\n\n\t// -- Conversions --\n\n\ttemplate <typename T, precision P> \n\ttemplate <\n\t\ttypename X1, typename Y1, typename Z1, typename W1,\n\t\ttypename X2, typename Y2, typename Z2, typename W2,\n\t\ttypename X3, typename Y3, typename Z3, typename W3,\n\t\ttypename X4, typename Y4, typename Z4, typename W4>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\tX1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,\n\t\tX2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,\n\t\tX3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,\n\t\tX4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4\n\t)\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\n\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.\");\n\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.\");\n\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.\");\n\n\t\tthis->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));\n\t\tthis->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));\n\t\tthis->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));\n\t\tthis->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));\n\t}\n\t\n\ttemplate <typename T, precision P>\n\ttemplate <typename V1, typename V2, typename V3, typename V4>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\n\t(\n\t\ttvec4<V1, P> const & v1,\n\t\ttvec4<V2, P> const & v2,\n\t\ttvec4<V3, P> const & v3,\n\t\ttvec4<V4, P> const & v4\n\t)\t\t\n\t{\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\n\n\t\tthis->value[0] = col_type(v1);\n\t\tthis->value[1] = col_type(v2);\n\t\tthis->value[2] = col_type(v3);\n\t\tthis->value[3] = col_type(v4);\n\t}\n\n\t// -- Matrix conversions --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0, 0);\n\t\tthis->value[1] = col_type(m[1], 0, 0);\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0);\n\t\tthis->value[1] = col_type(m[1], 0);\n\t\tthis->value[2] = col_type(m[2], 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0);\n\t\tthis->value[1] = col_type(m[1], 0);\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0, 0);\n\t\tthis->value[1] = col_type(m[1], 0, 0);\n\t\tthis->value[2] = col_type(m[2], 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)\n\t{\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0, 0);\n\t\tthis->value[1] = col_type(m[1], 0, 0);\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)\n\t{\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = m[2];\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)\n\t{\n\t\tthis->value[0] = col_type(m[0], 0);\n\t\tthis->value[1] = col_type(m[1], 0);\n\t\tthis->value[2] = col_type(m[2], 0);\n\t\tthis->value[3] = col_type(m[3], 1);\n\t}\n\n\t// -- Accesses --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)\n\t{\n\t\tassert(i < this->length());\n\t\treturn this->value[i];\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const\n\t{\n\t\tassert(i < this->length());\n\t\treturn this->value[i];\n\t}\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> const & m)\n\t\t{\n\t\t\t//memcpy could be faster\n\t\t\t//memcpy(&this->value, &m.value, 16 * sizeof(valType));\n\t\t\tthis->value[0] = m[0];\n\t\t\tthis->value[1] = m[1];\n\t\t\tthis->value[2] = m[2];\n\t\t\tthis->value[3] = m[3];\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P> \n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)\n\t{\n\t\t//memcpy could be faster\n\t\t//memcpy(&this->value, &m.value, 16 * sizeof(valType));\n\t\tthis->value[0] = m[0];\n\t\tthis->value[1] = m[1];\n\t\tthis->value[2] = m[2];\n\t\tthis->value[3] = m[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)\n\t{\n\t\tthis->value[0] += s;\n\t\tthis->value[1] += s;\n\t\tthis->value[2] += s;\n\t\tthis->value[3] += s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)\n\t{\n\t\tthis->value[0] += m[0];\n\t\tthis->value[1] += m[1];\n\t\tthis->value[2] += m[2];\n\t\tthis->value[3] += m[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)\n\t{\n\t\tthis->value[0] -= s;\n\t\tthis->value[1] -= s;\n\t\tthis->value[2] -= s;\n\t\tthis->value[3] -= s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)\n\t{\n\t\tthis->value[0] -= m[0];\n\t\tthis->value[1] -= m[1];\n\t\tthis->value[2] -= m[2];\n\t\tthis->value[3] -= m[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)\n\t{\n\t\tthis->value[0] *= s;\n\t\tthis->value[1] *= s;\n\t\tthis->value[2] *= s;\n\t\tthis->value[3] *= s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)\n\t{\n\t\treturn (*this = *this * m);\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)\n\t{\n\t\tthis->value[0] /= s;\n\t\tthis->value[1] /= s;\n\t\tthis->value[2] /= s;\n\t\tthis->value[3] /= s;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)\n\t{\n\t\treturn *this *= inverse(m);\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator++()\n\t{\n\t\t++this->value[0];\n\t\t++this->value[1];\n\t\t++this->value[2];\n\t\t++this->value[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator--()\n\t{\n\t\t--this->value[0];\n\t\t--this->value[1];\n\t\t--this->value[2];\n\t\t--this->value[3];\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> tmat4x4<T, P>::operator++(int)\n\t{\n\t\ttmat4x4<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> tmat4x4<T, P>::operator--(int)\n\t{\n\t\ttmat4x4<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary constant operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m)\n\t{\n\t\treturn m;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\t-m[0],\n\t\t\t-m[1],\n\t\t\t-m[2],\n\t\t\t-m[3]);\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] + s,\n\t\t\tm[1] + s,\n\t\t\tm[2] + s,\n\t\t\tm[3] + s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] + s,\n\t\t\tm[1] + s,\n\t\t\tm[2] + s,\n\t\t\tm[3] + s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm1[0] + m2[0],\n\t\t\tm1[1] + m2[1],\n\t\t\tm1[2] + m2[2],\n\t\t\tm1[3] + m2[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] - s,\n\t\t\tm[1] - s,\n\t\t\tm[2] - s,\n\t\t\tm[3] - s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\ts - m[0],\n\t\t\ts - m[1],\n\t\t\ts - m[2],\n\t\t\ts - m[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm1[0] - m2[0],\n\t\t\tm1[1] - m2[1],\n\t\t\tm1[2] - m2[2],\n\t\t\tm1[3] - m2[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const  & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] * s,\n\t\t\tm[1] * s,\n\t\t\tm[2] * s,\n\t\t\tm[3] * s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] * s,\n\t\t\tm[1] * s,\n\t\t\tm[2] * s,\n\t\t\tm[3] * s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type operator*\n\t(\n\t\ttmat4x4<T, P> const & m,\n\t\ttypename tmat4x4<T, P>::row_type const & v\n\t)\n\t{\n/*\n\t\t__m128 v0 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(0, 0, 0, 0));\n\t\t__m128 v1 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(1, 1, 1, 1));\n\t\t__m128 v2 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(2, 2, 2, 2));\n\t\t__m128 v3 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(3, 3, 3, 3));\n\n\t\t__m128 m0 = _mm_mul_ps(m[0].data, v0);\n\t\t__m128 m1 = _mm_mul_ps(m[1].data, v1);\n\t\t__m128 a0 = _mm_add_ps(m0, m1);\n\n\t\t__m128 m2 = _mm_mul_ps(m[2].data, v2);\n\t\t__m128 m3 = _mm_mul_ps(m[3].data, v3);\n\t\t__m128 a1 = _mm_add_ps(m2, m3);\n\n\t\t__m128 a2 = _mm_add_ps(a0, a1);\n\n\t\treturn typename tmat4x4<T, P>::col_type(a2);\n*/\n\n\t\ttypename tmat4x4<T, P>::col_type const Mov0(v[0]);\n\t\ttypename tmat4x4<T, P>::col_type const Mov1(v[1]);\n\t\ttypename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;\n\t\ttypename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;\n\t\ttypename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;\n\t\ttypename tmat4x4<T, P>::col_type const Mov2(v[2]);\n\t\ttypename tmat4x4<T, P>::col_type const Mov3(v[3]);\n\t\ttypename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;\n\t\ttypename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;\n\t\ttypename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;\n\t\ttypename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;\n\t\treturn Add2;\n\n/*\n\t\treturn typename tmat4x4<T, P>::col_type(\n\t\t\tm[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3],\n\t\t\tm[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3],\n\t\t\tm[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3],\n\t\t\tm[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3]);\n*/\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::row_type operator*\n\t(\n\t\ttypename tmat4x4<T, P>::col_type const & v,\n\t\ttmat4x4<T, P> const & m\n\t)\n\t{\n\t\treturn typename tmat4x4<T, P>::row_type(\n\t\t\tm[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],\n\t\t\tm[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],\n\t\t\tm[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],\n\t\t\tm[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)\n\t{\n\t\treturn tmat2x4<T, P>(\n\t\t\tm1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],\n\t\t\tm1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],\n\t\t\tm1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],\n\t\t\tm1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],\n\t\t\tm1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],\n\t\t\tm1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],\n\t\t\tm1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],\n\t\t\tm1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)\n\t{\n\t\treturn tmat3x4<T, P>(\n\t\t\tm1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],\n\t\t\tm1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],\n\t\t\tm1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],\n\t\t\tm1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],\n\t\t\tm1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],\n\t\t\tm1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],\n\t\t\tm1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],\n\t\t\tm1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],\n\t\t\tm1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],\n\t\t\tm1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],\n\t\t\tm1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],\n\t\t\tm1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\ttypename tmat4x4<T, P>::col_type const SrcA0 = m1[0];\n\t\ttypename tmat4x4<T, P>::col_type const SrcA1 = m1[1];\n\t\ttypename tmat4x4<T, P>::col_type const SrcA2 = m1[2];\n\t\ttypename tmat4x4<T, P>::col_type const SrcA3 = m1[3];\n\n\t\ttypename tmat4x4<T, P>::col_type const SrcB0 = m2[0];\n\t\ttypename tmat4x4<T, P>::col_type const SrcB1 = m2[1];\n\t\ttypename tmat4x4<T, P>::col_type const SrcB2 = m2[2];\n\t\ttypename tmat4x4<T, P>::col_type const SrcB3 = m2[3];\n\n\t\ttmat4x4<T, P> Result(uninitialize);\n\t\tResult[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];\n\t\tResult[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];\n\t\tResult[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];\n\t\tResult[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\tm[0] / s,\n\t\t\tm[1] / s,\n\t\t\tm[2] / s,\n\t\t\tm[3] / s);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(T const & s,\ttmat4x4<T, P> const & m)\n\t{\n\t\treturn tmat4x4<T, P>(\n\t\t\ts / m[0],\n\t\t\ts / m[1],\n\t\t\ts / m[2],\n\t\t\ts / m[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)\n\t{\n\t\treturn inverse(m) * v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)\n\t{\n\t\treturn v * inverse(m);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\ttmat4x4<T, P> m1_copy(m1);\n\t\treturn m1_copy /= m2;\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\n\t{\n\t\treturn (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);\n\t}\n}//namespace glm\n\n#if GLM_ARCH != GLM_ARCH_PURE\n#\tinclude \"type_mat4x4_simd.inl\"\n#endif\n","/// @ref core\n/// @file glm/detail/type_mat4x4.hpp\n\n#pragma once\n\n#include \"../fwd.hpp\"\n#include \"type_vec4.hpp\"\n#include \"type_mat.hpp\"\n#include <limits>\n#include <cstddef>\n\nnamespace glm\n{\n\ttemplate <typename T, precision P = defaultp>\n\tstruct tmat4x4\n\t{\n\t\ttypedef tvec4<T, P> col_type;\n\t\ttypedef tvec4<T, P> row_type;\n\t\ttypedef tmat4x4<T, P> type;\n\t\ttypedef tmat4x4<T, P> transpose_type;\n\t\ttypedef T value_type;\n\n\tprivate:\n\t\tcol_type value[4];\n\n\tpublic:\n\t\t// -- Constructors --\n\n\t\tGLM_FUNC_DECL tmat4x4() GLM_DEFAULT_CTOR;\n\t\tGLM_FUNC_DECL tmat4x4(tmat4x4<T, P> const & m) GLM_DEFAULT;\n\t\ttemplate <precision Q>\n\t\tGLM_FUNC_DECL tmat4x4(tmat4x4<T, Q> const & m);\n\n\t\tGLM_FUNC_DECL explicit tmat4x4(ctor);\n\t\tGLM_FUNC_DECL explicit tmat4x4(T const & x);\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\tT const & x0, T const & y0, T const & z0, T const & w0,\n\t\t\tT const & x1, T const & y1, T const & z1, T const & w1,\n\t\t\tT const & x2, T const & y2, T const & z2, T const & w2,\n\t\t\tT const & x3, T const & y3, T const & z3, T const & w3);\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\tcol_type const & v0,\n\t\t\tcol_type const & v1,\n\t\t\tcol_type const & v2,\n\t\t\tcol_type const & v3);\n\n\t\t// -- Conversions --\n\n\t\ttemplate <\n\t\t\ttypename X1, typename Y1, typename Z1, typename W1,\n\t\t\ttypename X2, typename Y2, typename Z2, typename W2,\n\t\t\ttypename X3, typename Y3, typename Z3, typename W3,\n\t\t\ttypename X4, typename Y4, typename Z4, typename W4>\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\tX1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,\n\t\t\tX2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,\n\t\t\tX3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,\n\t\t\tX4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);\n\n\t\ttemplate <typename V1, typename V2, typename V3, typename V4>\n\t\tGLM_FUNC_DECL tmat4x4(\n\t\t\ttvec4<V1, P> const & v1,\n\t\t\ttvec4<V2, P> const & v2,\n\t\t\ttvec4<V3, P> const & v3,\n\t\t\ttvec4<V4, P> const & v4);\n\n\t\t// -- Matrix conversions --\n\n\t\ttemplate <typename U, precision Q>\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x4<U, Q> const & m);\n\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat2x2<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat3x3<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat2x3<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat3x2<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat2x4<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x2<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat3x4<T, P> const & x);\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x3<T, P> const & x);\n\n\t\t// -- Accesses --\n\n\t\ttypedef length_t length_type;\n\t\tGLM_FUNC_DECL static length_type length(){return 4;}\n\n\t\tGLM_FUNC_DECL col_type & operator[](length_type i);\n\t\tGLM_FUNC_DECL col_type const & operator[](length_type i) const;\n\n\t\t// -- Unary arithmetic operators --\n\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m) GLM_DEFAULT;\n\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator+=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator-=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator*=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator/=(U s);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);\n\n\t\t// -- Increment and decrement operators --\n\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator++();\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator--();\n\t\tGLM_FUNC_DECL tmat4x4<T, P> operator++(int);\n\t\tGLM_FUNC_DECL tmat4x4<T, P> operator--(int);\n\t};\n\n\t// -- Unary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m);\n\n\t// -- Binary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1,\ttmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1,\ttmat4x4<T, P> const & m2);\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\n}//namespace glm\n\n#ifndef GLM_EXTERNAL_TEMPLATE\n#include \"type_mat4x4.inl\"\n#endif//GLM_EXTERNAL_TEMPLATE\n","#define _CRT_SECURE_NO_WARNINGS 1\r\n#define WIN32_LEAN_AND_MEAN 1\r\n#define VC_EXTRALEAN 1\r\n\r\n#include <stdio.h>\r\n#include <SDL2/SDL.h>\r\n\r\n#ifndef __EMSCRIPTEN__\r\n#include <windows.h>\r\n#include <sys/stat.h>\r\n#else\r\n#include <math.h>\r\n#include <GLES3/gl3.h>\r\n#include <GLES3/gl2ext.h>\r\n#endif\r\n\r\n#include <chrono>\r\n#include \"platform.h\"\r\n\r\nstruct ApplicationFunctions\r\n{\r\n\tinit_game*   gameInitPtr;\r\n\tupdate_Game* gameUpdatePtr;\r\n\tdraw_Game*   gameDrawPtr;\r\n\tvoid*        handle;\r\n\ttime_t       lastWriteTime;\r\n\r\n\tchar initName[64];\r\n\tchar updateName[64];\r\n\tchar drawName[64];\r\n\r\n\tchar   name[64];\r\n};\r\n\r\n\r\n// #include <glad/glad.h> #include \"glad.c\"\r\n\r\n\r\n#ifndef __EMSCRIPTEN__\r\n#include \"hotreload.cpp\" // must be after appfuncs\r\n#include \"Imgui/imgui.h\"\r\n#include \"Imgui/imgui_demo.cpp\"\r\n#include \"Imgui/imgui_impl_sdl_gl3.cpp\"\r\n#include \"glad/glad.h\"\r\n#include \"glad.c\"\r\n#else\r\n#include <emscripten.h>\r\n#include <functional>\r\n\r\n#include \"application/game.cpp\"\r\n#include \"graphics/graphics.cpp\"\r\n\r\nstd::function<void()> loop;\r\nstatic void main_loop() { loop(); }\r\n#endif\r\n\r\n\r\n\r\n\r\n#ifndef __EMSCRIPTEN__\r\nint main(int argc, char* argv[])\r\n#else\r\nextern \"C\" int mainf()\r\n#endif\r\n{\r\n\tSDL_Init(SDL_INIT_EVERYTHING);\r\n\r\n\r\n\tconst char* windowName = \"hello sdl\";\r\n\tint width = 1024; int height = 860;\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_PROFILE_CORE);\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\r\n\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);\r\n\tSDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\r\n\tSDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\r\n\tSDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\r\n#else\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\r\n\tSDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);\r\n\r\n\tSDL_GL_SetAttribute(SDL_GL_RED_SIZE, 2);\r\n\tSDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 3);\r\n\tSDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 2);\r\n\tSDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 2);\r\n#endif\r\n#ifdef DEBUG_OPENGL\r\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG);\r\n#endif\r\n\tUint32 flags = SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE;\r\n#ifdef __EMSCRIPTEN__\r\n\tSDL_Window* window = SDL_CreateWindow(windowName, 0, 0, width, height, flags);\r\n#else\r\n\tSDL_Window* window = SDL_CreateWindow(windowName, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, flags);\r\n#endif\r\n\r\n\tif (!window)\r\n\t{\r\n\t\t// debugBreak();\r\n\t\tprintf(\"failed to window \\n\");\r\n\t\t// std::terminate();\r\n\t\treturn false;\r\n\t}\r\n\r\n\tSDL_GLContext glContex = SDL_GL_CreateContext(window);\r\n\r\n\t// auto rdr = SDL_CreateRenderer(wnd, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);\r\n\r\n\tif (!glContex)\r\n\t{\r\n\t\t// debugBreak();\r\n\t\tprintf(\"failed to context \\n\");\r\n\t\t// std::terminate();\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tSDL_GL_MakeCurrent(window, glContex);\r\n\tSDL_GL_SetSwapInterval(0);\r\n\r\n\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\tif (!gladLoadGL())\r\n\t{\r\n\t\tprintf(\"failed to initaliaze GLAD\\n\");\r\n\t\tASSERT(false);\r\n\t}\r\n#endif\r\n\r\n\tbool quit = false;\r\n\r\n\tApplicationFunctions app = { };\r\n#ifndef __EMSCRIPTEN__\r\n\tinitializeApplication(&app, \"game\", \"initGame\", \"updateGame\", \"drawGame\");\r\n#endif\r\n\r\n\tApplicationFunctions graphics = { };\r\n#ifndef __EMSCRIPTEN__\r\n\tinitializeApplication(&graphics, \"graphics\", \"initGraphics\", \"updateGraphics\", \"drawGraphics\");\r\n#endif\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\tapp.gameInitPtr = initGame;\r\n\tapp.gameUpdatePtr = updateGame;\r\n\tapp.gameDrawPtr = drawGame;\r\n\r\n\tapp.gameInitPtr = initGraphics;\r\n\tapp.gameUpdatePtr = updateGraphics;\r\n\tapp.gameDrawPtr = drawGraphics;\r\n#endif\r\n\r\n\r\n\tEngineContext engine = { };\r\n\tengine.windowDims.x = (float)width;\r\n\tengine.windowDims.y = (float)height;\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\tImGui_ImplSdlGL3_Init(window);\r\n\tbool show_demo_window = true;\r\n\r\n\tengine.imguiContext = (void*)ImGui::GetCurrentContext();\r\n#endif\r\n\r\n\tif (app.gameInitPtr)\r\n\t{\r\n\t\tapp.gameInitPtr(&engine);\r\n\t}\r\n\r\n\tif (graphics.gameDrawPtr)\r\n\t{\r\n\t\tgraphics.gameInitPtr(&engine);\r\n\t}\r\n\r\n\r\n\tfloat dt = 0.f;\r\n#ifndef __EMSCRIPTEN__\r\n\twhile (!quit) {\r\n#else\r\n\tloop = [&] {\r\n#endif\r\n\t\tauto timePoint1(std::chrono::high_resolution_clock::now());\r\n\r\n\t\tSDL_Event e;\r\n\t\twhile (SDL_PollEvent(&e))\r\n\t\t{\r\n#ifndef __EMSCRIPTEN__\r\n\t\t\tImGui_ImplSdlGL3_ProcessEvent(&e);\r\n#endif\r\n\r\n\t\t\tswitch (e.type)\r\n\t\t\t{\r\n\t\t\tcase SDL_QUIT:\r\n\t\t\t{\r\n\t\t\t\tquit = true;\r\n\t\t\t} break;\r\n\t\t\tcase SDL_KEYDOWN:\r\n\t\t\tcase SDL_KEYUP:\r\n\t\t\t{\r\n\t\t\t\tbool down = e.key.state;\r\n\r\n\t\t\t\tswitch (e.key.keysym.scancode)\r\n\t\t\t\t{\r\n\t\t\t\tcase SDL_SCANCODE_W:\r\n\t\t\t\t\tengine.controller.cameraMovement[0] = down; break;\r\n\t\t\t\tcase SDL_SCANCODE_A:\r\n\t\t\t\t\tengine.controller.cameraMovement[1] = down; break;\r\n\t\t\t\tcase SDL_SCANCODE_S:\r\n\t\t\t\t\tengine.controller.cameraMovement[2] = down; break;\r\n\t\t\t\tcase SDL_SCANCODE_D:\r\n\t\t\t\t\tengine.controller.cameraMovement[3] = down; break;\r\n\t\t\t\tcase SDL_SCANCODE_LCTRL:\r\n\t\t\t\t\tengine.controller.cameraMovement[4] = down; break;\r\n\t\t\t\tcase SDL_SCANCODE_Q:\r\n\t\t\t\t\tengine.controller.cameraMovement[5] = down; break;\r\n\t\t\t\tcase SDL_SCANCODE_E:\r\n\t\t\t\t\tengine.controller.cameraMovement[6] = down; break;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tImGui_ImplSdlGL3_NewFrame(window);\r\n\r\n\t\tif (ImGui::Button(\"Demo Window\"))                       // Use buttons to toggle our bools. We could use Checkbox() as well.\r\n\t\t\tshow_demo_window ^= 1;\r\n\r\n\t\tif (show_demo_window)\r\n\t\t{\r\n\t\t\tImGui::SetNextWindowPos(ImVec2(650, 20), ImGuiCond_FirstUseEver); // Normally user code doesn't need/want to call this because positions are saved in .ini file anyway. Here we just want to make the demo initial state a bit more friendly!\r\n\t\t\tImGui::ShowDemoWindow(&show_demo_window);\r\n\t\t}\r\n\r\n\t\tImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\r\n\t\tImGui::Text(\"hello world\");\r\n\r\n\t\tupdate(&app);\r\n\t\tupdate(&graphics);\r\n#endif\r\n\r\n\t\tif (app.gameUpdatePtr)\r\n\t\t{\r\n\t\t\tapp.gameUpdatePtr(&engine);\r\n\t\t}\r\n\r\n\t\tif (app.gameDrawPtr)\r\n\t\t{\r\n\t\t\tapp.gameDrawPtr(&engine);\r\n\t\t}\r\n\r\n\t\tif (graphics.gameUpdatePtr)\r\n\t\t{\r\n\t\t\tgraphics.gameDrawPtr(&engine);\r\n\t\t}\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tImGui::Render();\r\n#endif\r\n\r\n\t\tSDL_GL_SwapWindow(window);\r\n\r\n\t\tauto timePoint2(std::chrono::high_resolution_clock::now());\r\n\t\tauto elapsedTime(timePoint2 - timePoint1);\r\n\t\tfloat ft = { std::chrono::duration_cast<std::chrono::duration<float, std::milli>>(elapsedTime).count() };\r\n\t\tdt = ft;\r\n\t\tfloat ftSeconds = (ft / 1000.f);\r\n\t\tengine.dt = ftSeconds;\r\n\t};\r\n\r\n#if __EMSCRIPTEN__\r\n\temscripten_set_main_loop(main_loop, 0, true);\r\n#else\r\n\treturn 0;\r\n#endif\r\n\r\n\treturn 0;\r\n}\r\n\r\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);                 // Removed in C++17\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))\n    -> decltype        (- _VSTD::forward<_Tp>(__x))\n        { return        - _VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))\n    -> decltype        (!_VSTD::forward<_Tp>(__x))\n        { return        !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))\n    -> decltype        (~_VSTD::forward<_Tp>(__x))\n        { return        ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                MEMFUN\n//==============================================================================\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm) _NOEXCEPT\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                FUNCTION\n//==============================================================================\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\ntemplate<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp const&) { return true; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp* __ptr) { return __ptr; }\n\ntemplate <class _Ret, class _Class>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Ret _Class::*__ptr) { return __ptr; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(function<_Fp> const& __f) { return !!__f; }\n\n} // namespace __function\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\nnamespace __function {\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n    return _Invoker::__call(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    _LIBCPP_NO_CFI static __base *__as_base(void *p) {\n      return reinterpret_cast<__base*>(p);\n    }\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value = is_same<void, _Rp>::value ||\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp>\n      function(_Fp, typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                      >::type* = 0);\n\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f,\n               typename enable_if<__callable<_Fp>::value>::type* = 0);\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n#endif\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f,\n                                     typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                     >::type*)\n    : __f_(0)\n{\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,\n                                     typename enable_if<__callable<_Fp>::value>::type*)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = __as_base(&__tempbuf);\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = __as_base(&__buf_);\n        __t->__clone(__as_base(&__f.__buf_));\n        __t->destroy();\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f_ == &__buf_)\n    {\n        __f_->__clone(__as_base(&__f.__buf_));\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = __as_base(&__buf_);\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__f_ == 0)\n        throw bad_function_call();\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\n#else // _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n//                                  BIND\n//==============================================================================\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n_LIBCPP_FUNC_VIS extern __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern __ph<10> _10;\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __lazy_enable_if\n<\n    is_bind_expression<_Ti>::value,\n    __invoke_of<_Ti&, _Uj...>\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(const __bind& __b)\n        : __f_(__b.__f_),\n          __bound_args_(__b.__bound_args_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(const __bind& __b)\n    {\n        __f_ = __b.__f_;\n        __bound_args_ = __b.__bound_args_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(__bind&& __b)\n        : __f_(_VSTD::move(__b.__f_)),\n          __bound_args_(_VSTD::move(__b.__bound_args_)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(__bind&& __b)\n    {\n        __f_ = _VSTD::move(__b.__f_);\n        __bound_args_ = _VSTD::move(__b.__bound_args_);\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(const __bind_r& __b)\n        : base(_VSTD::forward<const base&>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(const __bind_r& __b)\n    {\n        base::operator=(_VSTD::forward<const base&>(__b));\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(__bind_r&& __b)\n        : base(_VSTD::forward<base>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(__bind_r&& __b)\n    {\n        base::operator=(_VSTD::forward<base>(__b));\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_INT128\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<__int128_t>\n    : public __scalar_hash<__int128_t>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<__uint128_t>\n    : public __scalar_hash<__uint128_t>\n{\n};\n\n#endif\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__s.__c = 0;\n        __u.__s.__d = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash\n    : public unary_function<_Tp, size_t>\n{\n    static_assert(is_enum<_Tp>::value, \"This hash only works for enumeration types\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Fn, class ..._Args>\nresult_of_t<_Fn&&(_Args&&...)>\ninvoke(_Fn&& __f, _Args&&... __args) {\n    return __invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);\n}\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif defined(__sun__)\n# include <xlocale.h>\n# include <support/solaris/xlocale.h>\n#elif defined(_NEWLIB_VERSION)\n# include <support/newlib/xlocale.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#elif defined(_LIBCPP_HAS_MUSL_LIBC)\n# include <support/musl/xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#if defined(__GLIBC__)\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n# ifdef __APPLE__\n    typedef __uint32_t mask;\n# elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n    typedef unsigned short mask;\n# endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#elif defined(_NEWLIB_VERSION)\n    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.\n    typedef char mask;\n    static const mask space  = _S;\n    static const mask print  = _P | _U | _L | _N | _B;\n    static const mask cntrl  = _C;\n    static const mask upper  = _U;\n    static const mask lower  = _L;\n    static const mask alpha  = _U | _L;\n    static const mask digit  = _N;\n    static const mask punct  = _P;\n    static const mask xdigit = _X | _N;\n    static const mask blank  = _B;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT\n#else\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS_ONLY codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _LIBCPP_EXPLICIT_MOVE(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 \npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return make_pair(__last1, __last1);\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return make_pair(__first1, __first1 + __len2);\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff), \n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n#ifndef __sun__\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !defined(_AIX)\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\n#endif // __sun__\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n#ifndef __sun__\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n#endif // __sun__\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","/// @ref core\n/// @file glm/detail/type_tvec4.inl\n\nnamespace glm{\nnamespace detail\n{\n\ttemplate <typename T>\n\tstruct is_int\n\t{\n\t\tenum test {value = 0};\n\t};\n\n\ttemplate <>\n\tstruct is_int<uint32>\n\t{\n\t\tenum test {value = ~0};\n\t};\n\n\ttemplate <>\n\tstruct is_int<int32>\n\t{\n\t\tenum test {value = ~0};\n\t};\n\n\ttemplate <>\n\tstruct is_int<uint64>\n\t{\n\t\tenum test {value = ~0};\n\t};\n\n\ttemplate <>\n\tstruct is_int<int64>\n\t{\n\t\tenum test {value = ~0};\n\t};\n\n\ttemplate <typename T, precision P, bool Aligned>\n\tstruct compute_vec4_add\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, bool Aligned>\n\tstruct compute_vec4_sub\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, bool Aligned>\n\tstruct compute_vec4_mul\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, bool Aligned>\n\tstruct compute_vec4_div\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, bool Aligned>\n\tstruct compute_vec4_mod\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_and\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_or\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_xor\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_shift_left\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_shift_right\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\n\t\t{\n\t\t\treturn tvec4<T, P>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_equal\n\t{\n\t\tGLM_FUNC_QUALIFIER static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t\t{\n\t\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_nequal\n\t{\n\t\tGLM_FUNC_QUALIFIER static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t\t{\n\t\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);\n\t\t}\n\t};\n\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\n\tstruct compute_vec4_bitwise_not\n\t{\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & v)\n\t\t{\n\t\t\treturn tvec4<T, P>(~v.x, ~v.y, ~v.z, ~v.w);\n\t\t}\n\t};\n}//namespace detail\n\n\t// -- Implicit basic constructors --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4()\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT\n\t\t\t\t: x(0), y(0), z(0), w(0)\n#\t\t\tendif\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(tvec4<T, P> const & v)\n\t\t\t: x(v.x), y(v.y), z(v.z), w(v.w)\n\t\t{}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(tvec4<T, Q> const & v)\n\t\t: x(v.x), y(v.y), z(v.z), w(v.w)\n\t{}\n\n\t// -- Explicit basic constructors --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(ctor)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(T scalar)\n\t\t: x(scalar), y(scalar), z(scalar), w(scalar)\n\t{}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(T a, T b, T c, T d)\n\t\t: x(a), y(b), z(c), w(d)\n\t{}\n\n\t// -- Conversion scalar constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, typename D>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(A a, B b, C c, D d) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b)),\n\t\tz(static_cast<T>(c)),\n\t\tw(static_cast<T>(d))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, typename D>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(c.x)),\n\t\tw(static_cast<T>(d.x))\n\t{}\n\n\t// -- Conversion vector constructors --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b)),\n\t\tw(static_cast<T>(c))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b.x)),\n\t\tw(static_cast<T>(c.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :\n\t\tx(static_cast<T>(s1)),\n\t\ty(static_cast<T>(v.x)),\n\t\tz(static_cast<T>(v.y)),\n\t\tw(static_cast<T>(s2))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y)),\n\t\tw(static_cast<T>(c.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :\n\t\tx(static_cast<T>(s1)),\n\t\ty(static_cast<T>(s2)),\n\t\tz(static_cast<T>(v.x)),\n\t\tw(static_cast<T>(v.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, typename C, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(c.x)),\n\t\tw(static_cast<T>(c.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(a.z)),\n\t\tw(static_cast<T>(b))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(a.z)),\n\t\tw(static_cast<T>(b.x))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :\n\t\tx(static_cast<T>(a)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y)),\n\t\tw(static_cast<T>(b.z))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(b.x)),\n\t\tz(static_cast<T>(b.y)),\n\t\tw(static_cast<T>(b.z))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename A, typename B, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :\n\t\tx(static_cast<T>(a.x)),\n\t\ty(static_cast<T>(a.y)),\n\t\tz(static_cast<T>(b.x)),\n\t\tw(static_cast<T>(b.y))\n\t{}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U, precision Q>\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :\n\t\tx(static_cast<T>(v.x)),\n\t\ty(static_cast<T>(v.y)),\n\t\tz(static_cast<T>(v.z)),\n\t\tw(static_cast<T>(v.w))\n\t{}\n\n\t// -- Component accesses --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)\n\t{\n\t\tassert(i >= 0 && i < this->length());\n\t\treturn (&x)[i];\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const\n\t{\n\t\tassert(i >= 0 && i < this->length());\n\t\treturn (&x)[i];\n\t}\n\n\t// -- Unary arithmetic operators --\n\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\n\t\ttemplate <typename T, precision P>\n\t\tGLM_FUNC_QUALIFIER tvec4<T, P>& tvec4<T, P>::operator=(tvec4<T, P> const & v)\n\t\t{\n\t\t\tthis->x = v.x;\n\t\t\tthis->y = v.y;\n\t\t\tthis->z = v.z;\n\t\t\tthis->w = v.w;\n\t\t\treturn *this;\n\t\t}\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P>& tvec4<T, P>::operator=(tvec4<U, P> const & v)\n\t{\n\t\tthis->x = static_cast<T>(v.x);\n\t\tthis->y = static_cast<T>(v.y);\n\t\tthis->z = static_cast<T>(v.z);\n\t\tthis->w = static_cast<T>(v.w);\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\t// -- Increment and decrement operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator++()\n\t{\n\t\t++this->x;\n\t\t++this->y;\n\t\t++this->z;\n\t\t++this->w;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator--()\n\t{\n\t\t--this->x;\n\t\t--this->y;\n\t\t--this->z;\n\t\t--this->w;\n\t\treturn *this;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> tvec4<T, P>::operator++(int)\n\t{\n\t\ttvec4<T, P> Result(*this);\n\t\t++*this;\n\t\treturn Result;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> tvec4<T, P>::operator--(int)\n\t{\n\t\ttvec4<T, P> Result(*this);\n\t\t--*this;\n\t\treturn Result;\n\t}\n\n\t// -- Unary bit operators --\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const& v)\n\t{\n\t\treturn (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const& v)\n\t{\n\t\treturn (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)\n\t{\n\t\treturn (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\ttemplate <typename T, precision P>\n\ttemplate <typename U> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)\n\t{\n\t\treturn (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\n\t}\n\n\t// -- Unary constant operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v)\n\t{\n\t\treturn v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(0) -= v;\n\t}\n\n\t// -- Binary arithmetic operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) += scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) += v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(v) += scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v2) += v1;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) += v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) -= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) -= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) -= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) -= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) -= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) *= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) *= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(v) *= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v2) *= v1;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) *= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) /= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) /= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) /= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) /= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) /= v2;\n\t}\n\n\t// -- Binary bit operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) %= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) %= v2.x;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) %= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar.x) %= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) %= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) &= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\n\t{\n\t\treturn tvec4<T, P>(v) &= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) &= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) &= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) &= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) |= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) |= v2.x;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) |= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) |= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) |= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) ^= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) ^= v2.x;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) ^= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) ^= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) ^= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) <<= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) <<= v2.x;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) <<= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) <<= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) <<= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)\n\t{\n\t\treturn tvec4<T, P>(v) >>= scalar;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) >>= v2.x;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)\n\t{\n\t\treturn tvec4<T, P>(scalar) >>= v;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1.x) >>= v2;\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn tvec4<T, P>(v1) >>= v2;\n\t}\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator~(tvec4<T, P> const & v)\n\t{\n\t\treturn detail::compute_vec4_bitwise_not<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v);\n\t}\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn detail::compute_vec4_equal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);\n\t}\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\n\t{\n\t\treturn detail::compute_vec4_nequal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);\n\t}\n\n\ttemplate <precision P>\n\tGLM_FUNC_QUALIFIER tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)\n\t{\n\t\treturn tvec4<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);\n\t}\n\n\ttemplate <precision P>\n\tGLM_FUNC_QUALIFIER tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)\n\t{\n\t\treturn tvec4<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);\n\t}\n}//namespace glm\n\n#if GLM_ARCH != GLM_ARCH_PURE && GLM_HAS_ALIGNED_TYPE\n#\tinclude \"type_vec4_simd.inl\"\n#endif\n","/// @ref gtc_type_ptr\n/// @file glm/gtc/type_ptr.inl\n\n#include <cstring>\n\nnamespace glm\n{\n\t/// @addtogroup gtc_type_ptr\n\t/// @{\n\n\t/// Return the constant address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttvec2<T, P> const & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t//! Return the address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttvec2<T, P> & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t/// Return the constant address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttvec3<T, P> const & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t//! Return the address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttvec3<T, P> & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the vector input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\t\n\t\ttvec4<T, P> const & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t//! Return the address to the data of the vector input.\n\t//! From GLM_GTC_type_ptr extension.\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\t\n\t\ttvec4<T, P> & vec\n\t)\n\t{\n\t\treturn &(vec.x);\n\t}\n\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat2x2<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat2x2<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat3x3<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat3x3<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat4x4<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t//! From GLM_GTC_type_ptr extension.\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat4x4<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat2x3<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat2x3<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat3x2<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat3x2<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat2x4<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat2x4<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat4x2<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\t\n\t\ttmat4x2<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat3x4<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t//! Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttmat3x4<T, P> & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\t\t\n\t/// Return the constant address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttmat4x3<T, P> const & mat\n\t)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t/// Return the address to the data of the matrix input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr(tmat4x3<T, P> & mat)\n\t{\n\t\treturn &(mat[0].x);\n\t}\n\n\t/// Return the constant address to the data of the input parameter.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T const * value_ptr\n\t(\n\t\ttquat<T, P> const & q\n\t)\n\t{\n\t\treturn &(q[0]);\n\t}\n\n\t/// Return the address to the data of the quaternion input.\n\t/// @see gtc_type_ptr\n\ttemplate<typename T, precision P>\n\tGLM_FUNC_QUALIFIER T * value_ptr\n\t(\n\t\ttquat<T, P> & q\n\t)\n\t{\n\t\treturn &(q[0]);\n\t}\n\n\t/// Build a vector from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tvec2<T, defaultp> make_vec2(T const * const ptr)\n\t{\n\t\ttvec2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a vector from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tvec3<T, defaultp> make_vec3(T const * const ptr)\n\t{\n\t\ttvec3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a vector from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tvec4<T, defaultp> make_vec4(T const * const ptr)\n\t{\n\t\ttvec4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)\n\t{\n\t\ttmat2x2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)\n\t{\n\t\ttmat2x3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)\n\t{\n\t\ttmat2x4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)\n\t{\n\t\ttmat3x2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)\n\t{\n\t\ttmat3x3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)\n\t{\n\t\ttmat3x4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)\n\t{\n\t\ttmat4x2<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)\n\t{\n\t\ttmat4x3<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)\n\t{\n\t\ttmat4x4<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat2x2<T, defaultp> make_mat2(T const * const ptr)\n\t{\n\t\treturn make_mat2x2(ptr);\n\t}\n\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat3x3<T, defaultp> make_mat3(T const * const ptr)\n\t{\n\t\treturn make_mat3x3(ptr);\n\t}\n\t\t\n\t//! Build a matrix from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> make_mat4(T const * const ptr)\n\t{\n\t\treturn make_mat4x4(ptr);\n\t}\n\n\t//! Build a quaternion from a pointer.\n\t/// @see gtc_type_ptr\n\ttemplate <typename T>\n\tGLM_FUNC_QUALIFIER tquat<T, defaultp> make_quat(T const * const ptr)\n\t{\n\t\ttquat<T, defaultp> Result;\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));\n\t\treturn Result;\n\t}\n\n\t/// @}\n}//namespace glm\n\n","// -*- C++ -*-\n//===-------------------------- exception ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_EXCEPTION\n#define _LIBCPP_EXCEPTION\n\n/*\n    exception synopsis\n\nnamespace std\n{\n\nclass exception\n{\npublic:\n    exception() noexcept;\n    exception(const exception&) noexcept;\n    exception& operator=(const exception&) noexcept;\n    virtual ~exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_exception\n    : public exception\n{\npublic:\n    bad_exception() noexcept;\n    bad_exception(const bad_exception&) noexcept;\n    bad_exception& operator=(const bad_exception&) noexcept;\n    virtual ~bad_exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\ntypedef void (*unexpected_handler)();\nunexpected_handler set_unexpected(unexpected_handler  f ) noexcept;\nunexpected_handler get_unexpected() noexcept;\n[[noreturn]] void unexpected();\n\ntypedef void (*terminate_handler)();\nterminate_handler set_terminate(terminate_handler  f ) noexcept;\nterminate_handler get_terminate() noexcept;\n[[noreturn]] void terminate() noexcept;\n\nbool uncaught_exception()  noexcept;\nint  uncaught_exceptions() noexcept;  // C++17\n\ntypedef unspecified exception_ptr;\n\nexception_ptr current_exception() noexcept;\nvoid rethrow_exception [[noreturn]] (exception_ptr p);\ntemplate<class E> exception_ptr make_exception_ptr(E e) noexcept;\n\nclass nested_exception\n{\npublic:\n    nested_exception() noexcept;\n    nested_exception(const nested_exception&) noexcept = default;\n    nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() = default;\n\n    // access functions\n    [[noreturn]] void rethrow_nested() const;\n    exception_ptr nested_ptr() const noexcept;\n};\n\ntemplate <class T> [[noreturn]] void throw_with_nested(T&& t);\ntemplate <class E> void rethrow_if_nested(const E& e);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}\n    virtual ~exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_exception\n    : public exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}\n    virtual ~bad_exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\ntypedef void (*unexpected_handler)();\n_LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();\n\ntypedef void (*terminate_handler)();\n_LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;\n\n_LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;\n_LIBCPP_FUNC_VIS int uncaught_exceptions() _NOEXCEPT;\n\nclass _LIBCPP_TYPE_VIS exception_ptr;\n\n_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n\nclass _LIBCPP_TYPE_VIS exception_ptr\n{\n    void* __ptr_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}\n    _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}\n    exception_ptr(const exception_ptr&) _NOEXCEPT;\n    exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;\n    ~exception_ptr() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT\n        operator bool() const _NOEXCEPT {return __ptr_ != nullptr;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return !(__x == __y);}\n\n    friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n    friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n};\n\ntemplate<class _Ep>\nexception_ptr\nmake_exception_ptr(_Ep __e) _NOEXCEPT\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n        throw __e;\n    }\n    catch (...)\n    {\n        return current_exception();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\n// nested_exception\n\nclass _LIBCPP_EXCEPTION_ABI nested_exception\n{\n    exception_ptr __ptr_;\npublic:\n    nested_exception() _NOEXCEPT;\n//     nested_exception(const nested_exception&) noexcept = default;\n//     nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() _NOEXCEPT;\n\n    // access functions\n    _LIBCPP_NORETURN void rethrow_nested() const;\n    _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}\n};\n\ntemplate <class _Tp>\nstruct __nested\n    : public _Tp,\n      public nested_exception\n{\n    _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}\n};\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  is_class<typename remove_reference<_Tp>::type>::value &&\n                  !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                  && !__libcpp_is_final<typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw __nested<typename remove_reference<_Tp>::type>(_VSTD::forward<_Tp>(__t));\n#endif\n}\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  !is_class<typename remove_reference<_Tp>::type>::value ||\n                  is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                  || __libcpp_is_final<typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw _VSTD::forward<_Tp>(__t);\n#endif\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep& __e, typename enable_if<\n                                   is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n    const nested_exception* __nep = dynamic_cast<const nested_exception*>(_VSTD::addressof(__e));\n    if (__nep)\n        __nep->rethrow_nested();\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep&, typename enable_if<\n                                   !is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n}\n\n}  // std\n\n#endif  // _LIBCPP_EXCEPTION\n","/// @ref core\n/// @file glm/detail/type_vec4.hpp\n\n#pragma once\n\n#include \"type_vec.hpp\"\n#if GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n#\tif GLM_HAS_UNRESTRICTED_UNIONS\n#\t\tinclude \"_swizzle.hpp\"\n#\telse\n#\t\tinclude \"_swizzle_func.hpp\"\n#\tendif\n#endif //GLM_SWIZZLE\n#include <cstddef>\n\nnamespace glm\n{\n\ttemplate <typename T, precision P = defaultp>\n\tstruct tvec4\n\t{\n\t\t// -- Implementation detail --\n\n\t\ttypedef T value_type;\n\t\ttypedef tvec4<T, P> type;\n\t\ttypedef tvec4<bool, P> bool_type;\n\n\t\t// -- Data --\n\n#\t\tif GLM_HAS_ONLY_XYZW\n\t\t\tT x, y, z, w;\n\n#\t\telif GLM_HAS_ALIGNED_TYPE\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\t\t\tpragma GCC diagnostic push\n#\t\t\t\tpragma GCC diagnostic ignored \"-Wpedantic\"\n#\t\t\tendif\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\n#\t\t\t\tpragma clang diagnostic push\n#\t\t\t\tpragma clang diagnostic ignored \"-Wgnu-anonymous-struct\"\n#\t\t\t\tpragma clang diagnostic ignored \"-Wnested-anon-types\"\n#\t\t\tendif\n\n\t\t\tunion\n\t\t\t{\n\t\t\t\tstruct { T x, y, z, w;};\n\t\t\t\tstruct { T r, g, b, a; };\n\t\t\t\tstruct { T s, t, p, q; };\n\n\t\t\t\ttypename detail::storage<T, sizeof(T) * 4, detail::is_aligned<P>::value>::type data;\n\n#\t\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n\t\t\t\t\t_GLM_SWIZZLE4_2_MEMBERS(T, P, glm::tvec2, x, y, z, w)\n\t\t\t\t\t_GLM_SWIZZLE4_2_MEMBERS(T, P, glm::tvec2, r, g, b, a)\n\t\t\t\t\t_GLM_SWIZZLE4_2_MEMBERS(T, P, glm::tvec2, s, t, p, q)\n\t\t\t\t\t_GLM_SWIZZLE4_3_MEMBERS(T, P, glm::tvec3, x, y, z, w)\n\t\t\t\t\t_GLM_SWIZZLE4_3_MEMBERS(T, P, glm::tvec3, r, g, b, a)\n\t\t\t\t\t_GLM_SWIZZLE4_3_MEMBERS(T, P, glm::tvec3, s, t, p, q)\n\t\t\t\t\t_GLM_SWIZZLE4_4_MEMBERS(T, P, glm::tvec4, x, y, z, w)\n\t\t\t\t\t_GLM_SWIZZLE4_4_MEMBERS(T, P, glm::tvec4, r, g, b, a)\n\t\t\t\t\t_GLM_SWIZZLE4_4_MEMBERS(T, P, glm::tvec4, s, t, p, q)\n#\t\t\t\tendif//GLM_SWIZZLE\n\t\t\t};\n\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\n#\t\t\t\tpragma clang diagnostic pop\n#\t\t\tendif\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\t\t\tpragma GCC diagnostic pop\n#\t\t\tendif\n#\t\telse\n\t\t\tunion { T x, r, s; };\n\t\t\tunion { T y, g, t; };\n\t\t\tunion { T z, b, p; };\n\t\t\tunion { T w, a, q; };\n\n#\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n\t\t\t\tGLM_SWIZZLE_GEN_VEC_FROM_VEC4(T, P, tvec4, tvec2, tvec3, tvec4)\n#\t\t\tendif//GLM_SWIZZLE\n#\t\tendif\n\n\t\t// -- Component accesses --\n\n\t\t/// Return the count of components of the vector\n\t\ttypedef length_t length_type;\n\t\tGLM_FUNC_DECL static length_type length(){return 4;}\n\n\t\tGLM_FUNC_DECL T & operator[](length_type i);\n\t\tGLM_FUNC_DECL T const & operator[](length_type i) const;\n\n\t\t// -- Implicit basic constructors --\n\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4() GLM_DEFAULT_CTOR;\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(tvec4<T, P> const& v) GLM_DEFAULT;\n\t\ttemplate <precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(tvec4<T, Q> const& v);\n\n\t\t// -- Explicit basic constructors --\n\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD explicit tvec4(ctor);\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD explicit tvec4(T scalar);\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(T a, T b, T c, T d);\n\n\t\t// -- Conversion scalar constructors --\n\n\t\t/// Explicit converions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, typename D>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(A a, B b, C c, D d);\n\t\ttemplate <typename A, typename B, typename C, typename D>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, P> const& a, tvec1<B, P> const& b, tvec1<C, P> const& c, tvec1<D, P> const& d);\n\n\t\t// -- Conversion vector constructors --\n\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec2<A, Q> const & a, B b, C c);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(A a, tvec2<B, Q> const & b, C c);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(A a, B b, tvec2<C, Q> const & c);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec3<A, Q> const & a, B b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(A a, tvec3<B, Q> const & b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);\n\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename U, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR GLM_EXPLICIT tvec4(tvec4<U, Q> const& v);\n\n\t\t// -- Swizzle constructors --\n#\t\tif GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\n\t\t\ttemplate <int E0, int E1, int E2, int E3>\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<4, T, P, glm::tvec4, E0, E1, E2, E3> const & that)\n\t\t\t{\n\t\t\t\t*this = that();\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1, int F0, int F1>\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, detail::_swizzle<2, T, P, glm::tvec2, F0, F1, -1, -2> const & u)\n\t\t\t{\n\t\t\t\t*this = tvec4<T, P>(v(), u());\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1>\n\t\t\tGLM_FUNC_DECL tvec4(T const & x, T const & y, detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v)\n\t\t\t{\n\t\t\t\t*this = tvec4<T, P>(x, y, v());\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1>\n\t\t\tGLM_FUNC_DECL tvec4(T const & x, detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, T const & w)\n\t\t\t{\n\t\t\t\t*this = tvec4<T, P>(x, v(), w);\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1>\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, T const & z, T const & w)\n\t\t\t{\n\t\t\t\t*this = tvec4<T, P>(v(), z, w);\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1, int E2>\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<3, T, P, glm::tvec3, E0, E1, E2, -1> const & v, T const & w)\n\t\t\t{\n\t\t\t\t*this = tvec4<T, P>(v(), w);\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1, int E2>\n\t\t\tGLM_FUNC_DECL tvec4(T const & x, detail::_swizzle<3, T, P, glm::tvec3, E0, E1, E2, -1> const & v)\n\t\t\t{\n\t\t\t\t*this = tvec4<T, P>(x, v());\n\t\t\t}\n#\t\tendif// GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\n\n\t\t// -- Unary arithmetic operators --\n\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator=(tvec4<T, P> const & v) GLM_DEFAULT;\n\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator+=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator+=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator+=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator-=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator-=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator-=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator*=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator*=(tvec1<U, P> const& v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator*=(tvec4<U, P> const& v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator/=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator/=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator/=(tvec4<U, P> const & v);\n\n\t\t// -- Increment and decrement operators --\n\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator++();\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator--();\n\t\tGLM_FUNC_DECL tvec4<T, P> operator++(int);\n\t\tGLM_FUNC_DECL tvec4<T, P> operator--(int);\n\n\t\t// -- Unary bit operators --\n\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator%=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator%=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator%=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator&=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator&=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator&=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator|=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator|=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator|=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator^=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator^=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator^=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator<<=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator<<=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator<<=(tvec4<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator>>=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator>>=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator>>=(tvec4<U, P> const & v);\n\t};\n\n\t// -- Unary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v);\n\n\t// -- Binary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_DECL tvec4<T, P> operator~(tvec4<T, P> const & v);\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\n\n\ttemplate <precision P>\n\tGLM_FUNC_DECL tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);\n\n\ttemplate <precision P>\n\tGLM_FUNC_DECL tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);\n}//namespace glm\n\n#ifndef GLM_EXTERNAL_TEMPLATE\n#include \"type_vec4.inl\"\n#endif//GLM_EXTERNAL_TEMPLATE\n","/// @ref core\n/// @file glm/detail/type_vec3.hpp\n\n#pragma once\n\n#include \"type_vec.hpp\"\n#if GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n#\tif GLM_HAS_UNRESTRICTED_UNIONS\n#\t\tinclude \"_swizzle.hpp\"\n#\telse\n#\t\tinclude \"_swizzle_func.hpp\"\n#\tendif\n#endif //GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n#include <cstddef>\n\nnamespace glm\n{\n\ttemplate <typename T, precision P = defaultp>\n\tstruct tvec3\n\t{\n\t\t// -- Implementation detail --\n\n\t\ttypedef T value_type;\n\t\ttypedef tvec3<T, P> type;\n\t\ttypedef tvec3<bool, P> bool_type;\n\n\t\t// -- Data --\n\n#\t\tif GLM_HAS_ONLY_XYZW\n\t\t\tT x, y, z;\n\n#\t\telif GLM_HAS_ALIGNED_TYPE\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\t\t\tpragma GCC diagnostic push\n#\t\t\t\tpragma GCC diagnostic ignored \"-Wpedantic\"\n#\t\t\tendif\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\n#\t\t\t\tpragma clang diagnostic push\n#\t\t\t\tpragma clang diagnostic ignored \"-Wgnu-anonymous-struct\"\n#\t\t\t\tpragma clang diagnostic ignored \"-Wnested-anon-types\"\n#\t\t\tendif\n\n\t\t\tunion\n\t\t\t{\n\t\t\t\tstruct{ T x, y, z; };\n\t\t\t\tstruct{ T r, g, b; };\n\t\t\t\tstruct{ T s, t, p; };\n\n#\t\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n\t\t\t\t\t_GLM_SWIZZLE3_2_MEMBERS(T, P, glm::tvec2, x, y, z)\n\t\t\t\t\t_GLM_SWIZZLE3_2_MEMBERS(T, P, glm::tvec2, r, g, b)\n\t\t\t\t\t_GLM_SWIZZLE3_2_MEMBERS(T, P, glm::tvec2, s, t, p)\n\t\t\t\t\t_GLM_SWIZZLE3_3_MEMBERS(T, P, glm::tvec3, x, y, z)\n\t\t\t\t\t_GLM_SWIZZLE3_3_MEMBERS(T, P, glm::tvec3, r, g, b)\n\t\t\t\t\t_GLM_SWIZZLE3_3_MEMBERS(T, P, glm::tvec3, s, t, p)\n\t\t\t\t\t_GLM_SWIZZLE3_4_MEMBERS(T, P, glm::tvec4, x, y, z)\n\t\t\t\t\t_GLM_SWIZZLE3_4_MEMBERS(T, P, glm::tvec4, r, g, b)\n\t\t\t\t\t_GLM_SWIZZLE3_4_MEMBERS(T, P, glm::tvec4, s, t, p)\n#\t\t\t\tendif//GLM_SWIZZLE\n\t\t\t};\n\t\t\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\n#\t\t\t\tpragma clang diagnostic pop\n#\t\t\tendif\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\n#\t\t\t\tpragma GCC diagnostic pop\n#\t\t\tendif\n#\t\telse\n\t\t\tunion { T x, r, s; };\n\t\t\tunion { T y, g, t; };\n\t\t\tunion { T z, b, p; };\n\n#\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\n\t\t\t\tGLM_SWIZZLE_GEN_VEC_FROM_VEC3(T, P, tvec3, tvec2, tvec3, tvec4)\n#\t\t\tendif//GLM_SWIZZLE\n#\t\tendif//GLM_LANG\n\n\t\t// -- Component accesses --\n\n\t\t/// Return the count of components of the vector\n\t\ttypedef length_t length_type;\n\t\tGLM_FUNC_DECL static length_type length(){return 3;}\n\n\t\tGLM_FUNC_DECL T & operator[](length_type i);\n\t\tGLM_FUNC_DECL T const & operator[](length_type i) const;\n\n\t\t// -- Implicit basic constructors --\n\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3() GLM_DEFAULT_CTOR;\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec3<T, P> const & v) GLM_DEFAULT;\n\t\ttemplate <precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec3<T, Q> const & v);\n\n\t\t// -- Explicit basic constructors --\n\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR explicit tvec3(ctor);\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR explicit tvec3(T scalar);\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(T a, T b, T c);\n\n\t\t// -- Conversion scalar constructors --\n\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, typename C>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(A a, B b, C c);\n\t\ttemplate <typename A, typename B, typename C>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);\n\n\t\t// -- Conversion vector constructors --\n\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec2<A, Q> const & a, B b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(A a, tvec2<B, Q> const & b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename A, typename B, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename U, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR GLM_EXPLICIT tvec3(tvec4<U, Q> const & v);\n\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\n\t\ttemplate <typename U, precision Q>\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR GLM_EXPLICIT tvec3(tvec3<U, Q> const & v);\n\n\t\t// -- Swizzle constructors --\n#\t\tif GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\n\t\t\ttemplate <int E0, int E1, int E2>\n\t\t\tGLM_FUNC_DECL tvec3(detail::_swizzle<3, T, P, glm::tvec3, E0, E1, E2, -1> const & that)\n\t\t\t{\n\t\t\t\t*this = that();\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1>\n\t\t\tGLM_FUNC_DECL tvec3(detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, T const & scalar)\n\t\t\t{\n\t\t\t\t*this = tvec3<T, P>(v(), scalar);\n\t\t\t}\n\n\t\t\ttemplate <int E0, int E1>\n\t\t\tGLM_FUNC_DECL tvec3(T const & scalar, detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v)\n\t\t\t{\n\t\t\t\t*this = tvec3<T, P>(scalar, v());\n\t\t\t}\n#\t\tendif// GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\n\n\t\t// -- Unary arithmetic operators --\n\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator=(tvec3<T, P> const & v) GLM_DEFAULT;\n\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator+=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator+=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator+=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator-=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator-=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator-=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator*=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator*=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator*=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator/=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator/=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator/=(tvec3<U, P> const & v);\n\n\t\t// -- Increment and decrement operators --\n\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator++();\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator--();\n\t\tGLM_FUNC_DECL tvec3<T, P> operator++(int);\n\t\tGLM_FUNC_DECL tvec3<T, P> operator--(int);\n\n\t\t// -- Unary bit operators --\n\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator%=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator%=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator%=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator&=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator&=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator&=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator|=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator|=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator|=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator^=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator^=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator^=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator<<=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator<<=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator<<=(tvec3<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator>>=(U scalar);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator>>=(tvec1<U, P> const & v);\n\t\ttemplate <typename U>\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator>>=(tvec3<U, P> const & v);\n\t};\n\n\t// -- Unary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v);\n\n\t// -- Binary operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec3<T, P> const & v1, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P> \n\tGLM_FUNC_DECL tvec3<T, P> operator~(tvec3<T, P> const & v);\n\n\t// -- Boolean operators --\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <typename T, precision P>\n\tGLM_FUNC_DECL bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\n\n\ttemplate <precision P>\n\tGLM_FUNC_DECL tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);\n\n\ttemplate <precision P>\n\tGLM_FUNC_DECL tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);\n}//namespace glm\n\n#ifndef GLM_EXTERNAL_TEMPLATE\n#include \"type_vec3.inl\"\n#endif//GLM_EXTERNAL_TEMPLATE\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#include <__undef___deallocate>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#if defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309)\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#if defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309)\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n  \n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <size_t I, class T> class tuple_element; // undefined\ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t I, class T>\n  using tuple_element_t = typename tuple_element <I, T>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&&\n    get(const tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// tuple_size\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<tuple<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\n// tuple_element\n\ntemplate <size_t _Ip, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, tuple<_Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Ip, class ..._Tp>\nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;\n#endif\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp,\n          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)) ||\n                        (is_rvalue_reference<_Hp>::value &&\n                         !is_lvalue_reference<_Tp>::value),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <bool ..._Pred>\nstruct __all\n    : is_same<__all<_Pred...>, __all<(_Pred, true)...>>\n{ };\n\ntemplate <class ..._Tp>\nstruct __lazy_all : __all<_Tp::value...> {};\n\ntemplate <class _Tp>\nstruct __all_default_constructible;\n\ntemplate <class ..._Tp>\nstruct __all_default_constructible<__tuple_types<_Tp...>>\n    : __all<is_default_constructible<_Tp>::value...>\n{ };\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\ntemplate <bool _IsTuple, class _SizeTrait, size_t _Expected>\nstruct __tuple_like_with_size_imp : false_type {};\n\ntemplate <class _SizeTrait, size_t _Expected>\nstruct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>\n    : integral_constant<bool, _SizeTrait::value == _Expected> {};\n\ntemplate <class _Tuple, size_t _ExpectedSize,\n          class _RawTuple = typename __uncvref<_Tuple>::type>\nusing __tuple_like_with_size = __tuple_like_with_size_imp<\n                                   __tuple_like<_RawTuple>::value,\n                                   tuple_size<_RawTuple>, _ExpectedSize\n                              >;\n\n\nstruct _LIBCPP_TYPE_VIS __check_tuple_constructor_fail {\n    template <class ...>\n    static constexpr bool __enable_explicit() { return false; }\n    template <class ...>\n    static constexpr bool __enable_implicit() { return false; }\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n    template <class ..._Args>\n    struct _PackExpandsToThisTuple : false_type {};\n\n    template <class _Arg>\n    struct _PackExpandsToThisTuple<_Arg>\n        : is_same<typename __uncvref<_Arg>::type, tuple> {};\n\n    template <bool _MaybeEnable, class _Dummy = void>\n    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckArgsConstructor<true, _Dummy>\n    {\n        template <class ..._Args>\n        static constexpr bool __enable_explicit() {\n            return\n                __tuple_constructible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                !__tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_implicit() {\n            return\n                __tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n    };\n\n    template <bool _MaybeEnable,\n              bool = sizeof...(_Tp) == 1,\n              class _Dummy = void>\n    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, false, _Dummy>\n    {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, tuple>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, tuple>::value\n               && !__tuple_convertible<_Tuple, tuple>::value;\n        }\n    };\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, true, _Dummy>\n    {\n        // This trait is used to disable the tuple-like constructor when\n        // the UTypes... constructor should be selected instead.\n        // See LWG issue #2549.\n        template <class _Tuple>\n        using _PreferTupleLikeConstructor = __lazy_or<\n            // Don't attempt the two checks below if the tuple we are given\n            // has the same type as this tuple.\n            is_same<typename __uncvref<_Tuple>::type, tuple>,\n            __lazy_and<\n                __lazy_not<is_constructible<_Tp..., _Tuple>>,\n                __lazy_not<is_convertible<_Tuple, _Tp...>>\n            >\n        >;\n\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __lazy_and<\n                __tuple_convertible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>\n            >::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __lazy_and<\n                __tuple_constructible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>,\n                __lazy_not<__tuple_convertible<_Tuple, tuple>>\n            >::value;\n        }\n    };\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    template <bool _Dummy = true, class = typename enable_if<\n        __all<__dependent_type<is_default_constructible<_Tp>, _Dummy>::value...>::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<\n        __lazy_and<\n            is_base_of<allocator_arg_t, _AllocArgT>,\n            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>\n       >::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    tuple(_AllocArgT, _Alloc const& __a)\n      : base_(allocator_arg_t(), __a,\n                    __tuple_indices<>(), __tuple_types<>(),\n                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),\n                    __tuple_types<_Tp...>()) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      explicit\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(const tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const type&&>(\n             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n// get by type\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_helper;\n\n// -- find exactly one\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_checker {\n    static constexpr size_t value = _Idx;\n//  Check the rest of the list to make sure there's only one\n    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, \"type can only occur once in type list\" );\n    };\n\n\ntemplate <typename _T1, size_t _Idx>\nstruct __find_exactly_one_t_helper <_T1, _Idx> {\n    static constexpr size_t value = -1;\n    };\n\ntemplate <typename _T1, size_t _Idx, typename _Head, typename... _Args>\nstruct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {\n    static constexpr size_t value =\n        std::conditional<\n            std::is_same<_T1, _Head>::value,\n            __find_exactly_one_t_checker<_T1, _Idx,   _Args...>,\n            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>\n        >::type::value;\n    };\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t {\n    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;\n    static_assert ( value != -1, \"type not found in type list\" );\n    };\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        const size_t __idx = tuple_size<_Tp>::value - _Ip;\n        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))\n            return true;\n        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))\n            return false;\n        return __tuple_less<_Ip-1>()(__x, __y);\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n    const char* __type_name;\n#else\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        : __type_name(__n) {}\n#else\n        : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name;}\n#else\n        {return reinterpret_cast<const char*>(__type_name & ~_LIBCPP_NONUNIQUE_RTTI_BIT);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name < __arg.__type_name;}\n#else\n        {if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return __type_name < __arg.__type_name;\n         return __compare_nonunique_names(__arg) < 0;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n#else\n        {if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT)) return __type_name;\n         const char *__ptr = name();\n         size_t __hash = 5381;\n         while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n           __hash = (__hash * 33) ^ __c;\n         return __hash;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name == __arg.__type_name;}\n#else\n        {if (__type_name == __arg.__type_name) return true;\n         if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return false;\n         return __compare_nonunique_names(__arg) == 0;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n#ifdef _LIBCPP_NONUNIQUE_RTTI_BIT\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n        {return __builtin_strcmp(name(), __arg.name());}\n#endif\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n#endif // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\n#else // defined(_LIBCPP_CXX03_LANG)\n\n#include <__functional_base_03>\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n\ntemplate <class _Ret>\nstruct __invoke_void_return_wrapper\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static _Ret __call(_Args&&... __args) {\n        return __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static _Ret __call(_Fn __f) {\n        return __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static _Ret __call(_Fn __f, _A0& __a0) {\n        return __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        return __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){\n        return __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <>\nstruct __invoke_void_return_wrapper<void>\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static void __call(_Args&&... __args) {\n        __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static void __call(_Fn __f) {\n        __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static void __call(_Fn __f, _A0& __a0) {\n        __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {\n        __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_of<type&, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type>::type\n    operator() () const {\n        return __invoke(get());\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n#endif // _LIBCPP_HAS_NO_VARIADICS\n};\n\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// -*- C++ -*-\n//===---------------------------- chrono ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CHRONO\n#define _LIBCPP_CHRONO\n\n/*\n    chrono synopsis\n\nnamespace std\n{\nnamespace chrono\n{\n\ntemplate <class ToDuration, class Rep, class Period>\nconstexpr\nToDuration\nduration_cast(const duration<Rep, Period>& fd);\n\ntemplate <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};\n\ntemplate <class Rep> constexpr bool treat_as_floating_point_v\n    = treat_as_floating_point<Rep>::value;                       // C++17\n\ntemplate <class Rep>\nstruct duration_values\n{\npublic:\n    static constexpr Rep zero();\n    static constexpr Rep max();\n    static constexpr Rep min();\n};\n\n// duration\n\ntemplate <class Rep, class Period = ratio<1>>\nclass duration\n{\n    static_assert(!__is_duration<Rep>::value, \"A duration representation can not be a duration\");\n    static_assert(__is_ratio<Period>::value, \"Second template parameter of duration must be a std::ratio\");\n    static_assert(Period::num > 0, \"duration period must be positive\");\npublic:\n    typedef Rep rep;\n    typedef Period period;\n\n    constexpr duration() = default;\n    template <class Rep2>\n        constexpr explicit duration(const Rep2& r,\n            typename enable_if\n            <\n               is_convertible<Rep2, rep>::value &&\n               (treat_as_floating_point<rep>::value ||\n               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)\n            >::type* = 0);\n\n    // conversions\n    template <class Rep2, class Period2>\n        constexpr duration(const duration<Rep2, Period2>& d,\n            typename enable_if\n            <\n                treat_as_floating_point<rep>::value ||\n                ratio_divide<Period2, period>::type::den == 1\n            >::type* = 0);\n\n    // observer\n\n    constexpr rep count() const;\n\n    // arithmetic\n\n    constexpr duration  operator+() const;\n    constexpr duration  operator-() const;\n    duration& operator++();\n    duration  operator++(int);\n    duration& operator--();\n    duration  operator--(int);\n\n    duration& operator+=(const duration& d);\n    duration& operator-=(const duration& d);\n\n    duration& operator*=(const rep& rhs);\n    duration& operator/=(const rep& rhs);\n\n    // special values\n\n    static constexpr duration zero();\n    static constexpr duration min();\n    static constexpr duration max();\n};\n\ntypedef duration<long long,         nano> nanoseconds;\ntypedef duration<long long,        micro> microseconds;\ntypedef duration<long long,        milli> milliseconds;\ntypedef duration<long long              > seconds;\ntypedef duration<     long, ratio<  60> > minutes;\ntypedef duration<     long, ratio<3600> > hours;\n\ntemplate <class Clock, class Duration = typename Clock::duration>\nclass time_point\n{\npublic:\n    typedef Clock                     clock;\n    typedef Duration                  duration;\n    typedef typename duration::rep    rep;\n    typedef typename duration::period period;\nprivate:\n    duration d_;  // exposition only\n\npublic:\n    time_point();  // has value \"epoch\" // constexpr in C++14\n    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14\n\n    // conversions\n    template <class Duration2>\n       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14\n\n    // observer\n\n    duration time_since_epoch() const; // constexpr in C++14\n\n    // arithmetic\n\n    time_point& operator+=(const duration& d);\n    time_point& operator-=(const duration& d);\n\n    // special values\n\n    static constexpr time_point min();\n    static constexpr time_point max();\n};\n\n} // chrono\n\n// common_type traits\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;\n\ntemplate <class Clock, class Duration1, class Duration2>\n  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;\n\nnamespace chrono {\n\n// duration arithmetic\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type\n  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type\n  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator*(const duration<Rep1, Period>& d, const Rep2& s);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator*(const Rep1& s, const duration<Rep2, Period>& d);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator/(const duration<Rep1, Period>& d, const Rep2& s);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<Rep1, Rep2>::type\n  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\n\n// duration comparisons\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\n\n// duration_cast\ntemplate <class ToDuration, class Rep, class Period>\n  ToDuration duration_cast(const duration<Rep, Period>& d);\n\ntemplate <class ToDuration, class Rep, class Period>\n    constexpr ToDuration floor(const duration<Rep, Period>& d);    // C++17\ntemplate <class ToDuration, class Rep, class Period>\n    constexpr ToDuration ceil(const duration<Rep, Period>& d);     // C++17\ntemplate <class ToDuration, class Rep, class Period>\n    constexpr ToDuration round(const duration<Rep, Period>& d);    // C++17\n\n// time_point arithmetic (all constexpr in C++14)\ntemplate <class Clock, class Duration1, class Rep2, class Period2>\n  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>\n  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Clock, class Duration2>\n  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>\n  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Rep2, class Period2>\n  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>\n  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n  typename common_type<Duration1, Duration2>::type\n  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\n\n// time_point comparisons (all constexpr in C++14)\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\n\n// time_point_cast (constexpr in C++14)\n\ntemplate <class ToDuration, class Clock, class Duration>\n  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);\n\ntemplate <class ToDuration, class Clock, class Duration>\n    constexpr time_point<Clock, ToDuration>\n    floor(const time_point<Clock, Duration>& tp);                  // C++17\n\ntemplate <class ToDuration, class Clock, class Duration>\n    constexpr time_point<Clock, ToDuration>\n    ceil(const time_point<Clock, Duration>& tp);                   // C++17\n\ntemplate <class ToDuration, class Clock, class Duration>\n    constexpr time_point<Clock, ToDuration>\n    round(const time_point<Clock, Duration>& tp);                  // C++17\n\ntemplate <class Rep, class Period>\n    constexpr duration<Rep, Period> abs(duration<Rep, Period> d);  // C++17\n// Clocks\n\nclass system_clock\n{\npublic:\n    typedef microseconds                     duration;\n    typedef duration::rep                    rep;\n    typedef duration::period                 period;\n    typedef chrono::time_point<system_clock> time_point;\n    static const bool is_steady =            false; // constexpr in C++14\n\n    static time_point now() noexcept;\n    static time_t     to_time_t  (const time_point& __t) noexcept;\n    static time_point from_time_t(time_t __t) noexcept;\n};\n\nclass steady_clock\n{\npublic:\n    typedef nanoseconds                                   duration;\n    typedef duration::rep                                 rep;\n    typedef duration::period                              period;\n    typedef chrono::time_point<steady_clock, duration>    time_point;\n    static const bool is_steady =                         true; // constexpr in C++14\n\n    static time_point now() noexcept;\n};\n\ntypedef steady_clock high_resolution_clock;\n\n}  // chrono\n\nconstexpr chrono::hours                                 operator \"\" h(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , ratio<3600,1>> operator \"\" h(long double); // C++14\nconstexpr chrono::minutes                               operator \"\" min(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , ratio<60,1>>   operator \"\" min(long double); // C++14\nconstexpr chrono::seconds                               operator \"\" s(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified >                operator \"\" s(long double); // C++14\nconstexpr chrono::milliseconds                          operator \"\" ms(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , milli>         operator \"\" ms(long double); // C++14\nconstexpr chrono::microseconds                          operator \"\" us(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , micro>         operator \"\" us(long double); // C++14\nconstexpr chrono::nanoseconds                           operator \"\" ns(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , nano>          operator \"\" ns(long double); // C++14\n\n}  // std\n*/\n\n#include <__config>\n#include <ctime>\n#include <type_traits>\n#include <ratio>\n#include <limits>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace chrono\n{\n\ntemplate <class _Rep, class _Period = ratio<1> > class _LIBCPP_TYPE_VIS_ONLY duration;\n\ntemplate <class _Tp>\nstruct __is_duration : false_type {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<const duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<volatile duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<const volatile duration<_Rep, _Period> > : true_type  {};\n\n} // chrono\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<chrono::duration<_Rep1, _Period1>,\n                                         chrono::duration<_Rep2, _Period2> >\n{\n    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,\n                             typename __ratio_gcd<_Period1, _Period2>::type> type;\n};\n\nnamespace chrono {\n\n// duration_cast\n\ntemplate <class _FromDuration, class _ToDuration,\n          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,\n          bool = _Period::num == 1,\n          bool = _Period::den == 1>\nstruct __duration_cast;\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)\n                                                          / static_cast<_Ct>(_Period::den)));\n    }\n};\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nduration_cast(const duration<_Rep, _Period>& __fd)\n{\n    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);\n}\n\ntemplate <class _Rep>\nstruct _LIBCPP_TYPE_VIS_ONLY treat_as_floating_point : is_floating_point<_Rep> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Rep> _LIBCPP_CONSTEXPR bool treat_as_floating_point_v\n    = treat_as_floating_point<_Rep>::value;\n#endif\n\ntemplate <class _Rep>\nstruct _LIBCPP_TYPE_VIS_ONLY duration_values\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep zero() {return _Rep(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep max()  {return numeric_limits<_Rep>::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep min()  {return numeric_limits<_Rep>::lowest();}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nfloor(const duration<_Rep, _Period>& __d)\n{\n    _ToDuration __t = duration_cast<_ToDuration>(__d);\n    if (__t > __d)\n        __t = __t - _ToDuration{1};\n    return __t;\n}\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nceil(const duration<_Rep, _Period>& __d)\n{\n    _ToDuration __t = duration_cast<_ToDuration>(__d);\n    if (__t < __d)\n        __t = __t + _ToDuration{1};\n    return __t;\n}\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nround(const duration<_Rep, _Period>& __d)\n{\n    _ToDuration __lower = floor<_ToDuration>(__d);\n    _ToDuration __upper = __lower + _ToDuration{1};\n    auto __lowerDiff = __d - __lower;\n    auto __upperDiff = __upper - __d;\n    if (__lowerDiff < __upperDiff)\n        return __lower;\n    if (__lowerDiff > __upperDiff)\n        return __upper;\n    return __lower.count() & 1 ? __upper : __lower;\n}\n#endif\n\n// duration\n\ntemplate <class _Rep, class _Period>\nclass _LIBCPP_TYPE_VIS_ONLY duration\n{\n    static_assert(!__is_duration<_Rep>::value, \"A duration representation can not be a duration\");\n    static_assert(__is_ratio<_Period>::value, \"Second template parameter of duration must be a std::ratio\");\n    static_assert(_Period::num > 0, \"duration period must be positive\");\n\n    template <class _R1, class _R2>\n    struct __no_overflow\n    {\n    private:\n        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;\n        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;\n        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;\n        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;\n        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;\n        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;\n        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1);\n\n        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>\n        struct __mul    // __overflow == false\n        {\n            static const intmax_t value = _Xp * _Yp;\n        };\n\n        template <intmax_t _Xp, intmax_t _Yp>\n        struct __mul<_Xp, _Yp, true>\n        {\n            static const intmax_t value = 1;\n        };\n\n    public:\n        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);\n        typedef ratio<__mul<__n1, __d2, !value>::value,\n                      __mul<__n2, __d1, !value>::value> type;\n    };\n    \npublic:\n    typedef _Rep rep;\n    typedef _Period period;\nprivate:\n    rep __rep_;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n        duration() = default;\n#else\n        duration() {}\n#endif\n\n    template <class _Rep2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n        explicit duration(const _Rep2& __r,\n            typename enable_if\n            <\n               is_convertible<_Rep2, rep>::value &&\n               (treat_as_floating_point<rep>::value ||\n               !treat_as_floating_point<_Rep2>::value)\n            >::type* = 0)\n                : __rep_(__r) {}\n\n    // conversions\n    template <class _Rep2, class _Period2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n        duration(const duration<_Rep2, _Period2>& __d,\n            typename enable_if\n            <\n                __no_overflow<_Period2, period>::value && (\n                treat_as_floating_point<rep>::value ||\n                (__no_overflow<_Period2, period>::type::den == 1 &&\n                 !treat_as_floating_point<_Rep2>::value))\n            >::type* = 0)\n                : __rep_(_VSTD::chrono::duration_cast<duration>(__d).count()) {}\n\n    // observer\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR rep count() const {return __rep_;}\n\n    // arithmetic\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR duration  operator+() const {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR duration  operator-() const {return duration(-__rep_);}\n    _LIBCPP_INLINE_VISIBILITY duration& operator++()      {++__rep_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration  operator++(int)   {return duration(__rep_++);}\n    _LIBCPP_INLINE_VISIBILITY duration& operator--()      {--__rep_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration  operator--(int)   {return duration(__rep_--);}\n\n    _LIBCPP_INLINE_VISIBILITY duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}\n\n    // special values\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration zero() {return duration(duration_values<rep>::zero());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration min()  {return duration(duration_values<rep>::min());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration max()  {return duration(duration_values<rep>::max());}\n};\n\ntypedef duration<long long,         nano> nanoseconds;\ntypedef duration<long long,        micro> microseconds;\ntypedef duration<long long,        milli> milliseconds;\ntypedef duration<long long              > seconds;\ntypedef duration<     long, ratio<  60> > minutes;\ntypedef duration<     long, ratio<3600> > hours;\n\n// Duration ==\n\ntemplate <class _LhsDuration, class _RhsDuration>\nstruct __duration_eq\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const\n        {\n            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;\n            return _Ct(__lhs).count() == _Ct(__rhs).count();\n        }\n};\n\ntemplate <class _LhsDuration>\nstruct __duration_eq<_LhsDuration, _LhsDuration>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const\n        {return __lhs.count() == __rhs.count();}\n};\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);\n}\n\n// Duration !=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__lhs == __rhs);\n}\n\n// Duration <\n\ntemplate <class _LhsDuration, class _RhsDuration>\nstruct __duration_lt\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const\n        {\n            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;\n            return _Ct(__lhs).count() < _Ct(__rhs).count();\n        }\n};\n\ntemplate <class _LhsDuration>\nstruct __duration_lt<_LhsDuration, _LhsDuration>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const\n        {return __lhs.count() < __rhs.count();}\n};\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);\n}\n\n// Duration >\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __rhs < __lhs;\n}\n\n// Duration <=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__rhs < __lhs);\n}\n\n// Duration >=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__lhs < __rhs);\n}\n\n// Duration +\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());\n}\n\n// Duration -\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());\n}\n\n// Duration *\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,\n    duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n>::type\noperator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,\n    duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n>::type\noperator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)\n{\n    return __d * __s;\n}\n\n// Duration /\n\ntemplate <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>\nstruct __duration_divide_result\n{\n};\n\ntemplate <class _Duration, class _Rep2,\n    bool = is_convertible<_Rep2,\n                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>\nstruct __duration_divide_imp\n{\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\nstruct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>\n{\n    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\nstruct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>\n    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>\n{\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type\noperator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<_Rep1, _Rep2>::type\noperator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;\n    return _Ct(__lhs).count() / _Ct(__rhs).count();\n}\n\n// Duration %\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type\noperator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));\n}\n\n//////////////////////////////////////////////////////////\n///////////////////// time_point /////////////////////////\n//////////////////////////////////////////////////////////\n\ntemplate <class _Clock, class _Duration = typename _Clock::duration>\nclass _LIBCPP_TYPE_VIS_ONLY time_point\n{\n    static_assert(__is_duration<_Duration>::value,\n                  \"Second template parameter of time_point must be a std::chrono::duration\");\npublic:\n    typedef _Clock                    clock;\n    typedef _Duration                 duration;\n    typedef typename duration::rep    rep;\n    typedef typename duration::period period;\nprivate:\n    duration __d_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point() : __d_(duration::zero()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit time_point(const duration& __d) : __d_(__d) {}\n\n    // conversions\n    template <class _Duration2>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    time_point(const time_point<clock, _Duration2>& t,\n        typename enable_if\n        <\n            is_convertible<_Duration2, duration>::value\n        >::type* = 0)\n            : __d_(t.time_since_epoch()) {}\n\n    // observer\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 duration time_since_epoch() const {return __d_;}\n\n    // arithmetic\n\n    _LIBCPP_INLINE_VISIBILITY time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}\n    _LIBCPP_INLINE_VISIBILITY time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}\n\n    // special values\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point min() {return time_point(duration::min());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point max() {return time_point(duration::max());}\n};\n\n} // chrono\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<chrono::time_point<_Clock, _Duration1>,\n                                         chrono::time_point<_Clock, _Duration2> >\n{\n    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;\n};\n\nnamespace chrono {\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, _ToDuration>\ntime_point_cast(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>(_VSTD::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    time_point<_Clock, _ToDuration>\n>::type\nfloor(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>{floor<_ToDuration>(__t.time_since_epoch())};\n}\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    time_point<_Clock, _ToDuration>\n>::type\nceil(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>{ceil<_ToDuration>(__t.time_since_epoch())};\n}\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    time_point<_Clock, _ToDuration>\n>::type\nround(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>{round<_ToDuration>(__t.time_since_epoch())};\n}\n\ntemplate <class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    numeric_limits<_Rep>::is_signed,\n    duration<_Rep, _Period>\n>::type\nabs(duration<_Rep, _Period> __d)\n{\n    return __d >= __d.zero() ? __d : -__d;\n}\n#endif\n\n// time_point ==\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() == __rhs.time_since_epoch();\n}\n\n// time_point !=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__lhs == __rhs);\n}\n\n// time_point <\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() < __rhs.time_since_epoch();\n}\n\n// time_point >\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __rhs < __lhs;\n}\n\n// time_point <=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__rhs < __lhs);\n}\n\n// time_point >=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__lhs < __rhs);\n}\n\n// time_point operator+(time_point x, duration y);\n\ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>\noperator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;\n    return _Tr (__lhs.time_since_epoch() + __rhs);\n}\n\n// time_point operator+(duration x, time_point y);\n\ntemplate <class _Rep1, class _Period1, class _Clock, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>\noperator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __rhs + __lhs;\n}\n\n// time_point operator-(time_point x, duration y);\n\ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>\noperator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __lhs + (-__rhs);\n}\n\n// duration operator-(time_point x, time_point y);\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename common_type<_Duration1, _Duration2>::type\noperator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() - __rhs.time_since_epoch();\n}\n\n//////////////////////////////////////////////////////////\n/////////////////////// clocks ///////////////////////////\n//////////////////////////////////////////////////////////\n\nclass _LIBCPP_TYPE_VIS system_clock\n{\npublic:\n    typedef microseconds                     duration;\n    typedef duration::rep                    rep;\n    typedef duration::period                 period;\n    typedef chrono::time_point<system_clock> time_point;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = false;\n\n    static time_point now() _NOEXCEPT;\n    static time_t     to_time_t  (const time_point& __t) _NOEXCEPT;\n    static time_point from_time_t(time_t __t) _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_HAS_NO_MONOTONIC_CLOCK\nclass _LIBCPP_TYPE_VIS steady_clock\n{\npublic:\n    typedef nanoseconds                                   duration;\n    typedef duration::rep                                 rep;\n    typedef duration::period                              period;\n    typedef chrono::time_point<steady_clock, duration>    time_point;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = true;\n\n    static time_point now() _NOEXCEPT;\n};\n\ntypedef steady_clock high_resolution_clock;\n#else\ntypedef system_clock high_resolution_clock;\n#endif\n\n} // chrono\n\n#if _LIBCPP_STD_VER > 11\n// Suffixes for duration literals [time.duration.literals]\ninline namespace literals\n{ \n  inline namespace chrono_literals\n  {\n\n    constexpr chrono::hours operator\"\" h(unsigned long long __h)\n    {\n        return chrono::hours(static_cast<chrono::hours::rep>(__h));\n    }\n\n    constexpr chrono::duration<long double, ratio<3600,1>> operator\"\" h(long double __h)\n    {\n        return chrono::duration<long double, ratio<3600,1>>(__h);\n    }\n\n\n    constexpr chrono::minutes operator\"\" min(unsigned long long __m)\n    {\n        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));\n    }\n\n    constexpr chrono::duration<long double, ratio<60,1>> operator\"\" min(long double __m)\n    {\n        return chrono::duration<long double, ratio<60,1>> (__m);\n    }\n\n\n    constexpr chrono::seconds operator\"\" s(unsigned long long __s)\n    {\n        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));\n    }\n\n    constexpr chrono::duration<long double> operator\"\" s(long double __s)\n    {\n        return chrono::duration<long double> (__s);\n    }\n\n\n    constexpr chrono::milliseconds operator\"\" ms(unsigned long long __ms)\n    {\n        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));\n    }\n\n    constexpr chrono::duration<long double, milli> operator\"\" ms(long double __ms)\n    {\n        return chrono::duration<long double, milli>(__ms);\n    }\n\n\n    constexpr chrono::microseconds operator\"\" us(unsigned long long __us)\n    {\n        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));\n    }\n\n    constexpr chrono::duration<long double, micro> operator\"\" us(long double __us)\n    {\n        return chrono::duration<long double, micro> (__us);\n    }\n    \n\n    constexpr chrono::nanoseconds operator\"\" ns(unsigned long long __ns)\n    {\n        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));\n    }\n\n    constexpr chrono::duration<long double, nano> operator\"\" ns(long double __ns)\n    {\n        return chrono::duration<long double, nano> (__ns);\n    }\n\n}}\n\nnamespace chrono { // hoist the literals into namespace std::chrono\n   using namespace literals::chrono_literals;\n}\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CHRONO\n"]}